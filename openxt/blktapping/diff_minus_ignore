diff -Nur blktap2_oxt//control/Makefile blktap2_xen//control/Makefile
--- blktap2_oxt//control/Makefile	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/Makefile	2015-03-19 11:08:36.000000000 -0400
@@ -1,22 +1,21 @@
-#
-# Copyright (c) 2012 Citrix Systems, Inc.
-#
+XEN_ROOT := $(CURDIR)/../../../
+include $(XEN_ROOT)/tools/Rules.mk
 
-BLKTAP_ROOT := ../
-include $(BLKTAP_ROOT)/Rules.mk
+MAJOR              = 1.0
+MINOR              = 0
+LIBNAME            = libblktapctl
+LIBSONAME          = $(LIBNAME).so.$(MAJOR)
 
 IBIN               = tap-ctl
 
-#CFLAGS            += -Werror
+CFLAGS            += -Werror
 CFLAGS            += -Wno-unused
 CFLAGS            += -I../include -I../drivers
+CFLAGS            += $(CFLAGS_xeninclude)
+CFLAGS            += $(CFLAGS_libxenctrl)
 CFLAGS            += -D_GNU_SOURCE
 CFLAGS            += -DTAPCTL
 
-# Get gcc to generate the dependencies for us.
-CFLAGS            += -Wp,-MD,.$(@F).d
-DEPS               = .*.d
-
 CTL_OBJS  := tap-ctl-ipc.o
 CTL_OBJS  += tap-ctl-list.o
 CTL_OBJS  += tap-ctl-allocate.o
@@ -32,43 +31,46 @@
 CTL_OBJS  += tap-ctl-unpause.o
 CTL_OBJS  += tap-ctl-major.o
 CTL_OBJS  += tap-ctl-check.o
-CTL_OBJS  += tap-ctl-stats.o
 
 CTL_PICS  = $(patsubst %.o,%.opic,$(CTL_OBJS))
 
 OBJS = $(CTL_OBJS) tap-ctl.o
 PICS = $(CTL_PICS)
 
-LIBTAPCTL_MAJOR = 0.1
-LIBTAPCTL_MINOR = 0
-
-LIBS = libblktapctl.a libblktapctl.so.$(LIBTAPCTL_MAJOR).$(LIBTAPCTL_MINOR)
+LIB_STATIC = $(LIBNAME).a
+LIB_SHARED = $(LIBSONAME).$(MINOR)
 IBIN = tap-ctl
 
 all: build
 
-build: $(IBIN) $(LIBS)
+build: $(IBIN) $(LIB_STATIC) $(LIB_SHARED)
+
+$(LIBNAME).so: $(LIBSONAME)
+	ln -sf $< $@
+
+$(LIBSONAME): $(LIB_SHARED)
+	ln -sf $< $@
 
-tap-ctl: tap-ctl.o libblktapctl.so.$(LIBTAPCTL_MAJOR).$(LIBTAPCTL_MINOR)
-	$(CC) $(CFLAGS) -o $@ $^
+tap-ctl: tap-ctl.o $(LIBNAME).so
+	$(CC) $(LDFLAGS) -o $@ $^
 
-libblktapctl.a: $(CTL_OBJS)
+$(LIB_STATIC): $(CTL_OBJS)
 	$(AR) r $@ $^
 
-libblktapctl.so.$(LIBTAPCTL_MAJOR).$(LIBTAPCTL_MINOR): $(CTL_PICS)
-	$(CC) $(CFLAGS) -fPIC -shared -rdynamic $^ -o $@
+$(LIB_SHARED): $(CTL_PICS)
+	$(CC) $(LDFLAGS) -fPIC  -Wl,$(SONAME_LDFLAG) -Wl,$(LIBSONAME) $(SHLIB_LDFLAGS) -rdynamic $^ -o $@
 
-install: $(IBIN) $(LIBS)
+install: $(IBIN) $(LIB_STATIC) $(LIB_SHARED)
 	$(INSTALL_DIR) -p $(DESTDIR)$(SBINDIR)
 	$(INSTALL_PROG) $(IBIN) $(DESTDIR)$(SBINDIR)
-	$(INSTALL_DIR) -p $(DESTDIR)$(LIBDIR)
-	$(INSTALL_DATA) $(LIBS) $(DESTDIR)$(LIBDIR)
-	ln -sf libblktapctl.so.$(LIBTAPCTL_MAJOR).$(LIBTAPCTL_MINOR) libblktapctl.so
-#	$(INSTALL_DIR) -p $(DESTDIR)$(SYSCONFDIR)/udev/rules.d
-#	$(INSTALL_DATA) blktap.rules $(DESTDIR)$(SYSCONFDIR)/udev/rules.d/
+	$(INSTALL_DATA) $(LIB_STATIC) $(DESTDIR)$(LIBDIR)
+	$(INSTALL_PROG) $(LIB_SHARED) $(DESTDIR)$(LIBDIR)
+	ln -sf $(LIBSONAME) $(DESTDIR)$(LIBDIR)/$(LIBNAME).so
+	ln -sf $(LIB_SHARED) $(DESTDIR)$(LIBDIR)/$(LIBSONAME)
 
 clean:
-	rm -f $(OBJS) $(PICS) $(DEPS) $(IBIN) $(LIBS) libblktapctl.so*
+	rm -f $(OBJS) $(PICS) $(DEPS) $(IBIN) $(LIB_STATIC) $(LIB_SHARED)
+	rm -f $(LIBNAME).so $(LIBSONAME)
 	rm -f *~
 
 .PHONY: all build clean install
diff -Nur blktap2_oxt//control/tap-ctl.c blktap2_xen//control/tap-ctl.c
--- blktap2_oxt//control/tap-ctl.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//control/tap-ctl.c	2015-03-19 11:08:36.000000000 -0400
@@ -26,20 +26,11 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 #include <getopt.h>
-#include <signal.h>
-#include <sys/time.h>
-#include <sys/stat.h>
-#include <sys/types.h>
 
 #include "tap-ctl.h"
 
@@ -58,7 +49,7 @@
 }
 
 static void
-tap_cli_list_row(tap_list_t *entry)
+tap_ctl_list_row(tap_list_t *entry)
 {
 	char minor_str[10] = "-";
 	char state_str[10] = "-";
@@ -71,15 +62,15 @@
 		sprintf(minor_str, "%d", entry->minor);
 
 	if (entry->state != -1)
-		sprintf(state_str, "%#x", entry->state);
+		sprintf(state_str, "%x", entry->state);
 
-	printf("%8s %4s %4s %10s %s\n",
+	printf("%8s %2s %4s %10s %s\n",
 	       pid_str, minor_str, state_str,
 	       entry->type ? : "-", entry->path ? : "-");
 }
 
 static void
-tap_cli_list_dict(tap_list_t *entry)
+tap_ctl_list_dict(tap_list_t *entry)
 {
 	int d = 0;
 
@@ -95,7 +86,7 @@
 
 	if (entry->state != -1) {
 		if (d) putc(' ', stdout);
-		d = printf("state=%#x", entry->state);
+		d = printf("state=%d", entry->state);
 	}
 
 	if (entry->type && entry->path) {
@@ -109,12 +100,15 @@
 int
 tap_cli_list(int argc, char **argv)
 {
-	struct list_head list = LIST_HEAD_INIT(list);
+	tap_list_t **list, **_entry;
 	int c, minor, tty, err;
 	const char *type, *file;
-	tap_list_t *entry;
 	pid_t pid;
 
+	err = tap_ctl_list(&list);
+	if (err)
+		return -err;
+
 	pid   = -1;
 	minor = -1;
 	type  = NULL;
@@ -142,35 +136,30 @@
 		}
 	}
 
-	if (pid != -1)
-		err = tap_ctl_list_pid(pid, &list);
-	else
-		err = tap_ctl_list(&list);
-	if (err)
-		return -err;
-
 	tty = isatty(STDOUT_FILENO);
 
-	tap_list_for_each_entry(entry, &list) {
+	for (_entry = list; *_entry != NULL; ++_entry) {
+		tap_list_t *entry  = *_entry;
+
 		if (minor >= 0 && entry->minor != minor)
 			continue;
 
 		if (pid >= 0 && entry->pid != pid)
 			continue;
 
-		if (type && entry->type && strcmp(entry->type, type))
+		if (type && (!entry->type || strcmp(entry->type, type)))
 			continue;
 
-		if (file && entry->path && strcmp(entry->path, file))
+		if (file && (!entry->path || strcmp(entry->path, file)))
 			continue;
 
 		if (tty)
-			tap_cli_list_row(entry);
+			tap_ctl_list_row(entry);
 		else
-			tap_cli_list_dict(entry);
+			tap_ctl_list_dict(entry);
 	}
 
-	tap_ctl_list_free(&list);
+	tap_ctl_free_list(list);
 
 	return 0;
 
@@ -258,27 +247,20 @@
 static void
 tap_cli_create_usage(FILE *stream)
 {
-	fprintf(stream, "usage: create <-a args> [-d device name] [-R readonly] "
-		"[-e <minor> stack on existing tapdisk for the parent chain] "
-		"[-r turn on read caching into leaf node] [-2 <path> "
-		"use secondary image (in mirror mode if no -s)] [-s "
-		"fail over to the secondary image on ENOSPC]\n");
+	fprintf(stream, "usage: create <-a args> [-d device name]\n");
 }
 
 static int
 tap_cli_create(int argc, char **argv)
 {
-	int c, err, flags, prt_minor;
-	char *args, *devname, *secondary;
+	int c, err;
+	char *args, *devname;
 
-	args      = NULL;
-	devname   = NULL;
-	secondary = NULL;
-	prt_minor = -1;
-	flags     = 0;
+	args    = NULL;
+	devname = NULL;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "a:Rd:e:r2:sh")) != -1) {
+	while ((c = getopt(argc, argv, "a:d:h")) != -1) {
 		switch (c) {
 		case 'a':
 			args = optarg;
@@ -286,23 +268,6 @@
 		case 'd':
 			devname = optarg;
 			break;
-		case 'R':
-			flags |= TAPDISK_MESSAGE_FLAG_RDONLY;
-			break;
-		case 'r':
-			flags |= TAPDISK_MESSAGE_FLAG_ADD_LCACHE;
-			break;
-		case 'e':
-			flags |= TAPDISK_MESSAGE_FLAG_REUSE_PRT;
-			prt_minor = atoi(optarg);
-			break;
-		case '2':
-			flags |= TAPDISK_MESSAGE_FLAG_SECONDARY;
-			secondary = optarg;
-			break;
-		case 's':
-			flags |= TAPDISK_MESSAGE_FLAG_STANDBY;
-			break;
 		case '?':
 			goto usage;
 		case 'h':
@@ -314,7 +279,7 @@
 	if (!args)
 		goto usage;
 
-	err = tap_ctl_create(args, &devname, flags, prt_minor, secondary);
+	err = tap_ctl_create(args, &devname);
 	if (!err)
 		printf("%s\n", devname);
 
@@ -328,38 +293,19 @@
 static void
 tap_cli_destroy_usage(FILE *stream)
 {
-	fprintf(stream, "usage: destroy (<-m minor> [-p pid] | <-d dev>)\n");
-}
-
-static struct timeval*
-tap_cli_timeout(const char *optarg)
-{
-	static struct timeval tv;
-	struct timeval now;
-
-	tv.tv_sec  = atoi(optarg);
-	tv.tv_usec = 0;
-
-	gettimeofday(&now, NULL);
-	timeradd(&tv, &now, &tv);
-
-	return &tv;
+	fprintf(stream, "usage: destroy <-p pid> <-m minor>\n");
 }
 
 static int
 tap_cli_destroy(int argc, char **argv)
 {
 	int c, pid, minor;
-	const char *device;
-	struct timeval *timeout;
 
-	pid     = -1;
-	minor   = -1;
-	device  = NULL;
-	timeout = NULL;
+	pid   = -1;
+	minor = -1;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "p:m:d:t:h")) != -1) {
+	while ((c = getopt(argc, argv, "p:m:h")) != -1) {
 		switch (c) {
 		case 'p':
 			pid = atoi(optarg);
@@ -367,14 +313,6 @@
 		case 'm':
 			minor = atoi(optarg);
 			break;
-		case 'd':
-			device = optarg;
-			break;
-		case 't':
-			timeout = tap_cli_timeout(optarg);
-			if (!timeout)
-				goto usage;
-			break;
 		case '?':
 			goto usage;
 		case 'h':
@@ -383,41 +321,10 @@
 		}
 	}
 
-	if (device) {
-		int maj;
-		struct stat sb;
-
-		if (stat(device, &sb)) {
-			perror("stat");
-			return -errno;
-		}
-
-		maj = tap_ctl_blk_major();
-		if (maj < 0) {
-			fprintf(stderr, "failed to find td major: %d\n", maj);
-			return maj;
-		}
-
-		if (!S_ISBLK(sb.st_mode) || major(sb.st_rdev) != maj) {
-			fprintf(stderr, "invalid device %s\n", device);
-			return -EINVAL;
-		}
-
-		minor = minor(sb.st_rdev);
-	}
-
-	if (minor == -1)
+	if (pid == -1 || minor == -1)
 		goto usage;
 
-	if (pid == -1) {
-		pid = tap_ctl_find_pid(minor);
-		if (pid == -1) {
-			fprintf(stderr, "failed to find pid for %d\n", minor);
-			return pid;
-		}
-	}
-
-	return tap_ctl_destroy(pid, minor, 0, timeout);
+	return tap_ctl_destroy(pid, minor);
 
 usage:
 	tap_cli_destroy_usage(stderr);
@@ -433,8 +340,8 @@
 static int
 tap_cli_spawn(int argc, char **argv)
 {
-	int c, tty;
-	pid_t pid;
+	int c;
+	pid_t task;
 
 	optind = 0;
 	while ((c = getopt(argc, argv, "h")) != -1) {
@@ -447,16 +354,13 @@
 		}
 	}
 
-	pid = tap_ctl_spawn();
-	if (pid < 0)
-		return pid;
-
-	tty = isatty(STDOUT_FILENO);
-	if (tty)
-		printf("tapdisk spawned with pid %d\n", pid);
-	else
-		printf("%d\n", pid);
+	task = tap_ctl_spawn();
+	if (task < 0) {
+		printf("spawn failed: %d\n", errno);
+		return task;
+	}
 
+	printf("tapdisk spawned with pid %d\n", task);
 	return 0;
 
 usage:
@@ -556,15 +460,13 @@
 tap_cli_close(int argc, char **argv)
 {
 	int c, pid, minor, force;
-	struct timeval *timeout;
 
-	pid     = -1;
-	minor   = -1;
-	force   = 0;
-	timeout = NULL;
+	pid   = -1;
+	minor = -1;
+	force = 0;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "p:m:ft:h")) != -1) {
+	while ((c = getopt(argc, argv, "p:m:fh")) != -1) {
 		switch (c) {
 		case 'p':
 			pid = atoi(optarg);
@@ -575,11 +477,6 @@
 		case 'f':
 			force = -1;
 			break;
-		case 't':
-			timeout = tap_cli_timeout(optarg);
-			if (!timeout)
-				goto usage;
-			break;
 		case '?':
 			goto usage;
 		case 'h':
@@ -591,7 +488,7 @@
 	if (pid == -1 || minor == -1)
 		goto usage;
 
-	return tap_ctl_close(pid, minor, force, timeout);
+	return tap_ctl_close(pid, minor, force);
 
 usage:
 	tap_cli_close_usage(stderr);
@@ -601,21 +498,19 @@
 static void
 tap_cli_pause_usage(FILE *stream)
 {
-	fprintf(stream, "usage: pause <-m minor> [-p pid]\n");
+	fprintf(stream, "usage: pause <-p pid> <-m minor>\n");
 }
 
 static int
 tap_cli_pause(int argc, char **argv)
 {
 	int c, pid, minor;
-	struct timeval *timeout;
 
-	pid     = -1;
-	minor   = -1;
-	timeout = NULL;
+	pid   = -1;
+	minor = -1;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "p:m:t:h")) != -1) {
+	while ((c = getopt(argc, argv, "p:m:h")) != -1) {
 		switch (c) {
 		case 'p':
 			pid = atoi(optarg);
@@ -623,10 +518,6 @@
 		case 'm':
 			minor = atoi(optarg);
 			break;
-		case 't':
-			timeout = tap_cli_timeout(optarg);
-			if (!timeout)
-				goto usage;
 		case '?':
 			goto usage;
 		case 'h':
@@ -635,18 +526,10 @@
 		}
 	}
 
-	if (minor == -1)
+	if (pid == -1 || minor == -1)
 		goto usage;
 
-	if (pid == -1) {
-		pid = tap_ctl_find_pid(minor);
-		if (pid == -1) {
-			fprintf(stderr, "failed to find pid for %d\n", minor);
-			return pid;
-		}
-	}
-
-	return tap_ctl_pause(pid, minor, timeout);
+	return tap_ctl_pause(pid, minor);
 
 usage:
 	tap_cli_pause_usage(stderr);
@@ -656,7 +539,7 @@
 static void
 tap_cli_unpause_usage(FILE *stream)
 {
-	fprintf(stream, "usage: unpause <-m minor> [-p pid] [-a args]\n");
+	fprintf(stream, "usage: unpause <-p pid> <-m minor> [-a args]\n");
 }
 
 int
@@ -689,17 +572,9 @@
 		}
 	}
 
-	if (minor == -1)
+	if (pid == -1 || minor == -1)
 		goto usage;
 
-	if (pid == -1) {
-		pid = tap_ctl_find_pid(minor);
-		if (pid == -1) {
-			fprintf(stderr, "failed to find pid for %d\n", minor);
-			return pid;
-		}
-	}
-
 	return tap_ctl_unpause(pid, minor, args);
 
 usage:
@@ -758,28 +633,21 @@
 static void
 tap_cli_open_usage(FILE *stream)
 {
-	fprintf(stream, "usage: open <-p pid> <-m minor> <-a args> [-R readonly] "
-		"[-e <minor> stack on existing tapdisk for the parent chain] "
-		"[-r turn on read caching into leaf node] [-2 <path> "
-		"use secondary image (in mirror mode if no -s)] [-s "
-		"fail over to the secondary image on ENOSPC]\n");
+	fprintf(stream, "usage: open <-p pid> <-m minor> <-a args>\n");
 }
 
 static int
 tap_cli_open(int argc, char **argv)
 {
-	const char *args, *secondary;
-	int c, pid, minor, flags, prt_minor;
+	const char *args;
+	int c, pid, minor;
 
-	flags     = 0;
-	pid       = -1;
-	minor     = -1;
-	prt_minor = -1;
-	args      = NULL;
-	secondary = NULL;
+	pid   = -1;
+	minor = -1;
+	args  = NULL;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "a:Rm:p:e:r2:sh")) != -1) {
+	while ((c = getopt(argc, argv, "a:m:p:h")) != -1) {
 		switch (c) {
 		case 'p':
 			pid = atoi(optarg);
@@ -790,23 +658,6 @@
 		case 'a':
 			args = optarg;
 			break;
-		case 'R':
-			flags |= TAPDISK_MESSAGE_FLAG_RDONLY;
-			break;
-		case 'r':
-			flags |= TAPDISK_MESSAGE_FLAG_ADD_LCACHE;
-			break;
-		case 'e':
-			flags |= TAPDISK_MESSAGE_FLAG_REUSE_PRT;
-			prt_minor = atoi(optarg);
-			break;
-		case '2':
-			flags |= TAPDISK_MESSAGE_FLAG_SECONDARY;
-			secondary = optarg;
-			break;
-		case 's':
-			flags |= TAPDISK_MESSAGE_FLAG_STANDBY;
-			break;
 		case '?':
 			goto usage;
 		case 'h':
@@ -818,7 +669,7 @@
 	if (pid == -1 || minor == -1 || !args)
 		goto usage;
 
-	return tap_ctl_open(pid, minor, args, flags, prt_minor, secondary);
+	return tap_ctl_open(pid, minor, args);
 
 usage:
 	tap_cli_open_usage(stderr);
@@ -826,54 +677,6 @@
 }
 
 static void
-tap_cli_stats_usage(FILE *stream)
-{
-	fprintf(stream, "usage: info <-p pid> <-m minor>\n");
-}
-
-static int
-tap_cli_stats(int argc, char **argv)
-{
-	pid_t pid;
-	int c, minor, err;
-
-	pid     = -1;
-	minor   = -1;
-
-	optind = 0;
-	while ((c = getopt(argc, argv, "p:m:h")) != -1) {
-		switch (c) {
-		case 'p':
-			pid = atoi(optarg);
-			break;
-		case 'm':
-			minor = atoi(optarg);
-			break;
-		case '?':
-			goto usage;
-		case 'h':
-			tap_cli_stats_usage(stdout);
-			return 0;
-		}
-	}
-
-	if (pid == -1 || minor == -1)
-		goto usage;
-
-	err = tap_ctl_stats_fwrite(pid, minor, stdout);
-	if (err)
-		return err;
-
-	fprintf(stdout, "\n");
-
-	return 0;
-
-usage:
-	tap_cli_stats_usage(stderr);
-	return EINVAL;
-}
-
-static void
 tap_cli_check_usage(FILE *stream)
 {
 	fprintf(stream, "usage: check\n"
@@ -912,7 +715,6 @@
 	{ .name = "close",        .func = tap_cli_close         },
 	{ .name = "pause",        .func = tap_cli_pause         },
 	{ .name = "unpause",      .func = tap_cli_unpause       },
-	{ .name = "stats",        .func = tap_cli_stats         },
 	{ .name = "major",        .func = tap_cli_major         },
 	{ .name = "check",        .func = tap_cli_check         },
 };
@@ -970,8 +772,6 @@
 		PERROR("setrlimit failed");
 #endif
 
-	signal(SIGPIPE, SIG_IGN);
-
 	ret = 0;
 
 	if (argc < 2)
diff -Nur blktap2_oxt//control/tap-ctl-close.c blktap2_xen//control/tap-ctl-close.c
--- blktap2_oxt//control/tap-ctl-close.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-close.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -39,9 +34,8 @@
 
 #include "tap-ctl.h"
 
-int
-tap_ctl_close(const int id, const int minor, const int force,
-	      struct timeval *timeout)
+static int
+__tap_ctl_close(const int id, const int minor, const int force)
 {
 	int err;
 	tapdisk_message_t message;
@@ -52,7 +46,7 @@
 		message.type = TAPDISK_MESSAGE_FORCE_SHUTDOWN;
 	message.cookie = minor;
 
-	err = tap_ctl_connect_send_and_receive(id, &message, timeout);
+	err = tap_ctl_connect_send_and_receive(id, &message, 5);
 	if (err)
 		return err;
 
@@ -68,3 +62,26 @@
 
 	return err;
 }
+
+int
+tap_ctl_close(const int id, const int minor, const int force)
+{
+	int i, err;
+
+	for (i = 0; i < 20; i++) {
+		err = __tap_ctl_close(id, minor, force);
+		if (!err)
+			return 0;
+
+		err = (err < 0 ? -err : err);
+		if (err != EAGAIN) {
+			EPRINTF("close failed: %d\n", err);
+			return err;
+		}
+
+		usleep(1000);
+	}
+
+	EPRINTF("close timed out\n");
+	return EIO;
+}
diff -Nur blktap2_oxt//control/tap-ctl-create.c blktap2_xen//control/tap-ctl-create.c
--- blktap2_oxt//control/tap-ctl-create.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-create.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -40,8 +35,7 @@
 #include "blktap2.h"
 
 int
-tap_ctl_create(const char *params, char **devname, int flags, int parent_minor,
-		char *secondary)
+tap_ctl_create(const char *params, char **devname)
 {
 	int err, id, minor;
 
@@ -59,7 +53,7 @@
 	if (err)
 		goto destroy;
 
-	err = tap_ctl_open(id, minor, params, flags, parent_minor, secondary);
+	err = tap_ctl_open(id, minor, params);
 	if (err)
 		goto detach;
 
diff -Nur blktap2_oxt//control/tap-ctl-destroy.c blktap2_xen//control/tap-ctl-destroy.c
--- blktap2_oxt//control/tap-ctl-destroy.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-destroy.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -41,12 +36,11 @@
 #include "blktap2.h"
 
 int
-tap_ctl_destroy(const int id, const int minor,
-		int force, struct timeval *timeout)
+tap_ctl_destroy(const int id, const int minor)
 {
 	int err;
 
-	err = tap_ctl_close(id, minor, 0, timeout);
+	err = tap_ctl_close(id, minor, 0);
 	if (err)
 		return err;
 
diff -Nur blktap2_oxt//control/tap-ctl.h blktap2_xen//control/tap-ctl.h
--- blktap2_oxt//control/tap-ctl.h	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//control/tap-ctl.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,18 +25,12 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #ifndef __TAP_CTL_H__
 #define __TAP_CTL_H__
 
 #include <syslog.h>
 #include <errno.h>
 #include <tapdisk-message.h>
-#include <list.h>
 
 extern int tap_ctl_debug;
 
@@ -62,48 +56,33 @@
 
 int tap_ctl_connect(const char *path, int *socket);
 int tap_ctl_connect_id(int id, int *socket);
-int tap_ctl_read_raw(int fd, void *buf, size_t sz, struct timeval *timeout);
-int tap_ctl_read_message(int fd, tapdisk_message_t *message,
-			 struct timeval *timeout);
-int tap_ctl_write_message(int fd, tapdisk_message_t *message,
-			  struct timeval *timeout);
-int tap_ctl_send_and_receive(int fd, tapdisk_message_t *message,
-			     struct timeval *timeout);
+int tap_ctl_read_message(int fd, tapdisk_message_t *message, int timeout);
+int tap_ctl_write_message(int fd, tapdisk_message_t *message, int timeout);
+int tap_ctl_send_and_receive(int fd, tapdisk_message_t *message, int timeout);
 int tap_ctl_connect_send_and_receive(int id,
-				     tapdisk_message_t *message,
-				     struct timeval *timeout);
+				     tapdisk_message_t *message, int timeout);
 char *tap_ctl_socket_name(int id);
 
 typedef struct {
+	int         id;
 	pid_t       pid;
 	int         minor;
 	int         state;
 	char       *type;
 	char       *path;
-
-	struct list_head entry;
 } tap_list_t;
 
-#define tap_list_for_each_entry(_pos, _head) \
-	list_for_each_entry(_pos, _head, entry)
+int tap_ctl_get_driver_id(const char *handle);
 
-#define tap_list_for_each_entry_safe(_pos, _n, _head) \
-	list_for_each_entry_safe(_pos, _n, _head, entry)
-
-int tap_ctl_list(struct list_head *list);
-int tap_ctl_list_pid(pid_t pid, struct list_head *list);
-void tap_ctl_list_free(struct list_head *list);
-
-int tap_ctl_find_pid(int minor);
-int tap_ctl_find_minor(const char *type, const char *path);
+int tap_ctl_list(tap_list_t ***list);
+void tap_ctl_free_list(tap_list_t **list);
+int tap_ctl_find(const char *type, const char *path, tap_list_t *tap);
 
 int tap_ctl_allocate(int *minor, char **devname);
 int tap_ctl_free(const int minor);
 
-int tap_ctl_create(const char *params, char **devname, int flags, 
-		int prt_minor, char *secondary);
-int tap_ctl_destroy(const int id, const int minor, int force,
-		    struct timeval *timeout);
+int tap_ctl_create(const char *params, char **devname);
+int tap_ctl_destroy(const int id, const int minor);
 
 int tap_ctl_spawn(void);
 pid_t tap_ctl_get_pid(const int id);
@@ -111,17 +90,12 @@
 int tap_ctl_attach(const int id, const int minor);
 int tap_ctl_detach(const int id, const int minor);
 
-int tap_ctl_open(const int id, const int minor, const char *params, int flags,
-		const int prt_minor, const char *secondary);
-int tap_ctl_close(const int id, const int minor, const int force,
-		  struct timeval *timeout);
+int tap_ctl_open(const int id, const int minor, const char *params);
+int tap_ctl_close(const int id, const int minor, const int force);
 
-int tap_ctl_pause(const int id, const int minor, struct timeval *timeout);
+int tap_ctl_pause(const int id, const int minor);
 int tap_ctl_unpause(const int id, const int minor, const char *params);
 
-ssize_t tap_ctl_stats(pid_t pid, int minor, char *buf, size_t size);
-int tap_ctl_stats_fwrite(pid_t pid, int minor, FILE *out);
-
 int tap_ctl_blk_major(void);
 
 #endif
diff -Nur blktap2_oxt//control/tap-ctl-ipc.c blktap2_xen//control/tap-ctl-ipc.c
--- blktap2_oxt//control/tap-ctl-ipc.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-ipc.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,17 +25,11 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
+#include <unistd.h>
 #include <stdlib.h>
 #include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
 #include <sys/un.h>
 #include <sys/stat.h>
 #include <sys/types.h>
@@ -47,47 +41,51 @@
 int tap_ctl_debug = 0;
 
 int
-tap_ctl_read_raw(int fd, void *buf, size_t size, struct timeval *timeout)
+tap_ctl_read_message(int fd, tapdisk_message_t *message, int timeout)
 {
 	fd_set readfds;
-	size_t offset = 0;
-	int ret;
+	int ret, len, offset;
+	struct timeval tv, *t;
 
-	while (offset < size) {
+	t      = NULL;
+	offset = 0;
+	len    = sizeof(tapdisk_message_t);
+
+	if (timeout) {
+		tv.tv_sec  = timeout;
+		tv.tv_usec = 0;
+		t = &tv;
+	}
+
+	memset(message, 0, sizeof(tapdisk_message_t));
+
+	while (offset < len) {
 		FD_ZERO(&readfds);
 		FD_SET(fd, &readfds);
 
-		ret = select(fd + 1, &readfds, NULL, NULL, timeout);
-		if (ret == -1)
+		ret = select(fd + 1, &readfds, NULL, NULL, t);
+		if (ret == -1) {
+			if (errno == EINTR)
+				continue;
 			break;
+		}
 		else if (FD_ISSET(fd, &readfds)) {
-			ret = read(fd, (char*)buf + offset, size - offset);
-			if (ret <= 0)
+			ret = read(fd, message + offset, len - offset);
+			if (ret <= 0) {
+				if (errno == EINTR)
+					continue;
 				break;
+			}
 			offset += ret;
 		} else
 			break;
 	}
 
-	if (offset != size) {
-		EPRINTF("failure reading data %zd/%zd\n", offset, size);
+	if (offset != len) {
+		EPRINTF("failure reading message\n");
 		return -EIO;
 	}
 
-	return 0;
-}
-
-int
-tap_ctl_read_message(int fd, tapdisk_message_t *message,
-		     struct timeval *timeout)
-{
-	size_t size = sizeof(tapdisk_message_t);
-	int err;
-
-	err = tap_ctl_read_raw(fd, message, size, timeout);
-	if (err)
-		return err;
-
 	DBG("received '%s' message (uuid = %u)\n",
 	    tapdisk_message_name(message->type), message->cookie);
 
@@ -95,14 +93,22 @@
 }
 
 int
-tap_ctl_write_message(int fd, tapdisk_message_t *message, struct timeval *timeout)
+tap_ctl_write_message(int fd, tapdisk_message_t *message, int timeout)
 {
 	fd_set writefds;
 	int ret, len, offset;
+	struct timeval tv, *t;
 
+	t      = NULL;
 	offset = 0;
 	len    = sizeof(tapdisk_message_t);
 
+	if (timeout) {
+		tv.tv_sec  = timeout;
+		tv.tv_usec = 0;
+		t = &tv;
+	}
+
 	DBG("sending '%s' message (uuid = %u)\n",
 	    tapdisk_message_name(message->type), message->cookie);
 
@@ -113,13 +119,19 @@
 		/* we don't bother reinitializing tv. at worst, it will wait a
 		 * bit more time than expected. */
 
-		ret = select(fd + 1, NULL, &writefds, NULL, timeout);
-		if (ret == -1)
+		ret = select(fd + 1, NULL, &writefds, NULL, t);
+		if (ret == -1) {
+			if (errno == EINTR)
+				continue;
 			break;
+		}
 		else if (FD_ISSET(fd, &writefds)) {
-			ret = write(fd, (char*)message + offset, len - offset);
-			if (ret <= 0)
+			ret = write(fd, message + offset, len - offset);
+			if (ret <= 0) {
+				if (errno == EINTR)
+					continue;
 				break;
+			}
 			offset += ret;
 		} else
 			break;
@@ -134,8 +146,7 @@
 }
 
 int
-tap_ctl_send_and_receive(int sfd, tapdisk_message_t *message,
-			 struct timeval *timeout)
+tap_ctl_send_and_receive(int sfd, tapdisk_message_t *message, int timeout)
 {
 	int err;
 
@@ -217,15 +228,13 @@
 	}
 
 	err = tap_ctl_connect(name, sfd);
-
 	free(name);
 
 	return err;
 }
 
 int
-tap_ctl_connect_send_and_receive(int id, tapdisk_message_t *message,
-				 struct timeval *timeout)
+tap_ctl_connect_send_and_receive(int id, tapdisk_message_t *message, int timeout)
 {
 	int err, sfd;
 
diff -Nur blktap2_oxt//control/tap-ctl-list.c blktap2_xen//control/tap-ctl-list.c
--- blktap2_oxt//control/tap-ctl-list.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-list.c	2015-03-19 11:08:36.000000000 -0400
@@ -26,11 +26,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -42,43 +37,20 @@
 #include "blktap2.h"
 #include "list.h"
 
-static tap_list_t*
-_tap_list_alloc(void)
-{
-	const size_t sz = sizeof(tap_list_t);
-	tap_list_t *tl;
-
-	tl = malloc(sz);
-	if (!tl)
-		return NULL;
-
-	tl->pid   = -1;
-	tl->minor = -1;
-	tl->state = -1;
-	tl->type  = NULL;
-	tl->path  = NULL;
-
-	INIT_LIST_HEAD(&tl->entry);
-
-	return tl;
-}
-
 static void
-_tap_list_free(tap_list_t *tl)
+free_list(tap_list_t *entry)
 {
-	list_del_init(&tl->entry);
-
-	if (tl->type) {
-		free(tl->type);
-		tl->type = NULL;
+	if (entry->type) {
+		free(entry->type);
+		entry->type = NULL;
 	}
 
-	if (tl->path) {
-		free(tl->path);
-		tl->path = NULL;
+	if (entry->path) {
+		free(entry->path);
+		entry->path = NULL;
 	}
 
-	free(tl);
+	free(entry);
 }
 
 int
@@ -109,28 +81,103 @@
 	return 0;
 }
 
+static int
+init_list(tap_list_t *entry,
+	  int tap_id, pid_t tap_pid, int vbd_minor, int vbd_state,
+	  const char *params)
+{
+	int err = 0;
+
+	entry->id     = tap_id;
+	entry->pid    = tap_pid;
+	entry->minor  = vbd_minor;
+	entry->state  = vbd_state;
+
+	if (params)
+		err = _parse_params(params, &entry->type, &entry->path);
+
+	return err;
+}
+
 void
-tap_ctl_list_free(struct list_head *list)
+tap_ctl_free_list(tap_list_t **list)
 {
-	tap_list_t *tl, *n;
+	tap_list_t **_entry;
+
+	for (_entry = list; *_entry != NULL; ++_entry)
+		free_list(*_entry);
 
-	tap_list_for_each_entry_safe(tl, n, list)
-		_tap_list_free(tl);
+	free(list);
+}
+
+static tap_list_t**
+tap_ctl_alloc_list(int n)
+{
+	tap_list_t **list, *entry;
+	size_t size;
+	int i;
+
+	size = sizeof(tap_list_t*) * (n+1);
+	list = malloc(size);
+	if (!list)
+		goto fail;
+
+	memset(list, 0, size);
+
+	for (i = 0; i < n; ++i) {
+		tap_list_t *entry;
+
+		entry = malloc(sizeof(tap_list_t));
+		if (!entry)
+			goto fail;
+
+		memset(entry, 0, sizeof(tap_list_t));
+
+		list[i] = entry;
+	}
+
+	return list;
+
+fail:
+	if (list)
+		tap_ctl_free_list(list);
+
+	return NULL;
 }
 
 static int
-_tap_ctl_find_minors(struct list_head *list)
+tap_ctl_list_length(const tap_list_t **list)
 {
-	const char *pattern, *format;
-	glob_t glbuf = { 0 };
-	tap_list_t *tl;
-	int i, err;
+	const tap_list_t **_entry;
+	int n;
+
+	n = 0;
+	for (_entry = list; *_entry != NULL; ++_entry)
+		n++;
 
-	INIT_LIST_HEAD(list);
+	return n;
+}
+
+static int
+_tap_minor_cmp(const void *a, const void *b)
+{
+	return *(int*)a - *(int*)b;
+}
+
+int
+_tap_ctl_find_minors(int **_minorv)
+{
+	glob_t glbuf = { 0 };
+	const char *pattern, *format;
+	int *minorv = NULL, n_minors = 0;
+	int err, i;
 
 	pattern = BLKTAP2_SYSFS_DIR"/blktap*";
 	format  = BLKTAP2_SYSFS_DIR"/blktap%d";
 
+	n_minors = 0;
+	minorv   = NULL;
+
 	err = glob(pattern, 0, NULL, &glbuf);
 	switch (err) {
 	case GLOB_NOMATCH:
@@ -143,48 +190,66 @@
 		goto fail;
 	}
 
+	minorv = malloc(sizeof(int) * glbuf.gl_pathc);
+	if (!minorv) {
+		err = -errno;
+		goto fail;
+	}
+
 	for (i = 0; i < glbuf.gl_pathc; ++i) {
 		int n;
 
-		tl = _tap_list_alloc();
-		if (!tl) {
-			err = -ENOMEM;
-			goto fail;
-		}
-
-		n = sscanf(glbuf.gl_pathv[i], format, &tl->minor);
-		if (n != 1) {
-			_tap_list_free(tl);
+		n = sscanf(glbuf.gl_pathv[i], format, &minorv[n_minors]);
+		if (n != 1)
 			continue;
-		}
 
-		list_add_tail(&tl->entry, list);
+		n_minors++;
 	}
 
+	qsort(minorv, n_minors, sizeof(int), _tap_minor_cmp);
+
 done:
+	*_minorv = minorv;
 	err = 0;
+
 out:
 	if (glbuf.gl_pathv)
 		globfree(&glbuf);
 
-	return err;
+	return err ? : n_minors;
 
 fail:
-	tap_ctl_list_free(list);
+	if (minorv)
+		free(minorv);
+
 	goto out;
 }
 
+struct tapdisk {
+	int    id;
+	pid_t  pid;
+	struct list_head list;
+};
+
+static int
+_tap_tapdisk_cmp(const void *a, const void *b)
+{
+	return ((struct tapdisk*)a)->id - ((struct tapdisk*)b)->id;
+}
+
 int
-_tap_ctl_find_tapdisks(struct list_head *list)
+_tap_ctl_find_tapdisks(struct tapdisk **_tapv)
 {
-	const char *pattern, *format;
 	glob_t glbuf = { 0 };
+	const char *pattern, *format;
+	struct tapdisk *tapv = NULL;
 	int err, i, n_taps = 0;
 
 	pattern = BLKTAP2_CONTROL_DIR"/"BLKTAP2_CONTROL_SOCKET"*";
 	format  = BLKTAP2_CONTROL_DIR"/"BLKTAP2_CONTROL_SOCKET"%d";
 
-	INIT_LIST_HEAD(list);
+	n_taps = 0;
+	tapv   = NULL;
 
 	err = glob(pattern, 0, NULL, &glbuf);
 	switch (err) {
@@ -198,34 +263,38 @@
 		goto fail;
 	}
 
+	tapv = malloc(sizeof(struct tapdisk) * glbuf.gl_pathc);
+	if (!tapv) {
+		err = -errno;
+		goto fail;
+	}
+
 	for (i = 0; i < glbuf.gl_pathc; ++i) {
-		tap_list_t *tl;
+		struct tapdisk *tap;
 		int n;
 
-		tl = _tap_list_alloc();
-		if (!tl) {
-			err = -ENOMEM;
-			goto fail;
-		}
+		tap = &tapv[n_taps];
 
-		n = sscanf(glbuf.gl_pathv[i], format, &tl->pid);
-		if (n != 1)
-			goto skip;
+		err = sscanf(glbuf.gl_pathv[i], format, &tap->id);
+		if (err != 1)
+			continue;
 
-		tl->pid = tap_ctl_get_pid(tl->pid);
-		if (tl->pid < 0)
-			goto skip;
+		tap->pid = tap_ctl_get_pid(tap->id);
+		if (tap->pid < 0)
+			continue;
 
-		list_add_tail(&tl->entry, list);
 		n_taps++;
-		continue;
-
-skip:
-		_tap_list_free(tl);
 	}
 
+	qsort(tapv, n_taps, sizeof(struct tapdisk), _tap_tapdisk_cmp);
+
+	for (i = 0; i < n_taps; ++i)
+		INIT_LIST_HEAD(&tapv[i].list);
+
 done:
+	*_tapv = tapv;
 	err = 0;
+
 out:
 	if (glbuf.gl_pathv)
 		globfree(&glbuf);
@@ -233,19 +302,28 @@
 	return err ? : n_taps;
 
 fail:
-	tap_ctl_list_free(list);
+	if (tapv)
+		free(tapv);
+
 	goto out;
 }
 
+struct tapdisk_list {
+	int  minor;
+	int  state;
+	char *params;
+	struct list_head entry;
+};
+
 int
-_tap_ctl_list_tapdisk(pid_t pid, struct list_head *list)
+_tap_ctl_list_tapdisk(int id, struct list_head *_list)
 {
-	struct timeval timeout = { .tv_sec = 10, .tv_usec = 0 };
 	tapdisk_message_t message;
-	tap_list_t *tl;
+	struct list_head list;
+	struct tapdisk_list *tl, *next;
 	int err, sfd;
 
-	err = tap_ctl_connect_id(pid, &sfd);
+	err = tap_ctl_connect_id(id, &sfd);
 	if (err)
 		return err;
 
@@ -253,152 +331,192 @@
 	message.type   = TAPDISK_MESSAGE_LIST;
 	message.cookie = -1;
 
-	err = tap_ctl_write_message(sfd, &message, &timeout);
+	err = tap_ctl_write_message(sfd, &message, 2);
 	if (err)
 		return err;
 
-	INIT_LIST_HEAD(list);
-
+	INIT_LIST_HEAD(&list);
 	do {
-		err = tap_ctl_read_message(sfd, &message, &timeout);
+		err = tap_ctl_read_message(sfd, &message, 2);
 		if (err) {
 			err = -EPROTO;
-			goto fail;
+			break;
 		}
 
 		if (message.u.list.count == 0)
 			break;
 
-		tl = _tap_list_alloc();
+		tl = malloc(sizeof(struct tapdisk_list));
 		if (!tl) {
 			err = -ENOMEM;
-			goto fail;
+			break;
 		}
 
-		tl->pid    = pid;
 		tl->minor  = message.u.list.minor;
 		tl->state  = message.u.list.state;
-
 		if (message.u.list.path[0] != 0) {
-			err = _parse_params(message.u.list.path,
-					    &tl->type, &tl->path);
-			if (err) {
-				_tap_list_free(tl);
-				goto fail;
+			tl->params = strndup(message.u.list.path,
+					     sizeof(message.u.list.path));
+			if (!tl->params) {
+				err = -errno;
+				break;
 			}
-		}
+		} else
+			tl->params = NULL;
 
-		list_add(&tl->entry, list);
+		list_add(&tl->entry, &list);
 	} while (1);
 
-	err = 0;
-out:
-	close(sfd);
-	return 0;
+	if (err)
+		list_for_each_entry_safe(tl, next, &list, entry) {
+			list_del(&tl->entry);
+			free(tl->params);
+			free(tl);
+		}
 
-fail:
-	tap_ctl_list_free(list);
-	goto out;
+	close(sfd);
+	list_splice(&list, _list);
+	return err;
 }
 
-int
-tap_ctl_list(struct list_head *list)
+void
+_tap_ctl_free_tapdisks(struct tapdisk *tapv, int n_taps)
 {
-	struct list_head minors, tapdisks, vbds;
-	tap_list_t *t, *next_t, *v, *next_v, *m, *next_m;
-	int err;
-
-	/*
-	 * Find all minors, find all tapdisks, then list all minors
-	 * they attached to. Output is a 3-way outer join.
-	 */
+	struct tapdisk *tap;
 
-	err = _tap_ctl_find_minors(&minors);
-	if (err < 0)
-		goto fail;
+	for (tap = tapv; tap < &tapv[n_taps]; ++tap) {
+		struct tapdisk_list *tl, *next;
 
-	err = _tap_ctl_find_tapdisks(&tapdisks);
-	if (err < 0)
-		goto fail;
+		list_for_each_entry_safe(tl, next, &tap->list, entry) {
+			free(tl->params);
+			free(tl);
+		}
+	}
 
-	INIT_LIST_HEAD(list);
+	free(tapv);
+}
 
-	tap_list_for_each_entry_safe(t, next_t, &tapdisks) {
+int
+_tap_list_join3(int n_minors, int *minorv, int n_taps, struct tapdisk *tapv,
+		tap_list_t ***_list)
+{
+	tap_list_t **list, **_entry, *entry;
+	int i, _m, err;
 
-		err = _tap_ctl_list_tapdisk(t->pid, &vbds);
+	list = tap_ctl_alloc_list(n_minors + n_taps);
+	if (!list) {
+		err = -ENOMEM;
+		goto fail;
+	}
+
+	_entry = list;
 
-		if (err || list_empty(&vbds)) {
-			list_move_tail(&t->entry, list);
+	for (i = 0; i < n_taps; ++i) {
+		struct tapdisk *tap = &tapv[i];
+		struct tapdisk_list *tl;
+
+		/* orphaned tapdisk */
+		if (list_empty(&tap->list)) {
+			err = init_list(*_entry++, tap->id, tap->pid, -1, -1, NULL);
+			if (err)
+				goto fail;
 			continue;
 		}
 
-		tap_list_for_each_entry_safe(v, next_v, &vbds) {
+		list_for_each_entry(tl, &tap->list, entry) {
+
+			err = init_list(*_entry++,
+					tap->id, tap->pid,
+					tl->minor, tl->state, tl->params);
+			if (err)
+				goto fail;
 
-			tap_list_for_each_entry_safe(m, next_m, &minors)
-				if (m->minor == v->minor) {
-					_tap_list_free(m);
-					break;
+			if (tl->minor >= 0) {
+				/* clear minor */
+				for (_m = 0; _m < n_minors; ++_m) {
+					if (minorv[_m] == tl->minor) {
+						minorv[_m] = -1;
+						break;
+					}
 				}
+			}
+		}
+	}
 
-			list_move_tail(&v->entry, list);
+	/* orphaned minors */
+	for (_m = 0; _m < n_minors; ++_m) {
+		int minor = minorv[_m];
+		if (minor >= 0) {
+			err = init_list(*_entry++, -1, -1, minor, -1, NULL);
+			if (err)
+				goto fail;
 		}
+	}
 
-		_tap_list_free(t);
+	/* free extraneous list entries */
+	for (; *_entry != NULL; ++entry) {
+		free_list(*_entry);
+		*_entry = NULL;
 	}
 
-	/* orphaned minors */
-	list_splice_tail(&minors, list);
+	*_list = list;
 
 	return 0;
 
 fail:
-	tap_ctl_list_free(list);
-
-	tap_ctl_list_free(&vbds);
-	tap_ctl_list_free(&tapdisks);
-	tap_ctl_list_free(&minors);
+	if (list)
+		tap_ctl_free_list(list);
 
 	return err;
 }
 
 int
-tap_ctl_list_pid(pid_t pid, struct list_head *list)
+tap_ctl_list(tap_list_t ***list)
 {
-	tap_list_t *t;
-	int err;
+	int n_taps, n_minors, err, *minorv;
+	struct tapdisk *tapv, *tap;
 
-	t = _tap_list_alloc();
-	if (!t)
-		return -ENOMEM;
+	n_taps   = -1;
+	n_minors = -1;
 
-	t->pid = tap_ctl_get_pid(pid);
-	if (t->pid < 0) {
-		_tap_list_free(t);
-		return 0;
+	err = n_minors = _tap_ctl_find_minors(&minorv);
+	if (err < 0)
+		goto out;
+
+	err = n_taps = _tap_ctl_find_tapdisks(&tapv);
+	if (err < 0)
+		goto out;
+
+	for (tap = tapv; tap < &tapv[n_taps]; ++tap) {
+		err = _tap_ctl_list_tapdisk(tap->id, &tap->list);
+		if (err)
+			goto out;
 	}
 
-	err = _tap_ctl_list_tapdisk(t->pid, list);
+	err = _tap_list_join3(n_minors, minorv, n_taps, tapv, list);
+
+out:
+	if (n_taps > 0)
+		_tap_ctl_free_tapdisks(tapv, n_taps);
 
-	if (err || list_empty(list))
-		list_add_tail(&t->entry, list);
+	if (n_minors > 0)
+		free(minorv);
 
-	return 0;
+	return err;
 }
 
 int
-tap_ctl_find_minor(const char *type, const char *path)
+tap_ctl_find(const char *type, const char *path, tap_list_t *tap)
 {
-	struct list_head list = LIST_HEAD_INIT(list);
-	tap_list_t *entry;
-	int minor, err;
+	tap_list_t **list, **_entry;
+	int ret = -ENOENT, err;
 
 	err = tap_ctl_list(&list);
 	if (err)
 		return err;
 
-	minor = -1;
-
-	tap_list_for_each_entry(entry, &list) {
+	for (_entry = list; *_entry != NULL; ++_entry) {
+		tap_list_t *entry  = *_entry;
 
 		if (type && (!entry->type || strcmp(entry->type, type)))
 			continue;
@@ -406,36 +524,13 @@
 		if (path && (!entry->path || strcmp(entry->path, path)))
 			continue;
 
-		minor = entry->minor;
+		*tap = *entry;
+		tap->type = tap->path = NULL;
+		ret = 0;
 		break;
 	}
 
-	tap_ctl_list_free(&list);
-
-	return minor >= 0 ? minor : -ENOENT;
-}
-
-int
-tap_ctl_find_pid(int minor)
-{
-	int pid, err;
-	tap_list_t *entry;
-	struct list_head list = LIST_HEAD_INIT(list);
-
-	err = tap_ctl_list(&list);
-	if (err)
-		return err;
-
-	pid = -1;
-
-	tap_list_for_each_entry(entry, &list) {
-		if (entry->minor == minor) {
-			pid = entry->pid;
-			break;
-		}
-	}
-
-	tap_ctl_list_free(&list);
+	tap_ctl_free_list(list);
 
-	return pid >= 0 ? pid : -ENOENT;
+	return ret;
 }
diff -Nur blktap2_oxt//control/tap-ctl-open.c blktap2_xen//control/tap-ctl-open.c
--- blktap2_oxt//control/tap-ctl-open.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-open.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -41,8 +36,7 @@
 #include "blktaplib.h"
 
 int
-tap_ctl_open(const int id, const int minor, const char *params, int flags,
-		const int prt_minor, const char *secondary)
+tap_ctl_open(const int id, const int minor, const char *params)
 {
 	int err;
 	tapdisk_message_t message;
@@ -50,9 +44,8 @@
 	memset(&message, 0, sizeof(message));
 	message.type = TAPDISK_MESSAGE_OPEN;
 	message.cookie = minor;
+	message.u.params.storage = TAPDISK_STORAGE_TYPE_DEFAULT;
 	message.u.params.devnum = minor;
-	message.u.params.prt_devnum = prt_minor;
-	message.u.params.flags = flags;
 
 	err = snprintf(message.u.params.path,
 		       sizeof(message.u.params.path) - 1, "%s", params);
@@ -61,17 +54,7 @@
 		return ENAMETOOLONG;
 	}
 
-	if (secondary) {
-		err = snprintf(message.u.params.secondary,
-			       sizeof(message.u.params.secondary) - 1, "%s",
-			       secondary);
-		if (err >= sizeof(message.u.params.secondary)) {
-			EPRINTF("secondary image name too long\n");
-			return ENAMETOOLONG;
-		}
-	}
-
-	err = tap_ctl_connect_send_and_receive(id, &message, NULL);
+	err = tap_ctl_connect_send_and_receive(id, &message, 5);
 	if (err)
 		return err;
 
diff -Nur blktap2_oxt//control/tap-ctl-pause.c blktap2_xen//control/tap-ctl-pause.c
--- blktap2_oxt//control/tap-ctl-pause.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-pause.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -39,7 +34,7 @@
 #include "tap-ctl.h"
 
 int
-tap_ctl_pause(const int id, const int minor, struct timeval *timeout)
+tap_ctl_pause(const int id, const int minor)
 {
 	int err;
 	tapdisk_message_t message;
@@ -48,7 +43,7 @@
 	message.type = TAPDISK_MESSAGE_PAUSE;
 	message.cookie = minor;
 
-	err = tap_ctl_connect_send_and_receive(id, &message, timeout);
+	err = tap_ctl_connect_send_and_receive(id, &message, 5);
 	if (err)
 		return err;
 
diff -Nur blktap2_oxt//drivers/block-aio.c blktap2_xen//drivers/block-aio.c
--- blktap2_oxt//drivers/block-aio.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/block-aio.c	2015-03-19 11:08:36.000000000 -0400
@@ -26,11 +26,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
 
 #include <errno.h>
 #include <fcntl.h>
@@ -40,8 +35,8 @@
 #include <sys/statvfs.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
-#include <linux/fs.h>
 
+#include "blk.h"
 #include "tapdisk.h"
 #include "tapdisk-driver.h"
 #include "tapdisk-interface.h"
@@ -71,7 +66,6 @@
 	int ret;
 	long size;
 	unsigned long total_size;
-	unsigned long long bytes;
 	struct statvfs statBuf;
 	struct stat stat;
 
@@ -84,12 +78,8 @@
 	if (S_ISBLK(stat.st_mode)) {
 		/*Accessing block device directly*/
 		info->size = 0;
-		if (ioctl(fd,BLKGETSIZE64,&bytes)==0) {
-			info->size = bytes >> SECTOR_SHIFT;
-		} else if (ioctl(fd,BLKGETSIZE,&info->size)!=0) {
-			DPRINTF("ERR: BLKGETSIZE and BLKGETSIZE64 failed, couldn't stat image");
+		if (blk_getimagesize(fd, &info->size) != 0)
 			return -EINVAL;
-		}
 
 		DPRINTF("Image size: \n\tpre sector_shift  [%llu]\n\tpost "
 			"sector_shift [%llu]\n",
@@ -97,19 +87,8 @@
 			(long long unsigned)info->size);
 
 		/*Get the sector size*/
-#if defined(BLKSSZGET)
-		{
-			int arg;
+		if (blk_getsectorsize(fd, &info->sector_size) != 0)
 			info->sector_size = DEFAULT_SECTOR_SIZE;
-			ioctl(fd, BLKSSZGET, &info->sector_size);
-			
-			if (info->sector_size != DEFAULT_SECTOR_SIZE)
-				DPRINTF("Note: sector size is %ld (not %d)\n",
-					info->sector_size, DEFAULT_SECTOR_SIZE);
-		}
-#else
-		info->sector_size = DEFAULT_SECTOR_SIZE;
-#endif
 
 	} else {
 		/*Local file? try fstat instead*/
@@ -265,19 +244,6 @@
 	return -EINVAL;
 }
 
-void tdaio_stats(td_driver_t *driver, td_stats_t *st)
-{
-	struct tdaio_state *prv = (struct tdaio_state *)driver->data;
-	int n_pending;
-
-	n_pending = MAX_AIO_REQS - prv->aio_free_count;
-
-	tapdisk_stats_field(st, "reqs", "{");
-	tapdisk_stats_field(st, "max", "lu", MAX_AIO_REQS);
-	tapdisk_stats_field(st, "pending", "d", n_pending);
-	tapdisk_stats_leave(st, '}');
-}
-
 struct tap_disk tapdisk_aio = {
 	.disk_type          = "tapdisk_aio",
 	.flags              = 0,
@@ -289,5 +255,4 @@
 	.td_get_parent_id   = tdaio_get_parent_id,
 	.td_validate_parent = tdaio_validate_parent,
 	.td_debug           = NULL,
-	.td_stats           = tdaio_stats,
 };
diff -Nur blktap2_oxt//drivers/block-log.c blktap2_xen//drivers/block-log.c
--- blktap2_oxt//drivers/block-log.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/block-log.c	2015-03-19 11:08:36.000000000 -0400
@@ -26,11 +26,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2008 Citrix Systems, Inc.
- */
-
-
 /* Driver to sit on top of another disk and log writes, in order
  * to synchronize two distinct disks
  *
@@ -52,6 +47,7 @@
 #include <sys/socket.h>
 #include <sys/un.h>
 
+#include "xc_bitops.h"
 #include "log.h"
 #include "tapdisk.h"
 #include "tapdisk-server.h"
@@ -94,31 +90,6 @@
 
 /* large flat bitmaps don't scale particularly well either in size or scan
  * time, but they'll do for now */
-#define BITS_PER_LONG (sizeof(unsigned long) * 8)
-#define BITS_TO_LONGS(bits) (((bits)+BITS_PER_LONG-1)/BITS_PER_LONG)
-
-#define BITMAP_ENTRY(_nr, _bmap) ((unsigned long*)(_bmap))[(_nr)/BITS_PER_LONG]
-#define BITMAP_SHIFT(_nr) ((_nr) % BITS_PER_LONG)
-
-static inline int test_bit(int nr, void* bmap)
-{
-  return (BITMAP_ENTRY(nr, bmap) >> BITMAP_SHIFT(nr)) & 1;
-}
-
-static inline void clear_bit(int nr, void* bmap)
-{
-  BITMAP_ENTRY(nr, bmap) &= ~(1UL << BITMAP_SHIFT(nr));
-}
-
-static inline void set_bit(int nr, void* bmap)
-{
-  BITMAP_ENTRY(nr, bmap) |= (1UL << BITMAP_SHIFT(nr));
-}
-
-static inline int bitmap_size(uint64_t sz)
-{
-  return sz >> 3;
-}
 
 static int writelog_create(struct tdlog_state *s)
 {
@@ -128,7 +99,8 @@
 
   BDPRINTF("allocating %"PRIu64" bytes for dirty bitmap", bmsize);
 
-  if (!(s->writelog = calloc(bmsize, 1))) {
+  s->writelog = bitmap_alloc(s->size);
+  if (!s->writelog) {
     BWPRINTF("could not allocate dirty bitmap of size %"PRIu64, bmsize);
     return -1;
   }
@@ -319,7 +291,7 @@
     goto err_sock;
   }
     
-  if (bind(s->ctl.fd, &saddr, sizeof(saddr)) < 0) {
+  if (bind(s->ctl.fd, (const struct sockaddr *)&saddr, sizeof(saddr)) < 0) {
     BWPRINTF("error binding control socket to %s: %s", s->ctlpath,
 	     strerror(errno));
     goto err_sock;
@@ -352,11 +324,11 @@
 static int ctl_close(struct tdlog_state* s)
 {
   while (s->connected) {
+    s->connected--;
     tapdisk_server_unregister_event(s->connections[s->connected].id);
     close(s->connections[s->connected].fd);
     s->connections[s->connected].fd = -1;
     s->connections[s->connected].id = 0;
-    s->connected--;
   }
 
   if (s->ctl.fd >= 0) {
@@ -387,7 +359,7 @@
 {
   int i;
 
-  for (i = 0; i <= s->connected; i++) {
+  for (i = 0; i < s->connected; i++) {
     if (s->connections[i].fd == fd) {
       tapdisk_server_unregister_event(s->connections[i].id);
       close(s->connections[i].fd);
diff -Nur blktap2_oxt//drivers/block-ram.c blktap2_xen//drivers/block-ram.c
--- blktap2_oxt//drivers/block-ram.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/block-ram.c	2015-03-19 11:08:36.000000000 -0400
@@ -26,11 +26,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2008 Citrix Systems, Inc.
- */
-
-
 #include <errno.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -39,9 +34,9 @@
 #include <sys/statvfs.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
-#include <linux/fs.h>
 #include <string.h>
 
+#include "blk.h"
 #include "tapdisk.h"
 #include "tapdisk-driver.h"
 #include "tapdisk-interface.h"
@@ -74,10 +69,8 @@
 	if (S_ISBLK(stat.st_mode)) {
 		/*Accessing block device directly*/
 		info->size = 0;
-		if (ioctl(fd,BLKGETSIZE,&info->size)!=0) {
-			DPRINTF("ERR: BLKGETSIZE failed, couldn't stat image");
+		if (blk_getimagesize(fd, &info->size) != 0)
 			return -EINVAL;
-		}
 
 		DPRINTF("Image size: \n\tpre sector_shift  [%llu]\n\tpost "
 			"sector_shift [%llu]\n",
@@ -85,19 +78,8 @@
 			(long long unsigned)info->size);
 
 		/*Get the sector size*/
-#if defined(BLKSSZGET)
-		{
-			int arg;
+		if (blk_getsectorsize(fd, &info->sector_size) != 0)
 			info->sector_size = DEFAULT_SECTOR_SIZE;
-			ioctl(fd, BLKSSZGET, &info->sector_size);
-			
-			if (info->sector_size != DEFAULT_SECTOR_SIZE)
-				DPRINTF("Note: sector size is %ld (not %d)\n",
-					info->sector_size, DEFAULT_SECTOR_SIZE);
-		}
-#else
-		info->sector_size = DEFAULT_SECTOR_SIZE;
-#endif
 
 	} else {
 		/*Local file? try fstat instead*/
@@ -119,7 +101,7 @@
 	disksector_size = info->sector_size;
 	disksize        = info->size;
 	diskinfo        = info->info;
-	DPRINTF("Image sector_size: \n\t[%lu]\n",
+	DPRINTF("Image sector_size: \n\t[%"PRIu64"]\n",
 		info->sector_size);
 
 	return 0;
@@ -144,7 +126,7 @@
 			"sector_shift [%llu]\n",
 			(long long unsigned)(driver->info.size << SECTOR_SHIFT),
 			(long long unsigned)driver->info.size);
-		DPRINTF("Image sector_size: \n\t[%lu]\n",
+		DPRINTF("Image sector_size: \n\t[%"PRIu64"]\n",
 			driver->info.sector_size);
 
 		prv->fd = -1;
diff -Nur blktap2_oxt//drivers/block-vhd.c blktap2_xen//drivers/block-vhd.c
--- blktap2_oxt//drivers/block-vhd.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/block-vhd.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,8 +1,5 @@
-/*
- *
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* 
+ * Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -27,10 +24,6 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * block-vhd.c: asynchronous vhd implementation.
  *
  * A note on write transactions:
  * Writes that require updating the BAT or bitmaps cannot be signaled
@@ -57,20 +50,15 @@
 #include <unistd.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
-#include <uuid/uuid.h> /* For whatever reason, Linux packages this in */
-                       /* e2fsprogs-devel.                            */
 #include <string.h>    /* for memset.                                 */
 #include <libaio.h>
 #include <sys/mman.h>
-#include <sys/syscall.h>
 
 #include "libvhd.h"
 #include "tapdisk.h"
 #include "tapdisk-driver.h"
 #include "tapdisk-interface.h"
 #include "tapdisk-disktype.h"
-#include "tapdisk-storage.h"
-#include "block-crypto.h"
 
 unsigned int SPB;
 
@@ -96,7 +84,8 @@
 			__FILE__, __LINE__, #_p);			\
 		DBG(TLOG_WARN, "%s:%d: FAILED ASSERTION: '%s'\n",	\
 		    __FILE__, __LINE__, #_p);				\
-		td_panic();						\
+		tlog_flush();						\
+		*(int*)0 = 0;						\
 	}
 
 #if (DEBUGGING == 1)
@@ -132,7 +121,6 @@
 #define VHD_OP_BITMAP_READ           3
 #define VHD_OP_BITMAP_WRITE          4
 #define VHD_OP_ZERO_BM_WRITE         5
-#define VHD_OP_REDUNDANT_BM_WRITE    6
 
 #define VHD_BM_BAT_LOCKED            0
 #define VHD_BM_BAT_CLEAR             1
@@ -188,7 +176,6 @@
 	uint8_t                   op;
 	vhd_flag_t                flags;
 	td_request_t              treq;
-	char                     *orig_buf;
 	struct tiocb              tiocb;
 	struct vhd_state         *state;
 	struct vhd_request       *next;
@@ -235,7 +222,6 @@
 	vhd_context_t             vhd;
 	u32                       spp;         /* sectors per page */
         u32                       spb;         /* sectors per block */
-	u64                       first_db;    /* pointer to datablock 0 */
         u64                       next_db;     /* pointer to the next 
 						* (unallocated) datablock */
 
@@ -253,12 +239,6 @@
 	struct vhd_request       *vreq_free[VHD_REQS_DATA];
 	struct vhd_request        vreq_list[VHD_REQS_DATA];
 
-	/* for redundant bitmap writes */
-	int                       padbm_size;
-	char                     *padbm_buf;
-	long int                  debug_skipped_redundant_writes;
-	long int                  debug_done_redundant_writes;
-
 	td_driver_t              *driver;
 
 	uint64_t                  queued;
@@ -294,7 +274,7 @@
 		_vhd_zsize += VHD_BLOCK_SIZE;
 
 	_vhd_zeros = mmap(0, _vhd_zsize, PROT_READ,
-			  MAP_SHARED | MAP_ANONYMOUS, -1, 0);
+			  MAP_SHARED | MAP_ANON, -1, 0);
 	if (_vhd_zeros == MAP_FAILED) {
 		EPRINTF("vhd_initialize failed: %d\n", -errno);
 		_vhd_zeros = NULL;
@@ -353,7 +333,7 @@
 vhd_kill_footer(struct vhd_state *s)
 {
 	int err;
-	off64_t end;
+	off_t end;
 	char *zeros;
 
 	if (s->vhd.footer.type == HD_TYPE_FIXED)
@@ -366,10 +346,10 @@
 	err = 1;
 	memset(zeros, 0xc7c7c7c7, 512);
 
-	if ((end = lseek64(s->vhd.fd, 0, SEEK_END)) == -1)
+	if ((end = lseek(s->vhd.fd, 0, SEEK_END)) == -1)
 		goto fail;
 
-	if (lseek64(s->vhd.fd, (end - 512), SEEK_SET) == -1)
+	if (lseek(s->vhd.fd, (end - 512), SEEK_SET) == -1)
 		goto fail;
 
 	if (write(s->vhd.fd, zeros, 512) != 512)
@@ -384,61 +364,11 @@
 	return 0;
 }
 
-static int
-vhd_fix_batmap(struct vhd_state *s)
-{
-	int err;
-	uint32_t cksm;
-
-	err = vhd_read_batmap_header(&s->vhd, &s->vhd.batmap);
-	if (err) {
-		EPRINTF("%s: failed to read batmap header: %d\n",
-			s->vhd.file, err);
-		goto out;
-	}
-
-	err = vhd_read_batmap_map(&s->vhd, &s->vhd.batmap);
-	if (err) {
-		EPRINTF("%s: failed to read batmap map: %d\n",
-			s->vhd.file, err);
-		goto out;
-	}
-
-	cksm = vhd_checksum_batmap(&s->vhd, &s->vhd.batmap);
-	if (cksm == s->vhd.batmap.header.checksum) {
-		EPRINTF("%s: attempting to reset valid batmap\n", s->vhd.file);
-		err = -EINVAL;
-		goto out;
-	}
-
-	EPRINTF("%s: attempting to reset invalid batmap: "
-		"cksum 0x%x doesn't match header cksum 0x%x\n",
-		s->vhd.file, cksm, s->vhd.batmap.header.checksum);
-
-	/* temporarily disabled for diagnostic purposes */
-	EPRINTF("automatic batmap fixup disabled\n");
-	err = -ENOSYS;
-	goto out;
-
-	vhd_batmap_reset_map(&s->vhd, &s->vhd.batmap);
-
-	err = vhd_write_batmap(&s->vhd, &s->vhd.batmap);
-	if (err) {
-		EPRINTF("%s: failed to reset batmap: %d\n", s->vhd.file, err);
-		goto out;
-	}
-
-out:
-	free(s->vhd.batmap.map);
-	memset(&s->vhd.batmap, 0, sizeof(s->vhd.batmap));
-	return err;
-}
-
 static inline int
 find_next_free_block(struct vhd_state *s)
 {
 	int err;
-	off64_t eom;
+	off_t eom;
 	uint32_t i, entry;
 
 	err = vhd_end_of_headers(&s->vhd, &eom);
@@ -446,9 +376,6 @@
 		return err;
 
 	s->next_db = secs_round_up(eom);
-	s->first_db = s->next_db;
-	if ((s->first_db + s->bm_secs) % s->spp)
-		s->first_db += (s->spp - ((s->first_db + s->bm_secs) % s->spp));
 
 	for (i = 0; i < s->bat.bat.entries; i++) {
 		entry = bat_entry(s, i);
@@ -471,7 +398,7 @@
 static int
 vhd_initialize_bat(struct vhd_state *s)
 {
-	int err, psize, i;
+	int err, psize, batmap_required, i;
 
 	memset(&s->bat, 0, sizeof(struct vhd_bat));
 
@@ -483,48 +410,30 @@
 		return err;
 	}
 
-	if (!test_vhd_flag(s->flags, VHD_FLAG_OPEN_RDONLY)) {
+	batmap_required = 1;
+	if (test_vhd_flag(s->flags, VHD_FLAG_OPEN_RDONLY)) {
+		batmap_required = 0;
+	} else {
 		err = find_next_free_block(s);
 		if (err)
 			goto fail;
 	}
 
 	if (vhd_has_batmap(&s->vhd)) {
-		/*
-		 * if this vhd is read-only, its batmap could be temporarily
-		 * inconsistent due to a background coalesce task, so we retry
-		 * a few times if the initial read fails.
-		 */
 		for (i = 0; i < VHD_BATMAP_MAX_RETRIES; i++) {
 			err = vhd_read_batmap(&s->vhd, &s->bat.batmap);
-			if (!err)
-				break;
-
-			EPRINTF("%s: reading batmap: %d\n", s->vhd.file, err);
-
-			/*
-			 * EINVAL here probably means checksum mismatch.
-			 * if this is a writeable vhd and we have exclusive
-			 * access to it, we'll try to reset the batmap.
-			 */
-			if (err == -EINVAL &&
-			    /*
-			     * vhd_fix_batmap() is temporarily disabled, so
-			     * we'll fail early here to make the error obvious
-			     */
-			    /* test_vhd_flag(s->flags, VHD_FLAG_OPEN_STRICT) && */
-			    !test_vhd_flag(s->flags, VHD_FLAG_OPEN_RDONLY))
-				if (vhd_fix_batmap(s))
+			if (err) {
+				EPRINTF("%s: reading batmap: %d\n",
+						s->vhd.file, err);
+				if (batmap_required)
 					goto fail;
+			} else {
+				break;
+			}
 		}
-
-		/*
-		 * we couldn't read or fix the batmap, but we can still
-		 * carry on without it.
-		 */
 		if (err)
 			EPRINTF("%s: ignoring non-critical batmap error\n",
-				s->vhd.file);
+					s->vhd.file);
 	}
 
 	err = posix_memalign((void **)&s->bat.bat_buf,
@@ -599,7 +508,6 @@
 static int
 vhd_initialize_dynamic_disk(struct vhd_state *s)
 {
-	u32 bm_size;
 	int err;
 
 	err = vhd_get_header(&s->vhd);
@@ -619,19 +527,6 @@
 	s->spb     = s->vhd.header.block_size >> VHD_SECTOR_SHIFT;
 	s->bm_secs = secs_round_up_no_zero(s->spb >> 3);
 
-	s->padbm_size = (s->bm_secs / getpagesize()) * getpagesize();
-	if (s->bm_secs % getpagesize())
-		s->padbm_size += getpagesize();
-
-	err = posix_memalign((void **)&s->padbm_buf, 512, s->padbm_size);
-	if (err)
-		return -err;
-	bm_size = s->bm_secs << VHD_SECTOR_SHIFT;
-	memset(s->padbm_buf, 0, s->padbm_size - bm_size);
-	memset(s->padbm_buf + (s->padbm_size - bm_size), ~0, bm_size);
-	s->debug_skipped_redundant_writes = 0;
-	s->debug_done_redundant_writes = 0;
-
 	if (test_vhd_flag(s->flags, VHD_FLAG_OPEN_NO_CACHE))
 		return 0;
 
@@ -693,7 +588,7 @@
 			full++;
 	}
 
-	DPRINTF("%s version: %s 0x%08x, b: %u, a: %u, f: %u, n: %llu\n",
+	DPRINTF("%s version: %s 0x%08x, b: %u, a: %u, f: %u, n: %"PRIu64"\n",
 		s->vhd.file, buf, s->vhd.footer.crtr_ver, s->bat.bat.entries,
 		allocated, full, s->next_db);
 }
@@ -721,13 +616,6 @@
 	o_flags = ((test_vhd_flag(flags, VHD_FLAG_OPEN_RDONLY)) ? 
 		   VHD_OPEN_RDONLY : VHD_OPEN_RDWR);
 
-	if (test_vhd_flag(flags, VHD_FLAG_OPEN_STRICT))
-		set_vhd_flag(o_flags, VHD_OPEN_STRICT);
-
-#ifdef VHD_LOCKING
-	set_vhd_flag(o_flags, VHD_OPEN_LOCKED);
-#endif
-
 	err = vhd_open(&s->vhd, name, o_flags);
 	if (err) {
 		libvhd_set_log_level(1);
@@ -762,15 +650,10 @@
 	driver->info.sector_size = VHD_SECTOR_SIZE;
 	driver->info.info        = 0;
 
-        DBG(TLOG_INFO, "vhd_open: done (sz:%llu, sct:%lu, inf:%u)\n",
+        DBG(TLOG_INFO, "vhd_open: done (sz:%"PRIu64", sct:%"PRIu64
+            ", inf:%u)\n",
 	    driver->info.size, driver->info.sector_size, driver->info.info);
 
-	err = vhd_open_crypto(&s->vhd, name);
-	if (err) {
-		DPRINTF("failed to init crypto: %d\n", err);
-		goto fail;
-	}
-
 	if (test_vhd_flag(flags, VHD_FLAG_OPEN_STRICT) && 
 	    !test_vhd_flag(flags, VHD_FLAG_OPEN_RDONLY)) {
 		err = vhd_kill_footer(s);
@@ -809,8 +692,6 @@
 			      VHD_FLAG_OPEN_NO_CACHE);
 
 	/* pre-allocate for all but NFS and LVM storage */
-	driver->storage = tapdisk_storage_type(name);
-
 	if (driver->storage != TAPDISK_STORAGE_TYPE_NFS &&
 	    driver->storage != TAPDISK_STORAGE_TYPE_LVM)
 		vhd_flags |= VHD_FLAG_OPEN_PREALLOCATE;
@@ -836,7 +717,7 @@
 			full++;
 	}
 
-	DPRINTF("%s: b: %u, a: %u, f: %u, n: %llu\n",
+	DPRINTF("%s: b: %u, a: %u, f: %u, n: %"PRIu64"\n",
 		s->vhd.file, s->bat.bat.entries, allocated, full, s->next_db);
 }
 
@@ -850,10 +731,6 @@
 	DBG(TLOG_WARN, "vhd_close\n");
 	s = (struct vhd_state *)driver->data;
 
-	DPRINTF("gaps written/skipped: %ld/%ld\n", 
-			s->debug_done_redundant_writes,
-			s->debug_skipped_redundant_writes);
-
 	/* don't write footer if tapdisk is read-only */
 	if (test_vhd_flag(s->flags, VHD_FLAG_OPEN_RDONLY))
 		goto free;
@@ -895,6 +772,7 @@
 vhd_validate_parent(td_driver_t *child_driver,
 		    td_driver_t *parent_driver, td_flag_t flags)
 {
+	uint32_t status;
 	struct stat stats;
 	struct vhd_state *child  = (struct vhd_state *)child_driver->data;
 	struct vhd_state *parent;
@@ -929,7 +807,7 @@
 	}
 	*/
 
-	if (uuid_compare(child->vhd.header.prt_uuid, parent->vhd.footer.uuid)) {
+	if (vhd_uuid_compare(&child->vhd.header.prt_uuid, &parent->vhd.footer.uuid)) {
 		DPRINTF("ERROR: %s: %s, %s: parent uuid has changed since "
 			"snapshot.  Child image no longer valid.\n",
 			__func__, child->vhd.file, parent->vhd.file);
@@ -1465,56 +1343,6 @@
 	aio_write(s, req, offset);
 }
 
-/* This is a performance optimization. When writing sequentially into full 
- * blocks, skipping (up-to-date) bitmaps causes an approx. 25% reduction in 
- * throughput. To prevent skipping, we issue redundant writes into the (padded) 
- * bitmap area just to make all writes sequential. This will help VHDs on raw 
- * block devices, while the FS-based VHDs shouldn't suffer much.
- *
- * Note that it only makes sense to perform this reduntant bitmap write if the 
- * block is completely full (i.e. the batmap entry is set). If the block is not 
- * completely full then one of the following two things will be true:
- *  1. we'll either be allocating new sectors in this block and writing its
- *     bitmap transactionally, which will be slow anyways; or
- *  2. the IO will be skipping over the unallocated sectors again, so the
- *     pattern will not be sequential anyways
- * In either case a redundant bitmap write becomes pointless. This fact 
- * simplifies the implementation of redundant writes: since we know the bitmap 
- * cannot be updated by anyone else, we don't have to worry about transactions 
- * or potential write conflicts.
- * */
-static void
-schedule_redundant_bm_write(struct vhd_state *s, u32 blk)
-{
-	uint64_t offset;
-	struct vhd_bitmap *bm;
-	struct vhd_request *req;
-
-	ASSERT(s->vhd.footer.type != HD_TYPE_FIXED);
-	ASSERT(test_batmap(s, blk));
-
-	req = alloc_vhd_request(s);
-	if (!req) 
-		return;
-
-	req->treq.buf = s->padbm_buf;
-
-	offset = bat_entry(s, blk);
-	ASSERT(offset != DD_BLK_UNUSED);
-	offset <<= VHD_SECTOR_SHIFT;
-	offset -= s->padbm_size - (s->bm_secs << VHD_SECTOR_SHIFT);
-
-	req->op        = VHD_OP_REDUNDANT_BM_WRITE;
-	req->treq.sec  = blk * s->spb;
-	req->treq.secs = s->padbm_size >> VHD_SECTOR_SHIFT;
-	req->next      = NULL;
-
-	DBG(TLOG_DBG, "blk: %u, writing redundant bitmap at %" PRIu64 "\n",
-	    blk, offset);
-
-	aio_write(s, req, offset);
-}
-
 static int
 update_bat(struct vhd_state *s, uint32_t blk)
 {
@@ -1550,19 +1378,12 @@
 }
 
 static int
-vhd_fallocate(int fd, int mode, off_t offset, off_t length)
-{
-	return syscall(SYS_fallocate, fd, mode, offset, length);
-}
-
-static int
 allocate_block(struct vhd_state *s, uint32_t blk)
 {
 	char *zeros;
 	int err, gap;
 	uint64_t offset, size;
 	struct vhd_bitmap *bm;
-	ssize_t count;
 
 	ASSERT(bat_entry(s, blk) == DD_BLK_UNUSED);
 
@@ -1584,37 +1405,20 @@
 	}
 
 	s->bat.pbw_offset = s->next_db;
-	size = vhd_sectors_to_bytes(s->spb + s->bm_secs + gap);
 
 	DBG(TLOG_DBG, "blk: 0x%04x, pbwo: 0x%08"PRIx64"\n",
 	    blk, s->bat.pbw_offset);
 
-	err = vhd_fallocate(s->vhd.fd, 0, offset, size);
-	if (err) {
-		if (errno != ENOSYS) {
-			ERR(errno, "fallocate failed\n");
-			return -errno;
-		}
-
-		if (lseek(s->vhd.fd, offset, SEEK_SET) == (off_t)-1) {
-			ERR(errno, "lseek failed\n");
-			return -errno;
-		}
-
-		count = write(s->vhd.fd, vhd_zeros(size), size);
-		if (count != size) {
-			err = count < 0 ? -errno : -ENOSPC;
-			ERR(errno,
-			    "write failed (%zd, offset %"PRIu64")\n",
-			    count, offset);
-			return err;
-		}
+	if (lseek(s->vhd.fd, offset, SEEK_SET) == (off_t)-1) {
+		ERR(errno, "lseek failed\n");
+		return -errno;
 	}
 
-	err = fdatasync(s->vhd.fd);
-	if (err) {
-		err = -errno;
-		ERR(err, "sync failed");
+	size = vhd_sectors_to_bytes(s->spb + s->bm_secs + gap);
+	err  = write(s->vhd.fd, vhd_zeros(size), size);
+	if (err != size) {
+		err = (err == -1 ? -errno : -EIO);
+		ERR(err, "write failed");
 		return err;
 	}
 
@@ -1690,7 +1494,6 @@
 	u32 blk = 0, sec = 0;
 	struct vhd_bitmap  *bm = NULL;
 	struct vhd_request *req;
-	char *crypto_buf = NULL;
 
 	if (s->vhd.footer.type == HD_TYPE_FIXED) {
 		offset = vhd_sectors_to_bytes(treq.sec);
@@ -1717,30 +1520,15 @@
 	offset  = vhd_sectors_to_bytes(offset);
 
  make_request:
-	if (s->vhd.xts_tfm) {
-		err = posix_memalign((void **)&crypto_buf, VHD_SECTOR_SIZE,
-				     treq.secs * VHD_SECTOR_SIZE);
-		if (err)
-			return -EBUSY;
-	}
 	req = alloc_vhd_request(s);
-	if (!req) {
-		if (s->vhd.xts_tfm)
-			free(crypto_buf);
+	if (!req)
 		return -EBUSY;
-	}
 
 	req->treq  = treq;
 	req->flags = flags;
 	req->op    = VHD_OP_DATA_WRITE;
 	req->next  = NULL;
 
-	if (s->vhd.xts_tfm) {
-		req->orig_buf = req->treq.buf;
-		req->treq.buf = crypto_buf;
-		vhd_crypto_encrypt(&s->vhd, &req->treq, req->orig_buf);
-	}
-
 	if (test_vhd_flag(flags, VHD_FLAG_REQ_UPDATE_BITMAP)) {
 		bm = get_bitmap(s, blk);
 		ASSERT(bm && bitmap_valid(bm));
@@ -1751,11 +1539,7 @@
 			set_vhd_flag(req->flags, VHD_FLAG_REQ_QUEUED);
 		} else
 			add_to_transaction(&bm->tx, req);
-	} else if (sec == 0 && 	/* first sector inside data block */
-		   s->vhd.footer.type != HD_TYPE_FIXED && 
-		   bat_entry(s, blk) != s->first_db &&
-		   test_batmap(s, blk))
-		schedule_redundant_bm_write(s, blk);
+	}
 
 	aio_write(s, req, offset);
 
@@ -1983,6 +1767,7 @@
 
 		case VHD_BM_BAT_LOCKED:
 			err = -EBUSY;
+			clone.blocked = 1;
 			goto fail;
 
 		case VHD_BM_BAT_CLEAR:
@@ -2061,17 +1846,6 @@
 
 		err  = (error ? error : r->error);
 		next = r->next;
-		if (s->vhd.xts_tfm) {
-			switch (r->op) {
-			case VHD_OP_DATA_READ:
-				vhd_crypto_decrypt(&s->vhd, &r->treq);
-				break;
-			case VHD_OP_DATA_WRITE:
-				free(r->treq.buf);
-				r->treq.buf = r->orig_buf;
-				break;
-			}
-		}
 		td_complete_request(r->treq, err);
 		DBG(TLOG_DBG, "lsec: 0x%08"PRIx64", blk: 0x%04"PRIx64", "
 		    "err: %d\n", r->treq.sec, r->treq.sec / s->spb, err);
@@ -2284,26 +2058,6 @@
 		finish_data_transaction(s, bm);
 }
 
-static int
-finish_redundant_bm_write(struct vhd_request *req)
-{
-	/* u32 blk; */
-	struct vhd_state *s = (struct vhd_state *) req->state;
-
-	s->returned++;
-	TRACE(s);	
-	/* blk = req->treq.sec / s->spb;
-	   DBG(TLOG_DBG, "blk: %u\n", blk); */
-
-	if (req->error) {
-		ERR(req->error, "lsec: 0x%08"PRIx64, req->treq.sec);
-	}
-	free_vhd_request(s, req);
-	s->debug_done_redundant_writes++;
-	return 0;
-}
-
-
 static void
 finish_bitmap_read(struct vhd_request *req)
 {
@@ -2472,10 +2226,6 @@
 		finish_zero_bm_write(req);
 		break;
 
-	case VHD_OP_REDUNDANT_BM_WRITE:
-		finish_redundant_bm_write(req);
-		break;
-
 	case VHD_OP_BAT_WRITE:
 		finish_bat_write(req);
 		break;
diff -Nur blktap2_oxt//drivers/libaio-compat.h blktap2_xen//drivers/libaio-compat.h
--- blktap2_oxt//drivers/libaio-compat.h	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/libaio-compat.h	2015-03-19 11:08:36.000000000 -0400
@@ -19,11 +19,6 @@
  */
 
 /*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
-/*
  * kernel 2.6.21 added eventfd(2) support, kernel 2.6.22 eventfds for
  * aio. libaio 0.3.107 updated the header file, but few systems have
  * it. define a custom iocb_common struct instead, and work around a
@@ -34,6 +29,7 @@
 #ifndef __LIBAIO_COMPAT
 #define __LIBAIO_COMPAT
 
+#include "../../config.h"
 #include <libaio.h>
 #include <unistd.h>
 #include <sys/syscall.h>
@@ -55,6 +51,16 @@
 	c->resfd = eventfd;
 }
 
+#ifdef HAVE_SYS_EVENTFD_H
+
+#include <sys/eventfd.h>
+
+static inline int tapdisk_sys_eventfd(int initval)
+{
+	return eventfd(initval, 0);
+}
+
+#else /* Fallback */
 #ifndef SYS_eventfd
 #ifndef __NR_eventfd
 # if defined(__alpha__)
@@ -93,5 +99,6 @@
 {
 	return syscall(SYS_eventfd, initval, 0);
 }
+#endif
 
 #endif /* __LIBAIO_COMPAT */
diff -Nur blktap2_oxt//drivers/Makefile blktap2_xen//drivers/Makefile
--- blktap2_oxt//drivers/Makefile	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/Makefile	2015-03-19 11:08:36.000000000 -0400
@@ -1,108 +1,116 @@
-#
-# Copyright (c) 2014 Citrix Systems, Inc.
-#
-
+XEN_ROOT=$(CURDIR)/../../..
 BLKTAP_ROOT= ..
-include $(BLKTAP_ROOT)/Rules.mk
+include $(XEN_ROOT)/tools/Rules.mk
 
 LIBVHDDIR  = $(BLKTAP_ROOT)/vhd/lib
 
-IBIN       = tapdisk2 td-util tapdisk-stream tapdisk-diff
+IBIN       = tapdisk2 td-util tapdisk-client tapdisk-stream tapdisk-diff
+QCOW_UTIL  = img2qcow qcow-create qcow2raw
 LOCK_UTIL  = lock-util
-INST_DIR   = /usr/sbin
+INST_DIR   = $(SBINDIR)
 
-CFLAGS    += -Wall
-CFLAGS    += -g
+CFLAGS    += -Werror -g
 CFLAGS    += -Wno-unused
 CFLAGS    += -fno-strict-aliasing
-CFLAGS    += -I../include
+CFLAGS    += -I$(BLKTAP_ROOT)/include -I$(BLKTAP_ROOT)/drivers
+CFLAGS    += $(CFLAGS_libxenctrl)
 CFLAGS    += -D_GNU_SOURCE
 CFLAGS    += -DUSE_NFS_LOCKS
-CFLAGS    += -DTAPDISK
 
-LIBS      += -lrt
+ifeq ($(CONFIG_X86_64),y)
+CFLAGS            += -fPIC
+endif
 
-# Get gcc to generate the dependencies for us.
-CFLAGS    += -Wp,-MD,.$(@F).d
-DEPS       = .*.d
+VHDLIBS    := -L$(LIBVHDDIR) -lvhd
 
-tapdisk2 td-util tapdisk-stream tapdisk-diff: LIBS += -L$(LIBVHDDIR) -lvhd -luuid -licbinn_resolved -lpthread -ldl
+REMUS-OBJS  := block-remus.o
+REMUS-OBJS  += hashtable.o
+REMUS-OBJS  += hashtable_itr.o
+REMUS-OBJS  += hashtable_utility.o
 
-ifneq ($(USE_SYSTEM_LIBRARIES),y)
+ifneq ($(CONFIG_SYSTEM_LIBAIO),y)
+CFLAGS    += -I $(LIBAIO_DIR)
 LIBAIO_DIR = $(XEN_ROOT)/tools/libaio/src
-tapdisk2 tapdisk-stream tapdisk-diff: AIOLIBS := $(LIBAIO_DIR)/libaio.a
-tapdisk2 tapdisk-stream tapdisk-diff: CFLAGS  += -I$(LIBAIO_DIR) -I$(XEN_LIBXC)
-tapdisk2 tapdisk-client tapdisk-stream tapdisk-diff block-log: CFLAGS += -I$(XEN_ROOT)/tools/include
+tapdisk2 tapdisk-stream tapdisk-diff $(QCOW_UTIL): AIOLIBS := $(LIBAIO_DIR)/libaio.a 
+tapdisk-client tapdisk-stream tapdisk-diff $(QCOW_UTIL): CFLAGS  += -I$(LIBAIO_DIR)
 else
-tapdisk2 tapdisk-stream tapdisk-diff: AIOLIBS := -laio
+tapdisk2 tapdisk-stream tapdisk-diff $(QCOW_UTIL): AIOLIBS := -laio
+endif
+
+MEMSHRLIBS :=
+ifeq ($(CONFIG_Linux), __fixme__)
+MEMSHR_DIR = $(XEN_ROOT)/tools/memshr
+CFLAGS += -DMEMSHR
+CFLAGS += -I $(MEMSHR_DIR)
+MEMSHRLIBS += -L$(XEN_ROOT)/tools/libxc -lxenctrl $(MEMSHR_DIR)/libmemshr.a
 endif
 
 ifeq ($(VHD_STATIC),y)
 td-util: CFLAGS += -static
 endif
 
-tapdisk tapdisk2 tapdisk-stream tapdisk-diff: LIBS += -lcrypto -Lcrypto -lxts-aes
-tapdisk tapdisk2 tapdisk-stream tapdisk-diff: crypto/libxts-aes.a
-
-crypto/libxts-aes.a: crypto/*.c crypto/*.h
-	$(MAKE) -C crypto libxts-aes.a
+PORTABLE-OBJS-y :=
+PORTABLE-OBJS-$(CONFIG_Linux)  += blk_linux.o
+PORTABLE-OBJS-$(CONFIG_NetBSD) += blk_netbsd.o
+
+TAP-OBJS-y  := scheduler.o
+TAP-OBJS-y  += tapdisk-vbd.o
+TAP-OBJS-y  += tapdisk-control.o
+TAP-OBJS-y  += tapdisk-image.o
+TAP-OBJS-y  += tapdisk-driver.o
+TAP-OBJS-y  += tapdisk-disktype.o
+TAP-OBJS-y  += tapdisk-interface.o
+TAP-OBJS-y  += tapdisk-server.o
+TAP-OBJS-y  += tapdisk-queue.o
+TAP-OBJS-y  += tapdisk-filter.o
+TAP-OBJS-y  += tapdisk-log.o
+TAP-OBJS-y  += tapdisk-utils.o
+TAP-OBJS-y  += io-optimize.o
+TAP-OBJS-y  += lock.o
+TAP-OBJS-y  += $(PORTABLE-OBJS-y)
+
+MISC-OBJS-y := atomicio.o
+
+BLK-OBJS-y  := block-aio.o
+BLK-OBJS-y  += block-ram.o
+BLK-OBJS-y  += block-cache.o
+BLK-OBJS-y  += block-vhd.o
+BLK-OBJS-y  += block-log.o
+BLK-OBJS-y  += block-qcow.o
+BLK-OBJS-y  += aes.o
+BLK-OBJS-y  += md5.o
+BLK-OBJS-y  += $(PORTABLE-OBJS-y)
+BLK-OBJS-y  += $(REMUS-OBJS)
 
-TAP-OBJS  := scheduler.o
-TAP-OBJS  += tapdisk-control.o
-TAP-OBJS  += tapdisk-vbd.o
-TAP-OBJS  += tapdisk-image.o
-TAP-OBJS  += tapdisk-driver.o
-TAP-OBJS  += tapdisk-disktype.o
-TAP-OBJS  += tapdisk-interface.o
-TAP-OBJS  += tapdisk-server.o
-TAP-OBJS  += tapdisk-queue.o
-TAP-OBJS  += tapdisk-filter.o
-TAP-OBJS  += tapdisk-logfile.o
-TAP-OBJS  += tapdisk-log.o
-TAP-OBJS  += tapdisk-utils.o
-TAP-OBJS  += tapdisk-syslog.o
-TAP-OBJS  += tapdisk-stats.o
-TAP-OBJS  += tapdisk-storage.o
-TAP-OBJS  += io-optimize.o
-TAP-OBJS  += lock.o
-
-MISC-OBJS := atomicio.o
-
-BLK-OBJS  := block-aio.o
-BLK-OBJS  += block-ram.o
-BLK-OBJS  += block-cache.o
-BLK-OBJS  += block-vhd.o
-BLK-OBJS  += block-vindex.o
-BLK-OBJS  += block-lcache.o
-BLK-OBJS  += block-crypto.o
+all: $(IBIN) lock-util qcow-util
 
-all: $(IBIN) lock-util
 
-TAPDISK-OBJS := $(TAP-OBJS) $(BLK-OBJS)
-
-tapdisk2: tapdisk2.c $(TAPDISK-OBJS) $(MISC-OBJS)
-	$(CC) $(CFLAGS) -o $@ $(TAPDISK-OBJS) $(MISC-OBJS) $< $(LIBS) $(AIOLIBS)
+tapdisk2: $(TAP-OBJS-y) $(BLK-OBJS-y) $(MISC-OBJS-y) tapdisk2.o
+	$(CC) -o $@ $^ $(LDFLAGS) -lrt -lz $(VHDLIBS) $(AIOLIBS) $(MEMSHRLIBS) -lm 
 
 tapdisk-client: tapdisk-client.o
-	$(CC) $(CFLAGS) -o $@ $^ $(LIBS)
+	$(CC) -o $@ $^ $(LDFLAGS) -lrt
 
-tapdisk-stream tapdisk-diff: %: %.o $(TAPDISK-OBJS)
-	$(CC) $(CFLAGS) -o $@ $< $(TAPDISK-OBJS) $(LIBS) $(AIOLIBS)
+tapdisk-stream tapdisk-diff: %: %.o $(TAP-OBJS-y) $(BLK-OBJS-y)
+	$(CC) -o $@ $^ $(LDFLAGS) -lrt -lz $(VHDLIBS) $(AIOLIBS) $(MEMSHRLIBS) -lm
 
-td-util: td.o tapdisk-utils.o
-	$(CC) $(CFLAGS) -o $@ $^ $(LIBS)
+td-util: td.o tapdisk-utils.o tapdisk-log.o $(PORTABLE-OBJS-y)
+	$(CC) -o $@ $^ $(LDFLAGS) $(VHDLIBS)
 
 lock-util: lock.c
-	$(CC) $(CFLAGS) -DUTIL -o lock-util lock.c $(LIBS)
+	$(CC) $(CFLAGS) -DUTIL -o lock-util lock.c $(LDFLAGS)
+
+.PHONY: qcow-util
+qcow-util: img2qcow qcow2raw qcow-create
+
+img2qcow qcow2raw qcow-create: %: %.o $(TAP-OBJS-y) $(BLK-OBJS-y)
+	$(CC) -o $@ $^ $(LDFLAGS) -lrt -lz $(VHDLIBS) $(AIOLIBS) $(MEMSHRLIBS) -lm
 
 install: all
 	$(INSTALL_DIR) -p $(DESTDIR)$(INST_DIR)
-	$(INSTALL_PROG) $(IBIN) $(LOCK_UTIL) $(DESTDIR)$(INST_DIR)
+	$(INSTALL_PROG) $(IBIN) $(LOCK_UTIL) $(QCOW_UTIL) $(DESTDIR)$(INST_DIR)
 
 clean:
-	rm -rf *.o *~ $(DEPS) xen TAGS $(IBIN) $(LIB) $(LOCK_UTIL)
-	$(MAKE) -C crypto clean
+	rm -rf .*.d *.o *~ xen TAGS $(IBIN) $(LIB) $(LOCK_UTIL) $(QCOW_UTIL)
 
 .PHONY: clean install
-
--include $(DEPS)
diff -Nur blktap2_oxt//drivers/scheduler.c blktap2_xen//drivers/scheduler.c
--- blktap2_oxt//drivers/scheduler.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/scheduler.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,23 +25,16 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <errno.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
 #include <sys/time.h>
 
-#include "tapdisk.h"
 #include "scheduler.h"
 #include "tapdisk-log.h"
 
 #define DBG(_f, _a...)               tlog_write(TLOG_DBG, _f, ##_a)
-#define BUG_ON(_cond)                if (_cond) td_panic()
 
 #define SCHEDULER_MAX_TIMEOUT        600
 #define SCHEDULER_POLL_FD           (SCHEDULER_POLL_READ_FD |	\
@@ -51,17 +44,11 @@
 #define MIN(a, b)                   ((a) <= (b) ? (a) : (b))
 #define MAX(a, b)                   ((a) >= (b) ? (a) : (b))
 
-#define scheduler_for_each_event(s, event)	\
-	list_for_each_entry(event, &(s)->events, next)
-#define scheduler_for_each_event_safe(s, event, tmp)	\
+#define scheduler_for_each_event(s, event, tmp)	\
 	list_for_each_entry_safe(event, tmp, &(s)->events, next)
 
 typedef struct event {
 	char                         mode;
-	char                         dead;
-	char                         pending;
-	char                         masked;
-
 	event_id_t                   id;
 
 	int                          fd;
@@ -79,21 +66,18 @@
 {
 	int diff;
 	struct timeval now;
-	event_t *event;
+	event_t *event, *tmp;
 
 	FD_ZERO(&s->read_fds);
 	FD_ZERO(&s->write_fds);
 	FD_ZERO(&s->except_fds);
 
-	s->max_fd  = -1;
+	s->max_fd  = 0;
 	s->timeout = SCHEDULER_MAX_TIMEOUT;
 
 	gettimeofday(&now, NULL);
 
-	scheduler_for_each_event(s, event) {
-		if (event->masked || event->dead)
-			continue;
-
+	scheduler_for_each_event(s, event, tmp) {
 		if (event->mode & SCHEDULER_POLL_READ_FD) {
 			FD_SET(event->fd, &s->read_fds);
 			s->max_fd = MAX(event->fd, s->max_fd);
@@ -121,89 +105,59 @@
 	s->timeout = MIN(s->timeout, s->max_timeout);
 }
 
-static int
-scheduler_check_events(scheduler_t *s, int nfds)
+static void
+scheduler_event_callback(event_t *event, char mode)
 {
-	event_t *event;
-	struct timeval now;
+	if (event->mode & SCHEDULER_POLL_TIMEOUT) {
+		struct timeval now;
+		gettimeofday(&now, NULL);
+		event->deadline = now.tv_sec + event->timeout;
+	}
 
-	if (nfds <= 0)
-		return nfds;
+	event->cb(event->id, mode, event->private);
+}
+
+static void
+scheduler_run_events(scheduler_t *s)
+{
+	struct timeval now;
+	event_t *event, *tmp;
 
 	gettimeofday(&now, NULL);
 
-	scheduler_for_each_event(s, event) {
-		if (event->dead)
-			continue;
+ again:
+	s->restart = 0;
 
+	scheduler_for_each_event(s, event, tmp) {
 		if ((event->mode & SCHEDULER_POLL_READ_FD) &&
 		    FD_ISSET(event->fd, &s->read_fds)) {
 			FD_CLR(event->fd, &s->read_fds);
-			event->pending |= SCHEDULER_POLL_READ_FD;
-			--nfds;
+			scheduler_event_callback(event, SCHEDULER_POLL_READ_FD);
+			goto next;
 		}
 
 		if ((event->mode & SCHEDULER_POLL_WRITE_FD) &&
 		    FD_ISSET(event->fd, &s->write_fds)) {
 			FD_CLR(event->fd, &s->write_fds);
-			event->pending |= SCHEDULER_POLL_WRITE_FD;
-			--nfds;
+			scheduler_event_callback(event, SCHEDULER_POLL_WRITE_FD);
+			goto next;
 		}
 
 		if ((event->mode & SCHEDULER_POLL_EXCEPT_FD) &&
 		    FD_ISSET(event->fd, &s->except_fds)) {
 			FD_CLR(event->fd, &s->except_fds);
-			event->pending |= SCHEDULER_POLL_EXCEPT_FD;
-			--nfds;
-		}
-
-		if (event->pending) {
-			BUG_ON(event->masked);
-			continue;
+			scheduler_event_callback(event, SCHEDULER_POLL_EXCEPT_FD);
+			goto next;
 		}
 
 		if ((event->mode & SCHEDULER_POLL_TIMEOUT) &&
 		    (event->deadline <= now.tv_sec))
-			event->pending = SCHEDULER_POLL_TIMEOUT;
-	}
+		    scheduler_event_callback(event, SCHEDULER_POLL_TIMEOUT);
 
-	return nfds;
-}
-
-static void
-scheduler_event_callback(event_t *event, char mode)
-{
-	if (event->mode & SCHEDULER_POLL_TIMEOUT) {
-		struct timeval now;
-		gettimeofday(&now, NULL);
-		event->deadline = now.tv_sec + event->timeout;
+	next:
+		if (s->restart)
+			goto again;
 	}
-
-	event->cb(event->id, mode, event->private);
-}
-
-static int
-scheduler_run_events(scheduler_t *s)
-{
-	event_t *event;
-	int n_dispatched = 0;
-
-	scheduler_for_each_event(s, event) {
-		char pending;
-
-		if (event->dead)
-			continue;
-
-		pending = event->pending;
-		if (pending) {
-			event->pending = 0;
-			/* NB. must clear before cb */
-			scheduler_event_callback(event, pending);
-			n_dispatched++;
-		}
-	}
-
-	return n_dispatched;
 }
 
 int
@@ -234,7 +188,6 @@
 	event->cb       = cb;
 	event->private  = private;
 	event->id       = s->uuid++;
-	event->masked   = 0;
 
 	if (!s->uuid)
 		s->uuid++;
@@ -247,42 +200,17 @@
 void
 scheduler_unregister_event(scheduler_t *s, event_id_t id)
 {
-	event_t *event;
-
-	if (!id)
-		return;
-
-	scheduler_for_each_event(s, event)
-		if (event->id == id) {
-			event->dead = 1;
-			break;
-		}
-}
-
-void
-scheduler_mask_event(scheduler_t *s, event_id_t id, int masked)
-{
-	event_t *event;
+	event_t *event, *tmp;
 
 	if (!id)
 		return;
 
-	scheduler_for_each_event(s, event)
+	scheduler_for_each_event(s, event, tmp)
 		if (event->id == id) {
-			event->masked = !!masked;
-			break;
-		}
-}
-
-static void
-scheduler_gc_events(scheduler_t *s)
-{
-	event_t *event, *next;
-
-	scheduler_for_each_event_safe(s, event, next)
-		if (event->dead) {
 			list_del(&event->next);
 			free(event);
+			s->restart = 1;
+			break;
 		}
 }
 
@@ -299,15 +227,6 @@
 	int ret;
 	struct timeval tv;
 
-	s->depth++;
-	ret = 0;
-
-	if (s->depth > 1 && scheduler_run_events(s))
-		/* NB. recursive invocations continue with the pending
-		 * event set. We return as soon as we made some
-		 * progress. */
-		goto out;
-
 	scheduler_prepare_events(s);
 
 	tv.tv_sec  = s->timeout;
@@ -319,22 +238,14 @@
 	ret = select(s->max_fd + 1, &s->read_fds,
 		     &s->write_fds, &s->except_fds, &tv);
 
-	if (ret < 0)
-		goto out;
-
-	ret = scheduler_check_events(s, ret);
-	BUG_ON(ret);
-
+	s->restart     = 0;
 	s->timeout     = SCHEDULER_MAX_TIMEOUT;
 	s->max_timeout = SCHEDULER_MAX_TIMEOUT;
 
-	scheduler_run_events(s);
-
-	if (s->depth == 1)
-		scheduler_gc_events(s);
+	if (ret < 0)
+		return ret;
 
-out:
-	s->depth--;
+	scheduler_run_events(s);
 
 	return ret;
 }
@@ -344,8 +255,7 @@
 {
 	memset(s, 0, sizeof(scheduler_t));
 
-	s->uuid  = 1;
-	s->depth = 0;
+	s->uuid = 1;
 
 	FD_ZERO(&s->read_fds);
 	FD_ZERO(&s->write_fds);
diff -Nur blktap2_oxt//drivers/scheduler.h blktap2_xen//drivers/scheduler.h
--- blktap2_oxt//drivers/scheduler.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/scheduler.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #ifndef _SCHEDULER_H_
 #define _SCHEDULER_H_
 
@@ -55,8 +50,8 @@
 	int                          uuid;
 	int                          max_fd;
 	int                          timeout;
+	int                          restart;
 	int                          max_timeout;
-	int                          depth;
 } scheduler_t;
 
 void scheduler_initialize(scheduler_t *);
@@ -64,7 +59,6 @@
 				    int fd, int timeout,
 				    event_cb_t cb, void *private);
 void scheduler_unregister_event(scheduler_t *,  event_id_t);
-void scheduler_mask_event(scheduler_t *, event_id_t, int masked);
 void scheduler_set_max_timeout(scheduler_t *, int);
 int scheduler_wait_for_events(scheduler_t *);
 
diff -Nur blktap2_oxt//drivers/tapdisk2.c blktap2_xen//drivers/tapdisk2.c
--- blktap2_oxt//drivers/tapdisk2.c	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk2.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,16 +25,14 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <stdlib.h>
 #include <unistd.h>
+#ifdef MEMSHR
+#include <memshr.h>
+#endif
 
 #include "tapdisk.h"
 #include "tapdisk-utils.h"
@@ -44,80 +42,20 @@
 static void
 usage(const char *app, int err)
 {
-	fprintf(stderr, "usage: %s [-D don't daemonize] [-h help]\n", app);
+	fprintf(stderr, "usage: %s [-D] <-u uuid> <-c control socket>\n", app);
 	exit(err);
 }
 
-static FILE *
-fdup(FILE *stream, const char *mode)
-{
-	int fd, err;
-	FILE *f;
-
-	fd = dup(STDOUT_FILENO);
-	if (fd < 0)
-		goto fail;
-
-	f = fdopen(fd, mode);
-	if (!f)
-		goto fail;
-
-	return f;
-
-fail:
-	err = -errno;
-	if (fd >= 0)
-		close(fd);
-	errno = -err;
-
-	return NULL;
-}
-
-/*
- * put tapdisk pids in non-volatile directory for debugging purposes
- */
-#define TAPDISK2_PID_DIRECTORY "/var/log/tapdisk-pids"
-static char tapdisk2_pid_file[512] = { 0 };
-
-static int
-tapdisk2_create_pid_file(void)
-{
-	int fd;
-
-	if (access(TAPDISK2_PID_DIRECTORY, X_OK))
-		return (errno == ENOENT ? 0 : -errno);
-
-	snprintf(tapdisk2_pid_file, sizeof(tapdisk2_pid_file),
-		 "%s/%u", TAPDISK2_PID_DIRECTORY, getpid());
-
-	fd = open(tapdisk2_pid_file, O_CREAT | O_EXCL, 0644);
-	if (fd == -1)
-		return -errno;
-
-	close(fd);
-	return 0;
-}
-
-static int
-tapdisk2_remove_pid_file(void)
-{
-	if (!tapdisk2_pid_file[0])
-		return -EINVAL;
-
-	return (unlink(tapdisk2_pid_file) == -1 ? -errno : 0);
-}
-
 int
 main(int argc, char *argv[])
 {
 	char *control;
-	int c, err, nodaemon, fd;
-	FILE *out;
+	int c, err, nodaemon;
 
 	control  = NULL;
 	nodaemon = 0;
 
-	while ((c = getopt(argc, argv, "Dh")) != -1) {
+	while ((c = getopt(argc, argv, "s:Dh")) != -1) {
 		switch (c) {
 		case 'D':
 			nodaemon = 1;
@@ -125,6 +63,14 @@
 		case 'h':
 			usage(argv[0], 0);
 			break;
+		case 's':
+#ifdef MEMSHR
+			memshr_set_domid(atoi(optarg));
+#else
+			fprintf(stderr, "MEMSHR support not compiled in.\n");
+			exit(EXIT_FAILURE);
+#endif
+			break;
 		default:
 			usage(argv[0], EINVAL);
 		}
@@ -133,56 +79,60 @@
 	if (optind != argc)
 		usage(argv[0], EINVAL);
 
-	err = tapdisk_server_init();
-	if (err) {
-		DPRINTF("failed to initialize server: %d\n", err);
+	if (chdir("/")) {
+		DPRINTF("failed to chdir(/): %d\n", errno);
+		err = 1;
 		goto out;
 	}
 
-	out = fdup(stdout, "w");
-	if (!out) {
-		err = -errno;
-		DPRINTF("failed to dup stdout: %d\n", err);
+	tapdisk_start_logging("tapdisk2");
+
+	err = tapdisk_server_init();
+	if (err) {
+		DPRINTF("failed to initialize server: %d\n", err);
 		goto out;
 	}
 
 	if (!nodaemon) {
-		err = daemon(0, 0);
+		err = daemon(0, 1);
 		if (err) {
 			DPRINTF("failed to daemonize: %d\n", errno);
 			goto out;
 		}
 	}
 
-	tapdisk_start_logging("tapdisk", NULL);
-
 	err = tapdisk_control_open(&control);
 	if (err) {
 		DPRINTF("failed to open control socket: %d\n", err);
 		goto out;
 	}
 
-	err = tapdisk_server_complete();
-	if (err) {
-		DPRINTF("failed to complete server: %d\n", err);
-		goto out;
-	}
+	fprintf(stdout, "%s\n", control);
+	fflush(stdout);
+
+	if (!nodaemon) {
+		int fd;
 
-	fprintf(out, "%s\n", control);
-	fclose(out);
+		fd = open("/dev/null", O_RDWR);
+		if (fd != -1) {
+			dup2(fd, STDIN_FILENO);
+			dup2(fd, STDOUT_FILENO);
+			dup2(fd, STDERR_FILENO);
+			if (fd > 2)
+				close(fd);
+		}
+	}
 
-	err = tapdisk2_create_pid_file();
+	err = tapdisk_server_complete();
 	if (err) {
-		DPRINTF("failed to create pid file: %d\n", err);
+		DPRINTF("failed to complete server: %d\n", err);
 		goto out;
 	}
 
 	err = tapdisk_server_run();
-	if (!err)
-		tapdisk2_remove_pid_file();
 
 out:
 	tapdisk_control_close();
 	tapdisk_stop_logging();
-	return -err;
+	return err;
 }
diff -Nur blktap2_oxt//drivers/tapdisk-control.c blktap2_xen//drivers/tapdisk-control.c
--- blktap2_oxt//drivers/tapdisk-control.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-control.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -42,7 +37,6 @@
 #include <sys/types.h>
 #include <sys/ioctl.h>
 #include <sys/socket.h>
-#include <sys/mman.h>
 
 #include "list.h"
 #include "tapdisk.h"
@@ -53,348 +47,32 @@
 #include "tapdisk-server.h"
 #include "tapdisk-message.h"
 #include "tapdisk-disktype.h"
-#include "tapdisk-stats.h"
-#include "tapdisk-control.h"
-
-#define TD_CTL_MAX_CONNECTIONS  10
-#define TD_CTL_SOCK_BACKLOG     32
-#define TD_CTL_RECV_TIMEOUT     10
-#define TD_CTL_SEND_TIMEOUT     10
-#define TD_CTL_SEND_BUFSZ       4096
-
-#define DBG(_f, _a...)             tlog_syslog(LOG_DEBUG, _f, ##_a)
-#define ERR(err, _f, _a...)        tlog_error(err, _f, ##_a)
-
-#define ASSERT(_p)							\
-	if (!(_p)) {							\
-		EPRINTF("%s:%d: FAILED ASSERTION: '%s'\n",		\
-			__FILE__, __LINE__, #_p);			\
-		td_panic();						\
-	}
-
-#define WARN_ON(_p)							\
-	if (_p) {							\
-		EPRINTF("%s:%d: WARNING: '%s'\n",			\
-			__FILE__, __LINE__, #_p);			\
-	}
-
-struct tapdisk_ctl_conn {
-	int             fd;
-
-	struct {
-		void           *buf;
-		size_t          bufsz;
-		int             event_id;
-		int             done;
-
-		void           *prod;
-		void           *cons;
-	} out;
-
-	struct {
-		int             event_id;
-		int             busy;
-	} in;
-
-	struct tapdisk_control_info *info;
-};
-
-#define TAPDISK_MSG_REENTER    (1<<0) /* non-blocking, idempotent */
-#define TAPDISK_MSG_VERBOSE    (1<<1) /* tell syslog about it */
-
-struct tapdisk_control_info {
-	void (*handler)(struct tapdisk_ctl_conn *, tapdisk_message_t *);
-	int flags;
-};
 
 struct tapdisk_control {
 	char              *path;
-	int                uuid;
 	int                socket;
 	int                event_id;
-	int                busy;
+};
 
-	int                n_conn;
-	struct tapdisk_ctl_conn __conn[TD_CTL_MAX_CONNECTIONS];
-	struct tapdisk_ctl_conn *conn[TD_CTL_MAX_CONNECTIONS];
+struct tapdisk_control_connection {
+	int                socket;
+	event_id_t         event_id;
 };
 
 static struct tapdisk_control td_control;
 
-static inline size_t
-page_align(size_t size)
-{
-	size_t page_size = sysconf(_SC_PAGE_SIZE);
-	return (size + page_size - 1) & ~(page_size - 1);
-}
-
-static void
-tapdisk_ctl_conn_uninit(struct tapdisk_ctl_conn *conn)
-{
-	if (conn->out.buf) {
-		munmap(conn->out.buf, conn->out.bufsz);
-		conn->out.buf = NULL;
-	}
-}
-
-static int
-tapdisk_ctl_conn_init(struct tapdisk_ctl_conn *conn, size_t bufsz)
-{
-	int prot, flags, err;
-
-	memset(conn, 0, sizeof(*conn));
-	conn->out.event_id = -1;
-	conn->in.event_id  = -1;
-
-	prot  = PROT_READ|PROT_WRITE;
-	flags = MAP_ANONYMOUS|MAP_PRIVATE;
-
-	conn->out.buf = mmap(NULL, bufsz, prot, flags, -1, 0);
-	if (conn->out.buf == MAP_FAILED) {
-		conn->out.buf = NULL;
-		err = -ENOMEM;
-		goto fail;
-	}
-	conn->out.bufsz = page_align(bufsz);
-
-	return 0;
-
-fail:
-	tapdisk_ctl_conn_uninit(conn);
-	return err;
-}
-
-static int
-tapdisk_ctl_conn_connected(struct tapdisk_ctl_conn *conn)
-{
-	return conn->fd >= 1;
-}
-
-static void
-tapdisk_ctl_conn_free(struct tapdisk_ctl_conn *conn)
-{
-	struct tapdisk_ctl_conn *prev, *next;
-	int i;
-
-	i = --td_control.n_conn;
-	/* NB. bubble the freed connection off the active list. */
-	prev = conn;
-	do {
-		ASSERT(i >= 0);
-		next = td_control.conn[i];
-		td_control.conn[i] = prev;
-		prev = next;
-		i--;
-	} while (next != conn);
-}
-
-static void
-tapdisk_ctl_conn_close(struct tapdisk_ctl_conn *conn)
-{
-	if (conn->out.event_id >= 0) {
-		tapdisk_server_unregister_event(conn->out.event_id);
-		conn->out.event_id = -1;
-	}
-
-	if (conn->fd >= 0) {
-		close(conn->fd);
-		conn->fd = -1;
-
-		tapdisk_ctl_conn_free(conn);
-		tapdisk_server_mask_event(td_control.event_id, 0);
-	}
-}
-
-static void
-tapdisk_ctl_conn_mask_out(struct tapdisk_ctl_conn *conn)
-{
-	tapdisk_server_mask_event(conn->out.event_id, 1);
-}
-
-static void
-tapdisk_ctl_conn_unmask_out(struct tapdisk_ctl_conn *conn)
-{
-	tapdisk_server_mask_event(conn->out.event_id, 0);
-}
-
-static ssize_t
-tapdisk_ctl_conn_send_buf(struct tapdisk_ctl_conn *conn)
-{
-	ssize_t size;
-
-	size = conn->out.prod - conn->out.cons;
-	if (!size)
-		return 0;
-
-	size = send(conn->fd, conn->out.cons, size, MSG_DONTWAIT);
-	if (size < 0)
-		return -errno;
-
-	conn->out.cons += size;
-
-	return size;
-}
-
-static void
-tapdisk_ctl_conn_send_event(event_id_t id, char mode, void *private)
-{
-	struct tapdisk_ctl_conn *conn = private;
-	ssize_t rv;
-
-	do {
-		rv = tapdisk_ctl_conn_send_buf(conn);
-	} while (rv > 0);
-
-	if (rv == -EAGAIN)
-		return;
-
-	if (rv < 0)
-		ERR(rv, "failure sending message at offset %d/%d\n",
-		    conn->out.cons - conn->out.buf,
-		    conn->out.prod - conn->out.buf);
-
-	if (rv || conn->out.done || mode & SCHEDULER_POLL_TIMEOUT)
-		tapdisk_ctl_conn_close(conn);
-	else
-		tapdisk_ctl_conn_mask_out(conn);
-}
-
-/*
- * NB. the control interface is still not properly integrated into the
- * server, therefore neither the scheduler. After the last close, the
- * server will exit but we still have a pending close response in the
- * output buffer.
- */
-static void
-tapdisk_ctl_conn_drain(struct tapdisk_ctl_conn *conn)
-{
-	struct timeval tv = { .tv_sec = TD_CTL_SEND_TIMEOUT,
-			      .tv_usec = 0 };
-	fd_set wfds;
-	int n, mode;
-
-	ASSERT(conn->out.done);
-	ASSERT(conn->fd >= 0);
-
-	while (tapdisk_ctl_conn_connected(conn)) {
-		FD_ZERO(&wfds);
-		FD_SET(conn->fd, &wfds);
-
-		n = select(conn->fd + 1, NULL, &wfds, NULL, &tv);
-		if (n < 0)
-			break;
-
-		if (n)
-			mode = SCHEDULER_POLL_WRITE_FD;
-		else
-			mode = SCHEDULER_POLL_TIMEOUT;
-
-		tapdisk_ctl_conn_send_event(conn->out.event_id, mode, conn);
-	}
-}
-
-
-struct tapdisk_ctl_conn *
-tapdisk_ctl_conn_open(int fd)
-{
-	struct tapdisk_ctl_conn *conn;
-
-	if (td_control.n_conn >= TD_CTL_MAX_CONNECTIONS)
-		return NULL;
-
-	conn = td_control.conn[td_control.n_conn++];
-
-	conn->out.event_id =
-		tapdisk_server_register_event(SCHEDULER_POLL_WRITE_FD,
-					      fd, TD_CTL_SEND_TIMEOUT,
-					      tapdisk_ctl_conn_send_event,
-					      conn);
-	if (conn->out.event_id < 0)
-		return NULL;
-
-	conn->fd       = fd;
-	conn->out.prod = conn->out.buf;
-	conn->out.cons = conn->out.buf;
-
-	tapdisk_ctl_conn_mask_out(conn);
-
-	if (td_control.n_conn >= TD_CTL_MAX_CONNECTIONS)
-		tapdisk_server_mask_event(td_control.event_id, 1);
-
-	return conn;
-}
-
-static size_t
-tapdisk_ctl_conn_write(struct tapdisk_ctl_conn *conn, void *buf, size_t size)
-{
-	size_t rest;
-
-	rest = conn->out.buf + conn->out.bufsz - conn->out.prod;
-	if (rest < size)
-		size = rest;
-	if (!size)
-		return 0;
-
-	memcpy(conn->out.prod, buf, size);
-	conn->out.prod += size;
-	tapdisk_ctl_conn_unmask_out(conn);
-
-	return size;
-}
-
-static void
-tapdisk_ctl_conn_release(struct tapdisk_ctl_conn *conn)
-{
-	conn->out.done = 1;
-
-	if (conn->out.prod == conn->out.cons)
-		tapdisk_ctl_conn_close(conn);
-}
-
 static void
 tapdisk_control_initialize(void)
 {
-	struct tapdisk_ctl_conn *conn;
-	int i;
-
 	td_control.socket   = -1;
 	td_control.event_id = -1;
 
 	signal(SIGPIPE, SIG_IGN);
-
-	for (i = 0; i < TD_CTL_MAX_CONNECTIONS; i++) {
-		conn = &td_control.__conn[i];
-		tapdisk_ctl_conn_init(conn, TD_CTL_SEND_BUFSZ);
-		td_control.conn[i] = conn;
-	}
-
-	td_control.n_conn = 0;
-
-	DPRINTF("tapdisk-control: init, %d x %zuk buffers\n",
-		TD_CTL_MAX_CONNECTIONS, TD_CTL_SEND_BUFSZ >> 10);
 }
 
 void
 tapdisk_control_close(void)
 {
-	struct tapdisk_ctl_conn *conn;
-	int i;
-
-	DPRINTF("tapdisk-control: draining %d connections\n",
-		td_control.n_conn);
-
-	while (td_control.n_conn) {
-		conn = td_control.conn[td_control.n_conn-1];
-		tapdisk_ctl_conn_drain(conn);
-	}
-
-	for (i = 0; i < TD_CTL_MAX_CONNECTIONS; i++) {
-		conn = &td_control.__conn[i];
-		tapdisk_ctl_conn_uninit(conn);
-	}
-
-	DPRINTF("tapdisk-control: done\n");
-
 	if (td_control.path) {
 		unlink(td_control.path);
 		free(td_control.path);
@@ -407,40 +85,40 @@
 	}
 }
 
-static void
-tapdisk_control_release_connection(struct tapdisk_ctl_conn *conn)
+static struct tapdisk_control_connection *
+tapdisk_control_allocate_connection(int fd)
 {
-	if (conn->in.event_id) {
-		tapdisk_server_unregister_event(conn->in.event_id);
-		conn->in.event_id = -1;
+	struct tapdisk_control_connection *connection;
+	size_t sz;
+
+	connection = calloc(1, sizeof(*connection));
+	if (!connection) {
+		EPRINTF("calloc");
+		return NULL;
 	}
 
-	tapdisk_ctl_conn_release(conn);
+	connection->socket = fd;
+	return connection;
 }
 
 static void
-tapdisk_control_close_connection(struct tapdisk_ctl_conn *conn)
+tapdisk_control_close_connection(struct tapdisk_control_connection *connection)
 {
-	tapdisk_control_release_connection(conn);
-
-	if (tapdisk_ctl_conn_connected(conn))
-		/* NB. best effort for write/close sequences. */
-		tapdisk_ctl_conn_send_buf(conn);
-
-	tapdisk_ctl_conn_close(conn);
+	tapdisk_server_unregister_event(connection->event_id);
+	close(connection->socket);
+	free(connection);
 }
 
-
 static int
 tapdisk_control_read_message(int fd, tapdisk_message_t *message, int timeout)
 {
-	const int len = sizeof(tapdisk_message_t);
 	fd_set readfds;
-	int ret, offset, err = 0;
+	int ret, len, offset;
 	struct timeval tv, *t;
 
 	t      = NULL;
 	offset = 0;
+	len    = sizeof(tapdisk_message_t);
 
 	if (timeout) {
 		tv.tv_sec  = timeout;
@@ -466,30 +144,63 @@
 			break;
 	}
 
-	if (ret < 0)
-		err = -errno;
-	else if (offset != len)
-		err = -EIO;
-	if (err)
-		ERR(err, "failure reading message at offset %d/%d\n",
-		    offset, len);
+	if (offset != len) {
+		EPRINTF("failure reading message (wanted %d but got %d)\n",
+			len, offset);
+		return -EIO;
+	}
 
+	DPRINTF("received '%s' message (uuid = %u)\n",
+		tapdisk_message_name(message->type), message->cookie);
 
-	return err;
+	return 0;
 }
 
-static void
-tapdisk_control_write_message(struct tapdisk_ctl_conn *conn,
-			      tapdisk_message_t *message)
+static int
+tapdisk_control_write_message(int fd, tapdisk_message_t *message, int timeout)
 {
-	size_t size = sizeof(*message), count;
+	fd_set writefds;
+	int ret, len, offset;
+	struct timeval tv, *t;
 
-	if (conn->info->flags & TAPDISK_MSG_VERBOSE)
-		DBG("sending '%s' message (uuid = %u)\n",
-		    tapdisk_message_name(message->type), message->cookie);
+	t      = NULL;
+	offset = 0;
+	len    = sizeof(tapdisk_message_t);
+
+	if (timeout) {
+		tv.tv_sec  = timeout;
+		tv.tv_usec = 0;
+		t = &tv;
+	}
 
-	count = tapdisk_ctl_conn_write(conn, message, size);
-	WARN_ON(count != size);
+	DPRINTF("sending '%s' message (uuid = %u)\n",
+		tapdisk_message_name(message->type), message->cookie);
+
+	while (offset < len) {
+		FD_ZERO(&writefds);
+		FD_SET(fd, &writefds);
+
+		/* we don't bother reinitializing tv. at worst, it will wait a
+		 * bit more time than expected. */
+
+		ret = select(fd + 1, NULL, &writefds, NULL, t);
+		if (ret == -1)
+			break;
+		else if (FD_ISSET(fd, &writefds)) {
+			ret = write(fd, message + offset, len - offset);
+			if (ret <= 0)
+				break;
+			offset += ret;
+		} else
+			break;
+	}
+
+	if (offset != len) {
+		EPRINTF("failure writing message\n");
+		return -EIO;
+	}
+
+	return 0;
 }
 
 static int
@@ -504,7 +215,7 @@
 }
 
 static void
-tapdisk_control_list_minors(struct tapdisk_ctl_conn *conn,
+tapdisk_control_list_minors(struct tapdisk_control_connection *connection,
 			    tapdisk_message_t *request)
 {
 	int i;
@@ -530,11 +241,13 @@
 	}
 
 	response.u.minors.count = i;
-	tapdisk_ctl_conn_write(conn, &response, 2);
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 }
 
 static void
-tapdisk_control_list(struct tapdisk_ctl_conn *conn, tapdisk_message_t *request)
+tapdisk_control_list(struct tapdisk_control_connection *connection,
+		     tapdisk_message_t *request)
 {
 	td_vbd_t *vbd;
 	struct list_head *head;
@@ -557,25 +270,29 @@
 		response.u.list.state   = vbd->state;
 		response.u.list.path[0] = 0;
 
-		if (vbd->name)
+		if (!list_empty(&vbd->images)) {
+			td_image_t *image = list_entry(vbd->images.next,
+						       td_image_t, next);
 			snprintf(response.u.list.path,
 				 sizeof(response.u.list.path),
 				 "%s:%s",
-				 tapdisk_disk_types[vbd->type]->name,
-				 vbd->name);
+				 tapdisk_disk_types[image->type]->name,
+				 image->name);
+		}
 
-		tapdisk_control_write_message(conn, &response);
+		tapdisk_control_write_message(connection->socket, &response, 2);
 	}
 
 	response.u.list.count   = count;
 	response.u.list.minor   = -1;
 	response.u.list.path[0] = 0;
 
-	tapdisk_control_write_message(conn, &response);
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 }
 
 static void
-tapdisk_control_get_pid(struct tapdisk_ctl_conn *conn,
+tapdisk_control_get_pid(struct tapdisk_control_connection *connection,
 			tapdisk_message_t *request)
 {
 	tapdisk_message_t response;
@@ -585,11 +302,12 @@
 	response.cookie = request->cookie;
 	response.u.tapdisk_pid = getpid();
 
-	tapdisk_control_write_message(conn, &response);
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 }
 
 static void
-tapdisk_control_attach_vbd(struct tapdisk_ctl_conn *conn,
+tapdisk_control_attach_vbd(struct tapdisk_control_connection *connection,
 			   tapdisk_message_t *request)
 {
 	tapdisk_message_t response;
@@ -640,7 +358,8 @@
 	response.cookie = request->cookie;
 	response.u.response.error = -err;
 
-	tapdisk_control_write_message(conn, &response);
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 
 	return;
 
@@ -652,7 +371,7 @@
 
 
 static void
-tapdisk_control_detach_vbd(struct tapdisk_ctl_conn *conn,
+tapdisk_control_detach_vbd(struct tapdisk_control_connection *connection,
 			   tapdisk_message_t *request)
 {
 	tapdisk_message_t response;
@@ -665,11 +384,6 @@
 		goto out;
 	}
 
-	if (vbd->name) {
-		err = -EBUSY;
-		goto out;
-	}
-
 	tapdisk_vbd_detach(vbd);
 
 	if (list_empty(&vbd->images)) {
@@ -684,20 +398,20 @@
 	response.cookie = request->cookie;
 	response.u.response.error = -err;
 
-	tapdisk_control_write_message(conn, &response);
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 }
 
 static void
-tapdisk_control_open_image(struct tapdisk_ctl_conn *conn,
+tapdisk_control_open_image(struct tapdisk_control_connection *connection,
 			   tapdisk_message_t *request)
 {
-	int err, type, secondary_type;
+	int err;
 	image_t image;
 	td_vbd_t *vbd;
 	td_flag_t flags;
 	tapdisk_message_t response;
 	struct blktap2_params params;
-	const char *path, *secondary_path;
 
 	vbd = tapdisk_server_get_vbd(request->cookie);
 	if (!vbd) {
@@ -716,8 +430,6 @@
 	}
 
 	flags = 0;
-	secondary_type = 0;
-	secondary_path = NULL;
 	if (request->u.params.flags & TAPDISK_MESSAGE_FLAG_RDONLY)
 		flags |= TD_OPEN_RDONLY;
 	if (request->u.params.flags & TAPDISK_MESSAGE_FLAG_SHARED)
@@ -728,32 +440,19 @@
 		flags |= TD_OPEN_VHD_INDEX;
 	if (request->u.params.flags & TAPDISK_MESSAGE_FLAG_LOG_DIRTY)
 		flags |= TD_OPEN_LOG_DIRTY;
-	if (request->u.params.flags & TAPDISK_MESSAGE_FLAG_ADD_LCACHE)
-		flags |= TD_OPEN_LOCAL_CACHE;
-	if (request->u.params.flags & TAPDISK_MESSAGE_FLAG_REUSE_PRT)
-		flags |= TD_OPEN_REUSE_PARENT;
-	if (request->u.params.flags & TAPDISK_MESSAGE_FLAG_STANDBY)
-		flags |= TD_OPEN_STANDBY;
-	if (request->u.params.flags & TAPDISK_MESSAGE_FLAG_SECONDARY) {
-		flags |= TD_OPEN_SECONDARY;
-		secondary_type = tapdisk_disktype_parse_params(
-				request->u.params.secondary, &secondary_path);
-		if (secondary_type < 0) {
-			err = secondary_type;
-			goto out;
-		}
-	}
 
-	type = tapdisk_disktype_parse_params(request->u.params.path, &path);
-	if (type < 0) {
-		err = type;
+	vbd->name = strndup(request->u.params.path,
+			    sizeof(request->u.params.path));
+	if (!vbd->name) {
+		err = -ENOMEM;
 		goto out;
 	}
 
-	err = tapdisk_vbd_open_vdi(vbd,
-				   type, path,
-				   flags, request->u.params.prt_devnum,
-				   secondary_type, secondary_path);
+	err = tapdisk_vbd_parse_stack(vbd, request->u.params.path);
+	if (err)
+		goto out;
+
+	err = tapdisk_vbd_open_stack(vbd, request->u.params.storage, flags);
 	if (err)
 		goto out;
 
@@ -763,8 +462,7 @@
 
 	params.capacity = image.size;
 	params.sector_size = image.secsize;
-	snprintf(params.name, sizeof(params.name) - 1,
-		 "%s", request->u.params.path);
+	strncpy(params.name, vbd->name, BLKTAP2_MAX_MESSAGE_LEN);
 
 	err = ioctl(vbd->ring.fd, BLKTAP2_IOCTL_CREATE_DEVICE, &params);
 	if (err && errno != EEXIST) {
@@ -789,18 +487,20 @@
 		response.type                = TAPDISK_MESSAGE_OPEN_RSP;
 	}
 
-	tapdisk_control_write_message(conn, &response);
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 
 	return;
 
 fail_close:
 	tapdisk_vbd_close_vdi(vbd);
-	free(vbd);
+	free(vbd->name);
+	vbd->name = NULL;
 	goto out;
 }
 
 static void
-tapdisk_control_close_image(struct tapdisk_ctl_conn *conn,
+tapdisk_control_close_image(struct tapdisk_control_connection *connection,
 			    tapdisk_message_t *request)
 {
 	tapdisk_message_t response;
@@ -809,35 +509,14 @@
 
 	vbd = tapdisk_server_get_vbd(request->cookie);
 	if (!vbd) {
-		err = -ENODEV;
+		err = -EINVAL;
 		goto out;
 	}
 
-	do {
-		err = ioctl(vbd->ring.fd, BLKTAP2_IOCTL_REMOVE_DEVICE);
-
-		if (!err || errno != EBUSY)
-			break;
-
-		tapdisk_server_iterate();
-
-	} while (conn->fd >= 0);
-
-	if (err) {
-		err = -errno;
-		ERR(err, "failure closing image\n");
-	}
-
-	if (err == -ENOTTY) {
-
-		while (!list_empty(&vbd->pending_requests))
-			tapdisk_server_iterate();
-
-		err = 0;
-	}
-
-	if (err)
+	if (!list_empty(&vbd->pending_requests)) {
+		err = -EAGAIN;
 		goto out;
+	}
 
 	tapdisk_vbd_close_vdi(vbd);
 
@@ -849,20 +528,22 @@
 
 	if (vbd->minor == -1) {
 		tapdisk_server_remove_vbd(vbd);
-		free(vbd);
+		tapdisk_vbd_free(vbd);
 	}
 
+	err = 0;
 out:
 	memset(&response, 0, sizeof(response));
 	response.type = TAPDISK_MESSAGE_CLOSE_RSP;
 	response.cookie = request->cookie;
 	response.u.response.error = -err;
 
-	tapdisk_control_write_message(conn, &response);
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 }
 
 static void
-tapdisk_control_pause_vbd(struct tapdisk_ctl_conn *conn,
+tapdisk_control_pause_vbd(struct tapdisk_control_connection *connection,
 			  tapdisk_message_t *request)
 {
 	int err;
@@ -886,25 +567,22 @@
 			break;
 
 		tapdisk_server_iterate();
-
-	} while (conn->fd >= 0);
+	} while (1);
 
 out:
 	response.cookie = request->cookie;
 	response.u.response.error = -err;
-	tapdisk_control_write_message(conn, &response);
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 }
 
 static void
-tapdisk_control_resume_vbd(struct tapdisk_ctl_conn *conn,
+tapdisk_control_resume_vbd(struct tapdisk_control_connection *connection,
 			   tapdisk_message_t *request)
 {
 	int err;
 	td_vbd_t *vbd;
 	tapdisk_message_t response;
-	const char *path = NULL;
-	int type = -1;
-	size_t len;
 
 	memset(&response, 0, sizeof(response));
 
@@ -916,212 +594,124 @@
 		goto out;
 	}
 
-	len = strnlen(request->u.params.path, sizeof(request->u.params.path));
-	if (len) {
-		type = tapdisk_disktype_parse_params(request->u.params.path, &path);
-		if (type < 0) {
-			err = type;
-			goto out;
-		}
+	if (!td_flag_test(vbd->state, TD_VBD_PAUSED)) {
+		err = -EINVAL;
+		goto out;
 	}
 
-	err = tapdisk_vbd_resume(vbd, type, path);
-
-out:
-	response.cookie = request->cookie;
-	response.u.response.error = -err;
-	tapdisk_control_write_message(conn, &response);
-}
-
-static void
-tapdisk_control_stats(struct tapdisk_ctl_conn *conn,
-		      tapdisk_message_t *request)
-{
-	tapdisk_message_t response;
-	td_stats_t _st, *st = &_st;
-	td_vbd_t *vbd;
-	size_t rv;
-
-	tapdisk_stats_init(st,
-			   conn->out.buf + sizeof(response),
-			   conn->out.bufsz - sizeof(response));
-
-	if (request->cookie != (uint16_t)-1) {
-
-		vbd = tapdisk_server_get_vbd(request->cookie);
-		if (!vbd) {
-			rv = -ENODEV;
+	if (request->u.params.path[0]) {
+		free(vbd->name);
+		vbd->name = strndup(request->u.params.path,
+				    sizeof(request->u.params.path));
+		if (!vbd->name) {
+			err = -ENOMEM;
 			goto out;
 		}
+	} else if (!vbd->name) {
+		err = -EINVAL;
+		goto out;
+	}
 
-		tapdisk_vbd_stats(vbd, st);
-
-	} else {
-		struct list_head *list = tapdisk_server_get_all_vbds();
-
-		tapdisk_stats_enter(st, '[');
-
-		list_for_each_entry(vbd, list, next)
-			tapdisk_vbd_stats(vbd, st);
+	err = tapdisk_vbd_parse_stack(vbd, vbd->name);
+	if (err)
+		goto out;
 
-		tapdisk_stats_leave(st, ']');
-	}
+	err = tapdisk_vbd_resume(vbd, NULL, -1);
+	if (err)
+		goto out;
 
-	rv = tapdisk_stats_length(st);
 out:
-	memset(&response, 0, sizeof(response));
-	response.type = TAPDISK_MESSAGE_STATS_RSP;
 	response.cookie = request->cookie;
-	response.u.info.length = rv;
-
-	tapdisk_control_write_message(conn, &response);
-	if (rv > 0)
-		conn->out.prod += rv;
+	response.u.response.error = -err;
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 }
 
-struct tapdisk_control_info message_infos[] = {
-	[TAPDISK_MESSAGE_PID] = {
-		.handler = tapdisk_control_get_pid,
-		.flags   = TAPDISK_MSG_REENTER,
-	},
-	[TAPDISK_MESSAGE_LIST] = {
-		.handler = tapdisk_control_list,
-		.flags   = TAPDISK_MSG_REENTER,
-	},
-	[TAPDISK_MESSAGE_ATTACH] = {
-		.handler = tapdisk_control_attach_vbd,
-		.flags   = TAPDISK_MSG_VERBOSE,
-	},
-	[TAPDISK_MESSAGE_DETACH] = {
-		.handler = tapdisk_control_detach_vbd,
-		.flags   = TAPDISK_MSG_VERBOSE,
-	},
-	[TAPDISK_MESSAGE_OPEN] = {
-		.handler = tapdisk_control_open_image,
-		.flags   = TAPDISK_MSG_VERBOSE,
-	},
-	[TAPDISK_MESSAGE_PAUSE] = {
-		.handler = tapdisk_control_pause_vbd,
-		.flags   = TAPDISK_MSG_VERBOSE,
-	},
-	[TAPDISK_MESSAGE_RESUME] = {
-		.handler = tapdisk_control_resume_vbd,
-		.flags   = TAPDISK_MSG_VERBOSE,
-	},
-	[TAPDISK_MESSAGE_CLOSE] = {
-		.handler = tapdisk_control_close_image,
-		.flags   = TAPDISK_MSG_VERBOSE,
-	},
-	[TAPDISK_MESSAGE_STATS] = {
-		.handler = tapdisk_control_stats,
-		.flags   = TAPDISK_MSG_REENTER,
-	},
-};
-
-
 static void
 tapdisk_control_handle_request(event_id_t id, char mode, void *private)
 {
-	int err, len, excl;
-	tapdisk_message_t message, response;
-	struct tapdisk_ctl_conn *conn = private;
-	struct tapdisk_control_info *info;
-
-	err = tapdisk_control_read_message(conn->fd, &message, 2);
-	if (err)
-		goto close;
-
-	if (conn->in.busy)
-		goto busy;
+	int err;
+	tapdisk_message_t message;
+	struct tapdisk_control_connection *connection =
+		(struct tapdisk_control_connection *)private;
+
+	if (tapdisk_control_read_message(connection->socket, &message, 2)) {
+		EPRINTF("failed to read message from %d\n", connection->socket);
+		tapdisk_control_close_connection(connection);
+		return;
+	}
 
 	err = tapdisk_control_validate_request(&message);
 	if (err)
-		goto invalid;
-
-	if (message.type > TAPDISK_MESSAGE_EXIT)
-		goto invalid;
-
-	info = &message_infos[message.type];
-
-	if (!info->handler)
-		goto invalid;
-
-	if (info->flags & TAPDISK_MSG_VERBOSE)
-		DBG("received '%s' message (uuid = %u)\n",
-		    tapdisk_message_name(message.type), message.cookie);
+		goto fail;
 
-	excl = !(info->flags & TAPDISK_MSG_REENTER);
-	if (excl) {
-		if (td_control.busy)
-			goto busy;
+	switch (message.type) {
+	case TAPDISK_MESSAGE_PID:
+		return tapdisk_control_get_pid(connection, &message);
+	case TAPDISK_MESSAGE_LIST_MINORS:
+		return tapdisk_control_list_minors(connection, &message);
+	case TAPDISK_MESSAGE_LIST:
+		return tapdisk_control_list(connection, &message);
+	case TAPDISK_MESSAGE_ATTACH:
+		return tapdisk_control_attach_vbd(connection, &message);
+	case TAPDISK_MESSAGE_DETACH:
+		return tapdisk_control_detach_vbd(connection, &message);
+	case TAPDISK_MESSAGE_OPEN:
+		return tapdisk_control_open_image(connection, &message);
+	case TAPDISK_MESSAGE_PAUSE:
+		return tapdisk_control_pause_vbd(connection, &message);
+	case TAPDISK_MESSAGE_RESUME:
+		return tapdisk_control_resume_vbd(connection, &message);
+	case TAPDISK_MESSAGE_CLOSE:
+		return tapdisk_control_close_image(connection, &message);
+	default: {
+		tapdisk_message_t response;
+	fail:
+
+		EPRINTF("received unsupported message '%s'\n",
+			tapdisk_message_name(message.type));
+
+		memset(&response, 0, sizeof(response));
+
+		response.type = TAPDISK_MESSAGE_ERROR;
+		response.u.response.error = (err ? -err : EINVAL);
+		tapdisk_control_write_message(connection->socket, &response, 2);
 
-		td_control.busy = 1;
+		tapdisk_control_close_connection(connection);
+		break;
+	}
 	}
-	conn->in.busy = 1;
-	conn->info    = info;
-
-	info->handler(conn, &message);
-
-	conn->in.busy = 0;
-	if (excl)
-		td_control.busy = 0;
-
-	tapdisk_control_release_connection(conn);
-	return;
-
-error:
-	memset(&response, 0, sizeof(response));
-	response.type = TAPDISK_MESSAGE_ERROR;
-	response.u.response.error = (err ? -err : EINVAL);
-	tapdisk_control_write_message(conn, &response);
-
-close:
-	tapdisk_control_close_connection(conn);
-	return;
-
-busy:
-	err = -EBUSY;
-	ERR(err, "rejecting message '%s' while busy\n",
-	    tapdisk_message_name(message.type));
-	goto error;
-
-invalid:
-	err = -EINVAL;
-	ERR(err, "rejecting unsupported message '%s'\n",
-	    tapdisk_message_name(message.type));
-	goto error;
 }
 
 static void
 tapdisk_control_accept(event_id_t id, char mode, void *private)
 {
 	int err, fd;
-	struct tapdisk_ctl_conn *conn;
+	struct tapdisk_control_connection *connection;
 
 	fd = accept(td_control.socket, NULL, NULL);
 	if (fd == -1) {
-		ERR(-errno, "failed to accept new control connection: %d\n", errno);
+		EPRINTF("failed to accept new control connection: %d\n", errno);
 		return;
 	}
 
-	conn = tapdisk_ctl_conn_open(fd);
-	if (!conn) {
+	connection = tapdisk_control_allocate_connection(fd);
+	if (!connection) {
 		close(fd);
-		ERR(-ENOMEM, "failed to allocate new control connection\n");
-		return;
+		EPRINTF("failed to allocate new control connection\n");
 	}
 
 	err = tapdisk_server_register_event(SCHEDULER_POLL_READ_FD,
-					    conn->fd, TD_CTL_RECV_TIMEOUT,
+					    connection->socket, 0,
 					    tapdisk_control_handle_request,
-					    conn);
+					    connection);
 	if (err == -1) {
-		tapdisk_control_close_connection(conn);
-		ERR(err, "failed to register new control event\n");
-		return;
+		close(fd);
+		free(connection);
+		EPRINTF("failed to register new control event: %d\n", err);
 	}
 
-	conn->in.event_id = err;
+	connection->event_id = err;
 }
 
 static int
@@ -1211,7 +801,7 @@
 		goto fail;
 	}
 
-	err = listen(td_control.socket, TD_CTL_SOCK_BACKLOG);
+	err = listen(td_control.socket, 10);
 	if (err == -1) {
 		err = errno;
 		EPRINTF("failed to listen: %d\n", err);
diff -Nur blktap2_oxt//drivers/tapdisk-diff.c blktap2_xen//drivers/tapdisk-diff.c
--- blktap2_oxt//drivers/tapdisk-diff.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-diff.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,6 +1,5 @@
-/*
- * Copyright (c) 2009, Citrix Systems, Inc.
- *
+/* 
+ * Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -25,14 +24,14 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
+#include <libgen.h>	/* for basename(3) */
 #include <unistd.h>
 
 #include "list.h"
@@ -40,6 +39,7 @@
 #include "tapdisk-vbd.h"
 #include "tapdisk-server.h"
 #include "tapdisk-disktype.h"
+#include "tapdisk-utils.h"
 #include "libvhd.h"
 
 #define POLL_READ                        0
@@ -47,21 +47,6 @@
 
 #define SPB_SHIFT (VHD_BLOCK_SHIFT - SECTOR_SHIFT)
 
-/* 
- * we have to use half the max number of requests because we're using the same 
- * tapdisk server for both streams and all the parents will be shared. If we 
- * issue more than MAX_REQUESTS/2 requests, the vhd_state will run out of 
- * vhd_request's and return EBUSY, which we don't handle here. However, even 
- * with MAX_REQUESTS/2 we can still run out of vhd_request's because of 
- * splitting: if some sectors spanned by a segment are in a parent, a segment 
- * could be split into at most N/2 vhd_request's, where N is the number of 
- * sectors per segment. Therefore, if we use 11 segments, we need to divide 
- * MAX_REQUESTS by 11/2=6 on top of that. If we don't, we'd have to handle 
- * EBUSY by retrying here.
- */
-#define MAX_SEGMENTS 8
-#define MAX_STREAM_REQUESTS (MAX_REQUESTS / 2 / (MAX_SEGMENTS / 2))
-
 struct tapdisk_stream_poll {
 	int                              pipe[2];
 	int                              set;
@@ -96,7 +81,7 @@
 	struct list_head                 pending_list;
 	struct list_head                 completed_list;
 
-	struct tapdisk_stream_request    requests[MAX_STREAM_REQUESTS];
+	struct tapdisk_stream_request    requests[MAX_REQUESTS];
 };
 
 static unsigned int tapdisk_stream_count;
@@ -184,9 +169,9 @@
 static inline void
 tapdisk_stream_poll_clear(struct tapdisk_stream_poll *p)
 {
-	int gcc, dummy;
+	int dummy;
 
-	gcc = read(p->pipe[POLL_READ], &dummy, sizeof(dummy));
+	read_exact(p->pipe[POLL_READ], &dummy, sizeof(dummy));
 	p->set = 0;
 }
 
@@ -196,7 +181,7 @@
 	int dummy = 0;
 
 	if (!p->set) {
-		int gcc = write(p->pipe[POLL_WRITE], &dummy, sizeof(dummy));
+		write_exact(p->pipe[POLL_WRITE], &dummy, sizeof(dummy));
 		p->set = 1;
 	}
 }
@@ -341,12 +326,11 @@
 	else {
 		s->err = EIO;
 		list_add_tail(&sreq->next, &s->free_list);
-		fprintf(stderr, "error reading sector %llu (stream %d)\n",
-				sreq->sec, (s == &stream2) + 1);
+		fprintf(stderr, "error reading sector 0x%"PRIx64"\n", sreq->sec);
 	}
 
 	if (tapdisk_stream_process_data()) {
-		fprintf(stderr, "mismatch at sector %llu\n",
+		fprintf(stderr, "mismatch at sector 0x%"PRIx64"\n",
 				sreq->sec);
 		stream1.err = EINVAL;
 		stream2.err = EINVAL;
@@ -395,7 +379,6 @@
 	assert(vreq->secs_pending == 0);
 
 	memcpy(&vreq->req, breq, sizeof(*breq));
-	s->started++;
 	vbd->received++;
 	vreq->vbd = vbd;
 
@@ -447,7 +430,7 @@
 		breq->sector_number = sreq->sec;
 		breq->operation     = BLKIF_OP_READ;
 
-		for (i = 0; i < MAX_SEGMENTS; i++) {
+		for (i = 0; i < BLKIF_MAX_SEGMENTS_PER_REQUEST; i++) {
 			uint32_t secs;
 			struct blkif_request_segment *seg = breq->seg + i;
 
@@ -559,7 +542,7 @@
 
 	s->id = tapdisk_stream_count++;
 
-	err = tapdisk_vbd_initialize(-1, -1, s->id);
+	err = tapdisk_vbd_initialize(s->id);
 	if (err)
 		goto out;
 
@@ -571,11 +554,14 @@
 
 	tapdisk_vbd_set_callback(s->vbd, tapdisk_stream_dequeue, s);
 
-	err = tapdisk_vbd_open_vdi(s->vbd, type, path,
-				   TD_OPEN_RDONLY, -1, -1, NULL);
+	err = tapdisk_vbd_open_vdi(s->vbd, path, type,
+				   TAPDISK_STORAGE_TYPE_DEFAULT,
+				   TD_OPEN_RDONLY);
 	if (err)
 		goto out;
 
+	s->vbd->reopened = 1;
+
 	err = tapdisk_vbd_get_image_info(s->vbd, &image);
 	if (err) {
 		fprintf(stderr, "failed getting image size: %d\n", err);
@@ -629,7 +615,7 @@
 		return err;
 	}
 
-	for (i = 0; i < MAX_STREAM_REQUESTS; i++) {
+	for (i = 0; i < MAX_REQUESTS; i++) {
 		struct tapdisk_stream_request *req = s->requests + i;
 		tapdisk_stream_initialize_request(req);
 		list_add_tail(&req->next, &s->free_list);
@@ -771,9 +757,9 @@
 	if (err)
 		return err;
 
-	tapdisk_start_logging("tapdisk-diff", "daemon");
+	tapdisk_start_logging("tapdisk-diff");
 
-	err = tapdisk_server_initialize(NULL, NULL);
+	err = tapdisk_server_initialize();
 	if (err)
 		goto out;
 
diff -Nur blktap2_oxt//drivers/tapdisk-disktype.c blktap2_xen//drivers/tapdisk-disktype.c
--- blktap2_oxt//drivers/tapdisk-disktype.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-disktype.c	2015-03-19 11:08:36.000000000 -0400
@@ -26,16 +26,12 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
 #include <stddef.h>
 #include <string.h>
 #include <errno.h>
 
 #include "tapdisk-disktype.h"
+#include "tapdisk-message.h"
 
 static const disk_info_t aio_disk = {
        "aio",
@@ -98,13 +94,12 @@
 	0,
 };
 
-static const disk_info_t local_cache_disk = {
-       "lc",
-       "local cache image (lc)",
+static const disk_info_t remus_disk = {
+       "remus",
+       "remus disk replicator (remus)",
        0,
 };
 
-
 const disk_info_t *tapdisk_disk_types[] = {
 	[DISK_TYPE_AIO]	= &aio_disk,
 	[DISK_TYPE_SYNC]	= &sync_disk,
@@ -114,48 +109,37 @@
 	[DISK_TYPE_RAM]	= &ram_disk,
 	[DISK_TYPE_QCOW]	= &qcow_disk,
 	[DISK_TYPE_BLOCK_CACHE] = &block_cache_disk,
-	[DISK_TYPE_VINDEX]	= &vhd_index_disk,
 	[DISK_TYPE_LOG]	= &log_disk,
-	[DISK_TYPE_LOCAL_CACHE] = &local_cache_disk,
+	[DISK_TYPE_VINDEX]	= &vhd_index_disk,
+	[DISK_TYPE_REMUS]	= &remus_disk,
 	0,
 };
 
 extern struct tap_disk tapdisk_aio;
-#if 0
 extern struct tap_disk tapdisk_sync;
 extern struct tap_disk tapdisk_vmdk;
 extern struct tap_disk tapdisk_vhdsync;
-#endif
 extern struct tap_disk tapdisk_vhd;
 extern struct tap_disk tapdisk_ram;
-#if 0
 extern struct tap_disk tapdisk_qcow;
-#endif
 extern struct tap_disk tapdisk_block_cache;
 extern struct tap_disk tapdisk_vhd_index;
-#if 0
 extern struct tap_disk tapdisk_log;
-#endif
-extern struct tap_disk tapdisk_local_cache;
+extern struct tap_disk tapdisk_remus;
 
 const struct tap_disk *tapdisk_disk_drivers[] = {
 	[DISK_TYPE_AIO]         = &tapdisk_aio,
 #if 0
 	[DISK_TYPE_SYNC]        = &tapdisk_sync,
 	[DISK_TYPE_VMDK]        = &tapdisk_vmdk,
-	[DISK_TYPE_VHDSYNC]     = &tapdisk_vhdsync_disk
 #endif
 	[DISK_TYPE_VHD]         = &tapdisk_vhd,
 	[DISK_TYPE_RAM]         = &tapdisk_ram,
-#if 0
 	[DISK_TYPE_QCOW]        = &tapdisk_qcow,
-#endif
 	[DISK_TYPE_BLOCK_CACHE] = &tapdisk_block_cache,
 	[DISK_TYPE_VINDEX]      = &tapdisk_vhd_index,
-#if 0
 	[DISK_TYPE_LOG]         = &tapdisk_log,
-#endif
-	[DISK_TYPE_LOCAL_CACHE] = &tapdisk_local_cache,
+	[DISK_TYPE_REMUS]       = &tapdisk_remus,
 	0,
 };
 
@@ -204,3 +188,17 @@
 
 	return type;
 }
+
+int
+tapdisk_parse_disk_type(const char *params, const char **_path, int *_type)
+{
+	int type;
+
+	type = tapdisk_disktype_parse_params(params, _path);
+	if (type < 0)
+		return type;
+
+	*_type = type;
+
+	return 0;
+}
diff -Nur blktap2_oxt//drivers/tapdisk-disktype.h blktap2_xen//drivers/tapdisk-disktype.h
--- blktap2_oxt//drivers/tapdisk-disktype.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-disktype.h	2015-03-19 11:08:36.000000000 -0400
@@ -26,11 +26,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
 #ifndef __DISKTYPES_H__
 #define __DISKTYPES_H__
 
@@ -42,10 +37,9 @@
 #define DISK_TYPE_RAM         5
 #define DISK_TYPE_QCOW        6
 #define DISK_TYPE_BLOCK_CACHE 7
-#define DISK_TYPE_VINDEX      8
-#define DISK_TYPE_LOG         9
-#define DISK_TYPE_REMUS       10
-#define DISK_TYPE_LOCAL_CACHE 11
+#define DISK_TYPE_LOG         8
+#define DISK_TYPE_REMUS       9
+#define DISK_TYPE_VINDEX      10
 
 #define DISK_TYPE_NAME_MAX    32
 
@@ -63,5 +57,6 @@
 
 int tapdisk_disktype_find(const char *name);
 int tapdisk_disktype_parse_params(const char *params, const char **_path);
+int tapdisk_parse_disk_type(const char *, const char **, int *);
 
 #endif
diff -Nur blktap2_oxt//drivers/tapdisk-driver.c blktap2_xen//drivers/tapdisk-driver.c
--- blktap2_oxt//drivers/tapdisk-driver.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-driver.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,22 +25,14 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
 #include <stdlib.h>
-#include <stdio.h>
 
 #include "tapdisk-driver.h"
 #include "tapdisk-server.h"
 #include "tapdisk-disktype.h"
-#include "tapdisk-stats.h"
 
 td_driver_t *
-tapdisk_driver_allocate(int type, char *name, td_flag_t flags)
+tapdisk_driver_allocate(int type, char *name, td_flag_t flags, int storage)
 {
 	int err;
 	td_driver_t *driver;
@@ -60,7 +52,7 @@
 
 	driver->ops     = ops;
 	driver->type    = type;
-	driver->storage = -1;
+	driver->storage = storage;
 	driver->data    = calloc(1, ops->private_data_size);
 	if (!driver->data)
 		goto fail;
@@ -107,22 +99,3 @@
 	if (driver->ops->td_debug)
 		driver->ops->td_debug(driver);
 }
-
-void
-tapdisk_driver_stats(td_driver_t *driver, td_stats_t *st)
-{
-	const disk_info_t *info;
-
-	tapdisk_stats_field(st, "type", "d", driver->type);
-
-	info = tapdisk_disk_types[driver->type];
-	tapdisk_stats_field(st, "name", "s", info->name);
-
-	if (driver->ops->td_stats) {
-		tapdisk_stats_field(st, "status", "{");
-		driver->ops->td_stats(driver, st);
-		tapdisk_stats_leave(st, '}');
-	} else
-		tapdisk_stats_field(st, "status", NULL);
-
-}
diff -Nur blktap2_oxt//drivers/tapdisk-driver.h blktap2_xen//drivers/tapdisk-driver.h
--- blktap2_oxt//drivers/tapdisk-driver.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-driver.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #ifndef _TAPDISK_DRIVER_H_
 #define _TAPDISK_DRIVER_H_
 
@@ -57,13 +52,11 @@
 	struct list_head             next;
 };
 
-td_driver_t *tapdisk_driver_allocate(int, char *, td_flag_t);
+td_driver_t *tapdisk_driver_allocate(int, char *, td_flag_t, int);
 void tapdisk_driver_free(td_driver_t *);
 
 void tapdisk_driver_queue_tiocb(td_driver_t *, struct tiocb *);
 
 void tapdisk_driver_debug(td_driver_t *);
 
-void tapdisk_driver_stats(td_driver_t *, td_stats_t *);
-
 #endif
diff -Nur blktap2_oxt//drivers/tapdisk.h blktap2_xen//drivers/tapdisk.h
--- blktap2_oxt//drivers/tapdisk.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk.h	2015-03-19 11:08:36.000000000 -0400
@@ -53,11 +53,6 @@
  *     -errno on error
  */
 
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
 #ifndef _TAPDISK_H_
 #define _TAPDISK_H_
 
@@ -65,11 +60,17 @@
 #include <stdint.h>
 
 #include "list.h"
-#include "blktap-int.h"
 #include "blktaplib.h"
 #include "tapdisk-log.h"
 #include "tapdisk-utils.h"
-#include "tapdisk-stats.h"
+
+#ifdef MEMSHR
+#include "memshr.h"
+#endif
+
+#define DPRINTF(_f, _a...)           syslog(LOG_INFO, _f, ##_a)
+#define EPRINTF(_f, _a...)           syslog(LOG_ERR, "tap-err:%s: " _f, __func__, ##_a)
+#define PERROR(_f, _a...)            EPRINTF(_f ": %s", ##_a, strerror(errno))
 
 #define MAX_SEGMENTS_PER_REQ         11
 #define SECTOR_SHIFT                 9
@@ -93,11 +94,6 @@
 #define TD_OPEN_ADD_CACHE            0x00020
 #define TD_OPEN_VHD_INDEX            0x00040
 #define TD_OPEN_LOG_DIRTY            0x00080
-#define TD_OPEN_LOCAL_CACHE          0x00100
-#define TD_OPEN_REUSE_PARENT         0x00200
-#define TD_OPEN_SECONDARY            0x00400
-#define TD_OPEN_STANDBY              0x00800
-#define TD_IGNORE_ENOSPC             0x01000
 
 #define TD_CREATE_SPARSE             0x00001
 #define TD_CREATE_MULTITYPE          0x00002
@@ -114,12 +110,6 @@
 typedef struct td_request            td_request_t;
 typedef struct td_driver_handle      td_driver_t;
 typedef struct td_image_handle       td_image_t;
-typedef struct td_sector_count       td_sector_count_t;
-
-/* 
- * Prototype of the callback to activate as requests complete.
- */
-typedef void (*td_callback_t)(td_request_t, int);
 
 struct td_disk_id {
 	char                        *name;
@@ -128,7 +118,7 @@
 
 struct td_disk_info {
 	td_sector_t                  size;
-        long                         sector_size;
+        uint64_t                     sector_size;
 	uint32_t                     info;
 };
 
@@ -138,17 +128,28 @@
 	td_sector_t                  sec;
 	int                          secs;
 
+	uint8_t                      blocked; /* blocked on a dependency */
+
 	td_image_t                  *image;
 
-	td_callback_t                cb;
+	void * /*td_callback_t*/     cb;
 	void                        *cb_data;
 
 	uint64_t                     id;
 	int                          sidx;
 	void                        *private;
+    
+#ifdef MEMSHR
+	share_tuple_t                memshr_hnd;
+#endif
 };
 
 /* 
+ * Prototype of the callback to activate as requests complete.
+ */
+typedef void (*td_callback_t)(td_request_t, int);
+
+/* 
  * Structure describing the interface to a virtual disk implementation.
  * See note at the top of this file describing this interface.
  */
@@ -163,23 +164,6 @@
 	void (*td_queue_read)        (td_driver_t *, td_request_t);
 	void (*td_queue_write)       (td_driver_t *, td_request_t);
 	void (*td_debug)             (td_driver_t *);
-	void (*td_stats)             (td_driver_t *, td_stats_t *);
-};
-
-struct td_sector_count {
-	td_sector_t rd;
-	td_sector_t wr;
 };
 
-static inline void
-td_sector_count_add(td_sector_count_t *s, td_sector_t v, int write)
-{
-	if (write)
-		s->wr += v;
-	else
-		s->rd += v;
-}
-
-void td_panic(void);
-
 #endif
diff -Nur blktap2_oxt//drivers/tapdisk-image.c blktap2_xen//drivers/tapdisk-image.c
--- blktap2_oxt//drivers/tapdisk-image.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-image.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,25 +25,22 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #include <errno.h>
 #include <unistd.h>
 #include <stdlib.h>
-#include <stdio.h>
+#ifdef MEMSHR
+#include <memshr.h>
+#endif
 
 #include "tapdisk-image.h"
 #include "tapdisk-driver.h"
 #include "tapdisk-server.h"
-#include "tapdisk-stats.h"
 
 #define ERR(_err, _f, _a...) tlog_error(_err, _f, ##_a)
 
 td_image_t *
-tapdisk_image_allocate(char *file, int type, td_flag_t flags, void *private)
+tapdisk_image_allocate(const char *file, int type, int storage,
+		       td_flag_t flags, void *private)
 {
 	int err;
 	td_image_t *image;
@@ -58,9 +55,13 @@
 		return NULL;
 	}
 
-	image->type    = type;
-	image->flags   = flags;
-	image->private = private;
+	image->type      = type;
+	image->flags     = flags;
+	image->storage   = storage;
+	image->private   = private;
+#ifdef MEMSHR
+	image->memshr_id = memshr_vbd_image_get(file);
+#endif
 	INIT_LIST_HEAD(&image->next);
 
 	return image;
@@ -74,6 +75,9 @@
 
 	list_del(&image->next);
 
+#ifdef MEMSHR
+	memshr_vbd_image_put(image->memshr_id);
+#endif
 	free(image->name);
 	tapdisk_driver_free(image->driver);
 	free(image);
@@ -82,12 +86,10 @@
 int
 tapdisk_image_check_td_request(td_image_t *image, td_request_t treq)
 {
-	int rdonly, err;
+	int rdonly;
 	td_driver_t *driver;
 	td_disk_info_t *info;
 
-	err = -EINVAL;
-
 	driver = image->driver;
 	if (!driver)
 		return -ENODEV;
@@ -98,10 +100,8 @@
 	if (treq.op != TD_OP_READ && treq.op != TD_OP_WRITE)
 		goto fail;
 
-	if (treq.op == TD_OP_WRITE && rdonly) {
-		err = -EPERM;
+	if (treq.op == TD_OP_WRITE && rdonly)
 		goto fail;
-	}
 
 	if (treq.secs <= 0 || treq.sec + treq.secs > info->size)
 		goto fail;
@@ -109,10 +109,10 @@
 	return 0;
 
 fail:
-	ERR(err, "bad td request on %s (%s, %llu): %d at %llu",
+	ERR(-EINVAL, "bad td request on %s (%s, %"PRIu64"): %d at %"PRIu64,
 	    image->name, (rdonly ? "ro" : "rw"), info->size, treq.op,
 	    treq.sec + treq.secs);
-	return err;
+	return -EINVAL;
 
 }
 
@@ -121,14 +121,13 @@
 {
 	td_driver_t *driver;
 	td_disk_info_t *info;
+	int i, psize, rdonly;
 	uint64_t nsects, total;
-	int i, err, psize, rdonly;
 
 	driver = image->driver;
 	if (!driver)
 		return -ENODEV;
 
-	err    = -EINVAL;
 	nsects = 0;
 	total  = 0;
 	info   = &driver->info;
@@ -139,10 +138,8 @@
 	    req->operation != BLKIF_OP_WRITE)
 		goto fail;
 
-	if (req->operation == BLKIF_OP_WRITE && rdonly) {
-		err = -EPERM;
+	if (req->operation == BLKIF_OP_WRITE && rdonly)
 		goto fail;
-	}
 
 	if (!req->nr_segments || req->nr_segments > MAX_SEGMENTS_PER_REQ)
 		goto fail;
@@ -165,31 +162,8 @@
 	return 0;
 
 fail:
-	ERR(err, "bad request on %s (%s, %llu): id: %llu: %d at %llu",
+	ERR(-EINVAL, "bad request on %s (%s, %"PRIu64"): id: %"PRIu64": %d at %"PRIu64,
 	    image->name, (rdonly ? "ro" : "rw"), info->size, req->id,
 	    req->operation, req->sector_number + total);
-	return err;
-}
-
-void
-tapdisk_image_stats(td_image_t *image, td_stats_t *st)
-{
-	tapdisk_stats_enter(st, '{');
-	tapdisk_stats_field(st, "name", "s", image->name);
-
-	tapdisk_stats_field(st, "hits", "[");
-	tapdisk_stats_val(st, "llu", image->stats.hits.rd);
-	tapdisk_stats_val(st, "llu", image->stats.hits.wr);
-	tapdisk_stats_leave(st, ']');
-
-	tapdisk_stats_field(st, "fail", "[");
-	tapdisk_stats_val(st, "llu", image->stats.fail.rd);
-	tapdisk_stats_val(st, "llu", image->stats.fail.wr);
-	tapdisk_stats_leave(st, ']');
-
-	tapdisk_stats_field(st, "driver", "{");
-	tapdisk_driver_stats(image->driver, st);
-	tapdisk_stats_leave(st, '}');
-
-	tapdisk_stats_leave(st, '}');
+	return -EINVAL;
 }
diff -Nur blktap2_oxt//drivers/tapdisk-image.h blktap2_xen//drivers/tapdisk-image.h
--- blktap2_oxt//drivers/tapdisk-image.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-image.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #ifndef _TAPDISK_IMAGE_H_
 #define _TAPDISK_IMAGE_H_
 
@@ -39,8 +34,10 @@
 struct td_image_handle {
 	int                          type;
 	char                        *name;
+    uint16_t                     memshr_id;
 
 	td_flag_t                    flags;
+	int                          storage;
 
 	td_driver_t                 *driver;
 	td_disk_info_t               info;
@@ -48,32 +45,12 @@
 	void                        *private;
 
 	struct list_head             next;
-
-	/*
-	 * Basic datapath statistics, in sectors read/written.
-	 *
-	 * hits:  requests completed by this image.
-	 * fail:  requests completed with failure by this image.
-	 *
-	 * Not that we do not count e.g.
-	 * miss:  requests forwarded.
-	 * total: requests processed by this image.
-	 *
-	 * This is because we'd have to compensate for restarts due to
-	 * -EBUSY conditions. Those can be extrapolated by following
-	 * the chain instead: sum(image[i].hits, i=0..) == vbd.secs;
-	 */
-	struct {
-		td_sector_count_t    hits;
-		td_sector_count_t    fail;
-	} stats;
 };
 
-td_image_t *tapdisk_image_allocate(char *, int, td_flag_t, void *);
+td_image_t *tapdisk_image_allocate(const char *, int, int, td_flag_t, void *);
 void tapdisk_image_free(td_image_t *);
 
 int tapdisk_image_check_td_request(td_image_t *, td_request_t);
 int tapdisk_image_check_ring_request(td_image_t *, blkif_request_t *);
-void tapdisk_image_stats(td_image_t *, td_stats_t *);
 
 #endif
diff -Nur blktap2_oxt//drivers/tapdisk-interface.c blktap2_xen//drivers/tapdisk-interface.c
--- blktap2_oxt//drivers/tapdisk-interface.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-interface.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,14 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
-#include <signal.h>
-#include <unistd.h>
 #include <errno.h>
 
 #include "tapdisk.h"
@@ -41,11 +33,11 @@
 #include "tapdisk-driver.h"
 #include "tapdisk-server.h"
 #include "tapdisk-interface.h"
-#include "tapdisk-log.h"
 
 int
 td_load(td_image_t *image)
 {
+	int err;
 	td_image_t *shared;
 	td_driver_t *driver;
 
@@ -76,7 +68,8 @@
 	if (!driver) {
 		driver = tapdisk_driver_allocate(image->type,
 						 image->name,
-						 image->flags);
+						 image->flags,
+						 image->storage);
 		if (!driver)
 			return -ENOMEM;
 
@@ -229,7 +222,7 @@
 void
 td_complete_request(td_request_t treq, int res)
 {
-	treq.cb(treq, res);
+	((td_callback_t)treq.cb)(treq, res);
 }
 
 void
@@ -264,11 +257,3 @@
 
 	tapdisk_driver_debug(driver);
 }
-
-void
-td_panic(void)
-{
-	tlog_precious();
-	raise(SIGABRT);
-	_exit(-1); /* not reached */
-}
diff -Nur blktap2_oxt//drivers/tapdisk-interface.h blktap2_xen//drivers/tapdisk-interface.h
--- blktap2_oxt//drivers/tapdisk-interface.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-interface.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #ifndef _TAPDISK_INTERFACE_H_
 #define _TAPDISK_INTERFACE_H_
 
@@ -55,6 +50,5 @@
 		  long long, td_queue_callback_t, void *);
 void td_prep_write(struct tiocb *, int, char *, size_t,
 		   long long, td_queue_callback_t, void *);
-void td_panic(void) __attribute__((noreturn));
 
 #endif
diff -Nur blktap2_oxt//drivers/tapdisk-log.c blktap2_xen//drivers/tapdisk-log.c
--- blktap2_oxt//drivers/tapdisk-log.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-log.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,5 +1,5 @@
-/*
- * Copyright (c) 2008, 2009, XenSource Inc.
+/* 
+ * Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -24,267 +24,234 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
+*/
 
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
-#include <stdlib.h>
+#include <stdio.h>
+#include <fcntl.h>
 #include <unistd.h>
-#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
 #include <stdarg.h>
 #include <syslog.h>
+#include <inttypes.h>
 #include <sys/time.h>
-#include <sys/stat.h>
-#include <sys/types.h>
 
-#include "blktaplib.h"
 #include "tapdisk-log.h"
 #include "tapdisk-utils.h"
-#include "tapdisk-logfile.h"
-#include "tapdisk-syslog.h"
-#include "tapdisk-server.h"
-
-#define TLOG_LOGFILE_BUFSZ (16<<10)
-#define TLOG_SYSLOG_BUFSZ   (8<<10)
 
 #define MAX_ENTRY_LEN      512
+#define MAX_ERROR_MESSAGES 16
+
+struct error {
+	int            cnt;
+	int            err;
+	char          *func;
+	char           msg[MAX_ENTRY_LEN];
+};
+
+struct ehandle {
+	int            cnt;
+	int            dropped;
+	struct error   errors[MAX_ERROR_MESSAGES];
+};
 
 struct tlog {
-	char          *name;
-	td_logfile_t   logfile;
-	int            precious;
+	char          *p;
+	int            size;
+	uint64_t       cnt;
+	char          *buf;
 	int            level;
-
-	char          *ident;
-	td_syslog_t    syslog;
-	unsigned long  errors;
+	char          *file;
+	int            append;
 };
 
+static struct ehandle tapdisk_err;
 static struct tlog tapdisk_log;
 
-static void
-tlog_logfile_vprint(const char *fmt, va_list ap)
-{
-	tapdisk_logfile_vprintf(&tapdisk_log.logfile, fmt, ap);
-}
-
-static void
-__attribute__((format(printf, 1, 2)))
-tlog_logfile_print(const char *fmt, ...)
-{
-	va_list ap;
-
-	va_start(ap, fmt);
-	tlog_logfile_vprint(fmt, ap);
-	va_end(ap);
-}
-
-#define tlog_info(_fmt, _args ...)					\
-	tlog_logfile_print("%s: "_fmt, tapdisk_log.ident, ##_args)
-
-static void
-tlog_logfile_save(void)
+void
+open_tlog(char *file, size_t bytes, int level, int append)
 {
-	td_logfile_t *logfile = &tapdisk_log.logfile;
-	const char *name = tapdisk_log.name;
-	int err;
+	tapdisk_log.size = ((bytes + 511) & (~511));
 
-	tlog_info("saving log, %lu errors", tapdisk_log.errors);
+	if (asprintf(&tapdisk_log.file, "%s.%d", file, getpid()) == -1)
+		return;
 
-	tapdisk_logfile_flush(logfile);
+	if (posix_memalign((void **)&tapdisk_log.buf, 512, tapdisk_log.size)) {
+		free(tapdisk_log.file);
+		tapdisk_log.buf = NULL;
+		return;
+	}
 
-	err = tapdisk_logfile_rename(logfile,
-				     TLOG_DIR, name, ".log");
+	memset(tapdisk_log.buf, 0, tapdisk_log.size);
 
-	tlog_syslog(LOG_INFO,
-		    "logfile saved to %s: %d\n", logfile->path, err);
+	tapdisk_log.p      = tapdisk_log.buf;
+	tapdisk_log.level  = level;
+	tapdisk_log.append = append;
 }
 
-static void
-tlog_logfile_close(void)
+void
+close_tlog(void)
 {
-	td_logfile_t *logfile = &tapdisk_log.logfile;
-	int keep, err;
-
-	keep = tapdisk_log.precious || tapdisk_log.errors;
+	if (!tapdisk_log.buf)
+		return;
 
-	tlog_info("closing log, %lu errors", tapdisk_log.errors);
+	if (tapdisk_log.append)
+		tlog_flush();
 
-	if (keep)
-		tlog_logfile_save();
+	free(tapdisk_log.buf);
+	free(tapdisk_log.file);
 
-	tapdisk_logfile_close(logfile);
-
-	if (!keep)
-		tapdisk_logfile_unlink(logfile);
+	memset(&tapdisk_log, 0, sizeof(struct tlog));
 }
 
-static int
-tlog_logfile_open(const char *name, int level)
+void
+__tlog_write(int level, const char *func, const char *fmt, ...)
 {
-	td_logfile_t *logfile = &tapdisk_log.logfile;
-	int mode, err;
-
-	err = mkdir(TLOG_DIR, 0755);
-	if (err) {
-		err = -errno;
-		if (err != -EEXIST)
-			goto fail;
-	}
-
-	err = tapdisk_logfile_open(logfile,
-				   TLOG_DIR, name, ".tmp",
-				   TLOG_LOGFILE_BUFSZ);
-	if (err)
-		goto fail;
-
-	mode = (level == TLOG_DBG) ? _IOLBF : _IOFBF;
-
-	err = tapdisk_logfile_setvbuf(logfile, mode);
-	if (err)
-		goto fail;
+	char *buf;
+	va_list ap;
+	struct timeval t;
+	int ret, len, avail;
 
-	tlog_info("log start, level %d", level);
+	if (!tapdisk_log.buf)
+		return;
 
-	return 0;
+	if (level > tapdisk_log.level)
+		return;
 
-fail:
-	tlog_logfile_close();
-	return err;
-}
+	avail = tapdisk_log.size - (tapdisk_log.p - tapdisk_log.buf);
+	if (avail < MAX_ENTRY_LEN) {
+		if (tapdisk_log.append)
+			tlog_flush();
+		tapdisk_log.p = tapdisk_log.buf;
+	}
 
-static void
-tlog_syslog_close(void)
-{
-	td_syslog_t *syslog = &tapdisk_log.syslog;
+	buf = tapdisk_log.p;
+	gettimeofday(&t, NULL);
+	len = snprintf(buf, MAX_ENTRY_LEN - 1, "%08"PRIu64":%010ld.%06lld:"
+		       "%s ", tapdisk_log.cnt,
+			t.tv_sec, (unsigned long long)t.tv_usec, func);
 
-	tapdisk_syslog_stats(syslog, LOG_INFO);
-	tapdisk_syslog_flush(syslog);
-	tapdisk_syslog_close(syslog);
-}
+	va_start(ap, fmt);
+	ret = vsnprintf(buf + len, MAX_ENTRY_LEN - (len + 1), fmt, ap);
+	va_end(ap);
 
-static int
-tlog_syslog_open(const char *ident, int facility)
-{
-	td_syslog_t *syslog = &tapdisk_log.syslog;
-	int err;
+	len = (ret < MAX_ENTRY_LEN - (len + 1) ?
+	       len + ret : MAX_ENTRY_LEN - 1);
+	buf[len] = '\0';
 
-	err = tapdisk_syslog_open(syslog,
-				  tapdisk_log.ident, facility,
-				  TLOG_SYSLOG_BUFSZ);
-	return err;
+	tapdisk_log.cnt++;
+	tapdisk_log.p += len;
 }
 
 void
-tlog_vsyslog(int prio, const char *fmt, va_list ap)
+__tlog_error(int err, const char *func, const char *fmt, ...)
 {
-	td_syslog_t *syslog = &tapdisk_log.syslog;
+	va_list ap;
+	int i, len, ret;
+	struct error *e;
+	struct timeval t;
+
+	err = (err > 0 ? err : -err);
+
+	for (i = 0; i < tapdisk_err.cnt; i++) {
+		e = &tapdisk_err.errors[i];
+		if (e->err == err && e->func == func) {
+			e->cnt++;
+			return;
+		}
+	}
 
-	tapdisk_vsyslog(syslog, prio, fmt, ap);
-}
+	if (tapdisk_err.cnt >= MAX_ERROR_MESSAGES) {
+		tapdisk_err.dropped++;
+		return;
+	}
 
-void
-tlog_syslog(int prio, const char *fmt, ...)
-{
-	va_list ap;
+	gettimeofday(&t, NULL);
+	e = &tapdisk_err.errors[tapdisk_err.cnt];
+
+	len = snprintf(e->msg, MAX_ENTRY_LEN - 1, "%010ld.%06lld:%s ",
+		       t.tv_sec, (unsigned long long)t.tv_usec, func);
 
 	va_start(ap, fmt);
-	tlog_vsyslog(prio, fmt, ap);
+	ret = vsnprintf(e->msg + len, MAX_ENTRY_LEN - (len + 1), fmt, ap);
 	va_end(ap);
+
+	len = (ret < MAX_ENTRY_LEN - (len + 1) ?
+	       len + ret : MAX_ENTRY_LEN - 1);
+	e->msg[len] = '\0';
+
+	e->cnt++;
+	e->err  = err;
+	e->func = (char *)func;
+	tapdisk_err.cnt++;
 }
 
-int
-tlog_open(const char *name, int facility, int level)
+void
+tlog_print_errors(void)
 {
-	int err;
-
-	DPRINTF("tapdisk-log: started, level %d\n", level);
+	int i;
+	struct error *e;
 
-	tapdisk_log.level = level;
-	tapdisk_log.name  = strdup(name);
-	tapdisk_log.ident = tapdisk_syslog_ident(name);
-
-	if (!tapdisk_log.name || !tapdisk_log.ident) {
-		err = -errno;
-		goto fail;
+	for (i = 0; i < tapdisk_err.cnt; i++) {
+		e = &tapdisk_err.errors[i];
+		syslog(LOG_INFO, "TAPDISK ERROR: errno %d at %s (cnt = %d): "
+		       "%s\n", e->err, e->func, e->cnt, e->msg);
 	}
 
-#if 0
-	err = tlog_logfile_open(tapdisk_log.name, level);
-	if (err)
-		goto fail;
-#endif
-
-	tlog_syslog_open(tapdisk_log.ident, facility);
-
-	return 0;
-
-fail:
-	tlog_close();
-	return err;
+	if (tapdisk_err.dropped)
+		syslog(LOG_INFO, "TAPDISK ERROR: %d other error messages "
+		       "dropped\n", tapdisk_err.dropped);
 }
 
 void
-tlog_close(void)
+tlog_flush_errors(void)
 {
-	DPRINTF("tapdisk-log: closing after %lu errors\n",
-		tapdisk_log.errors);
+	int i;
+	struct error *e;
 
-	tlog_logfile_close();
-	tlog_syslog_close();
+	for (i = 0; i < tapdisk_err.cnt; i++) {
+		e = &tapdisk_err.errors[i];
+		tlog_write(TLOG_WARN, "TAPDISK ERROR: errno %d at %s "
+			   "(cnt = %d): %s\n", e->err, e->func, e->cnt,
+			   e->msg);
+	}
 
-	free(tapdisk_log.ident);
-	tapdisk_log.ident = NULL;
+	if (tapdisk_err.dropped)
+		tlog_write(TLOG_WARN, "TAPDISK ERROR: %d other error messages "
+		       "dropped\n", tapdisk_err.dropped);
 }
 
 void
-tlog_precious(void)
+tlog_flush(void)
 {
-	if (!tapdisk_log.precious)
-		tlog_logfile_save();
+	int fd, flags;
+	size_t size, wsize;
 
-	tapdisk_log.precious = 1;
-}
+	if (!tapdisk_log.buf)
+		return;
 
-void
-__tlog_write(int level, const char *fmt, ...)
-{
-	va_list ap;
+	flags = O_CREAT | O_WRONLY | O_DIRECT | O_NONBLOCK;
+	if (!tapdisk_log.append)
+		flags |= O_TRUNC;
 
-	if (level <= tapdisk_log.level) {
-		va_start(ap, fmt);
-		tlog_logfile_vprint(fmt, ap);
-		va_end(ap);
-	}
-}
+	fd = open(tapdisk_log.file, flags, 0644);
+	if (fd == -1)
+		return;
 
-void
-__tlog_error(const char *fmt, ...)
-{
-	va_list ap;
+	if (tapdisk_log.append)
+		if (lseek(fd, 0, SEEK_END) == (off_t)-1)
+			goto out;
 
-	va_start(ap, fmt);
-	tlog_vsyslog(LOG_ERR, fmt, ap);
-	va_end(ap);
+	tlog_flush_errors();
 
-	tapdisk_log.errors++;
-}
+	size  = tapdisk_log.p - tapdisk_log.buf;
+	wsize = ((size + 511) & (~511));
 
-void
-tapdisk_start_logging(const char *ident, const char *_facility)
-{
-	static char buf[128];
-	int facility, err;
+	memset(tapdisk_log.buf + size, '\n', wsize - size);
+	write_exact(fd, tapdisk_log.buf, wsize);
 
-	facility = tapdisk_syslog_facility(_facility);
-	tapdisk_server_openlog(ident, LOG_CONS|LOG_ODELAY, facility);
-}
+	tapdisk_log.p = tapdisk_log.buf;
 
-void
-tapdisk_stop_logging(void)
-{
-	tapdisk_server_closelog();
+out:
+	close(fd);
 }
diff -Nur blktap2_oxt//drivers/tapdisk-log.h blktap2_xen//drivers/tapdisk-log.h
--- blktap2_oxt//drivers/tapdisk-log.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-log.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,5 +1,5 @@
-/*
- * Copyright (c) 2009, XenSource Inc.
+/* 
+ * Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -24,13 +24,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
+*/
 #ifndef _TAPDISK_LOG_H_
 #define _TAPDISK_LOG_H_
 
@@ -38,27 +32,20 @@
 #define TLOG_INFO       1
 #define TLOG_DBG        2
 
-#define TLOG_DIR "/var/log/blktap"
-
-#include <stdarg.h>
-
-int  tlog_open(const char *, int, int);
-void tlog_close(void);
-void tlog_precious(void);
-void tlog_vsyslog(int, const char *, va_list);
-void tlog_syslog(int, const char *, ...);
-
-void __tlog_write(int, const char *, ...)
-	__attribute__((format(printf, 2, 3)));
-
-void __tlog_error(const char *fmt, ...)
-	__attribute__((format(printf, 1, 2)));
+void open_tlog(char *file, size_t bytes, int level, int append);
+void close_tlog(void);
+void tlog_flush(void);
+void tlog_print_errors(void);
+
+void __tlog_write(int level, const char *func, const char *fmt, ...)
+  __attribute__((format(printf, 3, 4)));
+void __tlog_error(int err, const char *func, const char *fmt, ...)
+  __attribute__((format(printf, 3, 4)));
 
 #define tlog_write(_level, _f, _a...)			\
-	__tlog_write(_level, "%s: " _f,  __func__, ##_a)
+	__tlog_write(_level, __func__, _f, ##_a)
 
 #define tlog_error(_err, _f, _a...)			\
-	__tlog_error("ERROR: errno %d at %s: " _f,	\
-		     _err, __func__, ##_a)
+	__tlog_error(_err, __func__, _f, ##_a)
 
 #endif
diff -Nur blktap2_oxt//drivers/tapdisk-queue.c blktap2_xen//drivers/tapdisk-queue.c
--- blktap2_oxt//drivers/tapdisk-queue.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-queue.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,5 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* 
+ * Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,7 +24,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
+*/
 
 #include <errno.h>
 #include <stdlib.h>
@@ -215,7 +213,7 @@
 	ssize_t (*func)(int, void *, size_t) = 
 		(iocb->aio_lio_opcode == IO_CMD_PWRITE ? vwrite : read);
 
-	if (lseek64(fd, off, SEEK_SET) == (off64_t)-1)
+	if (lseek(fd, off, SEEK_SET) == (off_t)-1)
 		return -errno;
 
 	if (atomicio(func, fd, buf, size) != size)
@@ -289,7 +287,11 @@
 static int
 tapdisk_lio_check_resfd(void)
 {
+#if defined(__linux__)
 	return tapdisk_linux_version() >= KERNEL_VERSION(2, 6, 22);
+#else
+	return 1;
+#endif
 }
 
 static void
@@ -432,9 +434,8 @@
 	struct lio *lio = queue->tio_data;
 	uint64_t val;
 
-	if (lio->flags & LIO_FLAG_EVENTFD) {
-		int gcc = read(lio->event_fd, &val, sizeof(val));
-	}
+	if (lio->flags & LIO_FLAG_EVENTFD)
+		read_exact(lio->event_fd, &val, sizeof(val));
 }
 
 static void
@@ -656,7 +657,7 @@
 
 	WARN("TAPDISK QUEUE:\n");
 	WARN("size: %d, tio: %s, queued: %d, iocbs_pending: %d, "
-	     "tiocbs_pending: %d, tiocbs_deferred: %d, deferrals: %llx\n",
+	     "tiocbs_pending: %d, tiocbs_deferred: %d, deferrals: %"PRIx64"\n",
 	     queue->size, queue->tio->name, queue->queued, queue->iocbs_pending,
 	     queue->tiocbs_pending, queue->tiocbs_deferred, queue->deferrals);
 
diff -Nur blktap2_oxt//drivers/tapdisk-server.c blktap2_xen//drivers/tapdisk-server.c
--- blktap2_oxt//drivers/tapdisk-server.c	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-server.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <unistd.h>
@@ -37,29 +32,15 @@
 #include <sys/ioctl.h>
 #include <sys/signal.h>
 
-#include "tapdisk-syslog.h"
+#include "tapdisk-utils.h"
 #include "tapdisk-server.h"
 #include "tapdisk-driver.h"
 #include "tapdisk-interface.h"
-#include "tapdisk-log.h"
 
 #define DBG(_level, _f, _a...)       tlog_write(_level, _f, ##_a)
 #define ERR(_err, _f, _a...)         tlog_error(_err, _f, ##_a)
 
-#define TAPDISK_TIOCBS              (TAPDISK_DATA_REQUESTS + 50)
-
-typedef struct tapdisk_server {
-	int                          run;
-	struct list_head             vbds;
-	scheduler_t                  scheduler;
-	struct tqueue                aio_queue;
-	char                        *name;
-	char                        *ident;
-	int                          facility;
-	int                          err;
-} tapdisk_server_t;
-
-static tapdisk_server_t server;
+ tapdisk_server_t server;
 
 #define tapdisk_server_for_each_vbd(vbd, tmp)			        \
 	list_for_each_entry_safe(vbd, tmp, &server.vbds, next)
@@ -130,8 +111,7 @@
 	tapdisk_server_for_each_vbd(vbd, tmp)
 		tapdisk_vbd_debug(vbd);
 
-	DBG(TLOG_INFO, "debug log completed\n");
-	tlog_precious();
+	tlog_flush();
 }
 
 void
@@ -156,12 +136,6 @@
 }
 
 void
-tapdisk_server_mask_event(event_id_t event, int masked)
-{
-	return scheduler_mask_event(&server.scheduler, event, masked);
-}
-
-void
 tapdisk_server_set_max_timeout(int seconds)
 {
 	scheduler_set_max_timeout(&server.scheduler, seconds);
@@ -206,6 +180,7 @@
 static void
 tapdisk_server_kick_responses(void)
 {
+	int n;
 	td_vbd_t *vbd, *tmp;
 
 	tapdisk_server_for_each_vbd(vbd, tmp)
@@ -243,54 +218,9 @@
 	tapdisk_free_queue(&server.aio_queue);
 }
 
-int
-tapdisk_server_openlog(const char *name, int options, int facility)
-{
-	server.facility = facility;
-	server.name     = strdup(name);
-	server.ident    = tapdisk_syslog_ident(name);
-
-	if (!server.name || !server.ident)
-		return -errno;
-
-	openlog(server.ident, options, facility);
-
-	return 0;
-}
-
-void
-tapdisk_server_closelog(void)
-{
-	closelog();
-
-	free(server.name);
-	server.name = NULL;
-
-	free(server.ident);
-	server.ident = NULL;
-}
-
-static int
-tapdisk_server_open_tlog(void)
-{
-	int err = 0;
-
-	if (server.name)
-		err = tlog_open(server.name, server.facility, TLOG_WARN);
-
-	return err;
-}
-
-static void
-tapdisk_server_close_tlog(void)
-{
-	tlog_close();
-}
-
 static void
 tapdisk_server_close(void)
 {
-	tapdisk_server_close_tlog();
 	tapdisk_server_close_aio();
 }
 
@@ -328,8 +258,6 @@
 	switch (signal) {
 	case SIGBUS:
 	case SIGINT:
-	case SIGTERM:
-		server.err = 1;
 		tapdisk_server_for_each_vbd(vbd, tmp)
 			tapdisk_vbd_close(vbd);
 		break;
@@ -344,7 +272,6 @@
 		break;
 
 	case SIGUSR1:
-		DBG(TLOG_INFO, "debugging on signal %d\n", signal);
 		tapdisk_server_debug();
 		break;
 	}
@@ -370,22 +297,17 @@
 	if (err)
 		goto fail;
 
-	err = tapdisk_server_open_tlog();
-	if (err)
-		goto fail;
-
 	server.run = 1;
 
 	return 0;
 
 fail:
-	tapdisk_server_close_tlog();
 	tapdisk_server_close_aio();
 	return err;
 }
 
 int
-tapdisk_server_initialize(const char *read, const char *write)
+tapdisk_server_initialize(void)
 {
 	int err;
 
@@ -395,12 +317,6 @@
 	if (err)
 		goto fail;
 
-	err = tapdisk_server_open_tlog();
-	if (err)
-		goto fail;
-
-	server.run = 1;
-
 	return 0;
 
 fail:
@@ -419,12 +335,11 @@
 
 	signal(SIGBUS, tapdisk_server_signal_handler);
 	signal(SIGINT, tapdisk_server_signal_handler);
-	signal(SIGTERM, tapdisk_server_signal_handler);
 	signal(SIGUSR1, tapdisk_server_signal_handler);
 	signal(SIGXFSZ, tapdisk_server_signal_handler);
 
 	__tapdisk_server_run();
 	tapdisk_server_close();
 
-	return server.err;
+	return 0;
 }
diff -Nur blktap2_oxt//drivers/tapdisk-server.h blktap2_xen//drivers/tapdisk-server.h
--- blktap2_oxt//drivers/tapdisk-server.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-server.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #ifndef _TAPDISK_SERVER_H_
 #define _TAPDISK_SERVER_H_
 
@@ -52,18 +47,21 @@
 
 event_id_t tapdisk_server_register_event(char, int, int, event_cb_t, void *);
 void tapdisk_server_unregister_event(event_id_t);
-void tapdisk_server_mask_event(event_id_t, int);
 void tapdisk_server_set_max_timeout(int);
 
 int tapdisk_server_init(void);
-int tapdisk_server_initialize(const char *, const char *);
+int tapdisk_server_initialize(void);
 int tapdisk_server_complete(void);
 int tapdisk_server_run(void);
 void tapdisk_server_iterate(void);
 
-int tapdisk_server_openlog(const char *, int, int);
-void tapdisk_server_closelog(void);
-void tapdisk_start_logging(const char *, const char *);
-void tapdisk_stop_logging(void);
+#define TAPDISK_TIOCBS              (TAPDISK_DATA_REQUESTS + 50)
+
+typedef struct tapdisk_server {
+	int                          run;
+	struct list_head             vbds;
+	scheduler_t                  scheduler;
+	struct tqueue                aio_queue;
+} tapdisk_server_t;
 
 #endif
diff -Nur blktap2_oxt//drivers/tapdisk-stream.c blktap2_xen//drivers/tapdisk-stream.c
--- blktap2_oxt//drivers/tapdisk-stream.c	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-stream.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -43,6 +38,7 @@
 #include "tapdisk-vbd.h"
 #include "tapdisk-server.h"
 #include "tapdisk-disktype.h"
+#include "tapdisk-utils.h"
 
 #define POLL_READ                        0
 #define POLL_WRITE                       1
@@ -148,9 +144,9 @@
 static inline void
 tapdisk_stream_poll_clear(struct tapdisk_stream_poll *p)
 {
-	int gcc, dummy;
+	int dummy;
 
-	gcc = read(p->pipe[POLL_READ], &dummy, sizeof(dummy));
+	read_exact(p->pipe[POLL_READ], &dummy, sizeof(dummy));
 	p->set = 0;
 }
 
@@ -160,7 +156,7 @@
 	int dummy = 0;
 
 	if (!p->set) {
-		int gcc = write(p->pipe[POLL_WRITE], &dummy, sizeof(dummy));
+		write_exact(p->pipe[POLL_WRITE], &dummy, sizeof(dummy));
 		p->set = 1;
 	}
 }
@@ -208,7 +204,7 @@
 {
 	unsigned long idx = (unsigned long)tapdisk_stream_request_idx(s, sreq);
 	char *buf = (char *)MMAP_VADDR(s->vbd->ring.vstart, idx, 0);
-	int gcc = write(s->out_fd, buf, sreq->secs << SECTOR_SHIFT);
+	write_exact(s->out_fd, buf, sreq->secs << SECTOR_SHIFT);
 }
 
 static void
@@ -256,7 +252,7 @@
 	else {
 		s->err = EIO;
 		list_add_tail(&sreq->next, &s->free_list);
-		fprintf(stderr, "error reading sector 0x%llx\n", sreq->sec);
+		fprintf(stderr, "error reading sector 0x%"PRIu64"\n", sreq->sec);
 	}
 
 	tapdisk_stream_write_data(s);
@@ -339,11 +335,11 @@
 
 	s->id = tapdisk_stream_count++;
 
-	err = tapdisk_server_initialize(NULL, NULL);
+	err = tapdisk_server_initialize();
 	if (err)
 		goto out;
 
-	err = tapdisk_vbd_initialize(-1, -1, s->id);
+	err = tapdisk_vbd_initialize(s->id);
 	if (err)
 		goto out;
 
@@ -355,11 +351,13 @@
 
 	tapdisk_vbd_set_callback(s->vbd, tapdisk_stream_dequeue, s);
 
-	err = tapdisk_vbd_open_vdi(s->vbd, type, path,
-				   TD_OPEN_RDONLY, -1, -1, NULL);
+	err = tapdisk_vbd_open_vdi(s->vbd, path, type,
+				   TAPDISK_STORAGE_TYPE_DEFAULT,
+				   TD_OPEN_RDONLY);
 	if (err)
 		goto out;
 
+	s->vbd->reopened = 1;
 	err = 0;
 
 out:
@@ -401,8 +399,8 @@
 		count = image.size - skip;
 
 	if (count + skip > image.size) {
-		fprintf(stderr, "0x%llx past end of image 0x%llx\n",
-			count + skip, image.size);
+		fprintf(stderr, "0x%"PRIx64" past end of image 0x%"PRIx64"\n",
+			(uint64_t) (count + skip), (uint64_t) image.size);
 		return -EINVAL;
 	}
 
@@ -588,7 +586,7 @@
 		return err;
 	}
 
-	tapdisk_start_logging("tapdisk-stream", "daemon");
+	tapdisk_start_logging("tapdisk-stream");
 
 	err = tapdisk_stream_open(&stream, path, type, count, skip);
 	if (err)
diff -Nur blktap2_oxt//drivers/tapdisk-utils.c blktap2_xen//drivers/tapdisk-utils.c
--- blktap2_oxt//drivers/tapdisk-utils.c	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-utils.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,18 +25,10 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
-#include <stdlib.h>
 #include <errno.h>
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>
-#include <linux/fs.h>
 #include <sys/stat.h>
 #include <sys/mman.h>
 #include <sys/ioctl.h>
@@ -46,100 +38,27 @@
 #include <linux/version.h>
 #endif
 
-#define SYSLOG_NAMES
-#include <syslog.h>
-
+#include "blk.h"
 #include "tapdisk.h"
 #include "blktaplib.h"
 #include "tapdisk-log.h"
 #include "tapdisk-utils.h"
-#include "tapdisk-syslog.h"
-
-#define MIN(a,b) (((a) < (b)) ? (a) : (b))
-
-static int
-tapdisk_syslog_facility_by_name(const char *name)
-{
-	int facility;
-	CODE *c;
-
-	facility = -1;
-
-	for (c = facilitynames; c->c_name != NULL; ++c)
-		if (!strcmp(c->c_name, name)) {
-			facility = c->c_val;
-			break;
-		}
-
-	return facility;
-}
-
-int
-tapdisk_syslog_facility(const char *arg)
-{
-	int facility;
-	char *endptr;
-
-	if (arg) {
-		facility = strtol(arg, &endptr, 0);
-		if (*endptr == 0)
-			return facility;
-
-		facility = tapdisk_syslog_facility_by_name(arg);
-		if (facility >= 0)
-			return facility;
-	}
-
-	return LOG_DAEMON;
-}
 
-char*
-tapdisk_syslog_ident(const char *name)
+void
+tapdisk_start_logging(const char *name)
 {
-	char ident[TD_SYSLOG_IDENT_MAX+1];
-	size_t size, len;
-	pid_t pid;
-
-	pid  = getpid();
-	size = sizeof(ident);
-	len  = 0;
-
-	len  = snprintf(NULL, 0, "[%d]", pid);
-	len  = snprintf(ident, size - len, "%s", name);
-	len += snprintf(ident + len, size - len, "[%d]", pid);
+	static char buf[128];
 
-	return strdup(ident);
+	snprintf(buf, sizeof(buf), "%s[%d]", name, getpid());
+	openlog(buf, LOG_CONS | LOG_ODELAY, LOG_DAEMON);
+	open_tlog("/tmp/tapdisk.log", (64 << 10), TLOG_WARN, 0);
 }
 
-size_t
-tapdisk_syslog_strftime(char *buf, size_t size, const struct timeval *tv)
+void
+tapdisk_stop_logging(void)
 {
-	const char *mon[] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun",
-			      "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
-	struct tm tm;
-
-	/*
-	 * TIMESTAMP :=  <Mmm> " " <dd> " " <hh> ":" <mm> ":" <ss>.
-	 * Local time, no locales.
-	 */
-
-	localtime_r(&tv->tv_sec, &tm);
-
-	return snprintf(buf, size, "%s %2d %02d:%02d:%02d",
-			mon[tm.tm_mon], tm.tm_mday,
-			tm.tm_hour, tm.tm_min, tm.tm_sec);
-}
-
-size_t
-tapdisk_syslog_strftv(char *buf, size_t size, const struct timeval *tv)
-{
-	struct tm tm;
-
-	localtime_r(&tv->tv_sec, &tm);
-
-	return snprintf(buf, size, "[%02d:%02d:%02d.%03ld]",
-			tm.tm_hour, tm.tm_min, tm.tm_sec,
-			(long)tv->tv_usec / 1000);
+	closelog();
+	close_tlog();
 }
 
 int
@@ -148,12 +67,6 @@
 	int err;
 	struct rlimit rlim;
 
-	err = setpriority(PRIO_PROCESS, 0, PRIO_SPECIAL_IO);
-	if (err) {
-		EPRINTF("PRIO_SPECIAL_IO failed: %d\n", errno);
-		return -errno;
-	}
-
 	rlim.rlim_cur = RLIM_INFINITY;
 	rlim.rlim_max = RLIM_INFINITY;
 
@@ -200,8 +113,8 @@
 {
 	int ret;
 	struct stat stat;
-	uint64_t sectors, bytes;
-	uint32_t sector_size;
+	uint64_t sectors;
+	uint64_t sector_size;
 
 	sectors       = 0;
 	sector_size   = 0;
@@ -215,28 +128,12 @@
 
 	if (S_ISBLK(stat.st_mode)) {
 		/*Accessing block device directly*/
-		if (ioctl(fd,BLKGETSIZE64,&bytes)==0) {
-			sectors = bytes >> SECTOR_SHIFT;
-		} else if (ioctl(fd,BLKGETSIZE,&sectors)!=0) {
-			DPRINTF("ERR: BLKGETSIZE and BLKGETSIZE64 failed, couldn't stat image");
+		if (blk_getimagesize(fd, &sectors) != 0)
 			return -EINVAL;
-		}
 
 		/*Get the sector size*/
-#if defined(BLKSSZGET)
-		{
-			int arg;
+		if (blk_getsectorsize(fd, &sector_size) != 0)
 			sector_size = DEFAULT_SECTOR_SIZE;
-			ioctl(fd, BLKSSZGET, &sector_size);
-
-			if (sector_size != DEFAULT_SECTOR_SIZE)
-				DPRINTF("Note: sector size is %u (not %d)\n",
-					sector_size, DEFAULT_SECTOR_SIZE);
-		}
-#else
-		sector_size = DEFAULT_SECTOR_SIZE;
-#endif
-
 	} else {
 		/*Local file? try fstat instead*/
 		sectors     = (stat.st_size >> SECTOR_SHIFT);
@@ -278,3 +175,40 @@
 }
 
 #endif
+int read_exact(int fd, void *data, size_t size)
+{
+    size_t offset = 0;
+    ssize_t len;
+
+    while ( offset < size )
+    {
+        len = read(fd, (char *)data + offset, size - offset);
+        if ( (len == -1) && (errno == EINTR) )
+            continue;
+        if ( len == 0 )
+            errno = 0;
+        if ( len <= 0 )
+            return -1;
+        offset += len;
+    }
+
+    return 0;
+}
+
+int write_exact(int fd, const void *data, size_t size)
+{
+    size_t offset = 0;
+    ssize_t len;
+
+    while ( offset < size )
+    {
+        len = write(fd, (const char *)data + offset, size - offset);
+        if ( (len == -1) && (errno == EINTR) )
+            continue;
+        if ( len <= 0 )
+            return -1;
+        offset += len;
+    }
+
+    return 0;
+}
diff -Nur blktap2_oxt//drivers/tapdisk-utils.h blktap2_xen//drivers/tapdisk-utils.h
--- blktap2_oxt//drivers/tapdisk-utils.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-utils.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,28 +25,21 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #ifndef _TAPDISK_UTILS_H_
 #define _TAPDISK_UTILS_H_
 
 #include <inttypes.h>
 
-#define MAX_NAME_LEN          1000
-#define TD_SYSLOG_IDENT_MAX   32
-#define TD_SYSLOG_STRTIME_LEN 15
+#define MAX_NAME_LEN                 1000
 
-int tapdisk_syslog_facility(const char *);
-char* tapdisk_syslog_ident(const char *);
-size_t tapdisk_syslog_strftime(char *, size_t, const struct timeval *);
-size_t tapdisk_syslog_strftv(char *, size_t, const struct timeval *);
+void tapdisk_start_logging(const char *);
+void tapdisk_stop_logging(void);
 int tapdisk_set_resource_limits(void);
 int tapdisk_namedup(char **, const char *);
-int tapdisk_parse_disk_type(const char *, char **, int *);
 int tapdisk_get_image_size(int, uint64_t *, uint32_t *);
 int tapdisk_linux_version(void);
 
+int read_exact(int fd, void *data, size_t size); /* EOF => -1, errno=0 */
+int write_exact(int fd, const void *data, size_t size);
+
 #endif
diff -Nur blktap2_oxt//drivers/tapdisk-vbd.c blktap2_xen//drivers/tapdisk-vbd.c
--- blktap2_oxt//drivers/tapdisk-vbd.c	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-vbd.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,5 @@
-/*
+/* 
  * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +24,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -37,17 +34,16 @@
 #include <libgen.h>
 #include <sys/mman.h>
 #include <sys/ioctl.h>
+#ifdef MEMSHR
+#include <memshr.h>
+#endif
 
-#include "libvhd.h"
 #include "tapdisk-image.h"
 #include "tapdisk-driver.h"
 #include "tapdisk-server.h"
-#include "tapdisk-vbd.h"
-#include "tapdisk-disktype.h"
 #include "tapdisk-interface.h"
-#include "tapdisk-stats.h"
-#include "tapdisk-storage.h"
-
+#include "tapdisk-disktype.h"
+#include "tapdisk-vbd.h"
 #include "blktap2.h"
 
 #define DBG(_level, _f, _a...) tlog_write(_level, _f, ##_a)
@@ -72,10 +68,7 @@
 #define TD_VBD_WATCHDOG_TIMEOUT     10
 
 static void tapdisk_vbd_ring_event(event_id_t, char, void *);
-static void tapdisk_vbd_complete_vbd_request(td_vbd_t *, td_vbd_request_t *);
 static void tapdisk_vbd_callback(void *, blkif_response_t *);
-static int  tapdisk_vbd_queue_ready(td_vbd_t *);
-static void tapdisk_vbd_check_queue_state(td_vbd_t *);
 
 /* 
  * initialization
@@ -88,10 +81,15 @@
 	INIT_LIST_HEAD(&vreq->next);
 }
 
-static void
-tapdisk_vbd_mark_progress(td_vbd_t *vbd)
+void
+tapdisk_vbd_free(td_vbd_t *vbd)
 {
-	gettimeofday(&vbd->ts, NULL);
+	if (vbd) {
+		tapdisk_vbd_free_stack(vbd);
+		list_del_init(&vbd->next);
+		free(vbd->name);
+		free(vbd);
+	}
 }
 
 td_vbd_t*
@@ -113,14 +111,19 @@
 	/* default blktap ring completion */
 	vbd->callback = tapdisk_vbd_callback;
 	vbd->argument = vbd;
+    
+#ifdef MEMSHR
+	memshr_vbd_initialize();
+#endif
 
+	INIT_LIST_HEAD(&vbd->driver_stack);
 	INIT_LIST_HEAD(&vbd->images);
 	INIT_LIST_HEAD(&vbd->new_requests);
 	INIT_LIST_HEAD(&vbd->pending_requests);
 	INIT_LIST_HEAD(&vbd->failed_requests);
 	INIT_LIST_HEAD(&vbd->completed_requests);
 	INIT_LIST_HEAD(&vbd->next);
-	tapdisk_vbd_mark_progress(vbd);
+	gettimeofday(&vbd->ts, NULL);
 
 	for (i = 0; i < MAX_REQUESTS; i++)
 		tapdisk_vbd_initialize_vreq(vbd->request_list + i);
@@ -129,7 +132,7 @@
 }
 
 int
-tapdisk_vbd_initialize(int rfd, int wfd, uint16_t uuid)
+tapdisk_vbd_initialize(uint16_t uuid)
 {
 	td_vbd_t *vbd;
 
@@ -162,12 +165,7 @@
 	DPRINTF("VBD CHAIN:\n");
 
 	tapdisk_vbd_for_each_image(vbd, image, tmp) {
-		DPRINTF("%s: type:%s(%d) storage:%s(%d)\n",
-			image->name,
-			tapdisk_disk_types[image->type]->name,
-			image->type,
-			tapdisk_storage_name(image->driver->storage),
-			image->driver->storage);
+		DPRINTF("%s: %d\n", image->name, image->type);
 
 		if (tapdisk_vbd_is_last_image(vbd, image))
 			break;
@@ -191,22 +189,10 @@
 		tapdisk_image_free(image);
 	}
 
-	if (vbd->secondary && vbd->secondary_mode != TD_VBD_SECONDARY_MIRROR) {
-		/* in mirror mode the image will have been closed as part of 
-		 * the chain */
-		td_close(vbd->secondary);
-		tapdisk_image_free(vbd->secondary);
-		DPRINTF("Secondary image closed\n");
-	}
-
-	if (vbd->retired) {
-		td_close(vbd->retired);
-		tapdisk_image_free(vbd->retired);
-		DPRINTF("Retired mirror image closed\n");
-	}
-
 	INIT_LIST_HEAD(&vbd->images);
 	td_flag_set(vbd->state, TD_VBD_CLOSED);
+
+	tapdisk_vbd_free_stack(vbd);
 }
 
 static int
@@ -230,6 +216,7 @@
 
 	cache = tapdisk_image_allocate(target->name,
 				       DISK_TYPE_BLOCK_CACHE,
+				       target->storage,
 				       target->flags,
 				       target->private);
 	if (!cache)
@@ -248,7 +235,8 @@
 
 	cache->driver = tapdisk_driver_allocate(cache->type,
 						cache->name,
-						cache->flags);
+						cache->flags,
+						cache->storage);
 	if (!cache->driver) {
 		err = -ENOMEM;
 		goto fail;
@@ -273,185 +261,6 @@
 }
 
 static int
-tapdisk_vbd_add_local_cache(td_vbd_t *vbd)
-{
-	int err;
-	td_driver_t *driver;
-	td_image_t *cache, *parent;
-
-	parent = tapdisk_vbd_first_image(vbd);
-	if (tapdisk_vbd_is_last_image(vbd, parent)) {
-		DPRINTF("Single-image chain, nothing to cache");
-		return 0;
-	}
-
-	cache = tapdisk_image_allocate(parent->name,
-			DISK_TYPE_LOCAL_CACHE,
-			parent->flags,
-			parent->private);
-
-	if (!cache)
-		return -ENOMEM;
-
-	/* try to load existing cache */
-	err = td_load(cache);
-	if (!err)
-		goto done;
-
-	cache->driver = tapdisk_driver_allocate(cache->type,
-						cache->name,
-						cache->flags);
-
-	if (!cache->driver) {
-		err = -ENOMEM;
-		goto fail;
-	}
-
-	cache->driver->info = parent->driver->info;
-
-	/* try to open new cache */
-	err = td_open(cache);
-	if (!err)
-		goto done;
-
-fail:
-	tapdisk_image_free(cache);
-	return err;
-
-done:
-	/* insert cache right above leaf image */
-	list_add(&cache->next, &parent->next);
-
-	DPRINTF("Added local_cache driver\n");
-	return 0;
-}
-
-static int
-tapdisk_vbd_add_secondary(td_vbd_t *vbd)
-{
-	int err;
-	td_driver_t *driver;
-	td_image_t *leaf, *second;
-
-	DPRINTF("Adding secondary image: %s\n", vbd->secondary_name);
-
-	leaf = tapdisk_vbd_first_image(vbd);
-	second = tapdisk_image_allocate(vbd->secondary_name,
-					vbd->secondary_type,
-					leaf->flags,
-					leaf->private);
-
-	if (!second)
-		return -ENOMEM;
-
-	second->driver = tapdisk_driver_allocate(second->type,
-						 second->name,
-						 second->flags);
-
-	if (!second->driver) {
-		err = -ENOMEM;
-		goto fail;
-	}
-
-	second->driver->info = leaf->driver->info;
-
-	/* try to open the secondary image */
-	err = td_open(second);
-	if (err)
-		goto fail;
-
-	if (second->info.size != leaf->info.size) {
-		EPRINTF("Secondary image size %lld != image size %lld\n",
-				second->info.size, leaf->info.size);
-		err = -EINVAL;
-		goto fail;
-	}
-
-	goto done;
-
-fail:
-	tapdisk_image_free(second);
-	return err;
-
-done:
-	vbd->secondary = second;
-	leaf->flags |= TD_IGNORE_ENOSPC;
-	if (td_flag_test(vbd->flags, TD_OPEN_STANDBY)) {
-		DPRINTF("In standby mode\n");
-		vbd->secondary_mode = TD_VBD_SECONDARY_STANDBY;
-	} else {
-		DPRINTF("In mirror mode\n");
-		vbd->secondary_mode = TD_VBD_SECONDARY_MIRROR;
-		/* we actually need this image to also be part of the chain, 
-		 * since it may already contain data */
-		list_add(&vbd->secondary->next, &leaf->next);
-	}
-
-	DPRINTF("Added secondary image\n");
-	return 0;
-}
-
-static void signal_enospc(td_vbd_t *vbd)
-{
-	int fd, err;
-	char *fn;
-
-	err = asprintf(&fn, BLKTAP2_ENOSPC_SIGNAL_FILE"%d", vbd->minor);
-	if (err == -1) {
-		EPRINTF("Failed to signal ENOSPC condition\n");
-		return;
-	}
-
-	fd = open(fn, O_WRONLY | O_CREAT | O_NONBLOCK, 0644);
-	if (fd == -1)
-		EPRINTF("Failed to open file to signal ENOSPC condition\n");
-	else
-		close(fd);
-
-	free(fn);
-}
-
-static int
-tapdisk_vbd_open_index(td_vbd_t *vbd)
-{
-	int err;
-	char *path;
-	td_flag_t flags;
-	td_image_t *last, *image;
-
-	last = tapdisk_vbd_last_image(vbd);
-	err  = asprintf(&path, "%s.bat", last->name);
-	if (err == -1)
-		return -errno;
-
-	err = access(path, R_OK);
-	if (err == -1) {
-		free(path);
-		return -errno;
-	}
-
-	flags = vbd->flags | TD_OPEN_RDONLY | TD_OPEN_SHAREABLE;
-	image = tapdisk_image_allocate(path, DISK_TYPE_VINDEX, flags, vbd);
-	if (!image) {
-		err = -ENOMEM;
-		goto fail;
-	}
-
-	err = td_open(image);
-	if (err)
-		goto fail;
-
-	tapdisk_vbd_add_image(vbd, image);
-	return 0;
-
-fail:
-	if (image)
-		tapdisk_image_free(image);
-	free(path);
-	return err;
-}
-
-static int
 tapdisk_vbd_add_dirty_log(td_vbd_t *vbd)
 {
 	int err;
@@ -465,6 +274,7 @@
 
 	log    = tapdisk_image_allocate(parent->name,
 					DISK_TYPE_LOG,
+					parent->storage,
 					parent->flags,
 					vbd);
 	if (!log)
@@ -472,7 +282,8 @@
 
 	driver = tapdisk_driver_allocate(log->type,
 					 log->name,
-					 log->flags);
+					 log->flags,
+					 log->storage);
 	if (!driver) {
 		err = -ENOMEM;
 		goto fail;
@@ -485,7 +296,7 @@
 	if (err)
 		goto fail;
 
-	tapdisk_vbd_add_image(vbd, log);
+	list_add(&log->next, &vbd->images);
 	return 0;
 
 fail:
@@ -494,81 +305,117 @@
 }
 
 static int
-__tapdisk_vbd_open_vdi(td_vbd_t *vbd, td_flag_t extra_flags)
+tapdisk_vbd_open_level(td_vbd_t *vbd, struct list_head *head,
+		       const char *params, int driver_type,
+		       td_disk_info_t *driver_info, td_flag_t flags)
 {
-	char *file;
-	int err, type;
-	td_flag_t flags;
+	const char *name;
+	int type, err;
+	td_image_t *image;
 	td_disk_id_t id;
-	td_image_t *image, *tmp;
-	struct tfilter *filter = NULL;
+	td_driver_t *driver;
 
-	flags = (vbd->flags & ~TD_OPEN_SHAREABLE) | extra_flags;
-	file  = vbd->name;
-	type  = vbd->type;
+	name    = params;
+	id.name = NULL;
+	type    = driver_type;
+	INIT_LIST_HEAD(head);
 
 	for (;;) {
 		err   = -ENOMEM;
-		image = tapdisk_image_allocate(file, type, flags, vbd);
+		image = tapdisk_image_allocate(name, type,
+					       vbd->storage, flags, vbd);
 
-		if (file != vbd->name) {
-			free(file);
-			file = NULL;
-		}
+		free(id.name);
 
 		if (!image)
-			goto fail;
+			goto out;
 
-		err = td_load(image);
-		if (err) {
-			if (err != -ENODEV)
-				goto fail;
 
-			if (td_flag_test(flags, TD_OPEN_VHD_INDEX) &&
-			    td_flag_test(flags, TD_OPEN_RDONLY)) {
-				err = tapdisk_vbd_open_index(vbd);
-				if (!err) {
-					tapdisk_image_free(image);
-					image = NULL;
-					break;
-				}
-
-				if (err != -ENOENT)
-					goto fail;
-			}
+		/* this breaks if a driver modifies its info within a layer */
+		err = __td_open(image, driver_info);
+		if (err)
+			goto out;
 
-			err = td_open(image);
-			if (err)
-				goto fail;
-		}
+		/* TODO: non-sink drivers that don't care about their child
+		 * currently return EINVAL. Could return TD_PARENT_OK or
+		 * TD_ANY_PARENT */
 
 		err = td_get_parent_id(image, &id);
-		if (err && err != TD_NO_PARENT) {
+		if (err && (err != TD_NO_PARENT && err != -EINVAL)) {
 			td_close(image);
-			goto fail;
+			goto out;
 		}
 
-		tapdisk_vbd_add_image(vbd, image);
+		/* add this image to the end of the list */
+		list_add_tail(&image->next, head);
 		image = NULL;
 
-		if (err == TD_NO_PARENT)
-			break;
+		/* if the image does not have a parent we return the
+		 * list of images generated by this level of the stack */
+		if (err == TD_NO_PARENT || err == -EINVAL) {
+			err = 0;
+			goto out;
+		}
 
-		file   = id.name;
+		name   = id.name;
 		type   = id.drivertype;
-		if (flags & TD_OPEN_REUSE_PARENT) {
-			free(file);
-			err = asprintf(&file, "%s%d", BLKTAP2_IO_DEVICE,
-					vbd->parent_devnum);
-			if (err == -1) {
-				err = ENOMEM;
-				goto fail;
-			}
-			type = DISK_TYPE_AIO;
-		}
+
 		flags |= (TD_OPEN_RDONLY | TD_OPEN_SHAREABLE);
 	}
 
+out:
+	if (err) {
+		if (image) {
+			td_close(image);
+			tapdisk_image_free(image);
+		}
+		while (!list_empty(head)) {
+			image = list_entry(&head->next, td_image_t, next);
+			td_close(image);
+			tapdisk_image_free(image);
+		}
+	}
+
+	return err;
+}
+
+static int
+__tapdisk_vbd_open_vdi(td_vbd_t *vbd, td_flag_t extra_flags)
+{
+	int err;
+	td_flag_t flags;
+	td_image_t *tmp;
+	td_vbd_driver_info_t *driver_info;
+	struct list_head *images;
+	td_disk_info_t *parent_info = NULL;
+
+	if (list_empty(&vbd->driver_stack))
+		return -ENOENT;
+
+	flags = (vbd->flags & ~TD_OPEN_SHAREABLE) | extra_flags;
+
+	/* loop on each user specified driver.
+	 * NOTE: driver_info is in reverse order. That is, the first
+	 * item is the 'parent' or 'sink' driver */
+	list_for_each_entry(driver_info, &vbd->driver_stack, next) {
+		LIST_HEAD(images);
+
+		err = tapdisk_vbd_open_level(vbd, &images,
+					     driver_info->params,
+					     driver_info->type,
+					     parent_info, flags);
+		if (err)
+			goto fail;
+
+		/* after each loop, 
+		 * append the created stack to the result stack */
+		list_splice(&images, &vbd->images);
+
+		/* set the parent_info to the first diskinfo on the stack */
+		tmp = tapdisk_vbd_first_image(vbd);
+		parent_info = &tmp->info;
+	}
+
 	if (td_flag_test(vbd->flags, TD_OPEN_LOG_DIRTY)) {
 		err = tapdisk_vbd_add_dirty_log(vbd);
 		if (err)
@@ -579,70 +426,144 @@
 		err = tapdisk_vbd_add_block_cache(vbd);
 		if (err)
 			goto fail;
-	}		
-
-	if (td_flag_test(vbd->flags, TD_OPEN_LOCAL_CACHE)) {
-		err = tapdisk_vbd_add_local_cache(vbd);
-		if (err)
-			goto fail;
-	}		
+	}
 
 	err = tapdisk_vbd_validate_chain(vbd);
 	if (err)
 		goto fail;
 
-	if (td_flag_test(vbd->flags, TD_OPEN_SECONDARY)) {
-		err = tapdisk_vbd_add_secondary(vbd);
-		if (err)
-			goto fail;
-	}
-
 	td_flag_clear(vbd->state, TD_VBD_CLOSED);
 
 	return 0;
 
 fail:
-	if (image)
-		tapdisk_image_free(image);
-
 	tapdisk_vbd_close_vdi(vbd);
+	return err;
+}
+
+/* this populates a vbd type based on path */
+int
+tapdisk_vbd_parse_stack(td_vbd_t *vbd, const char *path)
+{
+	int err;
+	char *params, *driver_str;
+	td_vbd_driver_info_t *driver;
+
+	err = tapdisk_namedup(&params, path);
+	if (err)
+		return err;
+
+	/* tokenize params based on pipe '|' */
+	driver_str = strtok(params, "|");
+	while (driver_str != NULL) {
+		const char *path;
+		int type;
+
+		/* parse driver info and add to vbd */
+		driver = calloc(1, sizeof(td_vbd_driver_info_t));
+		if (!driver) {
+			PERROR("malloc");
+			err = -errno;
+			goto out;
+		}
+		INIT_LIST_HEAD(&driver->next);
+
+		err = tapdisk_parse_disk_type(driver_str, &path, &type);
+		if (err) {
+			free(driver);
+			goto out;
+		}
+
+		driver->type   = type;
+		driver->params = strdup(path);
+		if (!driver->params) {
+			err = -ENOMEM;
+			free(driver);
+			goto out;
+		}
+
+		/* build the list backwards as the last driver will be the
+		 * first driver to open in the stack */
+		list_add(&driver->next, &vbd->driver_stack);
+
+		/* get next driver string */
+		driver_str = strtok(NULL, "|");
+	}
+
+out:
+	free(params);
+	if (err)
+		tapdisk_vbd_free_stack(vbd);
 
 	return err;
 }
 
+void
+tapdisk_vbd_free_stack(td_vbd_t *vbd)
+{
+	td_vbd_driver_info_t *driver;
+
+	while (!list_empty(&vbd->driver_stack)) {
+		driver = list_entry(vbd->driver_stack.next,
+				    td_vbd_driver_info_t, next);
+		list_del(&driver->next);
+		free(driver->params);
+		free(driver);
+	}
+}
+
+/* NOTE: driver type, etc. must be set */
 int
-tapdisk_vbd_open_vdi(td_vbd_t *vbd, int type, const char *path,
-		     td_flag_t flags, int prt_devnum,
-		     int secondary_type, const char *secondary_name)
+tapdisk_vbd_open_stack(td_vbd_t *vbd, uint16_t storage, td_flag_t flags)
 {
-	const disk_info_t *info;
 	int i, err;
 
-	info = tapdisk_disk_types[type];
-	if (!info)
-		return -EINVAL;
+	vbd->flags   = flags;
+	vbd->storage = storage;
 
-	DPRINTF("Loading driver '%s' for vbd %u %s 0x%08x\n",
-		info->name, vbd->uuid, path, flags);
+	for (i = 0; i < TD_VBD_EIO_RETRIES; i++) {
+		err = __tapdisk_vbd_open_vdi(vbd, 0);
+		if (err != -EIO)
+			break;
 
-	err = tapdisk_namedup(&vbd->name, path);
+		sleep(TD_VBD_EIO_SLEEP);
+	}
 	if (err)
-		return err;
+		goto fail;
 
-	if (flags & TD_OPEN_REUSE_PARENT)
-		vbd->parent_devnum = prt_devnum;
+	return 0;
 
-	if (flags & TD_OPEN_SECONDARY) {
-		vbd->secondary_type = secondary_type;
-		err = tapdisk_namedup(&vbd->secondary_name, secondary_name);
-		if (err)
-			return err;
-	}
+ fail:
+	return err;
+}
+
+int
+tapdisk_vbd_open_vdi(td_vbd_t *vbd, const char *path,
+		     uint16_t drivertype, uint16_t storage, td_flag_t flags)
+{
+	int i, err;
+	const struct tap_disk *ops;
+
+	ops = tapdisk_disk_drivers[drivertype];
+	if (!ops)
+		return -EINVAL;
+	DPRINTF("Loaded %s driver for vbd %u %s 0x%08x\n",
+		ops->disk_type, vbd->uuid, path, flags);
+
+	err = tapdisk_namedup(&vbd->name, path);
+	if (err)
+		return err;
 
 	vbd->flags   = flags;
-	vbd->type    = type;
+	vbd->storage = storage;
 
-	err = __tapdisk_vbd_open_vdi(vbd, TD_OPEN_STRICT);
+	for (i = 0; i < TD_VBD_EIO_RETRIES; i++) {
+		err = __tapdisk_vbd_open_vdi(vbd, 0);
+		if (err != -EIO)
+			break;
+
+		sleep(TD_VBD_EIO_SLEEP);
+	}
 	if (err)
 		goto fail;
 
@@ -771,12 +692,12 @@
 }
 
 int
-tapdisk_vbd_open(td_vbd_t *vbd, int type, const char *path,
-		 int minor, const char *ring, td_flag_t flags)
+tapdisk_vbd_open(td_vbd_t *vbd, const char *name, uint16_t type,
+		 uint16_t storage, int minor, const char *ring, td_flag_t flags)
 {
 	int err;
 
-	err = tapdisk_vbd_open_vdi(vbd, type, path, flags, -1, -1, NULL);
+	err = tapdisk_vbd_open_stack(vbd, storage, flags);
 	if (err)
 		goto out;
 
@@ -838,19 +759,19 @@
 	DPRINTF("%s: state: 0x%08x, new: 0x%02x, pending: 0x%02x, "
 		"failed: 0x%02x, completed: 0x%02x\n", 
 		vbd->name, vbd->state, new, pending, failed, completed);
-	DPRINTF("last activity: %010ld.%06ld, errors: 0x%04"PRIx64", "
+	DPRINTF("last activity: %010ld.%06lld, errors: 0x%04"PRIx64", "
 		"retries: 0x%04"PRIx64", received: 0x%08"PRIx64", "
-		"returned: 0x%08"PRIx64", kicked: 0x%08"PRIx64", "
-		"kicks in: 0x%08"PRIx64", out: 0x%08"PRIu64"\n",
-		vbd->ts.tv_sec, vbd->ts.tv_usec,
+		"returned: 0x%08"PRIx64", kicked: 0x%08"PRIx64"\n",
+		vbd->ts.tv_sec, (unsigned long long)vbd->ts.tv_usec,
 		vbd->errors, vbd->retries, vbd->received, vbd->returned,
-		vbd->kicked, vbd->kicks_in, vbd->kicks_out);
+		vbd->kicked);
 
 	tapdisk_vbd_close_vdi(vbd);
 	tapdisk_vbd_detach(vbd);
 	tapdisk_server_remove_vbd(vbd);
-	free(vbd->name);
-	free(vbd);
+	tapdisk_vbd_free(vbd);
+
+	tlog_print_errors();
 
 	return 0;
 }
@@ -895,14 +816,13 @@
 	tapdisk_vbd_queue_count(vbd, &new, &pending, &failed, &completed);
 
 	DBG(TLOG_WARN, "%s: state: 0x%08x, new: 0x%02x, pending: 0x%02x, "
-	    "failed: 0x%02x, completed: 0x%02x, last activity: %010ld.%06ld, "
-	    "errors: 0x%04llx, retries: 0x%04llx, received: 0x%08llx, "
-	    "returned: 0x%08llx, kicked: 0x%08llx, "
-	    "kicks in: 0x%08"PRIx64", out: 0x%08"PRIx64"\n",
+	    "failed: 0x%02x, completed: 0x%02x, last activity: %010ld.%06lld, "
+	    "errors: 0x%04"PRIx64", retries: 0x%04"PRIx64", received: 0x%08"PRIx64", "
+	    "returned: 0x%08"PRIx64", kicked: 0x%08"PRIx64"\n",
 	    vbd->name, vbd->state, new, pending, failed, completed,
-	    vbd->ts.tv_sec, vbd->ts.tv_usec, vbd->errors, vbd->retries,
-	    vbd->received, vbd->returned, vbd->kicked,
-	    vbd->kicks_in, vbd->kicks_out);
+	    vbd->ts.tv_sec, (unsigned long long)vbd->ts.tv_usec,
+	    vbd->errors, vbd->retries,
+	    vbd->received, vbd->returned, vbd->kicked);
 
 	tapdisk_vbd_for_each_image(vbd, image, tmp)
 		td_debug(image);
@@ -915,7 +835,7 @@
 		return;
 
 	tapdisk_vbd_debug(vbd);
-	tlog_precious();
+	tlog_flush();
 	td_flag_set(vbd->state, TD_VBD_LOG_DROPPED);
 }
 
@@ -937,7 +857,7 @@
 	return 0;
 }
 
-static int
+int
 tapdisk_vbd_queue_ready(td_vbd_t *vbd)
 {
 	return (!td_flag_test(vbd->state, TD_VBD_DEAD) &&
@@ -949,8 +869,7 @@
 int
 tapdisk_vbd_retry_needed(td_vbd_t *vbd)
 {
-	return !(list_empty(&vbd->failed_requests) &&
-		 list_empty(&vbd->new_requests));
+	return td_flag_test(vbd->state, TD_VBD_RETRY_NEEDED);
 }
 
 int
@@ -977,7 +896,6 @@
 {
 	td_flag_clear(vbd->state, TD_VBD_QUIESCED);
 	td_flag_clear(vbd->state, TD_VBD_QUIESCE_REQUESTED);
-	tapdisk_vbd_mark_progress(vbd);
 	return 0;
 }
 
@@ -1027,7 +945,7 @@
 	}
 
 	if (err)
-		td_flag_set(vbd->state, TD_VBD_CLOSED | TD_VBD_DEAD);
+		td_flag_set(vbd->state, TD_VBD_CLOSED);
 
 	return err;
 }
@@ -1037,8 +955,6 @@
 {
 	int err;
 
-	DBG(TLOG_DBG, "pause requested\n");
-
 	td_flag_set(vbd->state, TD_VBD_PAUSE_REQUESTED);
 
 	err = tapdisk_vbd_quiesce_queue(vbd);
@@ -1047,36 +963,17 @@
 
 	tapdisk_vbd_close_vdi(vbd);
 
-	DBG(TLOG_DBG, "pause completed\n");
-
 	td_flag_clear(vbd->state, TD_VBD_PAUSE_REQUESTED);
 	td_flag_set(vbd->state, TD_VBD_PAUSED);
 
 	return 0;
 }
 
-static void
-tapdisk_vbd_reset_request_timers(td_vbd_t *vbd)
-{
-	struct timeval now;
-	td_vbd_request_t *vreq, *tmp;
-
-	gettimeofday(&now, NULL);
-
-	tapdisk_vbd_for_each_request(vreq, tmp, &vbd->new_requests)
-		vreq->ts = now;
-
-	tapdisk_vbd_for_each_request(vreq, tmp, &vbd->failed_requests)
-		vreq->ts = now;
-}
-
 int
-tapdisk_vbd_resume(td_vbd_t *vbd, int type, const char *path)
+tapdisk_vbd_resume(td_vbd_t *vbd, const char *path, uint16_t drivertype)
 {
 	int i, err;
 
-	DBG(TLOG_DBG, "resume requested\n");
-
 	if (!td_flag_test(vbd->state, TD_VBD_PAUSED)) {
 		EPRINTF("resume request for unpaused vbd %s\n", vbd->name);
 		return -EINVAL;
@@ -1089,12 +986,11 @@
 			EPRINTF("copying new vbd %s name failed\n", path);
 			return -EINVAL;
 		}
-		vbd->type = type;
 	}
 
 	for (i = 0; i < TD_VBD_EIO_RETRIES; i++) {
 		err = __tapdisk_vbd_open_vdi(vbd, TD_OPEN_STRICT);
-		if (!err)
+		if (err != -EIO)
 			break;
 
 		sleep(TD_VBD_EIO_SLEEP);
@@ -1103,16 +999,11 @@
 	if (err)
 		return err;
 
-	DBG(TLOG_DBG, "resume completed\n");
-
 	tapdisk_vbd_start_queue(vbd);
 	td_flag_clear(vbd->state, TD_VBD_PAUSED);
 	td_flag_clear(vbd->state, TD_VBD_PAUSE_REQUESTED);
-	tapdisk_vbd_reset_request_timers(vbd);
 	tapdisk_vbd_check_state(vbd);
 
-	DBG(TLOG_DBG, "state checked\n");
-
 	return 0;
 }
 
@@ -1122,7 +1013,7 @@
 	int n;
 	td_ring_t *ring;
 
-	tapdisk_vbd_check_queue_state(vbd);
+	tapdisk_vbd_check_state(vbd);
 
 	ring = &vbd->ring;
 	if (!ring->sring)
@@ -1132,13 +1023,12 @@
 	if (!n)
 		return 0;
 
-	vbd->kicks_out++;
 	vbd->kicked += n;
 	RING_PUSH_RESPONSES(&ring->fe_ring);
 	ioctl(ring->fd, BLKTAP_IOCTL_KICK_FE, 0);
 
-	DBG(TLOG_INFO, "kicking %d: rec: 0x%08llx, ret: 0x%08llx, kicked: "
-	    "0x%08llx\n", n, vbd->received, vbd->returned, vbd->kicked);
+	DBG(TLOG_INFO, "kicking %d: rec: 0x%08"PRIx64", ret: 0x%08"PRIx64", kicked: "
+	    "0x%08"PRIx64"\n", n, vbd->received, vbd->returned, vbd->kicked);
 
 	return n;
 }
@@ -1179,52 +1069,19 @@
 	    (int)tmp.id, tmp.sector_number, vreq->status);
 
 	if (rsp->status != BLKIF_RSP_OKAY)
-		ERR(-vreq->error, "returning BLKIF_RSP %d", rsp->status);
+		ERR(EIO, "returning BLKIF_RSP %d", rsp->status);
 
 	vbd->returned++;
 	vbd->callback(vbd->argument, rsp);
 }
 
-static int
-tapdisk_vbd_request_ttl(td_vbd_request_t *vreq,
-			const struct timeval *now)
-{
-	struct timeval delta;
-	timersub(now, &vreq->ts, &delta);
-	return TD_VBD_REQUEST_TIMEOUT - delta.tv_sec;
-}
-
-static int
-__tapdisk_vbd_request_timeout(td_vbd_request_t *vreq,
-			      const struct timeval *now)
-{
-	int timeout;
-
-	timeout = tapdisk_vbd_request_ttl(vreq, now) < 0;
-	if (timeout)
-		DBG(TLOG_INFO, "req %"PRIu64" timed out, retried %d times\n",
-		    vreq->req.id, vreq->num_retries);
-
-	return timeout;
-}
-
-static int
-tapdisk_vbd_request_timeout(td_vbd_request_t *vreq)
-{
-	struct timeval now;
-	gettimeofday(&now, NULL);
-	return __tapdisk_vbd_request_timeout(vreq, &now);
-}
-
-static void
-tapdisk_vbd_check_queue_state(td_vbd_t *vbd)
+void
+tapdisk_vbd_check_state(td_vbd_t *vbd)
 {
 	td_vbd_request_t *vreq, *tmp;
-	struct timeval now;
 
-	gettimeofday(&now, NULL);
 	tapdisk_vbd_for_each_request(vreq, tmp, &vbd->failed_requests)
-		if (__tapdisk_vbd_request_timeout(vreq, &now))
+		if (vreq->num_retries >= TD_VBD_MAX_RETRIES)
 			tapdisk_vbd_complete_vbd_request(vbd, vreq);
 
 	if (!list_empty(&vbd->new_requests) ||
@@ -1236,12 +1093,6 @@
 		list_del(&vreq->next);
 		tapdisk_vbd_initialize_vreq(vreq);
 	}
-}
-
-void
-tapdisk_vbd_check_state(td_vbd_t *vbd)
-{
-	tapdisk_vbd_check_queue_state(vbd);
 
 	if (td_flag_test(vbd->state, TD_VBD_QUIESCE_REQUESTED))
 		tapdisk_vbd_quiesce_queue(vbd);
@@ -1256,21 +1107,18 @@
 void
 tapdisk_vbd_check_progress(td_vbd_t *vbd)
 {
-	time_t diff;
-	struct timeval now, delta;
+	int diff;
+	struct timeval now;
 
-	if (list_empty(&vbd->pending_requests) &&
-	    list_empty(&vbd->failed_requests) &&
-	    list_empty(&vbd->new_requests))
+	if (list_empty(&vbd->pending_requests))
 		return;
 
 	gettimeofday(&now, NULL);
-	timersub(&now, &vbd->ts, &delta);
-	diff = delta.tv_sec;
+	diff = now.tv_sec - vbd->ts.tv_sec;
 
-	if (diff >= TD_VBD_WATCHDOG_TIMEOUT && tapdisk_vbd_queue_ready(vbd)) {
+	if (diff >= TD_VBD_WATCHDOG_TIMEOUT) {
 		DBG(TLOG_WARN, "%s: watchdog timeout: pending requests "
-		    "idle for %ld seconds\n", vbd->name, diff);
+		    "idle for %d seconds\n", vbd->name, diff);
 		tapdisk_vbd_drop_log(vbd);
 		return;
 	}
@@ -1294,72 +1142,67 @@
 	if (!tapdisk_vbd_queue_ready(vbd))
 		return -EAGAIN;
 
-	return 0;
-}
+	if (!vbd->reopened) {
+		if (td_flag_test(vbd->state, TD_VBD_LOCKING)) {
+			err = tapdisk_vbd_lock(vbd);
+			if (err)
+				return err;
+		}
 
-static int
-tapdisk_vbd_request_should_retry(td_vbd_t *vbd, td_vbd_request_t *vreq)
-{
-	if (td_flag_test(vbd->state, TD_VBD_DEAD) ||
-	    td_flag_test(vbd->state, TD_VBD_SHUTDOWN_REQUESTED))
-		return 0;
+		image = tapdisk_vbd_first_image(vbd);
+		td_flag_set(image->flags, TD_OPEN_STRICT);
 
-	switch (abs(vreq->error)) {
-	case EPERM:
-	case ENOSYS:
-	case ESTALE:
-	case ENOSPC:
-		return 0;
+		if (tapdisk_vbd_close_and_reopen_image(vbd, image))
+			EPRINTF("reopening disks failed\n");
+		else {
+			DPRINTF("reopening disks succeeded\n");
+			vbd->reopened = 1;
+		}
 	}
 
-	if (tapdisk_vbd_request_timeout(vreq))
-		return 0;
-
-	return 1;
+	return 0;
 }
 
-static void
+void
 tapdisk_vbd_complete_vbd_request(td_vbd_t *vbd, td_vbd_request_t *vreq)
 {
 	if (!vreq->submitting && !vreq->secs_pending) {
 		if (vreq->status == BLKIF_RSP_ERROR &&
-		    tapdisk_vbd_request_should_retry(vbd, vreq))
+		    vreq->num_retries < TD_VBD_MAX_RETRIES &&
+		    !td_flag_test(vbd->state, TD_VBD_DEAD) &&
+		    !td_flag_test(vbd->state, TD_VBD_SHUTDOWN_REQUESTED))
 			tapdisk_vbd_move_request(vreq, &vbd->failed_requests);
 		else
 			tapdisk_vbd_move_request(vreq, &vbd->completed_requests);
 	}
 }
 
-static void
-FIXME_maybe_count_enospc_redirect(td_vbd_t *vbd, td_request_t treq)
+static uint64_t 
+tapdisk_vbd_breq_get_sector(blkif_request_t *breq, td_request_t treq)
 {
-	int write = treq.op == TD_OP_WRITE;
-	if (write &&
-	    treq.image == tapdisk_vbd_first_image(vbd) &&
-	    vbd->FIXME_enospc_redirect_count_enabled)
-		vbd->FIXME_enospc_redirect_count += treq.secs;
+    int seg, nsects; 
+    uint64_t sector_nr = breq->sector_number; 
+    
+    for(seg=0; seg < treq.sidx; seg++) {
+        nsects = breq->seg[seg].last_sect - breq->seg[seg].first_sect + 1;
+        sector_nr += nsects;
+    }
+
+    return sector_nr;
 }
 
 static void
 __tapdisk_vbd_complete_td_request(td_vbd_t *vbd, td_vbd_request_t *vreq,
 				  td_request_t treq, int res)
 {
-	td_image_t *image = treq.image, *prev, *tmp;
 	int err;
+    td_image_t *image = treq.image;
 
 	err = (res <= 0 ? res : -res);
 	vbd->secs_pending  -= treq.secs;
 	vreq->secs_pending -= treq.secs;
 
-	if (err != -EBUSY) {
-		int write = treq.op == TD_OP_WRITE;
-		td_sector_count_add(&image->stats.hits, treq.secs, write);
-		if (err)
-			td_sector_count_add(&image->stats.fail,
-					    treq.secs, write);
-
-		FIXME_maybe_count_enospc_redirect(vbd, treq);
-	}
+	vreq->blocked = treq.blocked;
 
 	if (err) {
 		vreq->status = BLKIF_RSP_ERROR;
@@ -1371,6 +1214,22 @@
 			    (treq.op == TD_OP_WRITE ? "write" : "read"),
 			    treq.secs, treq.sec);
 		}
+	} else {
+#ifdef MEMSHR
+		if (treq.op == TD_OP_READ
+		   && td_flag_test(image->flags, TD_OPEN_RDONLY)) {
+			share_tuple_t hnd = treq.memshr_hnd;
+			uint16_t uid  = image->memshr_id;
+			blkif_request_t *breq = &vreq->req;
+			uint64_t sec  = tapdisk_vbd_breq_get_sector(breq, treq);
+			int secs = breq->seg[treq.sidx].last_sect -
+			    breq->seg[treq.sidx].first_sect + 1;
+
+			if (hnd.handle != 0)
+				memshr_vbd_complete_ro_request(hnd, uid,
+								sec, secs);
+		}
+#endif
 	}
 
 	tapdisk_vbd_complete_vbd_request(vbd, vreq);
@@ -1423,7 +1282,28 @@
 		break;
 
 	case TD_OP_READ:
-		td_queue_read(parent, treq);
+#ifdef MEMSHR
+		if(td_flag_test(parent->flags, TD_OPEN_RDONLY)) {
+			int ret, seg = treq.sidx;
+			blkif_request_t *breq = &vreq->req;
+        
+			ret = memshr_vbd_issue_ro_request(treq.buf,
+			      breq->seg[seg].gref,
+			      parent->memshr_id,
+			      treq.sec,
+			      treq.secs,
+			      &treq.memshr_hnd);
+			if(ret == 0) {
+				/* Reset memshr handle. This'll prevent
+				 * memshr_vbd_complete_ro_request being called
+				 */
+				treq.memshr_hnd.handle = 0;
+				td_complete_request(treq, 0);
+			} else
+				td_queue_read(parent, treq);
+		} else
+#endif
+			td_queue_read(parent, treq);
 		break;
 	}
 
@@ -1444,48 +1324,27 @@
 	vbd   = (td_vbd_t *)image->private;
 	vreq  = (td_vbd_request_t *)treq.private;
 
-	tapdisk_vbd_mark_progress(vbd);
+	gettimeofday(&vbd->ts, NULL);
 
 	if (tapdisk_vbd_queue_ready(vbd))
 		__tapdisk_vbd_reissue_td_request(vbd, image, treq);
 	else
-		__tapdisk_vbd_complete_td_request(vbd, vreq, treq, -EBUSY);
+		__tapdisk_vbd_complete_td_request(vbd, vreq, treq, -EIO);
 }
 
 static void
 tapdisk_vbd_complete_td_request(td_request_t treq, int res)
 {
 	td_vbd_t *vbd;
-	td_image_t *image, *leaf;
+	td_image_t *image;
 	td_vbd_request_t *vreq;
 
 	image = treq.image;
 	vbd   = (td_vbd_t *)image->private;
 	vreq  = (td_vbd_request_t *)treq.private;
 
-	tapdisk_vbd_mark_progress(vbd);
-
-	if (abs(res) == ENOSPC && td_flag_test(image->flags,
-				TD_IGNORE_ENOSPC)) {
-		res = 0;
-		leaf = tapdisk_vbd_first_image(vbd);
-		if (vbd->secondary_mode == TD_VBD_SECONDARY_MIRROR) {
-			DPRINTF("ENOSPC: disabling mirroring\n");
-			list_del_init(&leaf->next);
-			vbd->retired = leaf;
-		} else if (vbd->secondary_mode == TD_VBD_SECONDARY_STANDBY) {
-			DPRINTF("ENOSPC: failing over to secondary image\n");
-			list_add(&vbd->secondary->next, leaf->next.prev);
-			vbd->FIXME_enospc_redirect_count_enabled = 1;
-		}
-		if (vbd->secondary_mode != TD_VBD_SECONDARY_DISABLED) {
-			vbd->secondary = NULL;
-			vbd->secondary_mode = TD_VBD_SECONDARY_DISABLED;
-			signal_enospc(vbd);
-		}
-	}
-
-	DBG(TLOG_DBG, "%s: req %d seg %d sec 0x%08llx "
+	gettimeofday(&vbd->ts, NULL);
+	DBG(TLOG_DBG, "%s: req %d seg %d sec 0x%08"PRIx64" "
 	    "secs 0x%04x buf %p op %d res %d\n", image->name,
 	    (int)treq.id, treq.sidx, treq.sec, treq.secs,
 	    treq.buf, (int)vreq->req.operation, res);
@@ -1493,38 +1352,6 @@
 	__tapdisk_vbd_complete_td_request(vbd, vreq, treq, res);
 }
 
-static inline void
-queue_mirror_req(td_vbd_t *vbd, td_request_t clone)
-{
-	clone.image = vbd->secondary;
-	td_queue_write(vbd->secondary, clone);
-}
-
-static inline void
-tapdisk_vbd_submit_request(td_vbd_t *vbd, blkif_request_t *req,
-		td_request_t treq)
-{
-	switch (req->operation)	{
-	case BLKIF_OP_WRITE:
-		treq.op = TD_OP_WRITE;
-		/* it's important to queue the mirror request before queuing 
-		 * the main one. If the main image runs into ENOSPC, the 
-		 * mirroring could be disabled before td_queue_write returns, 
-		 * so if the mirror request was queued after (which would then 
-		 * not happen), we'd lose that write and cause the process to 
-		 * hang with unacknowledged writes */
-		if (vbd->secondary_mode == TD_VBD_SECONDARY_MIRROR)
-			queue_mirror_req(vbd, treq);
-		td_queue_write(treq.image, treq);
-		break;
-
-	case BLKIF_OP_READ:
-		treq.op = TD_OP_READ;
-		td_queue_read(treq.image, treq);
-		break;
-	}
-}
-
 static int
 tapdisk_vbd_issue_request(td_vbd_t *vbd, td_vbd_request_t *vreq)
 {
@@ -1535,7 +1362,6 @@
 	uint64_t sector_nr;
 	blkif_request_t *req;
 	int i, err, id, nsects;
-	int treq_started = 0;
 
 	req       = &vreq->req;
 	id        = req->id;
@@ -1544,68 +1370,54 @@
 	image     = tapdisk_vbd_first_image(vbd);
 
 	vreq->submitting = 1;
-
-	tapdisk_vbd_mark_progress(vbd);
-	vreq->last_try = vbd->ts;
-
+	gettimeofday(&vbd->ts, NULL);
+	gettimeofday(&vreq->last_try, NULL);
 	tapdisk_vbd_move_request(vreq, &vbd->pending_requests);
 
+#if 0
 	err = tapdisk_vbd_check_queue(vbd);
-	if (err) {
-		vreq->error = err;
+	if (err)
 		goto fail;
-	}
+#endif
 
 	err = tapdisk_image_check_ring_request(image, req);
-	if (err) {
-		vreq->error = err;
+	if (err)
 		goto fail;
-	}
 
-	memset(&treq, 0, sizeof(td_request_t));
 	for (i = 0; i < req->nr_segments; i++) {
 		nsects = req->seg[i].last_sect - req->seg[i].first_sect + 1;
 		page   = (char *)MMAP_VADDR(ring->vstart, 
 					   (unsigned long)req->id, i);
 		page  += (req->seg[i].first_sect << SECTOR_SHIFT);
 
-		if (treq_started) {
-			if (page == treq.buf + (treq.secs << SECTOR_SHIFT)) {
-				treq.secs += nsects;
-			} else {
-				tapdisk_vbd_submit_request(vbd, req, treq);
-				treq_started = 0;
-			}
-		}
-
-		if (!treq_started) {
-			treq.id      = id;
-			treq.sidx    = i;
-			treq.buf     = page;
-			treq.sec     = sector_nr;
-			treq.secs    = nsects;
-			treq.image   = image;
-			treq.cb      = tapdisk_vbd_complete_td_request;
-			treq.cb_data = NULL;
-			treq.private = vreq;
-			treq_started = 1;
-		}
+		treq.id             = id;
+		treq.sidx           = i;
+		treq.blocked        = 0;
+		treq.buf            = page;
+		treq.sec            = sector_nr;
+		treq.secs           = nsects;
+		treq.image          = image;
+		treq.cb             = tapdisk_vbd_complete_td_request;
+		treq.cb_data        = NULL;
+		treq.private        = vreq;
 
-		DBG(TLOG_DBG, "%s: req %d seg %d sec 0x%08llx secs 0x%04x "
+		DBG(TLOG_DBG, "%s: req %d seg %d sec 0x%08"PRIx64" secs 0x%04x "
 		    "buf %p op %d\n", image->name, id, i, treq.sec, treq.secs,
 		    treq.buf, (int)req->operation);
 
 		vreq->secs_pending += nsects;
 		vbd->secs_pending  += nsects;
-		if (vbd->secondary_mode == TD_VBD_SECONDARY_MIRROR &&
-				req->operation == BLKIF_OP_WRITE) {
-			vreq->secs_pending += nsects;
-			vbd->secs_pending  += nsects;
-		}
 
-		if (i == req->nr_segments - 1) {
-			tapdisk_vbd_submit_request(vbd, req, treq);
-			treq_started = 0;
+		switch (req->operation)	{
+		case BLKIF_OP_WRITE:
+			treq.op = TD_OP_WRITE;
+			td_queue_write(image, treq);
+			break;
+
+		case BLKIF_OP_READ:
+			treq.op = TD_OP_READ;
+			td_queue_read(image, treq);
+			break;
 		}
 
 		sector_nr += nsects;
@@ -1628,12 +1440,6 @@
 }
 
 static int
-tapdisk_vbd_request_completed(td_vbd_t *vbd, td_vbd_request_t *vreq)
-{
-	return vreq->list_head == &vbd->completed_requests;
-}
-
-static int
 tapdisk_vbd_reissue_failed_requests(td_vbd_t *vbd)
 {
 	int err;
@@ -1647,17 +1453,31 @@
 		if (vreq->secs_pending)
 			continue;
 
-		if (td_flag_test(vbd->state, TD_VBD_SHUTDOWN_REQUESTED)) {
-			tapdisk_vbd_complete_vbd_request(vbd, vreq);
-			continue;
-		}
+		if (td_flag_test(vbd->state, TD_VBD_SHUTDOWN_REQUESTED))
+			goto fail;
 
 		if (vreq->error != -EBUSY &&
 		    now.tv_sec - vreq->last_try.tv_sec < TD_VBD_RETRY_INTERVAL)
 			continue;
 
-		vbd->retries++;
-		vreq->num_retries++;
+		if (vreq->num_retries >= TD_VBD_MAX_RETRIES) {
+		fail:
+			DBG(TLOG_INFO, "req %"PRIu64"retried %d times\n",
+			    vreq->req.id, vreq->num_retries);
+			tapdisk_vbd_complete_vbd_request(vbd, vreq);
+			continue;
+		}
+
+		/*
+		 * never fail due to too many retries if we are blocked on a 
+		 * dependency
+		 */
+		if (vreq->blocked) {
+			vreq->blocked = 0;
+		} else {
+			vbd->retries++;
+			vreq->num_retries++;
+		}
 		vreq->error  = 0;
 		vreq->status = BLKIF_RSP_OKAY;
 		DBG(TLOG_DBG, "retry #%d of req %"PRIu64", "
@@ -1666,30 +1486,16 @@
 		    vreq->req.nr_segments);
 
 		err = tapdisk_vbd_issue_request(vbd, vreq);
-		/*
-		 * if this request failed, but was not completed,
-		 * we'll back off for a while.
-		 */
-		if (err && !tapdisk_vbd_request_completed(vbd, vreq))
+		if (err)
 			break;
 	}
 
-	return 0;
-}
-
-static void
-tapdisk_vbd_count_new_request(td_vbd_t *vbd, td_vbd_request_t *vreq)
-{
-	blkif_request_t *req = &vreq->req;
-	struct blkif_request_segment *seg;
-	int write;
-
-	write = req->operation == BLKIF_OP_WRITE;
+	if (list_empty(&vbd->failed_requests))
+		td_flag_clear(vbd->state, TD_VBD_RETRY_NEEDED);
+	else
+		td_flag_set(vbd->state, TD_VBD_RETRY_NEEDED);
 
-	for (seg = &req->seg[0]; seg < &req->seg[req->nr_segments]; seg++) {
-		int secs = seg->last_sect - seg->first_sect + 1;
-		td_sector_count_add(&vbd->secs, secs, write);
-	}
+	return err;
 }
 
 static int
@@ -1700,14 +1506,8 @@
 
 	tapdisk_vbd_for_each_request(vreq, tmp, &vbd->new_requests) {
 		err = tapdisk_vbd_issue_request(vbd, vreq);
-		/*
-		 * if this request failed, but was not completed,
-		 * we'll back off for a while.
-		 */
-		if (err && !tapdisk_vbd_request_completed(vbd, vreq))
+		if (err)
 			return err;
-
-		tapdisk_vbd_count_new_request(vbd, vreq);
 	}
 
 	return 0;
@@ -1739,8 +1539,7 @@
 	if (td_flag_test(vbd->state, TD_VBD_DEAD))
 		return tapdisk_vbd_kill_requests(vbd);
 
-	if (td_flag_test(vbd->state, TD_VBD_QUIESCED) ||
-	    td_flag_test(vbd->state, TD_VBD_QUIESCE_REQUESTED))
+	if (!tapdisk_vbd_queue_ready(vbd))
 		return -EAGAIN;
 
 	err = tapdisk_vbd_reissue_failed_requests(vbd);
@@ -1758,14 +1557,11 @@
 	td_ring_t *ring;
 	blkif_request_t *req;
 	td_vbd_request_t *vreq;
-	struct timeval now;
 
 	ring = &vbd->ring;
 	if (!ring->sring)
 		return;
 
-	gettimeofday(&now, NULL);
-
 	rp   = ring->fe_ring.sring->req_prod;
 	xen_rmb();
 
@@ -1782,7 +1578,6 @@
 		memcpy(&vreq->req, req, sizeof(blkif_request_t));
 		vbd->received++;
 		vreq->vbd = vbd;
-		vreq->ts  = now;
 
 		tapdisk_vbd_move_request(vreq, &vbd->new_requests);
 
@@ -1839,9 +1634,8 @@
 		return err;
 	}
 
-	type = tapdisk_disktype_parse_params(message, &path);
-	if (type < 0) {
-		err = type;
+	err = tapdisk_parse_disk_type(message, &path, &type);
+	if (err) {
 		EPRINTF("%s: invalid resume string %s\n", vbd->name, message);
 		goto out;
 	}
@@ -1853,10 +1647,17 @@
 		err = -ENOMEM;
 		goto out;
 	}
-	vbd->type = type;
 
 	tapdisk_vbd_start_queue(vbd);
-	err = __tapdisk_vbd_open_vdi(vbd, TD_OPEN_STRICT);
+
+	for (i = 0; i < TD_VBD_EIO_RETRIES; i++) {
+		err = __tapdisk_vbd_open_vdi(vbd, TD_OPEN_STRICT);
+		if (err != -EIO)
+			break;
+
+		sleep(TD_VBD_EIO_SLEEP);
+	}
+
 out:
 	if (!err) {
 		image_t image;
@@ -1872,6 +1673,7 @@
 		ioctl(vbd->ring.fd, BLKTAP2_IOCTL_SET_PARAMS, &params);
 		td_flag_clear(vbd->state, TD_VBD_PAUSED);
 	}
+
 	ioctl(vbd->ring.fd, BLKTAP2_IOCTL_RESUME, err);
 	return err;
 }
@@ -1907,7 +1709,6 @@
 
 	vbd = (td_vbd_t *)private;
 
-	vbd->kicks_in++;
 	tapdisk_vbd_pull_ring_requests(vbd);
 	tapdisk_vbd_issue_requests(vbd);
 
@@ -1915,28 +1716,8 @@
 	tapdisk_vbd_check_ring_message(vbd);
 }
 
-void
-tapdisk_vbd_stats(td_vbd_t *vbd, td_stats_t *st)
+td_image_t *
+tapdisk_vbd_first_image(td_vbd_t *vbd)
 {
-	td_image_t *image, *next;
-
-	tapdisk_stats_enter(st, '{');
-	tapdisk_stats_field(st, "name", "s", vbd->name);
-	tapdisk_stats_field(st, "minor", "d", vbd->minor);
-
-	tapdisk_stats_field(st, "secs", "[");
-	tapdisk_stats_val(st, "llu", vbd->secs.rd);
-	tapdisk_stats_val(st, "llu", vbd->secs.wr);
-	tapdisk_stats_leave(st, ']');
-
-	tapdisk_stats_field(st, "images", "[");
-	tapdisk_vbd_for_each_image(vbd, image, next)
-		tapdisk_image_stats(image, st);
-	tapdisk_stats_leave(st, ']');
-
-	tapdisk_stats_field(st,
-			    "FIXME_enospc_redirect_count",
-			    "llu", vbd->FIXME_enospc_redirect_count);
-
-	tapdisk_stats_leave(st, '}');
+	return list_entry(vbd->images.next, td_image_t, next);
 }
diff -Nur blktap2_oxt//drivers/tapdisk-vbd.h blktap2_xen//drivers/tapdisk-vbd.h
--- blktap2_oxt//drivers/tapdisk-vbd.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-vbd.h	2015-03-19 11:08:36.000000000 -0400
@@ -24,12 +24,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
+*/
 #ifndef _TAPDISK_VBD_H_
 #define _TAPDISK_VBD_H_
 
@@ -41,7 +36,6 @@
 #include "scheduler.h"
 #include "tapdisk-image.h"
 
-#define TD_VBD_REQUEST_TIMEOUT      120
 #define TD_VBD_MAX_RETRIES          100
 #define TD_VBD_RETRY_INTERVAL       1
 
@@ -53,14 +47,12 @@
 #define TD_VBD_PAUSED               0x0020
 #define TD_VBD_SHUTDOWN_REQUESTED   0x0040
 #define TD_VBD_LOCKING              0x0080
-#define TD_VBD_LOG_DROPPED          0x0100
-
-#define TD_VBD_SECONDARY_DISABLED   0 
-#define TD_VBD_SECONDARY_MIRROR     1
-#define TD_VBD_SECONDARY_STANDBY    2
+#define TD_VBD_RETRY_NEEDED         0x0100
+#define TD_VBD_LOG_DROPPED          0x0200
 
 typedef struct td_ring              td_ring_t;
 typedef struct td_vbd_request       td_vbd_request_t;
+typedef struct td_vbd_driver_info   td_vbd_driver_info_t;
 typedef struct td_vbd_handle        td_vbd_t;
 typedef void (*td_vbd_cb_t)        (void *, blkif_response_t *);
 
@@ -77,15 +69,20 @@
 	int16_t                     status;
 
 	int                         error;
+	int                         blocked; /* blocked on a dependency */
 	int                         submitting;
 	int                         secs_pending;
 	int                         num_retries;
-	struct timeval		    ts;
 	struct timeval              last_try;
 
 	td_vbd_t                   *vbd;
 	struct list_head            next;
-	struct list_head           *list_head;
+};
+
+struct td_vbd_driver_info {
+	char                       *params;
+	int                         type;
+	struct list_head            next;
 };
 
 struct td_vbd_handle {
@@ -93,29 +90,18 @@
 
 	td_uuid_t                   uuid;
 	int                         minor;
-	int                         type;
 
+	struct list_head            driver_stack;
+
+	int                         storage;
+
+	uint8_t                     reopened;
+	uint8_t                     reactivated;
 	td_flag_t                   flags;
 	td_flag_t                   state;
 
 	struct list_head            images;
 
-	int                         parent_devnum;
-	char                       *secondary_name;
-	int                         secondary_type;
-	td_image_t                 *secondary;
-	uint8_t                     secondary_mode;
-
-	int                         FIXME_enospc_redirect_count_enabled;
-	uint64_t                    FIXME_enospc_redirect_count;
-
-	/* when we encounter ENOSPC on the primary leaf image in mirror mode, 
-	 * we need to remove it from the VBD chain so that writes start going 
-	 * on the secondary leaf. However, we cannot free the image at that 
-	 * time since it might still have in-flight treqs referencing it.  
-	 * Therefore, we move it into 'retired' until shutdown. */
-	td_image_t                 *retired;
-
 	struct list_head            new_requests;
 	struct list_head            pending_requests;
 	struct list_head            failed_requests;
@@ -139,10 +125,6 @@
 	uint64_t                    secs_pending;
 	uint64_t                    retries;
 	uint64_t                    errors;
-	td_sector_count_t           secs;
-
-	uint64_t                    kicks_in;
-	uint64_t                    kicks_out;
 };
 
 #define tapdisk_vbd_for_each_request(vreq, tmp, list)	                \
@@ -157,7 +139,6 @@
 	list_del(&vreq->next);
 	INIT_LIST_HEAD(&vreq->next);
 	list_add_tail(&vreq->next, dest);
-	vreq->list_head = dest;
 }
 
 static inline void
@@ -172,11 +153,8 @@
 	return list_is_last(&image->next, &vbd->images);
 }
 
-static inline td_image_t *
-tapdisk_vbd_first_image(td_vbd_t *vbd)
-{
-	return list_entry(vbd->images.next, td_image_t, next);
-}
+td_image_t *
+tapdisk_vbd_first_image(td_vbd_t *vbd);
 
 static inline td_image_t *
 tapdisk_vbd_last_image(td_vbd_t *vbd)
@@ -191,14 +169,18 @@
 }
 
 td_vbd_t *tapdisk_vbd_create(td_uuid_t);
-int tapdisk_vbd_initialize(int, int, td_uuid_t);
+int tapdisk_vbd_initialize(td_uuid_t);
 void tapdisk_vbd_set_callback(td_vbd_t *, td_vbd_cb_t, void *);
-int tapdisk_vbd_open(td_vbd_t *, int, const char *,
-		     int, const char *, td_flag_t);
+int tapdisk_vbd_parse_stack(td_vbd_t *vbd, const char *path);
+int tapdisk_vbd_open(td_vbd_t *, const char *, uint16_t,
+		     uint16_t, int, const char *, td_flag_t);
 int tapdisk_vbd_close(td_vbd_t *);
+void tapdisk_vbd_free(td_vbd_t *);
+void tapdisk_vbd_free_stack(td_vbd_t *);
 
-int tapdisk_vbd_open_vdi(td_vbd_t *, int, const char *, td_flag_t,
-			 int, int, const char *);
+int tapdisk_vbd_open_stack(td_vbd_t *, uint16_t, td_flag_t);
+int tapdisk_vbd_open_vdi(td_vbd_t *, const char *,
+			 uint16_t, uint16_t, td_flag_t);
 void tapdisk_vbd_close_vdi(td_vbd_t *);
 
 int tapdisk_vbd_attach(td_vbd_t *, const char *, int);
@@ -207,17 +189,19 @@
 void tapdisk_vbd_forward_request(td_request_t);
 
 int tapdisk_vbd_get_image_info(td_vbd_t *, image_t *);
+int tapdisk_vbd_queue_ready(td_vbd_t *);
 int tapdisk_vbd_retry_needed(td_vbd_t *);
 int tapdisk_vbd_quiesce_queue(td_vbd_t *);
 int tapdisk_vbd_start_queue(td_vbd_t *);
 int tapdisk_vbd_issue_requests(td_vbd_t *);
 int tapdisk_vbd_kill_queue(td_vbd_t *);
 int tapdisk_vbd_pause(td_vbd_t *);
-int tapdisk_vbd_resume(td_vbd_t *, int, const char *);
+int tapdisk_vbd_resume(td_vbd_t *, const char *, uint16_t);
 int tapdisk_vbd_kick(td_vbd_t *);
 void tapdisk_vbd_check_state(td_vbd_t *);
 void tapdisk_vbd_check_progress(td_vbd_t *);
 void tapdisk_vbd_debug(td_vbd_t *);
-void tapdisk_vbd_stats(td_vbd_t *, td_stats_t *);
+
+void tapdisk_vbd_complete_vbd_request(td_vbd_t *, td_vbd_request_t *);
 
 #endif
diff -Nur blktap2_oxt//include/blktap2.h blktap2_xen//include/blktap2.h
--- blktap2_oxt//include/blktap2.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/blktap2.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,16 +25,9 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #ifndef _BLKTAP_2_H_
 #define _BLKTAP_2_H_
 
-#define MISC_MAJOR_NUMBER              10
-
 #define BLKTAP2_MAX_MESSAGE_LEN        256
 
 #define BLKTAP2_RING_MESSAGE_PAUSE     1
@@ -49,7 +42,6 @@
 #define BLKTAP2_IOCTL_PAUSE            204
 #define BLKTAP2_IOCTL_REOPEN           205
 #define BLKTAP2_IOCTL_RESUME           206
-#define BLKTAP2_IOCTL_REMOVE_DEVICE    207
 
 #define BLKTAP2_SYSFS_DIR              "/sys/class/blktap2"
 #define BLKTAP2_CONTROL_NAME           "blktap-control"
@@ -59,7 +51,6 @@
 #define BLKTAP2_CONTROL_DEVICE         BLKTAP2_DIRECTORY"/control"
 #define BLKTAP2_RING_DEVICE            BLKTAP2_DIRECTORY"/blktap"
 #define BLKTAP2_IO_DEVICE              BLKTAP2_DIRECTORY"/tapdev"
-#define BLKTAP2_ENOSPC_SIGNAL_FILE     "/var/run/tapdisk-enospc"
 
 struct blktap2_handle {
 	unsigned int                   ring;
diff -Nur blktap2_oxt//include/blktaplib.h blktap2_xen//include/blktaplib.h
--- blktap2_oxt//include/blktaplib.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/blktaplib.h	2015-03-19 11:08:36.000000000 -0400
@@ -29,11 +29,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
 #ifndef __BLKTAPLIB_H__
 #define __BLKTAPLIB_H__
 
@@ -42,18 +37,7 @@
 #include <xenctrl.h>
 #include <xen/io/blkif.h>
 
-#ifdef TAPDISK
-#if 1
-#define DPRINTF(_f, _a...) syslog(LOG_INFO, _f, ##_a)
-#else
-#define DPRINTF(_f, _a...) ((void)0)
-#endif
-
-#define EPRINTF(_f, _a...) syslog(LOG_ERR, "tap-err:%s: " _f, __func__, ##_a)
-#define PERROR(_f, _a...)  EPRINTF(_f ": %s", ##_a, strerror(errno))
-#endif
-
-#define BLK_RING_SIZE __RING_SIZE((blkif_sring_t *)0, XC_PAGE_SIZE)
+#define BLK_RING_SIZE __CONST_RING_SIZE(blkif, XC_PAGE_SIZE)
 
 /* size of the extra VMA area to map in attached pages. */
 #define BLKTAP_VMA_PAGES BLK_RING_SIZE
@@ -228,8 +212,13 @@
 #define CTLMSG_RESUME          17
 #define CTLMSG_RESUME_RSP      18
 
+#define TAPDISK_STORAGE_TYPE_NFS       1
+#define TAPDISK_STORAGE_TYPE_EXT       2
+#define TAPDISK_STORAGE_TYPE_LVM       3
+#define TAPDISK_STORAGE_TYPE_DEFAULT   TAPDISK_STORAGE_TYPE_EXT
+
 /* Abitrary values, must match the underlying driver... */
-#define MAX_TAP_DEV 1024
+#define MAX_TAP_DEV 256
 
 /* Accessing attached data page mappings */
 #define MMAP_PAGES                                                    \
diff -Nur blktap2_oxt//include/libvhd.h blktap2_xen//include/libvhd.h
--- blktap2_oxt//include/libvhd.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/libvhd.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,27 +23,42 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #ifndef _VHD_LIB_H_
 #define _VHD_LIB_H_
 
-#include <stdio.h>
 #include <string.h>
+#if defined(__linux__)
 #include <endian.h>
 #include <byteswap.h>
-#include <uuid/uuid.h>
+#elif defined(__NetBSD__)
+#include <sys/endian.h>
+#include <sys/bswap.h>
+#endif
 
+#include "vhd-uuid.h"
 #include "vhd.h"
-#include "list.h"
+
+#ifndef O_LARGEFILE
+#define O_LARGEFILE	0
+#endif
 
 #if BYTE_ORDER == LITTLE_ENDIAN
+#if defined(__linux__)
   #define BE16_IN(foo)             (*(foo)) = bswap_16(*(foo))
   #define BE32_IN(foo)             (*(foo)) = bswap_32(*(foo))
   #define BE64_IN(foo)             (*(foo)) = bswap_64(*(foo))
   #define BE16_OUT(foo)            (*(foo)) = bswap_16(*(foo))
   #define BE32_OUT(foo)            (*(foo)) = bswap_32(*(foo))
   #define BE64_OUT(foo)            (*(foo)) = bswap_64(*(foo))
+#elif defined(__NetBSD__)
+  #define BE16_IN(foo)             (*(foo)) = bswap16(*(foo))
+  #define BE32_IN(foo)             (*(foo)) = bswap32(*(foo))
+  #define BE64_IN(foo)             (*(foo)) = bswap64(*(foo))
+  #define BE16_OUT(foo)            (*(foo)) = bswap16(*(foo))
+  #define BE32_OUT(foo)            (*(foo)) = bswap32(*(foo))
+  #define BE64_OUT(foo)            (*(foo)) = bswap64(*(foo))
+#endif
 #else
   #define BE16_IN(foo)
   #define BE32_IN(foo)
@@ -56,8 +68,6 @@
   #define BE64_OUT(foo)
 #endif
 
-#define BIT_MASK                   0x80
-
 #define MIN(a, b)                  (((a) < (b)) ? (a) : (b))
 #define MAX(a, b)                  (((a) > (b)) ? (a) : (b))
 
@@ -75,12 +85,8 @@
 #define VHD_OPEN_FAST              0x00004
 #define VHD_OPEN_STRICT            0x00008
 #define VHD_OPEN_IGNORE_DISABLED   0x00010
-#define VHD_OPEN_CACHED            0x00020
-#define VHD_OPEN_IO_WRITE_SPARSE   0x00040
-#define VHD_OPEN_LOCKED            0x00080
 
-#define VHD_FLAG_CREAT_FILE_SIZE_FIXED   0x00001
-#define VHD_FLAG_CREAT_PARENT_RAW        0x00002
+#define VHD_FLAG_CREAT_PARENT_RAW        0x00001
 
 #define vhd_flag_set(word, flag)         ((word) |= (flag))
 #define vhd_flag_clear(word, flag)       ((word) &= ~(flag))
@@ -118,20 +124,9 @@
 typedef struct vhd_batmap          vhd_batmap_t;
 typedef struct dd_batmap_hdr       vhd_batmap_header_t;
 typedef struct prt_loc             vhd_parent_locator_t;
-typedef struct vhd_devops          vhd_devops_t;
 typedef struct vhd_context         vhd_context_t;
 typedef uint32_t                   vhd_flag_creat_t;
 
-struct vhd_devops {
-	off64_t (*position)        (vhd_context_t *);
-	int (*seek)                (vhd_context_t *, off64_t, int);
-	int (*read)                (vhd_context_t *, void *, size_t);
-	int (*write)               (vhd_context_t *, void *, size_t);
-	int (*pread)               (vhd_context_t *, void *, size_t, off64_t);
-	int (*pwrite)              (vhd_context_t *, void *, size_t, off64_t);
-	void (*close)              (vhd_context_t *);
-};
-
 struct vhd_bat {
 	uint32_t                   spb;
 	uint32_t                   entries;
@@ -143,8 +138,6 @@
 	char                      *map;
 };
 
-struct crypto_blkcipher;
-
 struct vhd_context {
 	int                        fd;
 	char                      *file;
@@ -158,34 +151,8 @@
 	vhd_footer_t               footer;
 	vhd_bat_t                  bat;
 	vhd_batmap_t               batmap;
-
-	struct list_head           next;
-
-	vhd_devops_t              *devops;
-
-	struct crypto_blkcipher   *xts_tfm;
-
-	uint64_t		  offset;
 };
 
-static inline int
-test_bit (volatile char *addr, int nr)
-{
-	return ((addr[nr >> 3] << (nr & 7)) & BIT_MASK) != 0;
-}
-
-static inline void
-set_bit (volatile char *addr, int nr)
-{
-	addr[nr >> 3] |= (BIT_MASK >> (nr & 7));
-}
-
-static inline void
-clear_bit (volatile char *addr, int nr)
-{
-	addr[nr >> 3] &= ~(BIT_MASK >> (nr & 7));
-}
-
 static inline uint32_t
 secs_round_up(uint64_t bytes)
 {
@@ -249,27 +216,7 @@
 static inline int
 vhd_parent_raw(vhd_context_t *ctx)
 {
-	return uuid_is_null(ctx->header.prt_uuid);
-}
-
-/*
- * returns current capacity in bytes
- */
-static inline uint64_t
-vhd_cur_capacity(vhd_context_t *ctx)
-{
-	return ctx->footer.curr_size;
-}
-
-/*
- * returns maximum capacity this vhd can quickly be resized to in bytes
- */
-static inline uint64_t
-vhd_max_capacity(vhd_context_t *ctx)
-{
-	if (!vhd_type_dynamic(ctx))
-		return 0;
-	return (uint64_t)ctx->header.max_bat_size * ctx->header.block_size;
+	return vhd_uuid_is_nil(&ctx->header.prt_uuid);
 }
 
 void libvhd_set_log_level(int);
@@ -282,7 +229,7 @@
 
 uint32_t vhd_checksum_footer(vhd_footer_t *);
 uint32_t vhd_checksum_header(vhd_header_t *);
-uint32_t vhd_checksum_batmap(vhd_context_t *, vhd_batmap_t *);
+uint32_t vhd_checksum_batmap(vhd_batmap_t *);
 
 void vhd_footer_in(vhd_footer_t *);
 void vhd_footer_out(vhd_footer_t *);
@@ -296,40 +243,30 @@
 int vhd_validate_footer(vhd_footer_t *footer);
 int vhd_validate_header(vhd_header_t *header);
 int vhd_validate_batmap_header(vhd_batmap_t *batmap);
-int vhd_validate_batmap(vhd_context_t *, vhd_batmap_t *batmap);
+int vhd_validate_batmap(vhd_batmap_t *batmap);
 int vhd_validate_platform_code(uint32_t code);
 
 int vhd_open(vhd_context_t *, const char *file, int flags);
 void vhd_close(vhd_context_t *);
-/* vhd_create: mbytes is the virtual size for BAT/batmap preallocation - see 
- * vhd-util-resize.c
- */
-int vhd_create(const char *name, uint64_t bytes, int type, uint64_t mbytes,
-		vhd_flag_creat_t);
+int vhd_create(const char *name, uint64_t bytes, int type, vhd_flag_creat_t);
 /* vhd_snapshot: the bytes parameter is optional and can be 0 if the snapshot 
  * is to have the same size as the (first non-empty) parent */
 int vhd_snapshot(const char *snapshot, uint64_t bytes, const char *parent,
-		uint64_t mbytes, vhd_flag_creat_t);
+		vhd_flag_creat_t);
 
 int vhd_hidden(vhd_context_t *, int *);
 int vhd_chain_depth(vhd_context_t *, int *);
-int vhd_marker(vhd_context_t *, char *);   
-int vhd_set_marker(vhd_context_t *, char); 
-int vhd_get_keyhash(vhd_context_t *, struct vhd_keyhash *);
-int vhd_set_keyhash(vhd_context_t *, const struct vhd_keyhash *);
 
-off64_t vhd_position(vhd_context_t *);
-int vhd_seek(vhd_context_t *, off64_t, int);
+off_t vhd_position(vhd_context_t *);
+int vhd_seek(vhd_context_t *, off_t, int);
 int vhd_read(vhd_context_t *, void *, size_t);
 int vhd_write(vhd_context_t *, void *, size_t);
-int vhd_pread(vhd_context_t *, void *, size_t, off64_t);
-int vhd_pwrite(vhd_context_t *, void *, size_t, off64_t);
 
 int vhd_offset(vhd_context_t *, uint32_t, uint32_t *);
 
-int vhd_end_of_headers(vhd_context_t *ctx, off64_t *off);
-int vhd_end_of_data(vhd_context_t *ctx, off64_t *off);
-int vhd_batmap_header_offset(vhd_context_t *ctx, off64_t *off);
+int vhd_end_of_headers(vhd_context_t *ctx, off_t *off);
+int vhd_end_of_data(vhd_context_t *ctx, off_t *off);
+int vhd_batmap_header_offset(vhd_context_t *ctx, off_t *off);
 
 int vhd_get_header(vhd_context_t *);
 int vhd_get_footer(vhd_context_t *);
@@ -345,48 +282,39 @@
 int vhd_batmap_test(vhd_context_t *, vhd_batmap_t *, uint32_t);
 void vhd_batmap_set(vhd_context_t *, vhd_batmap_t *, uint32_t);
 void vhd_batmap_clear(vhd_context_t *, vhd_batmap_t *, uint32_t);
-void vhd_batmap_reset_map(vhd_context_t *, vhd_batmap_t *);
 
-int vhd_file_size_fixed(vhd_context_t *);
-int vhd_get_phys_size(vhd_context_t *, off64_t *);
-int vhd_set_phys_size(vhd_context_t *, off64_t);
-int vhd_set_virt_size(vhd_context_t *, uint64_t);
+int vhd_get_phys_size(vhd_context_t *, off_t *);
+int vhd_set_phys_size(vhd_context_t *, off_t);
 
 int vhd_bitmap_test(vhd_context_t *, char *, uint32_t);
 void vhd_bitmap_set(vhd_context_t *, char *, uint32_t);
 void vhd_bitmap_clear(vhd_context_t *, char *, uint32_t);
 
-int vhd_initialize_header_parent_name(vhd_context_t *, const char *);
-int vhd_write_parent_locators(vhd_context_t *, const char *);
 int vhd_parent_locator_count(vhd_context_t *);
 int vhd_parent_locator_get(vhd_context_t *, char **);
 int vhd_parent_locator_read(vhd_context_t *, vhd_parent_locator_t *, char **);
 int vhd_find_parent(vhd_context_t *, const char *, char **);
 int vhd_parent_locator_write_at(vhd_context_t *, const char *,
-				off64_t, uint32_t, size_t,
+				off_t, uint32_t, size_t,
 				vhd_parent_locator_t *);
 
 int vhd_header_decode_parent(vhd_context_t *, vhd_header_t *, char **);
 int vhd_change_parent(vhd_context_t *, char *parent_path, int raw);
-int vhd_macx_encode_location(char *name, char **out, int *outlen);
-int vhd_w2u_encode_location(char *name, char **out, int *outlen);
 
 int vhd_read_footer(vhd_context_t *, vhd_footer_t *);
-int vhd_read_footer_at(vhd_context_t *, vhd_footer_t *, off64_t);
+int vhd_read_footer_at(vhd_context_t *, vhd_footer_t *, off_t);
 int vhd_read_footer_strict(vhd_context_t *, vhd_footer_t *);
 int vhd_read_header(vhd_context_t *, vhd_header_t *);
-int vhd_read_header_at(vhd_context_t *, vhd_header_t *, off64_t);
+int vhd_read_header_at(vhd_context_t *, vhd_header_t *, off_t);
 int vhd_read_bat(vhd_context_t *, vhd_bat_t *);
 int vhd_read_batmap(vhd_context_t *, vhd_batmap_t *);
-int vhd_read_batmap_header(vhd_context_t *, vhd_batmap_t *);
-int vhd_read_batmap_map(vhd_context_t *, vhd_batmap_t *);
 int vhd_read_bitmap(vhd_context_t *, uint32_t block, char **bufp);
 int vhd_read_block(vhd_context_t *, uint32_t block, char **bufp);
 
 int vhd_write_footer(vhd_context_t *, vhd_footer_t *);
-int vhd_write_footer_at(vhd_context_t *, vhd_footer_t *, off64_t);
+int vhd_write_footer_at(vhd_context_t *, vhd_footer_t *, off_t);
 int vhd_write_header(vhd_context_t *, vhd_header_t *);
-int vhd_write_header_at(vhd_context_t *, vhd_header_t *, off64_t);
+int vhd_write_header_at(vhd_context_t *, vhd_header_t *, off_t);
 int vhd_write_bat(vhd_context_t *, vhd_bat_t *);
 int vhd_write_batmap(vhd_context_t *, vhd_batmap_t *);
 int vhd_write_bitmap(vhd_context_t *, uint32_t block, char *bitmap);
@@ -394,16 +322,5 @@
 
 int vhd_io_read(vhd_context_t *, char *, uint64_t, uint32_t);
 int vhd_io_write(vhd_context_t *, char *, uint64_t, uint32_t);
-int vhd_io_read_bytes(vhd_context_t *, char *, size_t, uint64_t);
-int vhd_io_write_bytes(vhd_context_t *, char *, size_t, uint64_t);
-
-int vhd_print_headers(vhd_context_t *, int hex);
-
-vhd_context_t *vhd_stream_initialize(FILE *, vhd_context_t *);
-vhd_context_t *vhd_stream_load(FILE *);
-char *vhd_realpath(const char *path, char *resolved_path);
-
-struct ICBINN_struct * vhd_icbinn_key (void);
-struct ICBINN_struct * vhd_icbinn_vhd (void);
 
 #endif
diff -Nur blktap2_oxt//include/libvhd-journal.h blktap2_xen//include/libvhd-journal.h
--- blktap2_oxt//include/libvhd-journal.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/libvhd-journal.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,6 +1,5 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
+/* Copyright (c) 2008, XenSource Inc.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -24,7 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
+*/
 #ifndef _VHD_JOURNAL_H_
 #define _VHD_JOURNAL_H_
 
@@ -36,11 +35,11 @@
 #define VHD_JOURNAL_DATA           0x02
 
 #define VHD_JOURNAL_HEADER_COOKIE  "vjournal"
-#define VHD_JOURNAL_ENTRY_COOKIE   0xaaaa12344321aaaaULL
+#define VHD_JOURNAL_ENTRY_COOKIE   0xaaaa12344321aaaa
 
 typedef struct vhd_journal_header {
 	char                       cookie[8];
-	uuid_t                     uuid;
+	vhd_uuid_t                 uuid;
 	uint64_t                   vhd_footer_offset;
 	uint32_t                   journal_data_entries;
 	uint32_t                   journal_metadata_entries;
diff -Nur blktap2_oxt//include/list.h blktap2_xen//include/list.h
--- blktap2_oxt//include/list.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/list.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,11 +1,8 @@
 /*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-/*
  * list.h
  * 
  * This is a subset of linux's list.h intended to be used in user-space.
+ * XXX The namespace conflicts with NetBSD's <sys/queue.h>
  * 
  */
 
@@ -19,6 +16,16 @@
         struct list_head *next, *prev;
 };
  
+/* XXX workaround for conflicts. The list API should use its own
+ * namespace prefix, i.e. BLK_
+ */
+#ifdef LIST_HEAD_INIT
+#undef LIST_HEAD_INIT
+#endif
+#ifndef LIST_HEAD
+#undef LIST_HEAD
+#endif
+
 #define LIST_HEAD_INIT(name) { &(name), &(name) }
  
 #define LIST_HEAD(name) \
@@ -59,8 +66,8 @@
 static inline void list_del(struct list_head *entry)
 {
         __list_del(entry->prev, entry->next);
-        entry->next = (struct list_head *)LIST_POISON1;
-        entry->prev = (struct list_head *)LIST_POISON2;
+        entry->next = LIST_POISON1;
+        entry->prev = LIST_POISON2;
 }
 
 static inline void list_del_init(struct list_head *entry)
@@ -69,19 +76,6 @@
 	INIT_LIST_HEAD(entry);
 }
 
-static inline void list_move(struct list_head *list, struct list_head *head)
-{
-	__list_del(list->prev, list->next);
-	list_add(list, head);
-}
-
-static inline void list_move_tail(struct list_head *list,
-				  struct list_head *head)
-{
-	__list_del(list->prev, list->next);
-	list_add_tail(list, head);
-}
-
 static inline int list_empty(const struct list_head *head)
 {
 	return head->next == head;
@@ -114,13 +108,6 @@
 		__list_splice(list, head, head->next);
 }
 
-static inline void list_splice_tail(struct list_head *list,
-				    struct list_head *head)
-{
-	if (!list_empty(list))
-		__list_splice(list, head->prev, head);
-}
-
 #define list_entry(ptr, type, member)                                   \
         ((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
 
diff -Nur blktap2_oxt//include/Makefile blktap2_xen//include/Makefile
--- blktap2_oxt//include/Makefile	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/Makefile	2015-03-19 11:08:36.000000000 -0400
@@ -1,25 +1,13 @@
-#
-# Copyright (c) 2013 Citrix Systems, Inc.
-#
-
-BLKTAP_ROOT := ..
-include $(BLKTAP_ROOT)/Rules.mk
-
-LIBVHDDIR      := vhd
-LIBVHD_HEADERS := vhd.h libvhd.h libvhd-index.h libvhd-journal.h list.h vhd-util.h
-
-BLKTAPDIR      := blktap
-BLKTAP_HEADERS := blktap2.h blktaplib.h tapdisk-message.h
+XEN_ROOT := $(CURDIR)/../../..
+include $(XEN_ROOT)/tools/Rules.mk
 
 .PHONY: all
 all:
 
 .PHONY: install
 install:
-	$(INSTALL_DIR) -p $(DESTDIR)/usr/include/$(BLKTAPDIR)
-	$(INSTALL_DATA) $(BLKTAP_HEADERS) $(DESTDIR)/usr/include/$(BLKTAPDIR)
-	$(INSTALL_DIR) -p $(DESTDIR)/usr/include/$(LIBVHDDIR)
-	$(INSTALL_DATA) $(LIBVHD_HEADERS) $(DESTDIR)/usr/include/$(LIBVHDDIR)
+	$(INSTALL_DIR) -p $(DESTDIR)$(INCLUDEDIR)
+
 
 .PHONY: clean
 clean:
diff -Nur blktap2_oxt//include/tapdisk-message.h blktap2_xen//include/tapdisk-message.h
--- blktap2_oxt//include/tapdisk-message.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/tapdisk-message.h	2015-03-19 11:08:36.000000000 -0400
@@ -23,12 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
+*/
 #ifndef _TAPDISK_MESSAGE_H_
 #define _TAPDISK_MESSAGE_H_
 
@@ -41,34 +36,29 @@
 #define TAPDISK_MESSAGE_MAX_MINORS \
 	((TAPDISK_MESSAGE_MAX_PATH_LENGTH / sizeof(int)) - 1)
 
-#define TAPDISK_MESSAGE_FLAG_SHARED      0x001
-#define TAPDISK_MESSAGE_FLAG_RDONLY      0x002
-#define TAPDISK_MESSAGE_FLAG_ADD_CACHE   0x004
-#define TAPDISK_MESSAGE_FLAG_VHD_INDEX   0x008
-#define TAPDISK_MESSAGE_FLAG_LOG_DIRTY   0x010
-#define TAPDISK_MESSAGE_FLAG_ADD_LCACHE  0x020
-#define TAPDISK_MESSAGE_FLAG_REUSE_PRT   0x040
-#define TAPDISK_MESSAGE_FLAG_SECONDARY   0x080
-#define TAPDISK_MESSAGE_FLAG_STANDBY     0x100
+#define TAPDISK_MESSAGE_FLAG_SHARED      0x01
+#define TAPDISK_MESSAGE_FLAG_RDONLY      0x02
+#define TAPDISK_MESSAGE_FLAG_ADD_CACHE   0x04
+#define TAPDISK_MESSAGE_FLAG_VHD_INDEX   0x08
+#define TAPDISK_MESSAGE_FLAG_LOG_DIRTY   0x10
 
 typedef struct tapdisk_message           tapdisk_message_t;
-typedef uint32_t                         tapdisk_message_flag_t;
+typedef uint8_t                          tapdisk_message_flag_t;
 typedef struct tapdisk_message_image     tapdisk_message_image_t;
 typedef struct tapdisk_message_params    tapdisk_message_params_t;
 typedef struct tapdisk_message_string    tapdisk_message_string_t;
 typedef struct tapdisk_message_response  tapdisk_message_response_t;
 typedef struct tapdisk_message_minors    tapdisk_message_minors_t;
 typedef struct tapdisk_message_list      tapdisk_message_list_t;
-typedef struct tapdisk_message_stat      tapdisk_message_stat_t;
 
 struct tapdisk_message_params {
 	tapdisk_message_flag_t           flags;
 
+	uint8_t                          storage;
 	uint32_t                         devnum;
 	uint32_t                         domid;
+	uint16_t                         path_len;
 	char                             path[TAPDISK_MESSAGE_MAX_PATH_LENGTH];
-	uint32_t                         prt_devnum;
-	char                             secondary[TAPDISK_MESSAGE_MAX_PATH_LENGTH];
 };
 
 struct tapdisk_message_image {
@@ -98,13 +88,6 @@
 	char                             path[TAPDISK_MESSAGE_MAX_PATH_LENGTH];
 };
 
-struct tapdisk_message_stat {
-	uint16_t                         type;
-	uint16_t                         cookie;
-	size_t                           length;
-};
-
-
 struct tapdisk_message {
 	uint16_t                         type;
 	uint16_t                         cookie;
@@ -117,7 +100,6 @@
 		tapdisk_message_minors_t minors;
 		tapdisk_message_response_t response;
 		tapdisk_message_list_t   list;
-		tapdisk_message_stat_t   info;
 	} u;
 };
 
@@ -142,14 +124,10 @@
 	TAPDISK_MESSAGE_LIST_MINORS_RSP,
 	TAPDISK_MESSAGE_LIST,
 	TAPDISK_MESSAGE_LIST_RSP,
-	TAPDISK_MESSAGE_STATS,
-	TAPDISK_MESSAGE_STATS_RSP,
 	TAPDISK_MESSAGE_FORCE_SHUTDOWN,
 	TAPDISK_MESSAGE_EXIT,
 };
 
-#define TAPDISK_MESSAGE_MAX TAPDISK_MESSAGE_EXIT
-
 static inline char *
 tapdisk_message_name(enum tapdisk_message_id id)
 {
@@ -214,12 +192,6 @@
 	case TAPDISK_MESSAGE_LIST_RSP:
 		return "list response";
 
-	case TAPDISK_MESSAGE_STATS:
-		return "stats";
-
-	case TAPDISK_MESSAGE_STATS_RSP:
-		return "stats response";
-
 	case TAPDISK_MESSAGE_EXIT:
 		return "exit";
 
diff -Nur blktap2_oxt//include/vhd.h blktap2_xen//include/vhd.h
--- blktap2_oxt//include/vhd.h	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//include/vhd.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,6 +1,5 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
+/* Copyright (c) 2008, XenSource Inc.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -24,17 +23,14 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #ifndef __VHD_H__
 #define __VHD_H__
 
-#include <asm/types.h>
-#include <uuid/uuid.h>
 #include <inttypes.h>
 
-typedef __u32 u32;
-typedef __u64 u64;
+typedef uint32_t u32;
+typedef uint64_t u64;
 
 #define DEBUG 1
 
@@ -63,7 +59,7 @@
   u32    geometry;        /* Disk geometry                                */
   u32    type;            /* Disk type                                    */
   u32    checksum;        /* 1's comp sum of this struct.                 */
-  uuid_t uuid;            /* Unique disk ID, used for naming parents      */
+  vhd_uuid_t uuid;        /* Unique disk ID, used for naming parents      */
   char   saved;           /* one-bit -- is this disk/VM in a saved state? */
   char   hidden;          /* tapdisk-specific field: is this vdi hidden?  */
   char   reserved[426];   /* padding                                      */
@@ -110,7 +106,15 @@
 #define HD_TYPE_DIFF       4  /* differencing disk */
 
 /* String table for hd.type */
-extern const char *HD_TYPE_STR[7];
+static const char *HD_TYPE_STR[7] = {
+        "None",                    /* 0 */
+        "Reserved (deprecated)",   /* 1 */
+        "Fixed hard disk",         /* 2 */
+        "Dynamic hard disk",       /* 3 */
+        "Differencing hard disk",  /* 4 */
+        "Reserved (deprecated)",   /* 5 */
+        "Reserved (deprecated)"    /* 6 */
+};
 
 #define HD_TYPE_MAX 6
 
@@ -143,7 +147,7 @@
   u32    max_bat_size;    /* Maximum number of entries in the BAT         */
   u32    block_size;      /* Block size in bytes. Must be power of 2.     */
   u32    checksum;        /* Header checksum.  1's comp of all fields.    */
-  uuid_t prt_uuid;        /* ID of the parent disk.                       */
+  vhd_uuid_t prt_uuid;    /* ID of the parent disk.                       */
   u32    prt_ts;          /* Modification time of the parent disk         */
   u32    res1;            /* Reserved.                                    */
   char   prt_name[512];   /* Parent unicode name.                         */
@@ -162,21 +166,12 @@
 
 #define DD_BLK_UNUSED 0xFFFFFFFF
 
-struct vhd_keyhash {
-  uint8_t cookie;         /* 1 if keyhash is set, 0 otherwise            */
-  uint8_t nonce[32];      /* arbitrary 256 bit nonce                     */
-  uint8_t hash[32];       /* SHA256 sum of nonce appended by keyhash     */
-};
-
 struct dd_batmap_hdr {
   char   cookie[8];       /* should contain "tdbatmap"                    */
   u64    batmap_offset;   /* byte offset to batmap                        */
   u32    batmap_size;     /* batmap size in sectors                       */
   u32    batmap_version;  /* version of batmap                            */
   u32    checksum;        /* batmap checksum -- 1's complement of batmap  */
-  char   marker;          /* generic marker field                         */
-  struct vhd_keyhash keyhash;  /* nonce & SHA256 hash of encryption key   */
-  char   res[418];        /* reserved                                     */
 };
 
 static const char VHD_BATMAP_COOKIE[9] = "tdbatmap";
diff -Nur blktap2_oxt//include/vhd-util.h blktap2_xen//include/vhd-util.h
--- blktap2_oxt//include/vhd-util.h	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//include/vhd-util.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,13 +23,10 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #ifndef _VHD_UTIL_H_
 #define _VHD_UTIL_H_
 
-#include "vhd.h"
-
 int vhd_util_create(int argc, char **argv);
 int vhd_util_snapshot(int argc, char **argv);
 int vhd_util_query(int argc, char **argv);
@@ -46,17 +40,5 @@
 int vhd_util_scan(int argc, char **argv);
 int vhd_util_check(int argc, char **argv);
 int vhd_util_revert(int argc, char **argv);
-int vhd_util_stream_coalesce(int argc, char **argv);
-int vhd_util_clone_metadata(int argc, char **argv);
-int vhd_util_dm_encrypt(int argc, char **argv);
-int vhd_util_dm_decrypt(int argc, char **argv);
-int vhd_util_key(int argc, char **argv);
-
-int __vhd_util_clone_metadata(vhd_context_t *, const char *, int);
-int __vhd_util_clone_metadata_s(vhd_context_t *, const char *,
-				uint64_t, uint64_t, int);
-
-int __vhd_util_calculate_keyhash(struct vhd_keyhash *,
-				 const uint8_t *, size_t);
 
 #endif
diff -Nur blktap2_oxt//lvm/lvm-util.c blktap2_xen//lvm/lvm-util.c
--- blktap2_oxt//lvm/lvm-util.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//lvm/lvm-util.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,24 +25,13 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
-#include <syslog.h>
 
 #include "lvm-util.h"
 
-#define EPRINTF(_f, _a...)					\
-	do {							\
-		syslog(LOG_INFO, "%s: " _f, __func__, ##_a);	\
-	} while (0)
-
 #define _NAME "%255s"
 static char line[1024];
 
@@ -135,16 +124,12 @@
 			break;
 
 		err = -EINVAL;
-		if (sscanf(line, _NAME" %llu %d %d "_NAME" %llu", vg->name, 
-			   &size, &lvs, &pvs, pvname, &pv_start) != 6) {
-			EPRINTF("sscanf failed on '%s'\n", line);
+                if (sscanf(line, _NAME" %"SCNu64" %d %d "_NAME" %"SCNu64,
+			   vg->name, &size, &lvs, &pvs, pvname, &pv_start) != 6)
 			goto out;
-		}
 
-		if (strcmp(vg->name, vgname)) {
-			EPRINTF("VG name '%s' != '%s'\n", vg->name, vgname);
+		if (strcmp(vg->name, vgname))
 			goto out;
-		}
 
 		err = lvm_parse_pv(vg, pvname, pvs, pv_start);
 		if (err)
@@ -155,16 +140,12 @@
 	}
 
 	err = -EINVAL;
-	if (strcmp(vg->name, vgname)) {
-		EPRINTF("VG name '%s' != '%s'\n", vg->name, vgname);
+	if (strcmp(vg->name, vgname))
 		goto out;
-	}
 
 	for (i = 0; i < pvs; i++)
-		if (!vg->pvs[i].name[0]) {
-			EPRINTF("pvs %d name empty\n", i);
+		if (!vg->pvs[i].name[0])
 			goto out;
-		}
 
 	err = -ENOMEM;
 	vg->lvs = calloc(lvs, sizeof(struct lv));
@@ -195,10 +176,8 @@
 		if (strchr(",()", devices[i]))
 			devices[i] = ' ';
 
-	if (sscanf(devices, _NAME" %llu", seg->device, &start) != 2) {
-		EPRINTF("sscanf failed on '%s'\n", devices);
+        if (sscanf(devices, _NAME" %"SCNu64, seg->device, &start) != 2)
 		return -EINVAL;
-	}
 
 	pe_start = -1;
 	for (i = 0; i < vg->pv_cnt; i++)
@@ -207,10 +186,8 @@
 			break;
 		}
 
-	if (pe_start == -1) {
-		EPRINTF("invalid pe_start value\n");
+	if (pe_start == -1)
 		return -EINVAL;
-	}
 
 	seg->pe_start = (start * vg->extent_size) + pe_start;
 	return 0;
@@ -240,8 +217,8 @@
 		int segs;
 		struct lv *lv;
 		struct lv_segment seg;
-		unsigned long long size, seg_start;
-		char type[32], name[256], devices[1024];
+		uint64_t size, seg_start;
+		char type[32], name[256], dev[256], devices[1024];
 
 		if (i >= vg->lv_cnt)
 			break;
@@ -254,12 +231,10 @@
 		err = -EINVAL;
 		lv  = vg->lvs + i;
 
-		if (sscanf(line, _NAME" %llu %31s %u %llu %llu %1023s",
+                if (sscanf(line, _NAME" %"SCNu64" %31s %u %"SCNu64" %"SCNu64" %1023s",
 			   name, &size, type, &segs, &seg_start,
-			   &seg.pe_size, devices) != 7) {
-			EPRINTF("sscanf failed on '%s'\n", line);
+			   &seg.pe_size, devices) != 7)
 			goto out;
-		}
 
 		if (seg_start)
 			goto next;
@@ -283,11 +258,8 @@
 		err = -EINVAL;
 
 	next:
-		if (lvm_next_line(scan)) {
-			if (err)
-				EPRINTF("fscanf failed\n");
+		if (lvm_next_line(scan))
 			goto out;
-		}
 	}
 
 	err = 0;
@@ -353,19 +325,20 @@
 		return (err >= 0 ? err : -err);
 	}
 
-	printf("vg %s: extent_size: %llu, pvs: %d, lvs: %d\n",
+	
+        printf("vg %s: extent_size: %"PRIu64", pvs: %d, lvs: %d\n",
 	       vg.name, vg.extent_size, vg.pv_cnt, vg.lv_cnt);
 
 	for (i = 0; i < vg.pv_cnt; i++) {
 		pv = vg.pvs + i;
-		printf("pv %s: start %llu\n", pv->name, pv->start);
+                printf("pv %s: start %"PRIu64"\n", pv->name, pv->start);
 	}
 
 	for (i = 0; i < vg.lv_cnt; i++) {
 		lv  = vg.lvs + i;
-		seg = &lv->first_segment;
-		printf("lv %s: size: %llu, segments: %u, type: %u, "
-		       "dev: %s, pe_start: %llu, pe_size: %llu\n",
+		seg = &lv->first_segment;                
+                printf("lv %s: size: %"PRIu64", segments: %u, type: %u, "
+                       "dev: %s, pe_start: %"PRIu64", pe_size: %"PRIu64"\n",
 		       lv->name, lv->size, lv->segments, seg->type,
 		       seg->device, seg->pe_start, seg->pe_size);
 	}
diff -Nur blktap2_oxt//lvm/Makefile blktap2_xen//lvm/Makefile
--- blktap2_oxt//lvm/Makefile	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//lvm/Makefile	2015-03-19 11:08:36.000000000 -0400
@@ -1,9 +1,6 @@
-#
-# Copyright (c) 2008 Citrix Systems, Inc.
-#
-
-BLKTAP_ROOT := ../
-include $(BLKTAP_ROOT)/Rules.mk
+XEN_ROOT = $(CURDIR)/../../..
+BLKTAP_ROOT := ..
+include $(XEN_ROOT)/tools/Rules.mk
 
 ifeq ($(LVM_UTIL_TEST),y)
 TEST              := lvm-util
@@ -14,9 +11,9 @@
 CFLAGS            += -I../include
 CFLAGS            += -D_GNU_SOURCE
 
-# Get gcc to generate the dependencies for us.
-CFLAGS            += -Wp,-MD,.$(@F).d
-DEPS               = .*.d
+ifeq ($(CONFIG_X86_64),y)
+CFLAGS            += -fPIC
+endif
 
 LVM-OBJS          := lvm-util.o
 
@@ -27,10 +24,10 @@
 install: all
 
 lvm-util: lvm-util.o
-	$(CC) $(CFLAGS) -DLVM_UTIL -o lvm-util lvm-util.c
+	$(CC) -DLVM_UTIL $(LDFLAGS) -o lvm-util lvm-util.c
 
 clean:
-	rm -rf *.o *~ $(DEPS) $(IBIN)
+	rm -rf *.o *.opic *~ $(DEPS) $(IBIN)
 
 .PHONY: all build clean install lvm-util
 
diff -Nur blktap2_oxt//Makefile blktap2_xen//Makefile
--- blktap2_oxt//Makefile	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//Makefile	2015-03-19 11:08:36.000000000 -0400
@@ -1,37 +1,18 @@
-#
-# Copyright (c) 2011 Citrix Systems, Inc.
-#
+XEN_ROOT = $(CURDIR)/../..
+include $(XEN_ROOT)/tools/Rules.mk
 
-BLKTAP_ROOT := .
-include $(BLKTAP_ROOT)/Rules.mk
+CFLAGS  += $(CFLAGS_libxenctrl)
+LDLIBS += $(LDLIBS_libxenctrl)
 
 SUBDIRS-y :=
 SUBDIRS-y += include
 SUBDIRS-y += lvm
-SUBDIRS-y += part
 SUBDIRS-y += vhd
-SUBDIRS-y += drivers
-SUBDIRS-y += control
-SUBDIRS-y += scripts
+SUBDIRS-$(CONFIG_Linux) += drivers
+SUBDIRS-$(CONFIG_Linux) += control
 
-.PHONY: all
-all: build
-
-.PHONY: build
-build:
-	@set -e; for subdir in $(SUBDIRS-y); do \
-	$(MAKE) -C $$subdir all;       \
-		done
-
-.PHONY: install
-install:
-	@set -e; for subdir in $(SUBDIRS-y); do \
-		$(MAKE) -C $$subdir install; \
-	done
-
-.PHONY: clean
 clean:
 	rm -rf *.a *.so *.o *.rpm $(LIB) *~ $(DEPS) TAGS
-	@set -e; for subdir in $(SUBDIRS-y); do \
-	$(MAKE) -C $$subdir clean;       \
-		done
+
+.PHONY: all clean install
+all clean install: %: subdirs-%
diff -Nur blktap2_oxt//vhd/lib/libvhd.c blktap2_xen//vhd/lib/libvhd.c
--- blktap2_oxt//vhd/lib/libvhd.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/libvhd.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #ifndef _GNU_SOURCE
 #define _GNU_SOURCE
 #endif
@@ -39,21 +35,14 @@
 #include <string.h>
 #include <libgen.h>
 #include <iconv.h>
-#include <sys/file.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
-#include <stddef.h>
 
-#include "xattr.h"
 #include "libvhd.h"
 #include "relative-path.h"
 
-#define VHD_HEADER_MAX_RETRIES 10
-
 static int libvhd_dbg = 0;
 
-
-
 void
 libvhd_set_log_level(int level)
 {
@@ -68,13 +57,7 @@
 			       __func__, ##_a);				\
 	} while (0)
 
-#define ASSERT(_p)							\
-	if (!(_p)) {							\
-		libvhd_set_log_level(1);                                \
-		VHDLOG("%s:%d: FAILED ASSERTION: '%s'\n",		\
-			__FILE__, __LINE__, #_p);			\
-		*(int*)0 = 0;						\
-	}
+#define BIT_MASK 0x80
 
 #ifdef ENABLE_FAILURE_TESTING
 const char* ENV_VAR_FAIL[NUM_FAIL_TESTS] = {
@@ -89,14 +72,23 @@
 int TEST_FAIL[NUM_FAIL_TESTS];
 #endif // ENABLE_FAILURE_TESTING
 
-static void vhd_cache_init(vhd_context_t *);
-static int vhd_cache_enabled(vhd_context_t *);
-static int vhd_cache_load(vhd_context_t *);
-static int vhd_cache_unload(vhd_context_t *);
-static vhd_context_t * vhd_cache_get_parent(vhd_context_t *);
-static void __vhd_close(vhd_context_t *ctx);
+static inline int
+test_bit (volatile char *addr, int nr)
+{
+	return ((addr[nr >> 3] << (nr & 7)) & BIT_MASK) != 0;
+}
+
+static inline void
+set_bit (volatile char *addr, int nr)
+{
+	addr[nr >> 3] |= (BIT_MASK >> (nr & 7));
+}
 
-#include "icbinn.c"
+static inline void
+clear_bit (volatile char *addr, int nr)
+{
+	addr[nr >> 3] &= ~(BIT_MASK >> (nr & 7));
+}
 
 static inline int
 old_test_bit(volatile char *addr, int nr)
@@ -210,7 +202,6 @@
 	BE32_OUT(&batmap->header.batmap_size);
 	BE32_OUT(&batmap->header.batmap_version);
 	BE32_OUT(&batmap->header.checksum);
-	memset(batmap->header.res, 0, sizeof(batmap->header.res));
 }
 
 void
@@ -260,8 +251,8 @@
 	if (memcmp(footer->cookie, HD_COOKIE, csize) != 0 &&
 	    memcmp(footer->cookie, VHD_POISON_COOKIE, csize) != 0) {
 		char buf[9];
-		memcpy(buf, footer->cookie, 8);
-		buf[8]= '\0';
+		strncpy(buf, footer->cookie, sizeof(buf));
+		buf[sizeof(buf)-1]= '\0';
 		VHDLOG("invalid footer cookie: %s\n", buf);
 		return -EINVAL;
 	}
@@ -321,8 +312,8 @@
 
 	if (memcmp(header->cookie, DD_COOKIE, 8) != 0) {
 		char buf[9];
-		memcpy(buf, header->cookie, 8);
-		buf[8] = '\0';
+		strncpy(buf, header->cookie, sizeof(buf));
+		buf[sizeof(buf)-1]= '\0';
 		VHDLOG("invalid header cookie: %s\n", buf);
 		return -EINVAL;
 	}
@@ -332,8 +323,8 @@
 		return -EINVAL;
 	}
 
-	if (header->data_offset != 0xFFFFFFFFFFFFFFFFULL) {
-		VHDLOG("invalid header data_offset 0x%016llx\n",
+	if (header->data_offset != 0xFFFFFFFFFFFFFFFF) {
+		VHDLOG("invalid header data_offset 0x%016"PRIx64"\n",
 		       header->data_offset);
 		return -EINVAL;
 	}
@@ -364,20 +355,18 @@
 }
 
 uint32_t
-vhd_checksum_batmap(vhd_context_t *ctx, vhd_batmap_t *batmap)
+vhd_checksum_batmap(vhd_batmap_t *batmap)
 {
-	int i;
+	int i, n;
 	char *blob;
 	uint32_t checksum;
-	size_t map_size;
 
 	blob     = batmap->map;
 	checksum = 0;
 
-	map_size = vhd_sectors_to_bytes(secs_round_up_no_zero(
-			ctx->footer.curr_size >> (VHD_BLOCK_SHIFT + 3)));
+	n = vhd_sectors_to_bytes(batmap->header.batmap_size);
 
-	for (i = 0; i < map_size; i++) {
+	for (i = 0; i < n; i++) {
 		if (batmap->header.batmap_version == VHD_BATMAP_VERSION(1, 1))
 			checksum += (uint32_t)blob[i];
 		else
@@ -400,27 +389,24 @@
 }
 
 int
-vhd_validate_batmap(vhd_context_t *ctx, vhd_batmap_t *batmap)
+vhd_validate_batmap(vhd_batmap_t *batmap)
 {
 	uint32_t checksum;
 
 	if (!batmap->map)
 		return -EINVAL;
 
-	checksum = vhd_checksum_batmap(ctx, batmap);
-	if (checksum != batmap->header.checksum) {
-		VHDLOG("checksum mismtch: 0x%x != 0x%x\n",
-		       checksum, batmap->header.checksum);
+	checksum = vhd_checksum_batmap(batmap);
+	if (checksum != batmap->header.checksum)
 		return -EINVAL;
-	}
 
 	return 0;
 }
 
 int
-vhd_batmap_header_offset(vhd_context_t *ctx, off64_t *_off)
+vhd_batmap_header_offset(vhd_context_t *ctx, off_t *_off)
 {
-	off64_t off;
+	off_t off;
 	size_t  bat;
 
 	*_off = 0;
@@ -607,11 +593,11 @@
  * byte of the file which is not vhd metadata
  */
 int
-vhd_end_of_headers(vhd_context_t *ctx, off64_t *end)
+vhd_end_of_headers(vhd_context_t *ctx, off_t *end)
 {
 	int err, i, n;
 	uint32_t bat_bytes;
-	off64_t eom, bat_end;
+	off_t eom, bat_end;
 	vhd_parent_locator_t *loc;
 
 	*end = 0;
@@ -627,14 +613,11 @@
 	eom       = MAX(eom, bat_end);
 
 	if (vhd_has_batmap(ctx)) {
-		off64_t hdr_end, hdr_secs, map_end, map_secs;
+		off_t hdr_end, hdr_secs, map_end, map_secs;
 
 		err = vhd_get_batmap(ctx);
-		if (err) {
-			err = vhd_read_batmap_header(ctx, &ctx->batmap);
-			if (err)
-				return err;
-		}
+		if (err)
+			return err;
 
 		hdr_secs = secs_round_up_no_zero(sizeof(vhd_batmap_header_t));
 		err      = vhd_batmap_header_offset(ctx, &hdr_end);
@@ -654,7 +637,7 @@
 	n = sizeof(ctx->header.loc) / sizeof(vhd_parent_locator_t);
 
 	for (i = 0; i < n; i++) {
-		off64_t loc_end;
+		off_t loc_end;
 
 		loc = &ctx->header.loc[i];
 		if (loc->code == PLAT_CODE_NONE)
@@ -669,10 +652,10 @@
 }
 
 int
-vhd_end_of_data(vhd_context_t *ctx, off64_t *end)
+vhd_end_of_data(vhd_context_t *ctx, off_t *end)
 {
 	int i, err;
-	off64_t max;
+	off_t max;
 	uint64_t blk;
 
 	if (!vhd_type_dynamic(ctx)) {
@@ -681,7 +664,7 @@
 			return err;
 
 		max = vhd_position(ctx);
-		if (max == (off64_t)-1)
+		if (max == (off_t)-1)
 			return -errno;
 
 		*end = max - sizeof(vhd_footer_t);
@@ -839,7 +822,7 @@
 	if (!vhd_has_batmap(ctx))
 		return -EINVAL;
 
-	if (!vhd_validate_batmap(ctx, &ctx->batmap))
+	if (!vhd_validate_batmap(&ctx->batmap))
 		return 0;
 
 	vhd_put_batmap(ctx);
@@ -889,7 +872,7 @@
 {
 	int err;
 	char *buf;
-	off64_t eof;
+	off_t eof;
 
 	buf = NULL;
 
@@ -898,7 +881,7 @@
 		goto out;
 
 	eof = vhd_position(ctx);
-	if (eof == (off64_t)-1) {
+	if (eof == (off_t)-1) {
 		err = -errno;
 		goto out;
 	}
@@ -936,7 +919,7 @@
 }
 
 int
-vhd_read_footer_at(vhd_context_t *ctx, vhd_footer_t *footer, off64_t off)
+vhd_read_footer_at(vhd_context_t *ctx, vhd_footer_t *footer, off_t off)
 {
 	int err;
 	char *buf;
@@ -976,14 +959,14 @@
 vhd_read_footer(vhd_context_t *ctx, vhd_footer_t *footer)
 {
 	int err;
-	off64_t off;
+	off_t off;
 
 	err = vhd_seek(ctx, 0, SEEK_END);
 	if (err)
 		return err;
 
 	off = vhd_position(ctx);
-	if (off == (off64_t)-1)
+	if (off == (off_t)-1)
 		return -errno;
 
 	err = vhd_read_footer_at(ctx, footer, off - 512);
@@ -994,19 +977,14 @@
 	if (err != -EINVAL)
 		return err;
 
-	/* 
-	 * Disable the enforcement of VHD_OPEN_STRICT until we figure out how 
-	 * to recover from crashes. Note that we never enforced it before 
-	 * anyways due to a bug (CA-28285) and everything was ok.
-	 */
-	/* if (ctx->oflags & VHD_OPEN_STRICT)
-		return -EINVAL; */
+	if (ctx->oflags & VHD_OPEN_STRICT)
+		return -EINVAL;
 
 	return vhd_read_footer_at(ctx, footer, 0);
 }
 
 int
-vhd_read_header_at(vhd_context_t *ctx, vhd_header_t *header, off64_t off)
+vhd_read_header_at(vhd_context_t *ctx, vhd_header_t *header, off_t off)
 {
 	int err;
 	char *buf;
@@ -1050,7 +1028,8 @@
 int
 vhd_read_header(vhd_context_t *ctx, vhd_header_t *header)
 {
-	off64_t off;
+	int err;
+	off_t off;
 
 	if (!vhd_type_dynamic(ctx)) {
 		VHDLOG("%s is not dynamic!\n", ctx->file);
@@ -1066,8 +1045,7 @@
 {
 	int err;
 	char *buf;
-	off64_t off;
-	uint32_t vhd_blks;
+	off_t off;
 	size_t size;
 
 	buf  = NULL;
@@ -1078,12 +1056,7 @@
 	}
 
 	off  = ctx->header.table_offset;
-	/* The BAT size is stored in ctx->header.max_bat_size. However, we
-	 * sometimes preallocate BAT + batmap for max VHD size, so only read in
-	 * the BAT entries that are in use for curr_size */
-	vhd_blks = ctx->footer.curr_size >> VHD_BLOCK_SHIFT;
-	ASSERT(ctx->header.max_bat_size >= vhd_blks);
-	size = vhd_bytes_padded(vhd_blks * sizeof(uint32_t));
+	size = vhd_bytes_padded(ctx->header.max_bat_size * sizeof(uint32_t));
 
 	err  = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, size);
 	if (err) {
@@ -1101,7 +1074,7 @@
 		goto fail;
 
 	bat->spb     = ctx->header.block_size >> VHD_SECTOR_SHIFT;
-	bat->entries = vhd_blks;
+	bat->entries = ctx->header.max_bat_size;
 	bat->bat     = (uint32_t *)buf;
 
 	vhd_bat_in(bat);
@@ -1115,12 +1088,12 @@
 	return err;
 }
 
-int
+static int
 vhd_read_batmap_header(vhd_context_t *ctx, vhd_batmap_t *batmap)
 {
 	int err;
 	char *buf;
-	off64_t off;
+	off_t off;
 	size_t size;
 
 	buf = NULL;
@@ -1160,17 +1133,15 @@
 	return err;
 }
 
-int
+static int
 vhd_read_batmap_map(vhd_context_t *ctx, vhd_batmap_t *batmap)
 {
 	int err;
 	char *buf;
-	off64_t off;
+	off_t off;
 	size_t map_size;
 
-	map_size = vhd_sectors_to_bytes(secs_round_up_no_zero(
-			ctx->footer.curr_size >> (VHD_BLOCK_SHIFT + 3)));
-	ASSERT(vhd_sectors_to_bytes(batmap->header.batmap_size) >= map_size);
+	map_size = vhd_sectors_to_bytes(batmap->header.batmap_size);
 
 	err = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, map_size);
 	if (err) {
@@ -1220,7 +1191,7 @@
 	if (err)
 		return err;
 
-	err = vhd_validate_batmap(ctx, batmap);
+	err = vhd_validate_batmap(batmap);
 	if (err)
 		goto fail;
 
@@ -1260,21 +1231,6 @@
 	return (!vhd_validate_batmap_header(&ctx->batmap));
 }
 
-void
-vhd_batmap_reset_map(vhd_context_t *ctx, vhd_batmap_t *batmap)
-{
-	if (batmap->map) {
-		size_t map_size =
-			vhd_sectors_to_bytes(
-				secs_round_up_no_zero(
-					(ctx->footer.curr_size >>
-					 (VHD_BLOCK_SHIFT + 3))
-					)
-				);
-		memset(batmap->map, 0, map_size);
-	}
-}
-
 /* 
  * Is this a block device (with a fixed size)? This affects whether the file 
  * can be truncated and where the footer is written for VHDs.
@@ -1305,7 +1261,7 @@
 	location   = NULL;
 	*_location = NULL;
 
-	if (!parent || !strcmp(parent, ""))
+	if (!parent)
 		return -EINVAL;
 
 	if (parent[0] == '/') {
@@ -1318,34 +1274,8 @@
 		}
 	}
 
-	if (parent[0] == '.') {
-		/* XCE synchroniser encodes relative paths which need to be resolved w/o using
-		 * realpath due to layers of symlinks */
-		cpath = strdup(ctx->file);
-		if (!cpath) {
-			err = -errno;
-			goto out;
-		}
-
-		cdir = dirname(cpath);
-		if (asprintf(&location, "%s/%s", cdir, parent) == -1) {
-			err = -errno;
-			location = NULL;
-			goto out;
-		}
-		if (!access(location, R_OK)) {
-			free(cpath);
-			*_location = location;
-			return 0;
-		} else {
-			err = -errno;
-			goto out;
-		}
-
-	}
-
 	/* check parent path relative to child's directory */
-	cpath = vhd_realpath(ctx->file, NULL);
+	cpath = realpath(ctx->file, NULL);
 	if (!cpath) {
 		err = -errno;
 		goto out;
@@ -1359,7 +1289,7 @@
 	}
 
 	if (!access(location, R_OK)) {
-		path = vhd_realpath(location, NULL);
+		path = realpath(location, NULL);
 		if (path) {
 			*_location = path;
 			return 0;
@@ -1373,13 +1303,14 @@
 	return err;
 }
 
-int 
+static int 
 vhd_macx_encode_location(char *name, char **out, int *outlen)
 {
 	iconv_t cd;
 	int len, err;
 	size_t ibl, obl;
-	char *uri, *urip, *uri_utf8, *uri_utf8p, *ret;
+	char *uri, *uri_utf8, *uri_utf8p, *ret;
+	const char *urip;
 
 	err     = 0;
 	ret     = NULL;
@@ -1390,7 +1321,7 @@
 	ibl     = len;
 	obl     = len;
 
-	uri = urip = malloc(ibl + 1);
+	urip = uri = malloc(ibl + 1);
 	uri_utf8 = uri_utf8p = malloc(obl);
 
 	if (!uri || !uri_utf8)
@@ -1402,9 +1333,13 @@
 		goto out;
 	}
 
-	sprintf(uri, "file://%s", name);
+	snprintf(uri, ibl+1, "file://%s", name);
 
-	if (iconv(cd, &urip, &ibl, &uri_utf8p, &obl) == (size_t)-1 ||
+	if (iconv(cd,
+#ifdef __linux__
+	    (char **)
+#endif
+	    &urip, &ibl, &uri_utf8p, &obl) == (size_t)-1 ||
 	    ibl || obl) {
 		err = (errno ? -errno : -EIO);
 		goto out;
@@ -1429,13 +1364,14 @@
 	return err;
 }
 
-int
+static int
 vhd_w2u_encode_location(char *name, char **out, int *outlen)
 {
 	iconv_t cd;
 	int len, err;
 	size_t ibl, obl;
-	char *uri, *urip, *uri_utf16, *uri_utf16p, *tmp, *ret;
+	char *uri, *uri_utf16, *uri_utf16p, *tmp, *ret;
+	const char *urip;
 
 	err     = 0;
 	ret     = NULL;
@@ -1489,7 +1425,11 @@
 		goto out;
 	}
 
-	if (iconv(cd, &urip, &ibl, &uri_utf16p, &obl) == (size_t)-1 ||
+	if (iconv(cd,
+#ifdef __linux__
+	    (char **)
+#endif
+	    &urip, &ibl, &uri_utf16p, &obl) == (size_t)-1 ||
 	    ibl || obl) {
 		err = (errno ? -errno : -EIO);
 		goto out;
@@ -1517,7 +1457,7 @@
 }
 
 static char *
-vhd_macx_decode_location(char *in, char *out, int len)
+vhd_macx_decode_location(const char *in, char *out, int len)
 {
 	iconv_t cd;
 	char *name;
@@ -1530,7 +1470,11 @@
 	if (cd == (iconv_t)-1) 
 		return NULL;
 
-	if (iconv(cd, &in, &ibl, &out, &obl) == (size_t)-1 || ibl)
+	if (iconv(cd,
+#ifdef __linux__
+		(char **)
+#endif
+		&in, &ibl, &out, &obl) == (size_t)-1 || ibl)
 		return NULL;
 
 	iconv_close(cd);
@@ -1545,7 +1489,7 @@
 }
 
 static char *
-vhd_w2u_decode_location(char *in, char *out, int len, char *utf_type)
+vhd_w2u_decode_location(const char *in, char *out, int len, char *utf_type)
 {
 	iconv_t cd;
 	char *name, *tmp;
@@ -1558,7 +1502,11 @@
 	if (cd == (iconv_t)-1) 
 		return NULL;
 
-	if (iconv(cd, &in, &ibl, &out, &obl) == (size_t)-1 || ibl)
+	if (iconv(cd,
+#ifdef __linux__
+		(char **)
+#endif
+		&in, &ibl, &out, &obl) == (size_t)-1 || ibl)
 		return NULL;
 
 	iconv_close(cd);
@@ -1673,7 +1621,7 @@
 		VHDLOG("%s: error reading parent locator: %d\n",
 		       ctx->file, err);
 		VHDLOG("%s: locator: code %u, space 0x%x, len 0x%x, "
-		       "off 0x%llx\n", ctx->file, loc->code, loc->data_space,
+		       "off 0x%"PRIx64"\n", ctx->file, loc->code, loc->data_space,
 		       loc->data_len, loc->data_offset);
 	}
 
@@ -1717,14 +1665,13 @@
 
 int
 vhd_parent_locator_write_at(vhd_context_t *ctx,
-			    const char *parent, off64_t off, uint32_t code,
+			    const char *parent, off_t off, uint32_t code,
 			    size_t max_bytes, vhd_parent_locator_t *loc)
 {
+	struct stat stats;
 	int err, len, size;
 	char *absolute_path, *relative_path, *encoded, *block;
 
-	ICBINN *icb = vhd_icbinn_vhd();
-
 	memset(loc, 0, sizeof(vhd_parent_locator_t));
 
 	if (ctx->footer.type != HD_TYPE_DIFF)
@@ -1746,36 +1693,21 @@
 		return -EINVAL;
 	}
 
-	absolute_path = vhd_realpath(parent, NULL);
+	absolute_path = realpath(parent, NULL);
 	if (!absolute_path) {
 		err = -errno;
 		goto out;
 	}
 
-	if (icb) {
-		struct icbinn_stat stats;
-		err = icbinn_stat(icb,absolute_path, &stats);
-		if (err) {
-			err = -ENOENT;
-			goto out;
-		}
-		if (stats.type != ICBINN_TYPE_FILE) {
-			err = -EINVAL;
-			goto out;
-		}
-	} else {
-		struct stat stats;
-
-		err = stat(absolute_path, &stats);
-		if (err) {
-			err = -errno;
-			goto out;
-		}
+	err = stat(absolute_path, &stats);
+	if (err) {
+		err = -errno;
+		goto out;
+	}
 
-		if (!S_ISREG(stats.st_mode) && !S_ISBLK(stats.st_mode)) {
-			err = -EINVAL;
-			goto out;
-		}
+	if (!S_ISREG(stats.st_mode) && !S_ISBLK(stats.st_mode)) {
+		err = -EINVAL;
+		goto out;
 	}
 
 	relative_path = relative_path_to(ctx->file, absolute_path, &err);
@@ -1849,11 +1781,11 @@
 }
 
 static int
-vhd_footer_offset_at_eof(vhd_context_t *ctx, off64_t *off)
+vhd_footer_offset_at_eof(vhd_context_t *ctx, off_t *off)
 {
 	int err;
 	if ((err = vhd_seek(ctx, 0, SEEK_END)))
-		return err;
+		return errno;
 	*off = vhd_position(ctx) - sizeof(vhd_footer_t);
 	return 0;
 }
@@ -1864,7 +1796,7 @@
 	int err;
 	char *buf;
 	size_t size;
-	off64_t off;
+	off_t off;
 	uint64_t blk;
 
 	buf   = NULL;
@@ -1914,7 +1846,7 @@
 	char *buf;
 	size_t size;
 	uint64_t blk;
-	off64_t end, off;
+	off_t end, off;
 
 	buf   = NULL;
 	*bufp = NULL;
@@ -1968,7 +1900,7 @@
 }
 
 int
-vhd_write_footer_at(vhd_context_t *ctx, vhd_footer_t *footer, off64_t off)
+vhd_write_footer_at(vhd_context_t *ctx, vhd_footer_t *footer, off_t off)
 {
 	int err;
 	vhd_footer_t *f;
@@ -2010,7 +1942,7 @@
 vhd_write_footer(vhd_context_t *ctx, vhd_footer_t *footer)
 {
 	int err;
-	off64_t off;
+	off_t off;
 
 	if (ctx->is_block)
 		err = vhd_footer_offset_at_eof(ctx, &off);
@@ -2023,16 +1955,6 @@
 	if (err)
 		return err;
 
-	if (!ctx->is_block) {
-		err = ftruncate(ctx->fd, off + sizeof(vhd_footer_t));
-		if (err)
-			return -errno;
-
-		err = fdatasync(ctx->fd);
-		if (err)
-			return -errno;
-	}
-
 	if (!vhd_type_dynamic(ctx))
 		return 0;
 
@@ -2040,7 +1962,7 @@
 }
 
 int
-vhd_write_header_at(vhd_context_t *ctx, vhd_header_t *header, off64_t off)
+vhd_write_header_at(vhd_context_t *ctx, vhd_header_t *header, off_t off)
 {
 	int err;
 	vhd_header_t *h;
@@ -2086,7 +2008,8 @@
 int
 vhd_write_header(vhd_context_t *ctx, vhd_header_t *header)
 {
-	off64_t off;
+	int err;
+	off_t off;
 
 	if (!vhd_type_dynamic(ctx))
 		return -EINVAL;
@@ -2099,7 +2022,7 @@
 vhd_write_bat(vhd_context_t *ctx, vhd_bat_t *bat)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	vhd_bat_t b;
 	size_t size;
 
@@ -2138,49 +2061,11 @@
 	return err;
 }
 
-static int
-vhd_write_batmap_header(vhd_context_t *ctx, vhd_batmap_t *batmap)
-{
-	int err;
-	size_t size;
-	off64_t off;
-	char *buf = NULL;
-
-	err = vhd_batmap_header_offset(ctx, &off);
-	if (err)
-		goto out;
-
-	size = vhd_bytes_padded(sizeof(batmap->header));
-
-	err = vhd_seek(ctx, off, SEEK_SET);
-	if (err)
-		goto out;
-
-	err = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, size);
-	if (err) {
-		err = -err;
-		buf = NULL;
-		goto out;
-	}
-
-	vhd_batmap_header_out(batmap);
-	memset(buf, 0, size);
-	memcpy(buf, &batmap->header, sizeof(batmap->header));
-
-	err = vhd_write(ctx, buf, size);
-
-out:
-	if (err)
-		VHDLOG("%s: failed writing batmap: %d\n", ctx->file, err);
-	free(buf);
-	return err;
-}
-
 int
 vhd_write_batmap(vhd_context_t *ctx, vhd_batmap_t *batmap)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	vhd_batmap_t b;
 	char *buf, *map;
 	size_t size, map_size;
@@ -2196,15 +2081,13 @@
 	b.header = batmap->header;
 	b.map    = batmap->map;
 
-	b.header.checksum = vhd_checksum_batmap(ctx, &b);
-	err = vhd_validate_batmap(ctx, &b);
+	b.header.checksum = vhd_checksum_batmap(&b);
+	err = vhd_validate_batmap(&b);
 	if (err)
 		goto out;
 
 	off      = b.header.batmap_offset;
-	map_size = vhd_sectors_to_bytes(secs_round_up_no_zero(
-			ctx->footer.curr_size >> (VHD_BLOCK_SHIFT + 3)));
-	ASSERT(vhd_sectors_to_bytes(b.header.batmap_size) >= map_size);
+	map_size = vhd_sectors_to_bytes(b.header.batmap_size);
 
 	err  = vhd_seek(ctx, off, SEEK_SET);
 	if (err)
@@ -2258,9 +2141,9 @@
 vhd_write_bitmap(vhd_context_t *ctx, uint32_t block, char *bitmap)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	uint64_t blk;
-	size_t size;
+	size_t secs, size;
 
 	if (!vhd_type_dynamic(ctx))
 		return -EINVAL;
@@ -2297,7 +2180,7 @@
 vhd_write_block(vhd_context_t *ctx, uint32_t block, char *data)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	size_t size;
 	uint64_t blk;
 
@@ -2311,7 +2194,7 @@
 	if (block >= ctx->bat.entries)
 		return -ERANGE;
 
-	if ((unsigned long)data & (VHD_SECTOR_SIZE - 1))
+	if ((unsigned long)data & ~(VHD_SECTOR_SIZE -1))
 		return -EINVAL;
 
 	blk  = ctx->bat.bat[block];
@@ -2347,82 +2230,13 @@
 	return 0;
 }
 
-#define vwrite (ssize_t (*)(int, void *, size_t))write
-#define vpwrite (ssize_t (*)(int, void *, size_t, off_t))pwrite
-
-static ssize_t
-vhd_atomic_pio(ssize_t (*f) (int, void *, size_t, off_t),
-	       int fd, void *_s, size_t n, off_t off)
-{
-	char *s = _s;
-	size_t pos = 0;
-	ssize_t res;
-	struct stat st;
-
-	memset(&st, 0, sizeof(st));
-
-	for (;;) {
-		res = (f) (fd, s + pos, n - pos, off + pos);
-		switch (res) {
-		case -1:
-			if (errno == EINTR || errno == EAGAIN)
-				continue;
-			else
-				return 0;
-			break;
-		case 0:
-			errno = EPIPE;
-			return pos;
-		}
-
-		if (pos + res == n)
-			return n;
-
-		if (!st.st_size) {
-			if (fstat(fd, &st) == -1)
-				return -1;
-
-			if (S_ISBLK(st.st_mode))
-				return pos;
-		}
-
-		if (off + pos + res == st.st_size)
-			return pos + res;
-
-		pos += (res & ~(VHD_SECTOR_SIZE - 1));
-	}
-
-	return -1;
-}
-
-static ssize_t
-vhd_atomic_io(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n)
-{
-	off64_t off;
-	ssize_t res;
-	ssize_t (*pf) (int, void *, size_t, off_t);
-
-	off = lseek64(fd, 0, SEEK_CUR);
-	if (off == (off_t)-1)
-		return -1;
-
-	pf = (f == read ? pread : vpwrite);
-	res = vhd_atomic_pio(pf, fd, _s, n, off);
-
-	if (res > 0)
-		if (lseek64(fd, off + res, SEEK_SET) == (off64_t)-1)
-			return -1;
-
-	return res;
-}
-
-static int
-__vhd_seek(vhd_context_t *ctx, off64_t offset, int whence)
+int
+vhd_seek(vhd_context_t *ctx, off_t offset, int whence)
 {
-	off64_t off;
+	off_t off;
 
-	off = lseek64(ctx->fd, offset, whence);
-	if (off == (off64_t)-1) {
+	off = lseek(ctx->fd, offset, whence);
+	if (off == (off_t)-1) {
 		VHDLOG("%s: seek(0x%08"PRIx64", %d) failed: %d\n",
 		       ctx->file, offset, whence, -errno);
 		return -errno;
@@ -2431,20 +2245,20 @@
 	return 0;
 }
 
-static off64_t
-__vhd_position(vhd_context_t *ctx)
+off_t
+vhd_position(vhd_context_t *ctx)
 {
-	return lseek64(ctx->fd, 0, SEEK_CUR);
+	return lseek(ctx->fd, 0, SEEK_CUR);
 }
 
-static int
-__vhd_read(vhd_context_t *ctx, void *buf, size_t size)
+int
+vhd_read(vhd_context_t *ctx, void *buf, size_t size)
 {
 	size_t ret;
 
 	errno = 0;
 
-	ret = vhd_atomic_io(read, ctx->fd, buf, size);
+	ret = read(ctx->fd, buf, size);
 	if (ret == size)
 		return 0;
 
@@ -2454,14 +2268,14 @@
 	return (errno ? -errno : -EIO);
 }
 
-static int
-__vhd_write(vhd_context_t *ctx, void *buf, size_t size)
+int
+vhd_write(vhd_context_t *ctx, void *buf, size_t size)
 {
 	size_t ret;
 
 	errno = 0;
 
-	ret = vhd_atomic_io(vwrite, ctx->fd, buf, size);
+	ret = write(ctx->fd, buf, size);
 	if (ret == size)
 		return 0;
 
@@ -2471,88 +2285,6 @@
 	return (errno ? -errno : -EIO);
 }
 
-static int
-__vhd_pread(vhd_context_t *ctx, void *buf, size_t size, off64_t offset)
-{
-	ssize_t ret;
-
-	errno = 0;
-
-	ret = vhd_atomic_pio(pread, ctx->fd, buf, size, offset);
-	if (ret == size)
-		return 0;
-
-	VHDLOG("%s: pread of %zu returned %zd, errno: %d\n",
-	       ctx->file, size, ret, -errno);
-
-	return (errno ? -errno : -EIO);
-}
-
-static int
-__vhd_pwrite(vhd_context_t *ctx, void *buf, size_t size, off64_t offset)
-{
-	ssize_t ret;
-
-	errno = 0;
-
-	ret = vhd_atomic_pio(vpwrite, ctx->fd, buf, size, offset);
-	if (ret == size)
-		return 0;
-
-	VHDLOG("%s: pwrite of %zu returned %zd, errno: %d\n",
-	       ctx->file, size, ret, -errno);
-
-	return (errno ? -errno : -EIO);
-}
-
-int
-vhd_seek(vhd_context_t *ctx, off64_t offset, int whence)
-{
-	if (ctx->devops && ctx->devops->seek)
-		return ctx->devops->seek(ctx, offset, whence);
-	return __vhd_seek(ctx, offset, whence);
-}
-
-off64_t
-vhd_position(vhd_context_t *ctx)
-{
-	if (ctx->devops && ctx->devops->position)
-		return ctx->devops->position(ctx);
-	return __vhd_position(ctx);
-}
-
-int
-vhd_read(vhd_context_t *ctx, void *buf, size_t size)
-{
-	if (ctx->devops && ctx->devops->read)
-		return ctx->devops->read(ctx, buf, size);
-	return __vhd_read(ctx, buf, size);
-}
-
-int
-vhd_write(vhd_context_t *ctx, void *buf, size_t size)
-{
-	if (ctx->devops && ctx->devops->write)
-		return ctx->devops->write(ctx, buf, size);
-	return __vhd_write(ctx, buf, size);
-}
-
-int
-vhd_pread(vhd_context_t *ctx, void *buf, size_t size, off64_t offset)
-{
-	if (ctx->devops && ctx->devops->pread)
-		return ctx->devops->pread(ctx, buf, size, offset);
-	return __vhd_pread(ctx, buf, size, offset);
-}
-
-int
-vhd_pwrite(vhd_context_t *ctx, void *buf, size_t size, off64_t offset)
-{
-	if (ctx->devops && ctx->devops->pwrite)
-		return ctx->devops->pwrite(ctx, buf, size, offset);
-	return __vhd_pwrite(ctx, buf, size, offset);
-}
-
 int
 vhd_offset(vhd_context_t *ctx, uint32_t sector, uint32_t *offset)
 {
@@ -2628,84 +2360,35 @@
 int
 vhd_open(vhd_context_t *ctx, const char *file, int flags)
 {
-	int i, err, oflags;
-	ICBINN *icb;
+	int err, oflags;
 
 	if (flags & VHD_OPEN_STRICT)
 		vhd_flag_clear(flags, VHD_OPEN_FAST);
 
 	memset(ctx, 0, sizeof(vhd_context_t));
-	vhd_cache_init(ctx);
-
 	ctx->fd     = -1;
 	ctx->oflags = flags;
 
-	icb    = vhd_icbinn_vhd();
-
 	err = namedup(&ctx->file, file);
 	if (err)
 		return err;
 
-	if (icb){
-		oflags = 0;
-		if (flags & VHD_OPEN_RDONLY)
-			oflags |= ICBINN_RDONLY;
-		if (flags & VHD_OPEN_RDWR)
-			oflags |= ICBINN_RDWR;
-
-		ctx->fd = icbinn_open(icb, ctx->file, oflags);
-		ctx->devops = &vhd_icbinn_devops;
-        } else {
-		oflags = O_LARGEFILE;
-		if (!(flags & VHD_OPEN_CACHED))
-			oflags |= O_DIRECT;
-		if (flags & VHD_OPEN_RDONLY)
-			oflags |= O_RDONLY;
-		if (flags & VHD_OPEN_RDWR)
-			oflags |= O_RDWR;
-
-		ctx->fd = open(ctx->file, oflags, 0644);
-	}
+	oflags = O_DIRECT | O_LARGEFILE;
+	if (flags & VHD_OPEN_RDONLY)
+		oflags |= O_RDONLY;
+	if (flags & VHD_OPEN_RDWR)
+		oflags |= O_RDWR;
 
+	ctx->fd = open(ctx->file, oflags, 0644);
 	if (ctx->fd == -1) {
 		err = -errno;
 		VHDLOG("failed to open %s: %d\n", ctx->file, err);
 		goto fail;
 	}
 
-	if (flags & VHD_OPEN_LOCKED) {
-		if (icb) {
-			if (icbinn_lock(icb, ctx->fd, oflags & ICBINN_RDWR ? ICBINN_LTYPE_WRLCK:ICBINN_LTYPE_RDLCK)) {
-				if (!getenv("VHD_BREAK_LOCKS")) {
-					VHDLOG("Failed to lock %s\n", file);
-					goto fail;
-				} else {
-					err = 0;
-					VHDLOG("Forcing lock for %s\n", file);
-				}
-			}
-		} else {
-			int op = (oflags & O_RDWR ? LOCK_EX : LOCK_SH);
-			if (flock(ctx->fd, op | LOCK_NB)) {
-				err = -errno;
-				if (!getenv("VHD_BREAK_LOCKS")) {
-					VHDLOG("Failed to lock %s: %d\n", file, err);
-					goto fail;
-				} else {
-					err = 0;
-					VHDLOG("Forcing lock for %s\n", file);
-				}
-			}
-		}
-	}
-
-	if (icb) {
-		ctx->is_block = 0;
-	} else {
-		err = vhd_test_file_fixed(ctx->file, &ctx->is_block);
-		if (err)
-			goto fail;
-	}
+	err = vhd_test_file_fixed(ctx->file, &ctx->is_block);
+	if (err)
+		goto fail;
 
 	if (flags & VHD_OPEN_FAST) {
 		err = vhd_open_fast(ctx);
@@ -2725,13 +2408,7 @@
 	}
 
 	if (vhd_type_dynamic(ctx)) {
-		for (i = 0; i < VHD_HEADER_MAX_RETRIES; i++) {
-			err = vhd_read_header(ctx, &ctx->header);
-			if (!err)
-				break;
-			VHDLOG("Error reading header, retry %d\n", i);
-			sleep(1);
-		}
+		err = vhd_read_header(ctx, &ctx->header);
 		if (err)
 			goto fail;
 
@@ -2739,49 +2416,27 @@
 		ctx->bm_secs = secs_round_up_no_zero(ctx->spb >> 3);
 	}
 
-	err = vhd_cache_load(ctx);
-	if (err) {
-		VHDLOG("failed to load cache: %d\n", err);
-		goto fail;
-	}
-
 	return 0;
 
 fail:
-	if (ctx->fd != -1) {
-		if (icb) icbinn_close(icb,ctx->fd);
-			else close(ctx->fd);
-	}
-
+	if (ctx->fd != -1)
+		close(ctx->fd);
 	free(ctx->file);
 	memset(ctx, 0, sizeof(vhd_context_t));
 	return err;
 }
 
-static void
-__vhd_close(vhd_context_t *ctx)
+void
+vhd_close(vhd_context_t *ctx)
 {
-	vhd_cache_unload(ctx);
-
-	if (ctx->file && ctx->fd != -1) {
-		fsync(ctx->fd);
+	if (ctx->file)
 		close(ctx->fd);
-	}
-
 	free(ctx->file);
 	free(ctx->bat.bat);
 	free(ctx->batmap.map);
 	memset(ctx, 0, sizeof(vhd_context_t));
 }
 
-void
-vhd_close(vhd_context_t *ctx)
-{
-	if (ctx->devops && ctx->devops->close)
-		return ctx->devops->close(ctx);
-	return __vhd_close(ctx);
-}
-
 static inline void
 vhd_initialize_footer(vhd_context_t *ctx, int type, uint64_t size)
 {
@@ -2797,18 +2452,19 @@
 	ctx->footer.geometry     = vhd_chs(size);
 	ctx->footer.type         = type;
 	ctx->footer.saved        = 0;
-	ctx->footer.data_offset  = 0xFFFFFFFFFFFFFFFFULL;
+	ctx->footer.data_offset  = 0xFFFFFFFFFFFFFFFF;
 	strcpy(ctx->footer.crtr_app, "tap");
-	uuid_generate(ctx->footer.uuid);
+	vhd_uuid_generate(&ctx->footer.uuid);
 }
 
-int
+static int
 vhd_initialize_header_parent_name(vhd_context_t *ctx, const char *parent_path)
 {
 	int err;
 	iconv_t cd;
 	size_t ibl, obl;
-	char *pname, *ppath, *dst;
+	char *ppath, *dst;
+	const char *pname;
 
 	err   = 0;
 	pname = NULL;
@@ -2842,7 +2498,11 @@
 
 	memset(dst, 0, obl);
 
-	if (iconv(cd, &pname, &ibl, &dst, &obl) == (size_t)-1 || ibl)
+	if (iconv(cd,
+#ifdef __linux__
+		(char **)
+#endif
+		&pname, &ibl, &dst, &obl) == (size_t)-1 || ibl)
 		err = (errno ? -errno : -EINVAL);
 
 out:
@@ -2851,39 +2511,25 @@
 	return err;
 }
 
-static off64_t
+static off_t
 get_file_size(const char *name)
 {
 	int fd;
-	off64_t end;
-
-	ICBINN *icb=vhd_icbinn_vhd();
-
-	if (icb) {
-		struct icbinn_stat buf;
-
-		if (icbinn_stat(icb,name,&buf))
-			return -1;
+	off_t end;
 
-		if (buf.type != ICBINN_TYPE_FILE)
-			return -1;
-		
-		end=buf.size;
-	} else {
-		fd = open(name, O_LARGEFILE | O_RDONLY);
-		if (fd == -1) {
-			VHDLOG("unable to open '%s': %d\n", name, errno);
-			return -errno;
-		}
-		end = lseek64(fd, 0, SEEK_END);
-		close(fd); 
+	fd = open(name, O_LARGEFILE | O_RDONLY);
+	if (fd == -1) {
+		VHDLOG("unable to open '%s': %d\n", name, errno);
+		return -errno;
 	}
+	end = lseek(fd, 0, SEEK_END);
+	close(fd); 
 	return end;
 }
 
 static int
-vhd_initialize_header(ICBINN *icb, vhd_context_t *ctx, const char *parent_path, 
-		uint64_t size, int raw, uint64_t *psize)
+vhd_initialize_header(vhd_context_t *ctx, const char *parent_path, 
+		uint64_t size, int raw)
 {
 	int err;
 	struct stat stats;
@@ -2901,30 +2547,21 @@
 	ctx->header.prt_ts       = 0;
 	ctx->header.res1         = 0;
 	ctx->header.max_bat_size = (ctx->footer.curr_size +
-			VHD_BLOCK_SIZE - 1) >> VHD_BLOCK_SHIFT;
+				    VHD_BLOCK_SIZE - 1) >> VHD_BLOCK_SHIFT;
 
 	ctx->footer.data_offset  = VHD_SECTOR_SIZE;
 
 	if (ctx->footer.type == HD_TYPE_DYNAMIC)
 		return 0;
 
-	if (icb) {
-		struct icbinn_stat buf;
-		err = icbinn_stat(icb,parent_path,&buf);
-		time( &stats.st_mtime );
-	} else {
-		err = stat(parent_path, &stats);
-	}
-
-
+	err = stat(parent_path, &stats);
 	if (err == -1)
 		return -errno;
 
 	if (raw) {
 		ctx->header.prt_ts = vhd_time(stats.st_mtime);
-		*psize = get_file_size(parent_path);
 		if (!size)
-			size = *psize;
+			size = get_file_size(parent_path);
 	}
 	else {
 		err = vhd_open(&parent, parent_path, VHD_OPEN_RDONLY);
@@ -2932,17 +2569,11 @@
 			return err;
 
 		ctx->header.prt_ts = vhd_time(stats.st_mtime);
-		uuid_copy(ctx->header.prt_uuid, parent.footer.uuid);
-		*psize = parent.footer.curr_size;
+		vhd_uuid_copy(&ctx->header.prt_uuid, &parent.footer.uuid);
 		if (!size)
-			size = *psize;
+			size = parent.footer.curr_size;
 		vhd_close(&parent);
 	}
-	if (size < *psize) {
-		VHDLOG("snapshot size (%llu) < parent size (%llu)\n",
-				size, *psize);
-		return -EINVAL;
-	}
 	ctx->footer.orig_size    = size;
 	ctx->footer.curr_size    = size;
 	ctx->footer.geometry     = vhd_chs(size);
@@ -2952,11 +2583,11 @@
 	return vhd_initialize_header_parent_name(ctx, parent_path);
 }
 
-int
+static int
 vhd_write_parent_locators(vhd_context_t *ctx, const char *parent)
 {
 	int i, err;
-	off64_t off;
+	off_t off;
 	uint32_t code;
 
 	code = PLAT_CODE_NONE;
@@ -3001,7 +2632,7 @@
 	struct stat stats;
 	vhd_context_t parent;
 
-	ppath = vhd_realpath(parent_path, NULL);
+	ppath = realpath(parent_path, NULL);
 	if (!ppath) {
 		VHDLOG("error resolving parent path %s for %s: %d\n",
 		       parent_path, child->file, errno);
@@ -3020,7 +2651,7 @@
 	}
 
 	if (raw) {
-		uuid_clear(child->header.prt_uuid);
+		vhd_uuid_clear(&child->header.prt_uuid);
 	} else {
 		err = vhd_open(&parent, ppath, VHD_OPEN_RDONLY);
 		if (err) {
@@ -3028,7 +2659,7 @@
 			       ppath, child->file, err);
 			goto out;
 		}
-		uuid_copy(child->header.prt_uuid, parent.footer.uuid);
+		vhd_uuid_copy(&child->header.prt_uuid, &parent.footer.uuid);
 		vhd_close(&parent);
 	}
 
@@ -3076,7 +2707,7 @@
 static int
 vhd_create_batmap(vhd_context_t *ctx)
 {
-	off64_t off;
+	off_t off;
 	int err, map_bytes;
 	vhd_batmap_header_t *header;
 
@@ -3156,7 +2787,7 @@
 		return err;
 
 	buf = mmap(0, VHD_BLOCK_SIZE, PROT_READ,
-		   MAP_SHARED | MAP_ANONYMOUS, -1, 0);
+		   MAP_SHARED | MAP_ANON, -1, 0);
 	if (buf == MAP_FAILED)
 		return -errno;
 
@@ -3174,7 +2805,7 @@
 }
 
 int 
-vhd_get_phys_size(vhd_context_t *ctx, off64_t *size)
+vhd_get_phys_size(vhd_context_t *ctx, off_t *size)
 {
 	int err;
 
@@ -3185,9 +2816,9 @@
 }
 
 int 
-vhd_set_phys_size(vhd_context_t *ctx, off64_t size)
+vhd_set_phys_size(vhd_context_t *ctx, off_t size)
 {
-	off64_t phys_size;
+	off_t phys_size;
 	int err;
 
 	err = vhd_get_phys_size(ctx, &phys_size);
@@ -3204,45 +2835,15 @@
 }
 
 static int
-vhd_set_virt_size_no_write(vhd_context_t *ctx, uint64_t size)
-{
-	if ((size >> VHD_BLOCK_SHIFT) > ctx->header.max_bat_size) {
-		VHDLOG("not enough metadata space reserved for fast "
-				"resize (BAT size %u, need %llu)\n",
-				ctx->header.max_bat_size, 
-				size >> VHD_BLOCK_SHIFT);
-		return -EINVAL;
-	}
-
-	/* update footer */
-	ctx->footer.curr_size = size;
-	ctx->footer.geometry  = vhd_chs(ctx->footer.curr_size);
-	ctx->footer.checksum  = vhd_checksum_footer(&ctx->footer);
-	return 0;
-}
-
-int
-vhd_set_virt_size(vhd_context_t *ctx, uint64_t size)
-{
-	int err;
-
-	err = vhd_set_virt_size_no_write(ctx, size);
-	if (err)
-		return err;
-	return vhd_write_footer(ctx, &ctx->footer);
-}
-
-static int
 __vhd_create(const char *name, const char *parent, uint64_t bytes, int type,
-		uint64_t mbytes, vhd_flag_creat_t flags)
+		vhd_flag_creat_t flags)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	vhd_context_t ctx;
 	vhd_footer_t *footer;
 	vhd_header_t *header;
-	uint64_t size, psize, blks;
-	ICBINN *icb;
+	uint64_t size, blks;
 
 	switch (type) {
 	case HD_TYPE_DIFF:
@@ -3258,34 +2859,14 @@
 	if (strnlen(name, VHD_MAX_NAME_LEN - 1) == VHD_MAX_NAME_LEN - 1)
 		return -ENAMETOOLONG;
 
-	if (bytes && mbytes && mbytes < bytes)
-		return -EINVAL;
-
 	memset(&ctx, 0, sizeof(vhd_context_t));
-	psize = 0;
 	footer = &ctx.footer;
 	header = &ctx.header;
 	blks   = (bytes + VHD_BLOCK_SIZE - 1) >> VHD_BLOCK_SHIFT;
-	/* If mbytes is provided (virtual-size-for-metadata-preallocation),
-	 * create the VHD of size mbytes, which will create the BAT & the 
-	 * batmap of the appropriate size. Once the BAT & batmap are 
-	 * initialized, reset the virtual size to the requested one.
-	 */
-	if (mbytes)
-		blks = (mbytes + VHD_BLOCK_SIZE - 1) >> VHD_BLOCK_SHIFT;
-	size = blks << VHD_BLOCK_SHIFT;
-
-
-	icb = vhd_icbinn_vhd();
-	
-	if (icb) {
-		ctx.fd = icbinn_open(icb, (char *) name, ICBINN_WRONLY | ICBINN_CREAT | ICBINN_TRUNC);
-		ctx.devops = &vhd_icbinn_devops;
-	} else {
-		ctx.fd = open(name, O_WRONLY | O_CREAT |
-			      O_TRUNC | O_LARGEFILE | O_DIRECT, 0644);
-	}
+	size   = blks << VHD_BLOCK_SHIFT;
 
+	ctx.fd = open(name, O_WRONLY | O_CREAT |
+		      O_TRUNC | O_LARGEFILE | O_DIRECT, 0644);
 	if (ctx.fd == -1)
 		return -errno;
 
@@ -3295,13 +2876,9 @@
 		goto out;
 	}
 
-	if (icb) {
-		ctx.is_block = 0;
-	} else {
-		err = vhd_test_file_fixed(ctx.file, &ctx.is_block);
-		if (err)
-			goto out;
-	}
+	err = vhd_test_file_fixed(ctx.file, &ctx.is_block);
+	if (err)
+		goto out;
 
 	vhd_initialize_footer(&ctx, type, size);
 
@@ -3311,7 +2888,15 @@
 			goto out;
 	} else {
 		int raw = vhd_flag_test(flags, VHD_FLAG_CREAT_PARENT_RAW);
-		err = vhd_initialize_header(icb, &ctx, parent, size, raw, &psize);
+		err = vhd_initialize_header(&ctx, parent, size, raw);
+		if (err)
+			goto out;
+
+		err = vhd_write_footer_at(&ctx, &ctx.footer, 0);
+		if (err)
+			goto out;
+
+		err = vhd_write_header_at(&ctx, &ctx.header, VHD_SECTOR_SIZE);
 		if (err)
 			goto out;
 
@@ -3328,29 +2913,8 @@
 			if (err)
 				goto out;
 		}
-	}
-
-	if (mbytes) {
-		/* set the virtual size to the requested size */
-		if (bytes) {
-			blks = (bytes + VHD_BLOCK_SIZE - 1) >> VHD_BLOCK_SHIFT;
-			size = blks << VHD_BLOCK_SHIFT;
-
-		}
-		else {
-			size = psize;
-		}
-		ctx.footer.orig_size = size;
-		err = vhd_set_virt_size_no_write(&ctx, size);
-		if (err)
-			goto out;
-	}
-
-	if (type != HD_TYPE_FIXED) {
-		err = vhd_write_footer_at(&ctx, &ctx.footer, 0);
-		if (err)
-			goto out;
 
+		/* write header again since it may have changed */
 		err = vhd_write_header_at(&ctx, &ctx.header, VHD_SECTOR_SIZE);
 		if (err)
 			goto out;
@@ -3361,7 +2925,7 @@
 		goto out;
 
 	off = vhd_position(&ctx);
-	if (off == (off64_t)-1) {
+	if (off == (off_t)-1) {
 		err = -errno;
 		goto out;
 	}
@@ -3377,25 +2941,22 @@
 
 out:
 	vhd_close(&ctx);
-	if (err && !ctx.is_block) {
-		if (icb) icbinn_unlink(icb, name);
-			else unlink(name);
-	}
+	if (err && !ctx.is_block)
+		unlink(name);
 	return err;
 }
 
 int
-vhd_create(const char *name, uint64_t bytes, int type, uint64_t mbytes,
-		vhd_flag_creat_t flags)
+vhd_create(const char *name, uint64_t bytes, int type, vhd_flag_creat_t flags)
 {
-	return __vhd_create(name, NULL, bytes, type, mbytes, flags);
+	return __vhd_create(name, NULL, bytes, type, flags);
 }
 
 int
 vhd_snapshot(const char *name, uint64_t bytes, const char *parent,
-		uint64_t mbytes, vhd_flag_creat_t flags)
+		vhd_flag_creat_t flags)
 {
-	return __vhd_create(name, parent, bytes, HD_TYPE_DIFF, mbytes, flags);
+	return __vhd_create(name, parent, bytes, HD_TYPE_DIFF, flags);
 }
 
 static int
@@ -3439,7 +3000,7 @@
 __vhd_io_dynamic_read_link(vhd_context_t *ctx, char *map,
 			   char *buf, uint64_t sector, uint32_t secs)
 {
-	off64_t off;
+	off_t off;
 	uint32_t blk, sec;
 	int err, cnt, map_off;
 	char *bitmap, *data, *src;
@@ -3495,7 +3056,7 @@
 		char *map, char *buf, uint64_t sec, uint32_t secs)
 {
 	int fd, err;
-	off64_t off;
+	off_t off;
 	uint64_t size;
 	char *data;
 
@@ -3507,8 +3068,8 @@
 		return -errno;
 	}
 
-	off = lseek64(fd, vhd_sectors_to_bytes(sec), SEEK_SET);
-	if (off == (off64_t)-1) {
+	off = lseek(fd, vhd_sectors_to_bytes(sec), SEEK_SET);
+	if (off == (off_t)-1) {
 		VHDLOG("%s: seek(0x%08"PRIx64") failed: %d\n",
 		       filename, vhd_sectors_to_bytes(sec), -errno);
 		err = -errno;
@@ -3573,16 +3134,6 @@
 		}
 
 		if (vhd->footer.type == HD_TYPE_DIFF) {
-			vhd_context_t *p;
-			p = vhd_cache_get_parent(vhd);
-			if (p) {
-				vhd = p;
-				err = vhd_get_bat(vhd);
-				if (err)
-					goto out;
-				continue;
-			}
-
 			err = vhd_parent_locator_get(vhd, &next);
 			if (err)
 				goto close;
@@ -3613,7 +3164,7 @@
 	}
 
 close:
-	if (vhd != ctx && !vhd_flag_test(vhd->oflags, VHD_OPEN_CACHED))
+	if (vhd != ctx)
 		vhd_close(vhd);
 out:
 	free(map);
@@ -3651,8 +3202,8 @@
 {
 	char *buf;
 	size_t size;
-	off64_t off, max;
-	int err, gap, spp, secs;
+	off_t off, max;
+	int i, err, gap, spp;
 
 	spp = getpagesize() >> VHD_SECTOR_SHIFT;
 
@@ -3674,12 +3225,8 @@
 	if (err)
 		return err;
 
-	secs = ctx->bm_secs + gap;
-	if (!vhd_flag_test(ctx->oflags, VHD_OPEN_IO_WRITE_SPARSE))
-		secs += ctx->spb;
-
-	size = vhd_sectors_to_bytes(secs);
-	buf  = mmap(0, size, PROT_READ, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
+	size = vhd_sectors_to_bytes(ctx->spb + ctx->bm_secs + gap);
+	buf  = mmap(0, size, PROT_READ, MAP_SHARED | MAP_ANON, -1, 0);
 	if (buf == MAP_FAILED)
 		return -errno;
 
@@ -3704,7 +3251,7 @@
 		       char *buf, uint64_t sector, uint32_t secs)
 {
 	char *map;
-	off64_t off;
+	off_t off;
 	uint32_t blk, sec;
 	int i, err, cnt, ret;
 
@@ -3803,833 +3350,3 @@
 
 	return __vhd_io_dynamic_write(ctx, buf, sec, secs);
 }
-
-static void
-vhd_cache_init(vhd_context_t *ctx)
-{
-	INIT_LIST_HEAD(&ctx->next);
-}
-
-static int
-vhd_cache_enabled(vhd_context_t *ctx)
-{
-	return vhd_flag_test(ctx->oflags, VHD_OPEN_CACHED);
-}
-
-static int
-vhd_cache_load(vhd_context_t *ctx)
-{
-	char *next;
-	int err, pflags;
-	vhd_context_t *vhd;
-
-	err    = 1;
-	pflags = ctx->oflags;
-	vhd    = ctx;
-	next   = NULL;
-
-	vhd_flag_set(pflags, VHD_OPEN_RDONLY);
-	vhd_flag_clear(pflags, VHD_OPEN_CACHED);
-
-	if (!vhd_cache_enabled(vhd))
-		goto done;
-
-	while (vhd->footer.type == HD_TYPE_DIFF) {
-		vhd_context_t *parent;
-
-		parent = NULL;
-
-		if (vhd_parent_raw(vhd))
-			goto done;
-
-		err = vhd_parent_locator_get(vhd, &next);
-		if (err)
-			goto out;
-
-		parent = calloc(1, sizeof(*parent));
-		if (!parent)
-			goto out;
-
-		err = vhd_open(parent, next, pflags);
-		if (err) {
-			free(parent);
-			parent = NULL;
-			goto out;
-		}
-
-		fcntl(parent->fd, F_SETFL,
-		      fcntl(parent->fd, F_GETFL) & ~O_DIRECT);
-		vhd_flag_set(parent->oflags, VHD_OPEN_CACHED);
-		list_add(&parent->next, &vhd->next);
-
-		free(next);
-		next = NULL;
-		vhd  = parent;
-	}
-
-done:
-	err = 0;
-out:
-	free(next);
-	if (err)
-		vhd_cache_unload(vhd);
-
-	return err;
-}
-
-static int
-vhd_cache_unload(vhd_context_t *ctx)
-{
-	vhd_context_t *vhd, *tmp;
-
-	if (!vhd_cache_enabled(ctx))
-		goto out;
-
-	list_for_each_entry_safe(vhd, tmp, &ctx->next, next) {
-		list_del_init(&vhd->next);
-		vhd_close(vhd);
-		free(vhd);
-	}
-
-	INIT_LIST_HEAD(&ctx->next);
-
-out:
-	return 0;
-}
-
-static vhd_context_t *
-vhd_cache_get_parent(vhd_context_t *ctx)
-{
-	vhd_context_t *vhd;
-
-	vhd = NULL;
-
-	if (!vhd_cache_enabled(ctx))
-		goto out;
-
-	if (list_empty(&ctx->next))
-		goto out;
-
-	vhd = list_entry(ctx->next.next, vhd_context_t, next);
-
-out:
-	return vhd;
-}
-
-typedef struct vhd_block_vector vhd_block_vector_t;
-typedef struct vhd_block_vector_entry vhd_block_vector_entry_t;
-
-struct vhd_block_vector_entry {
-	uint64_t                   off;       /* byte offset from block */
-	uint32_t                   bytes;     /* size in bytes */
-	char                      *buf;       /* destination buffer */
-};
-
-struct vhd_block_vector {
-	uint32_t                   block;     /* logical block in vhd */
-	int                        entries;   /* number of vector entries */
-	vhd_block_vector_entry_t  *array;     /* vector list */
-};
-
-/**
- * @vec: block vector describing read
- *
- * @vec describes a list of byte-spans within a given block
- * and a corresponding list of destination buffers.
- */
-static int
-vhd_block_vector_read(vhd_context_t *ctx, vhd_block_vector_t *vec)
-{
-	int err, i;
-	off64_t off;
-	uint32_t blk;
-
-	err = vhd_get_bat(ctx);
-	if (err)
-		goto out;
-
-	if (vec->block >= ctx->bat.entries) {
-		err = -ERANGE;
-		goto out;
-	}
-
-	blk = ctx->bat.bat[vec->block];
-	if (blk == DD_BLK_UNUSED) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	off = vhd_sectors_to_bytes(blk + ctx->bm_secs);
-
-	for (i = 0; i < vec->entries; i++) {
-		vhd_block_vector_entry_t *v = vec->array + i;
-		err = vhd_pread(ctx, v->buf, v->bytes, off + v->off);
-		if (err)
-			goto out;
-	}
-
-out:
-	return err;
-}
-
-/**
- * @vec: block vector to initialize
- * @block: vhd block number
- * @map: optional bitmap of sectors to map (relative to beginning of block)
- * @buf: destination buffer
- * @blk_start: byte offset relative to beginning of block
- * @blk_end: byte offset relative to beginning of block
- *
- * initializes @vec to describe a read into a contiguous buffer
- * of potentially non-contiguous byte ranges in a given vhd block.
- * only sectors with corresponding bits set in @map (if it is not NULL)
- * will be mapped; bits corresponding to unmapped sectors will be cleared.
- * first and last sector maps may be smaller than vhd sector size.
- */
-static int
-vhd_block_vector_init(vhd_context_t *ctx,
-		      vhd_block_vector_t *vec, uint32_t block, char *map,
-		      char *buf, uint64_t blk_start, uint64_t blk_end)
-{
-	int err, sec;
-	char *bitmap;
-	uint32_t first_sec, last_sec;
-
-	bitmap = NULL;
-	memset(vec, 0, sizeof(*vec));
-
-	first_sec = blk_start >> VHD_SECTOR_SHIFT;
-	last_sec  = secs_round_up_no_zero(blk_end);
-
-	err = vhd_read_bitmap(ctx, block, &bitmap);
-	if (err)
-		goto out;
-
-	vec->array = calloc(ctx->spb, sizeof(vhd_block_vector_entry_t));
-	if (!vec->array) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	for (sec = first_sec; sec < last_sec; sec++) {
-		uint32_t cnt;
-		vhd_block_vector_entry_t *v;
-
-		cnt = VHD_SECTOR_SIZE - (blk_start & (VHD_SECTOR_SIZE - 1));
-		if (cnt > blk_end - blk_start)
-			cnt = blk_end - blk_start;
-
-		if (map && !test_bit(map, sec))
-			goto next;
-
-		if (vhd_bitmap_test(ctx, bitmap, sec)) {
-			if (vec->entries > 0) {
-				v = vec->array + vec->entries - 1;
-				if (v->off + v->bytes == blk_start) {
-					v->bytes += cnt;
-					goto next;
-				}
-			}
-
-			v        = vec->array + vec->entries;
-			v->off   = blk_start;
-			v->bytes = cnt;
-			v->buf   = buf;
-
-			vec->entries++;
-
-		} else if (map) {
-			clear_bit(map, sec);
-		}
-
-	next:
-		blk_start += cnt;
-		buf       += cnt;
-	}
-
-	vec->block = block;
-
-out:
-	free(bitmap);
-	return err;
-}
-
-#if 0
-/**
- * @block: vhd block number
- * @buf: buffer to place data in
- * @size: number of bytes to read
- * @start: byte offset into block from which to start reading
- * @end: byte offset in block at which to stop reading
- *
- * reads data (if it exists) into @buf.  partial reads may occur
- * for the first and last sectors if @start and @end are not multiples
- * of vhd sector size.
- */
-static int
-vhd_block_vector_read_allocated(vhd_context_t *ctx, uint32_t block,
-				char *buf, uint64_t start, uint64_t end)
-{
-	int err;
-	vhd_block_vector_t vec;
-
-	vec.array = NULL;
-
-	err = vhd_block_vector_init(ctx, &vec, block, NULL, buf, start, end);
-	if (err)
-		goto out;
-
-	err = vhd_block_vector_read(ctx, &vec);
-
-out:
-	free(vec.array);
-	return err;
-}
-#endif
-
-/**
- * @block: vhd block number
- * @map: bitmap of sectors in block which should be read
- * @buf: buffer to place data in
- * @start: byte offset into block from which to start reading
- * @end: byte offset in block at which to stop reading
- *
- * for every bit set in @map (corresponding to sectors in @block),
- * reads data (if it exists) into @buf.  if data does not exist,
- * clears corresponding bit in @map.  partial reads may occur
- * for the first and last sectors if @start and @end are not multiples
- * of vhd sector size.
- */
-static int
-vhd_block_vector_read_allocated_selective(vhd_context_t *ctx,
-					  uint32_t block, char *map, char *buf,
-					  uint64_t start, uint64_t end)
-{
-	int err;
-	vhd_block_vector_t vec;
-
-	vec.array = NULL;
-
-	err = vhd_block_vector_init(ctx, &vec, block, map, buf, start, end);
-	if (err)
-		goto out;
-
-	err = vhd_block_vector_read(ctx, &vec);
-
-out:
-	free(vec.array);
-	return err;
-}
-
-/**
- * @map: bitmap of sectors which have already been read
- * @buf: destination buffer
- * @size: size in bytes to read
- * @off: byte offset in virtual disk to read
- *
- * reads @size bytes into @buf, starting at @off, skipping sectors
- * which have corresponding bits set in @map
- */
-static int
-__vhd_io_dynamic_read_link_bytes(vhd_context_t *ctx, char *map,
-				 char *buf, size_t size, uint64_t off)
-{
-	char *blkmap;
-	int i, err, map_off;
-	off64_t blk_off, blk_size;
-	uint32_t blk, bytes, first_sec, last_sec;
-
-	blkmap = malloc((ctx->spb + 7) >> 3);
-	if (!blkmap) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	map_off  = 0;
-	blk_size = vhd_sectors_to_bytes(ctx->spb);
-
-	do {
-		blk     = off / blk_size;
-		blk_off = off % blk_size;
-		bytes   = MIN(blk_size - blk_off, size);
-
-		first_sec = blk_off >> VHD_SECTOR_SHIFT;
-		last_sec  = secs_round_up_no_zero(blk_off + bytes);
-
-		if (ctx->bat.bat[blk] == DD_BLK_UNUSED)
-			goto next;
-
-		memset(blkmap, 0, (ctx->spb + 7) >> 3);
-
-		for (i = 0; i < (last_sec - first_sec); i++)
-			if (!test_bit(map, map_off + i))
-				set_bit(blkmap, first_sec + i);
-
-		err = vhd_block_vector_read_allocated_selective(ctx, blk,
-								blkmap, buf,
-								blk_off,
-								blk_off +
-								bytes);
-		if (err)
-			goto out;
-
-		for (i = 0; i < (last_sec - first_sec); i++)
-			if (test_bit(blkmap, first_sec + i))
-				set_bit(map, map_off + i);
-
-	next:
-		size    -= bytes;
-		off     += bytes;
-		map_off += (last_sec - first_sec);
-		buf     += bytes;
-
-	} while (size);
-
-	err = 0;
-out:
-	free(blkmap);
-	return err;
-}
-
-static int
-__raw_read_link_bytes(const char *filename,
-		      char *map, char *buf, size_t size, uint64_t off)
-{
-	int fd, err;
-	uint32_t i, first_sec, last_sec;
-
-	fd = open(filename, O_RDONLY | O_LARGEFILE);
-	if (fd == -1) {
-		VHDLOG("%s: failed to open: %d\n", filename, -errno);
-		return -errno;
-	}
-
-	first_sec = off >> VHD_SECTOR_SHIFT;
-	last_sec  = secs_round_up_no_zero(off + size);
-
-	for (i = first_sec; i < last_sec; i++) {
-		if (!test_bit(map, i - first_sec)) {
-			uint32_t secs = 0;
-			uint64_t coff, csize;
-
-			while (i + secs < last_sec &&
-			       !test_bit(map, i + secs - first_sec))
-				secs++;
-
-			coff  = vhd_sectors_to_bytes(i);
-			csize = vhd_sectors_to_bytes(secs);
-
-			if (i == first_sec)
-				coff = off;
-			if (secs == last_sec - 1)
-				csize = (off + size) - coff;
-
-			if (pread(fd, buf + coff - off, csize, coff) != csize) {
-				err = (errno ? -errno : -EIO);
-				goto close;
-			}
-
-			i += secs - 1;
-		}
-	}
-
-	err = 0;
-
-close:
-	close(fd);
-	return err;
-}
-
-static int
-__vhd_io_dynamic_read_bytes(vhd_context_t *ctx,
-			    char *buf, size_t size, uint64_t off)
-{
-	int err;
-	char *next, *map;
-	vhd_context_t parent, *vhd;
-	uint32_t i, done, first_sec, last_sec;
-
-	err  = vhd_get_bat(ctx);
-	if (err)
-		return err;
-
-	first_sec = off >> VHD_SECTOR_SHIFT;
-	last_sec  = secs_round_up_no_zero(off + size);
-
-	vhd  = ctx;
-	next = NULL;
-	map  = calloc(1, ((last_sec - first_sec) + 7) >> 3);
-	if (!map) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	for (;;) {
-		err = __vhd_io_dynamic_read_link_bytes(vhd, map,
-						       buf, size, off);
-		if (err)
-			goto close;
-
-		for (done = 0, i = 0; i < (last_sec - first_sec); i++)
-			if (test_bit(map, i))
-				done++;
-
-		if (done == last_sec - first_sec) {
-			err = 0;
-			goto close;
-		}
-
-		if (vhd->footer.type == HD_TYPE_DIFF) {
-			vhd_context_t *p;
-			p = vhd_cache_get_parent(vhd);
-			if (p) {
-				vhd = p;
-				err = vhd_get_bat(vhd);
-				if (err)
-					goto out;
-				continue;
-			}
-
-			err = vhd_parent_locator_get(vhd, &next);
-			if (err)
-				goto close;
-
-			if (vhd_parent_raw(vhd)) {
-				err = __raw_read_link_bytes(next, map,
-							    buf, size, off);
-				goto close;
-			}
-		} else {
-			err = 0;
-			goto close;
-		}
-
-		if (vhd != ctx)
-			vhd_close(vhd);
-		vhd = &parent;
-
-		err = vhd_open(vhd, next, VHD_OPEN_RDONLY);
-		if (err)
-			goto out;
-
-		err = vhd_get_bat(vhd);
-		if (err)
-			goto close;
-
-		free(next);
-		next = NULL;
-	}
-
-close:
-	if (!err) {
-		/*
-		 * clear any regions not present on disk
-		 */
-		for (i = first_sec; i < last_sec; i++) {
-			if (!test_bit(map, i - first_sec)) {
-				uint64_t coff  = vhd_sectors_to_bytes(i);
-				uint32_t csize = VHD_SECTOR_SIZE;
-
-				if (i == first_sec)
-					coff = off;
-				if (i == last_sec - 1)
-					csize = (off + size) - coff;
-
-				memset(buf + coff - off, 0, csize);
-			}
-		}
-	}
-
-	if (vhd != ctx && !vhd_flag_test(vhd->oflags, VHD_OPEN_CACHED))
-		vhd_close(vhd);
-out:
-	free(map);
-	free(next);
-	return err;
-}
-
-int
-vhd_io_read_bytes(vhd_context_t *ctx, char *buf, size_t size, uint64_t off)
-{
-	if (off + size > ctx->footer.curr_size)
-		return -ERANGE;
-
-	if (!vhd_type_dynamic(ctx))
-		return vhd_pread(ctx, buf, size, off);
-
-	return __vhd_io_dynamic_read_bytes(ctx, buf, size, off);
-}
-
-static int
-__vhd_io_dynamic_write_bytes_aligned(vhd_context_t *ctx,
-				     char *buf, size_t size, uint64_t off)
-{
-	char *map;
-	int i, err, ret, new;
-	uint64_t blk_off, blk_size, blk_start;
-	uint32_t blk, bytes, first_sec, last_sec;
-
-	if (off & (VHD_SECTOR_SIZE - 1) || size & (VHD_SECTOR_SIZE - 1))
-		return -EINVAL;
-
-	err = vhd_get_bat(ctx);
-	if (err)
-		return err;
-
-	if (vhd_has_batmap(ctx)) {
-		err = vhd_get_batmap(ctx);
-		if (err)
-			return err;
-	}
-
-	new      = 0;
-	map      = NULL;
-	blk_size = vhd_sectors_to_bytes(ctx->spb);
-
-	do {
-		blk     = off / blk_size;
-		blk_off = off % blk_size;
-		bytes   = MIN(blk_size - blk_off, size);
-
-		first_sec = blk_off >> VHD_SECTOR_SHIFT;
-		last_sec  = secs_round_up_no_zero(blk_off + bytes);
-
-		blk_start = ctx->bat.bat[blk];
-		if (blk_start == DD_BLK_UNUSED) {
-			err = __vhd_io_allocate_block(ctx, blk);
-			if (err)
-				goto fail;
-
-			blk_start = ctx->bat.bat[blk];
-			new = 1;
-		}
-
-		blk_start = vhd_sectors_to_bytes(blk_start + ctx->bm_secs);
-
-		err = vhd_pwrite(ctx, buf, bytes, blk_start + blk_off);
-		if (err)
-			goto fail;
-
-		if (vhd_has_batmap(ctx) &&
-		    vhd_batmap_test(ctx, &ctx->batmap, blk))
-			goto next;
-
-		err = vhd_read_bitmap(ctx, blk, &map);
-		if (err) {
-			map = NULL;
-			goto fail;
-		}
-
-		for (i = first_sec; i < last_sec; i++)
-			vhd_bitmap_set(ctx, map, i);
-
-		err = vhd_write_bitmap(ctx, blk, map);
-		if (err)
-			goto fail;
-
-		if (vhd_has_batmap(ctx)) {
-			for (i = 0; i < ctx->spb; i++)
-				if (!vhd_bitmap_test(ctx, map, i)) {
-					free(map);
-					map = NULL;
-					goto next;
-				}
-
-			vhd_batmap_set(ctx, &ctx->batmap, blk);
-			err = vhd_write_batmap(ctx, &ctx->batmap);
-			if (err)
-				goto fail;
-		}
-
-		free(map);
-		map = NULL;
-
-	next:
-		size   -= bytes;
-		off    += bytes;
-		buf    += bytes;
-
-	} while (size);
-
-	err = 0;
-
-out:
-	ret = (new ? vhd_write_footer(ctx, &ctx->footer) : 0);
-	return (err ? err : ret);
-
-fail:
-	free(map);
-	goto out;
-}
-
-static int
-__vhd_io_dynamic_write_bytes(vhd_context_t *ctx,
-			     char *buf, size_t size, uint64_t off)
-{
-	int err;
-	char *tmp;
-	uint32_t first_sec, last_sec, first_sec_off, last_sec_off;
-
-	err = 0;
-	tmp = NULL;
-
-	first_sec = off >> VHD_SECTOR_SHIFT;
-	last_sec  = secs_round_up_no_zero(off + size);
-
-	first_sec_off = off & (VHD_SECTOR_SIZE - 1);
-	last_sec_off  = (off + size) & (VHD_SECTOR_SIZE - 1);
-
-	if (first_sec_off || last_sec_off) {
-		tmp = malloc(VHD_SECTOR_SIZE);
-		if (!tmp) {
-			err = -ENOMEM;
-			goto out;
-		}
-
-		if (first_sec_off) {
-			uint32_t new = VHD_SECTOR_SIZE - first_sec_off;
-			if (new > size)
-				new = size;
-
-			err = vhd_io_read_bytes(
-				ctx, tmp, VHD_SECTOR_SIZE,
-				vhd_sectors_to_bytes(first_sec));
-			if (err)
-				goto out;
-
-			memcpy(tmp + first_sec_off, buf, new);
-
-			err = __vhd_io_dynamic_write_bytes_aligned(
-				ctx, tmp, VHD_SECTOR_SIZE,
-				vhd_sectors_to_bytes(first_sec));
-			if (err)
-				goto out;
-
-			buf  += new;
-			off  += new;
-			size -= new;
-		}
-
-		if (last_sec_off &&
-		    (last_sec - first_sec > 1 || !first_sec_off)) {
-			uint32_t new = last_sec_off;
-
-			err = vhd_io_read_bytes(
-				ctx, tmp, VHD_SECTOR_SIZE,
-				vhd_sectors_to_bytes(last_sec - 1));
-			if (err)
-				goto out;
-
-			memcpy(tmp, buf + size - new, new);
-
-			err = __vhd_io_dynamic_write_bytes_aligned(
-				ctx, tmp, VHD_SECTOR_SIZE,
-				vhd_sectors_to_bytes(last_sec - 1));
-			if (err)
-				goto out;
-
-			size -= new;
-		}
-	}
-
-	if (size)
-		err = __vhd_io_dynamic_write_bytes_aligned(ctx, buf, size, off);
-
-out:
-	free(tmp);
-	return err;
-}
-
-int
-vhd_io_write_bytes(vhd_context_t *ctx, char *buf, size_t size, uint64_t off)
-{
-	if (off + size > ctx->footer.curr_size)
-		return -ERANGE;
-
-	if (!vhd_type_dynamic(ctx))
-		return vhd_pwrite(ctx, buf, size, off);
-
-	return __vhd_io_dynamic_write_bytes(ctx, buf, size, off);
-}
-
-int
-vhd_marker(vhd_context_t *ctx, char *marker)
-{
-	int err;
-	vhd_batmap_t batmap;
-
-	*marker = 0;
-
-	if (!vhd_has_batmap(ctx))
-		return xattr_get(ctx->fd,
-				 VHD_XATTR_MARKER,
-				 (void *)marker,
-				 sizeof(*marker));
-
-	err = vhd_read_batmap_header(ctx, &batmap);
-	if (err)
-		return err;
-
-	*marker = batmap.header.marker;
-	return 0;
-}
-
-int
-vhd_set_marker(vhd_context_t *ctx, char marker)
-{
-	int err;
-	vhd_batmap_t batmap;
-
-	if (!vhd_has_batmap(ctx))
-		return xattr_set(ctx->fd,
-				 VHD_XATTR_MARKER,
-				 (void *)&marker,
-				 sizeof(marker));
-
-	err = vhd_read_batmap_header(ctx, &batmap);
-	if (err)
-		return err;
-
-	batmap.header.marker = marker;
-	return vhd_write_batmap_header(ctx, &batmap);
-}
-
-int
-vhd_get_keyhash(vhd_context_t *ctx, struct vhd_keyhash *keyhash)
-{
-	int err;
-	vhd_batmap_t batmap;
-
-	if (!vhd_has_batmap(ctx))
-		return xattr_get(ctx->fd,
-				 VHD_XATTR_KEYHASH,
-				 (void *)keyhash,
-				 sizeof(*keyhash));
-
-	err = vhd_read_batmap_header(ctx, &batmap);
-	if (err)
-		return err;
-
-	memcpy(keyhash, &batmap.header.keyhash, sizeof(*keyhash));
-	return 0;
-}
-
-int
-vhd_set_keyhash(vhd_context_t *ctx, const struct vhd_keyhash *keyhash)
-{
-	int err;
-	vhd_batmap_t batmap;
-
-	if (!vhd_has_batmap(ctx))
-		return xattr_set(ctx->fd,
-				 VHD_XATTR_KEYHASH,
-				 (void *)keyhash,
-				 sizeof(*keyhash));
-
-	err = vhd_read_batmap_header(ctx, &batmap);
-	if (err)
-		return err;
-
-	memcpy(&batmap.header.keyhash, keyhash, sizeof(*keyhash));
-	return vhd_write_batmap_header(ctx, &batmap);
-}
diff -Nur blktap2_oxt//vhd/lib/libvhd-journal.c blktap2_xen//vhd/lib/libvhd-journal.c
--- blktap2_oxt//vhd/lib/libvhd-journal.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/libvhd-journal.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -56,21 +52,21 @@
 } vhd_journal_entry_t;
 
 static inline int
-vhd_journal_seek(vhd_journal_t *j, off64_t offset, int whence)
+vhd_journal_seek(vhd_journal_t *j, off_t offset, int whence)
 {
-	off64_t off;
+	off_t off;
 
-	off = lseek64(j->jfd, offset, whence);
-	if (off == (off64_t)-1)
+	off = lseek(j->jfd, offset, whence);
+	if (off == (off_t)-1)
 		return -errno;
 
 	return 0;
 }
 
-static inline off64_t
+static inline off_t
 vhd_journal_position(vhd_journal_t *j)
 {
-	return lseek64(j->jfd, 0, SEEK_CUR);
+	return lseek(j->jfd, 0, SEEK_CUR);
 }
 
 static inline int
@@ -102,7 +98,7 @@
 }
 
 static inline int
-vhd_journal_truncate(vhd_journal_t *j, off64_t length)
+vhd_journal_truncate(vhd_journal_t *j, off_t length)
 {
 	int err;
 
@@ -149,7 +145,7 @@
 vhd_journal_validate_header(vhd_journal_t *j, vhd_journal_header_t *header)
 {
 	int err;
-	off64_t eof;
+	off_t eof;
 
 	if (memcmp(header->cookie,
 		   VHD_JOURNAL_HEADER_COOKIE, sizeof(header->cookie)))
@@ -160,7 +156,7 @@
 		return err;
 
 	eof = vhd_journal_position(j);
-	if (eof == (off64_t)-1)
+	if (eof == (off_t)-1)
 		return -errno;
 
 	if (j->header.journal_data_offset > j->header.journal_eof)
@@ -223,7 +219,7 @@
 vhd_journal_add_journal_header(vhd_journal_t *j)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	vhd_context_t *vhd;
 
 	vhd = &j->vhd;
@@ -234,14 +230,14 @@
 		return err;
 
 	off = vhd_position(vhd);
-	if (off == (off64_t)-1)
+	if (off == (off_t)-1)
 		return -errno;
 
 	err = vhd_get_footer(vhd);
 	if (err)
 		return err;
 
-	uuid_copy(j->header.uuid, vhd->footer.uuid);
+	vhd_uuid_copy(&j->header.uuid, &vhd->footer.uuid);
 	memcpy(j->header.cookie,
 	       VHD_JOURNAL_HEADER_COOKIE, sizeof(j->header.cookie));
 	j->header.vhd_footer_offset = off - sizeof(vhd_footer_t);
@@ -357,10 +353,11 @@
 }
 
 static int
-vhd_journal_update(vhd_journal_t *j, off64_t offset,
+vhd_journal_update(vhd_journal_t *j, off_t offset,
 		   char *buf, size_t size, uint32_t type)
 {
 	int err;
+	off_t eof;
 	uint64_t *off, off_bak;
 	uint32_t *entries;
 	vhd_journal_entry_t entry;
@@ -416,7 +413,7 @@
 vhd_journal_add_footer(vhd_journal_t *j)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	vhd_context_t *vhd;
 	vhd_footer_t footer;
 
@@ -427,7 +424,7 @@
 		return err;
 
 	off = vhd_position(vhd);
-	if (off == (off64_t)-1)
+	if (off == (off_t)-1)
 		return -errno;
 
 	err = vhd_read_footer_at(vhd, &footer, off - sizeof(vhd_footer_t));
@@ -462,7 +459,7 @@
 vhd_journal_add_header(vhd_journal_t *j)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	vhd_context_t *vhd;
 	vhd_header_t header;
 
@@ -498,7 +495,7 @@
 	n = sizeof(vhd->header.loc) / sizeof(vhd_parent_locator_t);
 	for (i = 0; i < n; i++) {
 		char *buf;
-		off64_t off;
+		off_t off;
 		size_t size;
 		vhd_parent_locator_t *loc;
 
@@ -545,7 +542,7 @@
 vhd_journal_add_bat(vhd_journal_t *j)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	size_t size;
 	vhd_bat_t bat;
 	vhd_context_t *vhd;
@@ -575,7 +572,7 @@
 vhd_journal_add_batmap(vhd_journal_t *j)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	size_t size;
 	vhd_context_t *vhd;
 	vhd_batmap_t batmap;
@@ -614,6 +611,7 @@
 vhd_journal_add_metadata(vhd_journal_t *j)
 {
 	int err;
+	off_t eof;
 	vhd_context_t *vhd;
 
 	vhd = &j->vhd;
@@ -906,7 +904,7 @@
 	if (err)
 		return err;
 
-	err = vhd_validate_batmap(&j->vhd, batmap);
+	err = vhd_validate_batmap(batmap);
 	if (err) {
 		free(batmap->map);
 		batmap->map = NULL;
@@ -932,7 +930,7 @@
 static int
 vhd_journal_restore_header(vhd_journal_t *j, vhd_header_t *header)
 {
-	off64_t off;
+	off_t off;
 	vhd_context_t *vhd;
 
 	vhd = &j->vhd;
@@ -987,7 +985,7 @@
 static int
 vhd_journal_restore_metadata(vhd_journal_t *j)
 {
-	off64_t off;
+	off_t off;
 	char **locators;
 	vhd_footer_t copy;
 	vhd_context_t *vhd;
@@ -1048,7 +1046,7 @@
 
 restore:
 	off  = vhd_journal_position(j);
-	if (off == (off64_t)-1)
+	if (off == (off_t)-1)
 		return -errno;
 
 	if (j->header.journal_data_offset != off)
@@ -1258,7 +1256,11 @@
 int
 vhd_journal_create(vhd_journal_t *j, const char *file, const char *jfile)
 {
-	int err;
+	char *buf;
+	int i, err;
+	size_t size;
+	off_t off;
+	struct stat stats;
 
 	memset(j, 0, sizeof(vhd_journal_t));
 	j->jfd = -1;
@@ -1343,7 +1345,7 @@
 {
 	int err;
 	char *buf;
-	off64_t off;
+	off_t off;
 	size_t size;
 	uint64_t blk;
 	vhd_context_t *vhd;
diff -Nur blktap2_oxt//vhd/lib/Makefile blktap2_xen//vhd/lib/Makefile
--- blktap2_oxt//vhd/lib/Makefile	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/Makefile	2015-03-19 11:08:36.000000000 -0400
@@ -1,41 +1,34 @@
-#
-# Copyright (c) 2012 Citrix Systems, Inc.
-#
-
-BLKTAP_ROOT := ../../
-include $(BLKTAP_ROOT)/Rules.mk
+XEN_ROOT=$(CURDIR)/../../../..
+BLKTAP_ROOT := ../..
+include $(XEN_ROOT)/tools/Rules.mk
 
 LIBVHD-MAJOR     = 1.0
 LIBVHD-MINOR     = 0
 LIBVHD-SONAME    = libvhd.so.$(LIBVHD-MAJOR)
 
-LVM-UTIL-OBJ    := $(BLKTAP_ROOT)lvm/lvm-util.o
+LVM-UTIL-OBJ    := $(BLKTAP_ROOT)/lvm/lvm-util.o
 
-LIBVHD          := libvhd.a libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR)
-LIBVHDIO        := libvhdio.a libvhdio.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR)
-LIBVHD-BUILD    := $(LIBVHD) $(LIBVHDIO)
+LIBVHD-BUILD    := libvhd.a
 
-INST-DIR         = /usr/lib
+INST-DIR         = $(LIBDIR)
 
-CFLAGS          += -Wall
-CFLAGS          += -Werror -Wno-error=unused-but-set-variable -Wno-error=uninitialized
+CFLAGS          += -Werror
+CFLAGS          += -Wno-unused
 CFLAGS          += -I../../include
 CFLAGS          += -D_GNU_SOURCE
-ifndef TRANSFERVM
 CFLAGS          += -fPIC
-endif
 CFLAGS          += -g
 
-LIBS            := -luuid -lcrypto -licbinn_resolved -ldl
+ifeq ($(CONFIG_Linux),y)
+LIBS            := -luuid
+endif
 
-# Get gcc to generate the dependencies for us.
-CFLAGS          += -Wp,-MD,.$(@F).d
-DEPS             = .*.d
+ifeq ($(CONFIG_LIBICONV),y)
+LIBS            += -liconv
+endif
 
 LIB-SRCS        := libvhd.c
 LIB-SRCS        += libvhd-journal.c
-LIB-SRCS        += libvhd-index.c
-LIB-SRCS        += libvhd-stream.c
 LIB-SRCS        += vhd-util-coalesce.c
 LIB-SRCS        += vhd-util-create.c
 LIB-SRCS        += vhd-util-fill.c
@@ -49,65 +42,39 @@
 LIB-SRCS        += vhd-util-snapshot.c
 LIB-SRCS        += vhd-util-scan.c
 LIB-SRCS        += vhd-util-check.c
-LIB-SRCS        += vhd-util-clone-metadata.c
-LIB-SRCS        += vhd-util-stream-coalesce.c
-LIB-SRCS        += vhd-util-dm-encrypt.c
-LIB-SRCS        += vhd-util-dm-decrypt.c
-LIB-SRCS        += vhd-util-key.c
+LIB-SRCS        += vhd-util-uuid.c
 LIB-SRCS        += relative-path.c
 LIB-SRCS        += atomicio.c
-LIB-SRCS        += xattr.c
 
 LIB-OBJS         = $(patsubst %.c,%.o,$(LIB-SRCS))
-ifndef TRANSFERVM
 LIB-OBJS        += $(LVM-UTIL-OBJ)
-endif
-
-LIBVHD-IO-LIBS  := -ldl -L./ -lvhd
-LIBVHD-IO-OBJS  := libvhdio.o $(BLKTAP_ROOT)/part/partition.o
-LIBVHD-IO        = libvhdio.a libvhdio.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR)
-LIBVHD-IO-SONAME = libvhdio.so.$(LIBVHD-MAJOR)
 
-all: build
+LIB-PICOBJS      = $(patsubst %.o,%.opic,$(LIB-OBJS))
 
-build: $(LIBVHD-BUILD)
+LIBVHD           = libvhd.a libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR)
 
-libvhd.so: libvhd.so.$(LIBVHD-MAJOR)
-	ln -sf $^ $@
-
-libvhdio.so: libvhdio.so.$(LIBVHD-MAJOR)
-	ln -sf $^ $@
-
-libvhd.so.$(LIBVHD-MAJOR): libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR)
-	ln -sf $^ $@
-
-libvhdio.so.$(LIBVHD-MAJOR): libvhdio.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR)
-	ln -sf $^ $@
-
-libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR): $(LIB-OBJS)
-	$(CC) $(CFLAGS) -Wl,$(SONAME_LDFLAG),$(LIBVHD-SONAME) $(SHLIB_CFLAGS) \
-		-o $@ $^ ${LIBS}
+all: build
 
-libvhdio.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR): $(LIBVHD-IO-OBJS) libvhd.so
-	$(CC) $(CFLAGS) -Wl,$(SONAME_LDFLAG),$(LIBVHD-IO-SONAME) $(SHLIB_CFLAGS) \
-		-o $@ $(LIBVHD-IO-LIBS) $^
+build: libvhd.a libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR)
 
 libvhd.a: $(LIB-OBJS)
 	$(AR) rc $@ $^
 
-libvhdio.a: $(LIBVHD-IO-OBJS)
-	$(AR) rc $@ $^
+libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR): $(LIB-PICOBJS)
+	$(CC) -Wl,$(SONAME_LDFLAG),$(LIBVHD-SONAME) $(SHLIB_LDFLAGS) \
+		$(LDFLAGS) -o libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR) $^ $(LIBS)
+	ln -sf libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR) libvhd.so.$(LIBVHD-MAJOR)
+	ln -sf libvhd.so.$(LIBVHD-MAJOR) libvhd.so
 
 install: all
 	$(INSTALL_DIR) -p $(DESTDIR)$(INST-DIR)
-	$(INSTALL_DATA) $(LIBVHD) $(LIBVHD-IO) $(DESTDIR)$(INST-DIR)
+	$(INSTALL_DATA) libvhd.a $(DESTDIR)$(INST-DIR)
+	$(INSTALL_PROG) libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR) $(DESTDIR)$(INST-DIR)
 	ln -sf libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR) $(DESTDIR)$(INST-DIR)/libvhd.so.$(LIBVHD-MAJOR)
 	ln -sf libvhd.so.$(LIBVHD-MAJOR) $(DESTDIR)$(INST-DIR)/libvhd.so
-	ln -sf libvhdio.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR) $(DESTDIR)$(INST-DIR)/libvhdio.so.$(LIBVHD-MAJOR)
-	ln -sf libvhdio.so.$(LIBVHD-MAJOR) $(DESTDIR)$(INST-DIR)/libvhdio.so
 
 clean:
-	rm -rf *.a *.so* *.o *~ $(DEPS) $(LIBVHD) $(LIBVHD-IO)
+	rm -rf *.a *.so* *.o *.opic *~ $(DEPS) $(LIBVHD)
 
 .PHONY: all build clean install libvhd
 
diff -Nur blktap2_oxt//vhd/lib/relative-path.c blktap2_xen//vhd/lib/relative-path.c
--- blktap2_oxt//vhd/lib/relative-path.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/relative-path.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,15 +23,12 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
 
-char *vhd_realpath(const char *path, char *resolved_path);
-
 #include "relative-path.h"
 
 #define sfree(ptr)         \
@@ -235,14 +229,14 @@
 		return NULL;
 	}
 
-	to_absolute = vhd_realpath(to, NULL);
+	to_absolute = realpath(to, NULL);
 	if (!to_absolute) {
 		EPRINTF("failed to get absolute path of %s\n", to);
 		*err = -errno;
 		goto out;
 	}
 
-	from_absolute = vhd_realpath(from, NULL);
+	from_absolute = realpath(from, NULL);
 	if (!from_absolute) {
 		EPRINTF("failed to get absolute path of %s\n", from);
 		*err = -errno;
diff -Nur blktap2_oxt//vhd/lib/vhd-util-check.c blktap2_xen//vhd/lib/vhd-util-check.c
--- blktap2_oxt//vhd/lib/vhd-util-check.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-check.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <time.h>
 #include <stdio.h>
 #include <errno.h>
@@ -38,7 +34,6 @@
 #include <inttypes.h>
 #include <sys/stat.h>
 
-#include "list.h"
 #include "libvhd.h"
 #include "vhd-util.h"
 
@@ -46,180 +41,6 @@
 // account for time skew with NFS servers
 #define TIMESTAMP_MAX_SLACK 1800
 
-struct vhd_util_check_options {
-	char                             ignore_footer;
-	char                             ignore_parent_uuid;
-	char                             ignore_timestamps;
-	char                             check_data;
-	char                             check_bitmaps;
-	char                             collect_stats;
-};
-
-struct vhd_util_check_stats {
-	char                            *name;
-	char                            *bitmap;
-	uint64_t                         secs_total;
-	uint64_t                         secs_allocated;
-	uint64_t                         secs_written;
-	struct list_head                 next;
-};
-
-struct vhd_util_check_ctx {
-	struct vhd_util_check_options    opts;
-	struct list_head                 stats;
-	int                              primary_footer_missing;
-};
-
-#define ctx_cur_stats(ctx) \
-	list_entry((ctx)->stats.next, struct vhd_util_check_stats, next)
-
-static inline int
-test_bit_u64(volatile char *addr, uint64_t nr)
-{
-	return ((addr[nr >> 3] << (nr & 7)) & 0x80) != 0;
-}
-
-static inline void
-set_bit_u64(volatile char *addr, uint64_t nr)
-{
-	addr[nr >> 3] |= (0x80 >> (nr & 7));
-}
-
-static void
-vhd_util_check_stats_init(struct vhd_util_check_ctx *ctx)
-{
-	memset(&ctx->stats, 0, sizeof(ctx->stats));
-	INIT_LIST_HEAD(&ctx->stats);
-}
-
-static void
-vhd_util_check_stats_free_one(struct vhd_util_check_stats *stats)
-{
-	if (stats) {
-		free(stats->name);
-		free(stats->bitmap);
-		free(stats);
-	}
-}
-
-static int
-vhd_util_check_stats_alloc_one(struct vhd_util_check_ctx *ctx,
-			       vhd_context_t *vhd)
-{
-	int size;
-	struct vhd_util_check_stats *stats;
-
-	stats = calloc(1, sizeof(*stats));
-	if (!stats)
-		goto fail;
-
-	stats->name = strdup(vhd->file);
-	if (!stats->name)
-		goto fail;
-
-	stats->secs_total = (uint64_t)vhd->spb * vhd->header.max_bat_size;
-	size = (stats->secs_total + 7) >> 3;
-	stats->bitmap = calloc(1, size);
-	if (!stats->bitmap)
-		goto fail;
-
-	INIT_LIST_HEAD(&stats->next);
-	list_add(&stats->next, &ctx->stats);
-
-	return 0;
-
-fail:
-	vhd_util_check_stats_free_one(stats);
-	printf("failed to allocate stats for %s\n", vhd->file);
-	return -ENOMEM;
-}
-
-static void
-vhd_util_check_stats_free(struct vhd_util_check_ctx *ctx)
-{
-	struct vhd_util_check_stats *stats, *tmp;
-
-	list_for_each_entry_safe(stats, tmp, &ctx->stats, next) {
-		list_del_init(&stats->next);
-		vhd_util_check_stats_free_one(stats);
-	}
-}
-
-static inline float
-pct(uint64_t num, uint64_t den)
-{
-	return (!den ? 0.0 : (((float)num / (float)den)) * 100.0);
-}
-
-static inline char *
-name(const char *path)
-{
-	char *p = strrchr(path, '/');
-	if (p && (p - path) == strlen(path))
-		p = strrchr(--p, '/');
-	return (char *)(p ? ++p : path);
-}
-
-static void
-vhd_util_check_stats_print(struct vhd_util_check_ctx *ctx)
-{
-	char *bitmap;
-	uint64_t secs;
-	struct vhd_util_check_stats *head, *cur, *prev;
-
-	if (list_empty(&ctx->stats))
-		return;
-
-	head = list_entry(ctx->stats.next, struct vhd_util_check_stats, next);
-	printf("%s: secs allocated: 0x%llx secs written: 0x%llx (%.2f%%)\n",
-	       name(head->name), head->secs_allocated, head->secs_written,
-	       pct(head->secs_written, head->secs_allocated));
-
-	if (list_is_last(&head->next, &ctx->stats))
-		return;
-
-	secs = head->secs_total;
-
-	bitmap = malloc((secs + 7) >> 3);
-	if (!bitmap) {
-		printf("failed to allocate bitmap\n");
-		return;
-	}
-	memcpy(bitmap, head->bitmap, ((secs + 7) >> 3));
-
-	cur = prev = head;
-	while (!list_is_last(&cur->next, &ctx->stats)) {
-		uint64_t i, up = 0, uc = 0;
-
-		cur = list_entry(cur->next.next,
-				 struct vhd_util_check_stats, next);
-
-		for (i = 0; i < secs; i++) {
-			if (test_bit_u64(cur->bitmap, i)) {
-				if (!test_bit_u64(prev->bitmap, i))
-					up++; /* sector is unique wrt parent */
-
-				if (!test_bit_u64(bitmap, i))
-					uc++; /* sector is unique wrt chain */
-
-				set_bit_u64(bitmap, i);
-			}
-		}
-
-		printf("%s: secs allocated: 0x%llx secs written: 0x%llx "
-		       "(%.2f%%) secs not in parent: 0x%llx (%.2f%%) "
-		       "secs not in ancestors: 0x%llx (%.2f%%)\n",
-		       name(cur->name), cur->secs_allocated, cur->secs_written,
-		       pct(cur->secs_written, cur->secs_allocated),
-		       up, pct(up, cur->secs_written),
-		       uc, pct(uc, cur->secs_written));
-
-		prev = cur;
-	}
-
-	free(bitmap);
-}
-
 static int
 vhd_util_check_zeros(void *buf, size_t size)
 {
@@ -234,12 +55,27 @@
 	return 0;
 }
 
+static int
+vhd_util_check_footer_opened(vhd_footer_t *footer)
+{
+	int i, n;
+	uint32_t *buf;
+
+	buf = (uint32_t *)footer;
+	n = sizeof(*footer) / sizeof(uint32_t);
+
+	for (i = 0; i < n; i++)
+		if (buf[i] != 0xc7c7c7c7)
+			return 0;
+
+	return 1;
+}
+
 static char *
-vhd_util_check_validate_footer(struct vhd_util_check_ctx *ctx,
-			       vhd_footer_t *footer)
+vhd_util_check_validate_footer(vhd_footer_t *footer)
 {
 	int size;
-	uint32_t checksum;
+	uint32_t checksum, now;
 
 	size = sizeof(footer->cookie);
 	if (memcmp(footer->cookie, HD_COOKIE, size))
@@ -278,11 +114,9 @@
 	    footer->data_offset != ~(0ULL))
 		return "invalid data offset";
 
-	if (!ctx->opts.ignore_timestamps) {
-		uint32_t now = vhd_time(time(NULL));
-		if (footer->timestamp > now + TIMESTAMP_MAX_SLACK)
-			return "creation time in future";
-	}
+	now = vhd_time(time(NULL));
+	if (footer->timestamp > now + TIMESTAMP_MAX_SLACK)
+		return "creation time in future";
 
 	if (!strncmp(footer->crtr_app, "tap", 3) &&
 	    footer->crtr_ver > VHD_CURRENT_VERSION)
@@ -312,7 +146,7 @@
 static char *
 vhd_util_check_validate_header(int fd, vhd_header_t *header)
 {
-	off64_t eof;
+	off_t eof;
 	int i, cnt, size;
 	uint32_t checksum;
 
@@ -330,8 +164,8 @@
 	if (header->data_offset != ~(0ULL))
 		return "invalid data offset";
 
-	eof = lseek64(fd, 0, SEEK_END);
-	if (eof == (off64_t)-1)
+	eof = lseek(fd, 0, SEEK_END);
+	if (eof == (off_t)-1)
 		return "error finding eof";
 
 	if (header->table_offset <= 0  ||
@@ -358,8 +192,7 @@
 }
 
 static char *
-vhd_util_check_validate_differencing_header(struct vhd_util_check_ctx *ctx,
-					    vhd_context_t *vhd)
+vhd_util_check_validate_differencing_header(vhd_context_t *vhd)
 {
 	vhd_header_t *header;
 
@@ -367,12 +200,11 @@
 
 	if (vhd->footer.type == HD_TYPE_DIFF) {
 		char *parent;
+		uint32_t now;
 
-		if (!ctx->opts.ignore_timestamps) {
-			uint32_t now = vhd_time(time(NULL));
-			if (header->prt_ts > now + TIMESTAMP_MAX_SLACK)
-				return "parent creation time in future";
-		}
+		now = vhd_time(time(NULL));
+		if (header->prt_ts > now + TIMESTAMP_MAX_SLACK)
+			return "parent creation time in future";
 
 		if (vhd_header_decode_parent(vhd, header, &parent))
 			return "invalid parent name";
@@ -386,7 +218,7 @@
 		if (vhd_util_check_zeros(header->loc, sizeof(header->loc)))
 			return "invalid non-null parent locators";
 
-		if (!uuid_is_null(header->prt_uuid))
+		if (!vhd_uuid_is_nil(&header->prt_uuid))
 			return "invalid non-null parent uuid";
 
 		if (header->prt_ts)
@@ -400,7 +232,7 @@
 vhd_util_check_validate_batmap(vhd_context_t *vhd, vhd_batmap_t *batmap)
 {
 	int size;
-	off64_t eof;
+	off_t eof;
 	uint32_t checksum;
 
 	size = sizeof(batmap->header.cookie);
@@ -410,19 +242,15 @@
 	if (batmap->header.batmap_version > VHD_BATMAP_CURRENT_VERSION)
 		return "unsupported batmap version";
 
-	checksum = vhd_checksum_batmap(vhd, batmap);
+	checksum = vhd_checksum_batmap(batmap);
 	if (checksum != batmap->header.checksum)
 		return "invalid checksum";
 
 	if (!batmap->header.batmap_size)
 		return "invalid size zero";
 
-	if (batmap->header.batmap_size << (VHD_SECTOR_SHIFT + 3) <
-			vhd->header.max_bat_size)
-		return "batmap-BAT size mismatch";
-
-	eof = lseek64(vhd->fd, 0, SEEK_END);
-	if (eof == (off64_t)-1)
+	eof = lseek(vhd->fd, 0, SEEK_END);
+	if (eof == (off_t)-1)
 		return "error finding eof";
 
 	if (!batmap->header.batmap_offset ||
@@ -441,7 +269,7 @@
 vhd_util_check_validate_parent_locator(vhd_context_t *vhd,
 				       vhd_parent_locator_t *loc)
 {
-	off64_t eof;
+	off_t eof;
 
 	if (vhd_validate_platform_code(loc->code))
 		return "invalid platform code";
@@ -462,8 +290,8 @@
 	if (!loc->data_len)
 		return "invalid data length";
 
-	eof = lseek64(vhd->fd, 0, SEEK_END);
-	if (eof == (off64_t)-1)
+	eof = lseek(vhd->fd, 0, SEEK_END);
+	if (eof == (off_t)-1)
 		return "error finding eof";
 
 	if (loc->data_offset + vhd_parent_locator_size(loc) >
@@ -476,26 +304,23 @@
 	return NULL;
 }
 
-static char *
-vhd_util_check_validate_parent(struct vhd_util_check_ctx *ctx,
-			       vhd_context_t *vhd, const char *ppath)
+static const char *
+vhd_util_check_validate_parent(vhd_context_t *vhd, const char *ppath)
 {
-	char *msg;
+	const char *msg;
 	vhd_context_t parent;
+	uint32_t status;
 
 	msg = NULL;
 
 	if (vhd_parent_raw(vhd))
 		return msg;
 
-	if (ctx->opts.ignore_parent_uuid)
-		return msg;
-
 	if (vhd_open(&parent, ppath,
 				VHD_OPEN_RDONLY | VHD_OPEN_IGNORE_DISABLED))
 		return "error opening parent";
 
-	if (uuid_compare(vhd->header.prt_uuid, parent.footer.uuid)) {
+	if (vhd_uuid_compare(&vhd->header.prt_uuid, &parent.footer.uuid)) {
 		msg = "invalid parent uuid";
 		goto out;
 	}
@@ -506,13 +331,12 @@
 }
 
 static int
-vhd_util_check_footer(struct vhd_util_check_ctx *ctx,
-		      int fd, vhd_footer_t *footer)
+vhd_util_check_footer(int fd, vhd_footer_t *footer, int ignore)
 {
-	int err;
 	size_t size;
+	int err, opened;
 	char *msg, *buf;
-	off64_t eof, off;
+	off_t eof, off;
 	vhd_footer_t primary, backup;
 
 	memset(&primary, 0, sizeof(primary));
@@ -526,16 +350,16 @@
 
 	memset(buf, 0, sizeof(primary));
 
-	eof = lseek64(fd, 0, SEEK_END);
-	if (eof == (off64_t)-1) {
+	eof = lseek(fd, 0, SEEK_END);
+	if (eof == (off_t)-1) {
 		err = -errno;
 		printf("error calculating end of file: %d\n", err);
 		goto out;
 	}
 
 	size = ((eof % 512) ? 511 : 512);
-	eof  = lseek64(fd, eof - size, SEEK_SET);
-	if (eof == (off64_t)-1) {
+	eof  = lseek(fd, eof - size, SEEK_SET);
+	if (eof == (off_t)-1) {
 		err = -errno;
 		printf("error calculating end of file: %d\n", err);
 		goto out;
@@ -549,13 +373,12 @@
 	}
 
 	memcpy(&primary, buf, sizeof(primary));
+	opened = vhd_util_check_footer_opened(&primary);
 	vhd_footer_in(&primary);
 
-	msg = vhd_util_check_validate_footer(ctx, &primary);
+	msg = vhd_util_check_validate_footer(&primary);
 	if (msg) {
-		ctx->primary_footer_missing = 1;
-
-		if (ctx->opts.ignore_footer)
+		if (opened && ignore)
 			goto check_backup;
 
 		err = -EINVAL;
@@ -569,8 +392,8 @@
 	}
 
 check_backup:
-	off = lseek64(fd, 0, SEEK_SET);
-	if (off == (off64_t)-1) {
+	off = lseek(fd, 0, SEEK_SET);
+	if (off == (off_t)-1) {
 		err = -errno;
 		printf("error seeking to backup footer: %d\n", err);
 		goto out;
@@ -589,7 +412,7 @@
 	memcpy(&backup, buf, sizeof(backup));
 	vhd_footer_in(&backup);
 
-	msg = vhd_util_check_validate_footer(ctx, &backup);
+	msg = vhd_util_check_validate_footer(&backup);
 	if (msg) {
 		err = -EINVAL;
 		printf("backup footer invalid: %s\n", msg);
@@ -597,7 +420,7 @@
 	}
 
 	if (memcmp(&primary, &backup, sizeof(primary))) {
-		if (ctx->opts.ignore_footer) {
+		if (opened && ignore) {
 			memcpy(&primary, &backup, sizeof(primary));
 			goto ok;
 		}
@@ -632,7 +455,7 @@
 vhd_util_check_header(int fd, vhd_footer_t *footer)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	char *msg, *buf;
 	vhd_header_t header;
 
@@ -643,8 +466,8 @@
 	}
 
 	off = footer->data_offset;
-	off = lseek64(fd, off, SEEK_SET);
-	if (off == (off64_t)-1) {
+	off = lseek(fd, off, SEEK_SET);
+	if (off == (off_t)-1) {
 		err = -errno;
 		printf("error seeking to header: %d\n", err);
 		goto out;
@@ -675,12 +498,11 @@
 }
 
 static int
-vhd_util_check_differencing_header(struct vhd_util_check_ctx *ctx,
-				   vhd_context_t *vhd)
+vhd_util_check_differencing_header(vhd_context_t *vhd)
 {
 	char *msg;
 
-	msg = vhd_util_check_validate_differencing_header(ctx, vhd);
+	msg = vhd_util_check_validate_differencing_header(vhd);
 	if (msg) {
 		printf("differencing header is invalid: %s\n", msg);
 		return -EINVAL;
@@ -690,113 +512,11 @@
 }
 
 static int
-vhd_util_check_bitmap(struct vhd_util_check_ctx *ctx,
-		      vhd_context_t *vhd, uint32_t block)
+vhd_util_check_bat(vhd_context_t *vhd)
 {
-	int err, i, bits;
-	uint64_t sector;
-	char *bitmap, *data;
-
-	bits   = 0;
-	data   = NULL;
-	bitmap = NULL;
-	sector = (uint64_t)block * vhd->spb;
-
-	err = vhd_read_bitmap(vhd, block, &bitmap);
-	if (err) {
-		printf("error reading bitmap 0x%x\n", block);
-		goto out;
-	}
-
-	if (ctx->opts.check_data) {
-		err = vhd_read_block(vhd, block, &data);
-		if (err) {
-			printf("error reading data block 0x%x\n", block);
-			goto out;
-		}
-	}
-
-	for (i = 0; i < vhd->spb; i++) {
-		int map = vhd_bitmap_test(vhd, bitmap, i);
-		if (map)
-			bits++;
-
-		if (ctx->opts.collect_stats && map) {
-			ctx_cur_stats(ctx)->secs_written++;
-			set_bit_u64(ctx_cur_stats(ctx)->bitmap, sector + i);
-		}
-
-		if (ctx->opts.check_data) {
-			char *buf = data + (i << VHD_SECTOR_SHIFT);
-			int set   = vhd_util_check_zeros(buf, VHD_SECTOR_SIZE);
-
-			if (set && !map) {
-				printf("sector 0x%x of block 0x%x has data "
-				       "where bitmap is clear\n", i, block);
-				err = -EINVAL;
-			}
-		}
-	}
-
-	if (ctx->opts.check_bitmaps) {
-		if (bits == vhd->spb &&
-		    !vhd_batmap_test(vhd, &vhd->batmap, block))
-			printf("bitmap of block 0x%x is full "
-			       "where batmap is clear\n", block);
-		else if (bits < vhd->spb &&
-			 vhd_batmap_test(vhd, &vhd->batmap, block)) {
-			printf("bitmap of block 0x%x is not full "
-			       "where batmap is set\n", block);
-			err = -EINVAL;
-		}
-	}
-
-out:
-	free(data);
-	free(bitmap);
-	return err;
-}
-
-static int
-vhd_util_check_get_batmap(vhd_context_t *vhd)
-{
-	int err;
-
-	if (vhd->batmap.map)
-		return 0;
-
-	if (!vhd_has_batmap(vhd))
-		return -EINVAL;
-
-	err = vhd_get_batmap(vhd);
-	if (err) {
-		err = vhd_read_batmap_header(vhd, &vhd->batmap);
-		if (err) {
-			printf("failed to read batmap header: %d\n", err);
-			return err;
-		}
-
-		err = vhd_read_batmap_map(vhd, &vhd->batmap);
-		if (err)
-			printf("failed to read batmap: %d\n", err);
-	}
-
-	return err;
-}
-
-static int
-vhd_util_check_bat(struct vhd_util_check_ctx *ctx, vhd_context_t *vhd)
-{
-	off64_t eof, eoh;
-	uint64_t vhd_blks;
+	off_t eof, eoh;
 	int i, j, err, block_size;
 
-	if (ctx->opts.collect_stats) {
-		err = vhd_util_check_stats_alloc_one(ctx, vhd);
-		if (err)
-			return err;
-	}
-
 	err = vhd_seek(vhd, 0, SEEK_END);
 	if (err) {
 		printf("error calculating eof: %d\n", err);
@@ -804,7 +524,7 @@
 	}
 
 	eof = vhd_position(vhd);
-	if (eof == (off64_t)-1) {
+	if (eof == (off_t)-1) {
 		printf("error calculating eof: %d\n", -errno);
 		return -errno;
 	}
@@ -836,18 +556,7 @@
 	eoh >>= VHD_SECTOR_SHIFT;
 	block_size = vhd->spb + vhd->bm_secs;
 
-	vhd_blks = vhd->footer.curr_size >> VHD_BLOCK_SHIFT;
-	if (vhd_blks > vhd->header.max_bat_size) {
-		printf("VHD size (%llu blocks) exceeds BAT size (%u)\n",
-		       vhd_blks, vhd->header.max_bat_size);
-		return -EINVAL;
-	}
-
-	free(vhd->batmap.map);
-	vhd->batmap.map = NULL;
-	vhd_util_check_get_batmap(vhd);
-
-	for (i = 0; i < vhd_blks; i++) {
+	for (i = 0; i < vhd->header.max_bat_size; i++) {
 		uint32_t off = vhd->bat.bat[i];
 		if (off == DD_BLK_UNUSED)
 			continue;
@@ -859,16 +568,12 @@
 		}
 
 		if (off + block_size > eof) {
-			if (!(ctx->primary_footer_missing &&
-			      ctx->opts.ignore_footer     &&
-			      off + block_size == eof + 1)) {
-				printf("block %d (offset 0x%x) clobbers "
-				       "footer\n", i, off);
-				return -EINVAL;
-			}
+			printf("block %d (offset 0x%x) clobbers footer\n",
+			       i, off);
+			return -EINVAL;
 		}
 
-		for (j = 0; j < vhd_blks; j++) {
+		for (j = 0; j < vhd->header.max_bat_size; j++) {
 			uint32_t joff = vhd->bat.bat[j];
 
 			if (i == j)
@@ -894,17 +599,6 @@
 				return err;
 			}
 		}
-
-		if (ctx->opts.check_data ||
-		    ctx->opts.check_bitmaps ||
-		    ctx->opts.collect_stats) {
-			if (ctx->opts.collect_stats)
-				ctx_cur_stats(ctx)->secs_allocated += vhd->spb;
-
-			err = vhd_util_check_bitmap(ctx, vhd, i);
-			if (err)
-				return err;
-		}
 	}
 
 	return 0;
@@ -913,9 +607,8 @@
 static int
 vhd_util_check_batmap(vhd_context_t *vhd)
 {
-	int err;
 	char *msg;
-	uint32_t i;
+	int i, err;
 
 	err = vhd_get_bat(vhd);
 	if (err) {
@@ -923,7 +616,7 @@
 		return err;
 	}
 
-	err = vhd_util_check_get_batmap(vhd);
+	err = vhd_get_batmap(vhd);
 	if (err) {
 		printf("error reading batmap: %d\n", err);
 		return err;
@@ -935,7 +628,7 @@
 		return -EINVAL;
 	}
 
-	for (i = 0; i < vhd->footer.curr_size >> VHD_BLOCK_SHIFT; i++) {
+	for (i = 0; i < vhd->header.max_bat_size; i++) {
 		if (!vhd_batmap_test(vhd, &vhd->batmap, i))
 			continue;
 
@@ -945,16 +638,16 @@
 		}
 	}
 
-	return err;
+	return 0;
 }
 
 static int
-vhd_util_check_parent_locators(struct vhd_util_check_ctx *ctx,
-			       vhd_context_t *vhd)
+vhd_util_check_parent_locators(vhd_context_t *vhd)
 {
 	int i, n, err;
 	vhd_parent_locator_t *loc;
-	char *msg, *file, *ppath, *location, *pname;
+	char *file, *ppath, *location, *pname;
+	const char *msg;
 	int mac, macx, w2ku, w2ru, wi2r, wi2k, found;
 
 	mac      = 0;
@@ -1060,7 +753,7 @@
 			goto out;
 		}
 
-		msg = vhd_util_check_validate_parent(ctx, vhd, location);
+		msg = vhd_util_check_validate_parent(vhd, location);
 		if (msg) {
 			err = -EINVAL;
 			printf("invalid parent %s: %s\n", location, msg);
@@ -1108,15 +801,16 @@
 }
 
 static int
-vhd_util_check_vhd(struct vhd_util_check_ctx *ctx, const char *name)
+vhd_util_check_vhd(const char *name, int ignore)
 {
 	int fd, err;
 	vhd_context_t vhd;
 	struct stat stats;
-	vhd_footer_t footer = {};
+	vhd_footer_t footer;
 
 	fd = -1;
 	memset(&vhd, 0, sizeof(vhd));
+        memset(&footer, 0, sizeof(footer));
 
 	err = stat(name, &stats);
 	if (err == -1) {
@@ -1135,7 +829,7 @@
 		return -errno;
 	}
 
-	err = vhd_util_check_footer(ctx, fd, &footer);
+	err = vhd_util_check_footer(fd, &footer, ignore);
 	if (err)
 		goto out;
 
@@ -1150,11 +844,11 @@
 	if (err)
 		goto out;
 
-	err = vhd_util_check_differencing_header(ctx, &vhd);
+	err = vhd_util_check_differencing_header(&vhd);
 	if (err)
 		goto out;
 
-	err = vhd_util_check_bat(ctx, &vhd);
+	err = vhd_util_check_bat(&vhd);
 	if (err)
 		goto out;
 
@@ -1165,15 +859,13 @@
 	}
 
 	if (vhd.footer.type == HD_TYPE_DIFF) {
-		err = vhd_util_check_parent_locators(ctx, &vhd);
+		err = vhd_util_check_parent_locators(&vhd);
 		if (err)
 			goto out;
 	}
 
 	err = 0;
-
-	if (!ctx->opts.collect_stats)
-		printf("%s is valid\n", name);
+	printf("%s is valid\n", name);
 
 out:
 	if (err)
@@ -1185,7 +877,7 @@
 }
 
 static int
-vhd_util_check_parents(struct vhd_util_check_ctx *ctx, const char *name)
+vhd_util_check_parents(const char *name, int ignore)
 {
 	int err;
 	vhd_context_t vhd;
@@ -1216,7 +908,7 @@
 			free(cur);
 		cur = parent;
 
-		err = vhd_util_check_vhd(ctx, cur);
+		err = vhd_util_check_vhd(cur, ignore);
 		if (err)
 			goto out;
 	}
@@ -1233,46 +925,30 @@
 vhd_util_check(int argc, char **argv)
 {
 	char *name;
-	int c, err, parents;
-	struct vhd_util_check_ctx ctx;
+	vhd_context_t vhd;
+	int c, err, ignore, parents;
 
 	if (!argc || !argv) {
 		err = -EINVAL;
 		goto usage;
 	}
 
-	name    = NULL;
+	ignore  = 0;
 	parents = 0;
-	memset(&ctx, 0, sizeof(ctx));
-	vhd_util_check_stats_init(&ctx);
+	name    = NULL;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "n:iItpbsh")) != -1) {
+	while ((c = getopt(argc, argv, "n:iph")) != -1) {
 		switch (c) {
 		case 'n':
 			name = optarg;
 			break;
 		case 'i':
-			ctx.opts.ignore_footer = 1;
-			break;
-		case 'I':
-			ctx.opts.ignore_parent_uuid = 1;
-			break;
-		case 't':
-			ctx.opts.ignore_timestamps = 1;
+			ignore = 1;
 			break;
 		case 'p':
 			parents = 1;
 			break;
-		case 'b':
-			ctx.opts.check_bitmaps = 1;
-			break;
-		case 'd':
-			ctx.opts.check_data = 1;
-			break;
-		case 's':
-			ctx.opts.collect_stats = 1;
-			break;
 		case 'h':
 			err = 0;
 			goto usage;
@@ -1287,25 +963,18 @@
 		goto usage;
 	}
 
-	err = vhd_util_check_vhd(&ctx, name);
+	err = vhd_util_check_vhd(name, ignore);
 	if (err)
 		goto out;
 
 	if (parents)
-		err = vhd_util_check_parents(&ctx, name);
-
-	if (ctx.opts.collect_stats)
-		vhd_util_check_stats_print(&ctx);
-
-	vhd_util_check_stats_free(&ctx);
+		err = vhd_util_check_parents(name, ignore);
 
 out:
 	return err;
 
 usage:
 	printf("options: -n <file> [-i ignore missing primary footers] "
-	       "[-I ignore parent uuids] [-t ignore timestamps] "
-	       "[-p check parents] [-b check bitmaps] [-d check data] "
-	       "[-s stats] [-h help]\n");
+	       "[-p check parents] [-h help]\n");
 	return err;
 }
diff -Nur blktap2_oxt//vhd/lib/vhd-util-coalesce.c blktap2_xen//vhd/lib/vhd-util-coalesce.c
--- blktap2_oxt//vhd/lib/vhd-util-coalesce.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-coalesce.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <errno.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -39,12 +35,12 @@
 static int
 __raw_io_write(int fd, char* buf, uint64_t sec, uint32_t secs)
 {
-	off64_t off;
+	off_t off;
 	size_t ret;
 
 	errno = 0;
-	off = lseek64(fd, vhd_sectors_to_bytes(sec), SEEK_SET);
-	if (off == (off64_t)-1) {
+	off = lseek(fd, vhd_sectors_to_bytes(sec), SEEK_SET);
+	if (off == (off_t)-1) {
 		printf("raw parent: seek(0x%08"PRIx64") failed: %d\n",
 		       vhd_sectors_to_bytes(sec), -errno);
 		return -errno;
@@ -64,7 +60,7 @@
  */
 static int
 vhd_util_coalesce_block(vhd_context_t *vhd, vhd_context_t *parent,
-			int parent_fd, uint64_t block)
+		int parent_fd, uint64_t block)
 {
 	int i, err;
 	char *buf, *map;
@@ -127,52 +123,36 @@
 	return err;
 }
 
-static int
-vhd_util_coalesce_onto(vhd_context_t *from,
-		       vhd_context_t *to, int to_fd, int progress)
+int
+vhd_util_coalesce(int argc, char **argv)
 {
-	int err;
+	int err, c;
 	uint64_t i;
+	char *name, *pname;
+	vhd_context_t vhd, parent;
+	int parent_fd = -1;
 
-	err = vhd_get_bat(from);
-	if (err)
-		goto out;
+	name  = NULL;
+	pname = NULL;
+	parent.file = NULL;
 
-	if (vhd_has_batmap(from)) {
-		err = vhd_get_batmap(from);
-		if (err)
-			goto out;
-	}
+	if (!argc || !argv)
+		goto usage;
 
-	for (i = 0; i < from->bat.entries; i++) {
-		if (progress) {
-			printf("\r%6.2f%%",
-			       ((float)i / (float)from->bat.entries) * 100.00);
-			fflush(stdout);
+	optind = 0;
+	while ((c = getopt(argc, argv, "n:h")) != -1) {
+		switch (c) {
+		case 'n':
+			name = optarg;
+			break;
+		case 'h':
+		default:
+			goto usage;
 		}
-		err = vhd_util_coalesce_block(from, to, to_fd, i);
-		if (err)
-			goto out;
 	}
 
-	err = 0;
-
-	if (progress)
-		printf("\r100.00%%\n");
-
-out:
-	return err;
-}
-
-static int
-vhd_util_coalesce_parent(const char *name, int sparse, int progress)
-{
-	char *pname;
-	int err, parent_fd;
-	vhd_context_t vhd, parent;
-
-	parent_fd   = -1;
-	parent.file = NULL;
+	if (!name || optind != argc)
+		goto usage;
 
 	err = vhd_open(&vhd, name, VHD_OPEN_RDONLY);
 	if (err) {
@@ -196,9 +176,7 @@
 			return err;
 		}
 	} else {
-		int flags = (sparse ? VHD_OPEN_IO_WRITE_SPARSE : 0);
-		if (sparse) printf("opening for sparse writes\n");
-		err = vhd_open(&parent, pname, VHD_OPEN_RDWR | flags);
+		err = vhd_open(&parent, pname, VHD_OPEN_RDWR);
 		if (err) {
 			printf("error opening %s: %d\n", pname, err);
 			free(pname);
@@ -207,503 +185,34 @@
 		}
 	}
 
-	err = vhd_util_coalesce_onto(&vhd, &parent, parent_fd, progress);
-
-	free(pname);
-	vhd_close(&vhd);
-	if (parent.file)
-		vhd_close(&parent);
-	else
-		close(parent_fd);
-	return err;
-}
-
-struct vhd_list_entry {
-	int                raw;
-	int                raw_fd;
-	vhd_context_t      vhd;
-	struct list_head   next;
-};
-
-static int
-vhd_util_pathcmp(const char *a, const char *b, int *cmp)
-{
-	int err;
-	char *apath = NULL, *bpath = NULL;
-
-	apath = vhd_realpath(a, NULL);
-	if (!apath) {
-		err = -errno;
-		goto out;
-	}
-
-	bpath = vhd_realpath(b, NULL);
-	if (!bpath) {
-		err = -errno;
-		goto out;
-	}
-
-	*cmp = strcmp(apath, bpath);
-	err  = 0;
-
-out:
-	free(apath);
-	free(bpath);
-	return err;
-}
-
-static void
-vhd_util_coalesce_free_chain(struct list_head *head)
-{
-	struct vhd_list_entry *entry, *tmp;
-
-	list_for_each_entry_safe(entry, tmp, head, next) {
-		if (entry->raw)
-			close(entry->raw_fd);
-		else
-			vhd_close(&entry->vhd);
-		list_del(&entry->next);
-		free(entry);
-	}
-
-	INIT_LIST_HEAD(head);
-}
-
-static int
-vhd_util_coalesce_load_chain(struct list_head *head,
-			     const char *cname, const char *aname, int sparse)
-{
-	char *next;
-	vhd_context_t *child;
-	int err, cmp, vhd_flags;
-	struct vhd_list_entry *entry;
-
-	next  = NULL;
-	entry = NULL;
-	INIT_LIST_HEAD(head);
-
-	vhd_flags = VHD_OPEN_RDWR | (sparse ? VHD_OPEN_IO_WRITE_SPARSE : 0);
-
-	err = vhd_util_pathcmp(cname, aname, &cmp);
-	if (err)
-		goto out;
-
-	if (!cmp) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	entry = calloc(1, sizeof(*entry));
-	if (!entry)
-		goto out;
-
-	err = vhd_open(&entry->vhd, cname, vhd_flags);
-	if (err)
-		goto out;
-
-	err = vhd_get_bat(&entry->vhd);
-	if (err)
-		goto out;
-
-	if (vhd_has_batmap(&entry->vhd)) {
-		err = vhd_get_batmap(&entry->vhd);
-		if (err)
-			goto out;
-	}
-
-	child = &entry->vhd;
-	list_add(&entry->next, head);
-
-	for (;;) {
-		int raw;
-
-		if (entry->raw || entry->vhd.footer.type != HD_TYPE_DIFF) {
-			err = -ENOENT;
-			goto out;
-		}
-
-		if (child->header.block_size != entry->vhd.header.block_size) {
-			err = -EINVAL;
-			goto out;
-		}
-
-		err = vhd_parent_locator_get(&entry->vhd, &next);
-		if (err)
-			goto out;
-
-		raw = vhd_parent_raw(&entry->vhd);
-
-		entry = calloc(1, sizeof(*entry));
-		if (!entry)
-			goto out;
-
-		if (raw) {
-			entry->raw = raw;
-			entry->raw_fd = open(next,
-					     O_RDWR | O_DIRECT | O_LARGEFILE);
-			if (entry->raw_fd == -1) {
-				err = -errno;
-				goto out;
-			}
-		} else {
-			err = vhd_open(&entry->vhd, next, vhd_flags);
-			if (err)
-				goto out;
-
-			err = vhd_get_bat(&entry->vhd);
-			if (err)
-				goto out;
-
-			if (vhd_has_batmap(&entry->vhd)) {
-				err = vhd_get_batmap(&entry->vhd);
-				if (err)
-					goto out;
-			}
-		}
-
-		list_add_tail(&entry->next, head);
-
-		err = vhd_util_pathcmp(next, aname, &cmp);
-		if (err)
-			goto out;
-
-		if (!cmp)
-			goto done;
-
-		free(next);
-		next = NULL;
-	}
-
-done:
-	err = 0;
-out:
-	if (err) {
-		if (entry && list_empty(&entry->next)) {
-			if (entry->vhd.file)
-				vhd_close(&entry->vhd);
-			else if (entry->raw)
-				close(entry->raw_fd);
-			free(entry);
-		}
-		vhd_util_coalesce_free_chain(head);
-	}
-	return err;
-}
-
-static int
-vhd_util_coalesce_clear_bitmap(vhd_context_t *child, char *cmap,
-			       vhd_context_t *ancestor, const uint64_t block)
-{
-	char *amap = NULL;
-	int i, dirty, err;
-
-	if (child->spb != ancestor->spb) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	if (block >= ancestor->bat.entries)
-		goto done;
-
-	if (ancestor->bat.bat[block] == DD_BLK_UNUSED)
-		goto done;
-
-	err = vhd_read_bitmap(ancestor, block, &amap);
-	if (err)
-		goto out;
-
-	for (i = 0; i < child->spb; i++) {
-		if (vhd_bitmap_test(child, cmap, i)) {
-			if (vhd_bitmap_test(ancestor, amap, i)) {
-				dirty = 1;
-				vhd_bitmap_clear(ancestor, amap, i);
-			}
-		}
-	}
-
-	if (dirty) {
-		err = vhd_write_bitmap(ancestor, block, amap);
-		if (err)
-			goto out;
-		if (vhd_has_batmap(ancestor) &&
-		    vhd_batmap_test(ancestor, &ancestor->batmap, block)) {
-			vhd_batmap_clear(ancestor, &ancestor->batmap, block);
-			err = vhd_write_batmap(ancestor, &ancestor->batmap);
-			if (err)
-				goto out;
-		}
-	}
-
-done:
-	err = 0;
-out:
-	free(amap);
-	return err;
-}
-
-static int
-vhd_util_coalesce_clear_bitmaps(struct list_head *chain, vhd_context_t *child,
-				vhd_context_t *ancestor, uint64_t block)
-{
-	int err;
-	char *map = NULL;
-	struct vhd_list_entry *entry;
-
-	if (child->bat.bat[block] == DD_BLK_UNUSED)
-		goto done;
-
-	err = vhd_read_bitmap(child, block, &map);
-	if (err)
-		goto out;
-
-	list_for_each_entry(entry, chain, next) {
-		if (&entry->vhd == child)
-			continue;
-		if (&entry->vhd == ancestor)
-			break;
-		err = vhd_util_coalesce_clear_bitmap(child, map,
-						     &entry->vhd, block);
-		if (err)
-			goto out;
-	}
-
-done:
-	err = 0;
-out:
-	free(map);
-	return err;
-}
-
-static int
-vhd_util_coalesce_ancestor(const char *cname,
-			   const char *aname, int sparse, int progress)
-{
-	uint64_t i;
-	int err, raw_fd;
-	struct list_head chain;
-	struct vhd_list_entry *entry;
-	vhd_context_t *child, *ancestor;
-
-	child    = NULL;
-	ancestor = NULL;
-
-	err = vhd_util_coalesce_load_chain(&chain, cname, aname, sparse);
-	if (err)
-		goto out;
-
-	list_for_each_entry(entry, &chain, next) {
-		if (!child)
-			child = &entry->vhd;
-		else if (list_is_last(&entry->next, &chain)) {
-			ancestor = &entry->vhd;
-			raw_fd = entry->raw_fd;
-			break;
-		}
-	}
-
-	if (!ancestor) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	err = vhd_util_coalesce_onto(child, ancestor, raw_fd, progress);
-	if (err)
-		goto out;
-
-	for (i = 0; i < child->bat.entries; i++) {
-		err = vhd_util_coalesce_clear_bitmaps(&chain,
-						      child, ancestor, i);
-		if (err)
-			goto out;
-	}
-
-out:
-	vhd_util_coalesce_free_chain(&chain);
-	return err;
-}
-
-static int
-vhd_util_coalesce_open_output(vhd_context_t *dst,
-			      vhd_context_t *src, const char *name, int flags)
-{
-	int err;
-
-	err = access(name, F_OK);
-	if (!err) {
-		printf("%s already exists\n", name);
-		return -EEXIST;
-	} else if (errno != ENOENT) {
-		printf("error checking %s: %d\n", name, errno);
-		return -errno;
-	}
-
-	err = vhd_create(name,
-			 vhd_cur_capacity(src),
-			 HD_TYPE_DYNAMIC,
-			 vhd_max_capacity(src),
-			 0);
-	if (err) {
-		printf("error creating %s: %d\n", name, err);
-		return err;
-	}
-
-	err = vhd_open(dst, name, VHD_OPEN_RDWR | flags);
-	if (err || dst->header.block_size != src->header.block_size) {
-		printf("error opening %s: %d\n", name, (err ? : EINVAL));
-		unlink(name);
-		return err ? : EINVAL;
-	}
-
-	return 0;
-}
-
-/*
- * read block from @src chain and write it to @dst, unless it is all zeros
- */
-static int
-vhd_util_coalesce_block_out(vhd_context_t *dst,
-			    vhd_context_t *src, uint64_t block)
-{
-	int i, err;
-	uint64_t sec;
-	char *buf, *p;
-
-	buf = NULL;
-	sec = block * src->spb;
-
-	err = posix_memalign((void **)&buf, 4096, src->header.block_size);
-	if (err)
-		return -err;
-
-	err = vhd_io_read(src, buf, sec, src->spb);
-	if (err)
-		goto done;
-
-	for (p = buf, i = 0; i < src->header.block_size; i++, p++) {
-		if (*p) {
-			err = vhd_io_write(dst, buf, sec, src->spb);
-			break;
-		}
-	}
-
-done:
-	free(buf);
-	return err;
-}
-
-static int
-vhd_util_coalesce_out(const char *src_name, const char *dst_name,
-		      int sparse, int progress)
-{
-	uint64_t i;
-	int err, flags;
-	vhd_context_t src, dst;
-
-	err = vhd_open(&src, src_name, VHD_OPEN_RDONLY | VHD_OPEN_CACHED);
-	if (err)
-		return err;
-
-	flags = (sparse ? VHD_OPEN_IO_WRITE_SPARSE : 0);
-	err = vhd_util_coalesce_open_output(&dst, &src, dst_name, flags);
-	if (err) {
-		vhd_close(&src);
-		return err;
-	}
-
-	err = vhd_get_bat(&src);
+	err = vhd_get_bat(&vhd);
 	if (err)
 		goto done;
 
-	if (vhd_has_batmap(&src)) {
-		err = vhd_get_batmap(&src);
+	if (vhd_has_batmap(&vhd)) {
+		err = vhd_get_batmap(&vhd);
 		if (err)
 			goto done;
 	}
 
-	for (i = 0; i < src.bat.entries; i++) {
-		if (progress) {
-			printf("\r%6.2f%%",
-			       ((float)i / (float)src.bat.entries) * 100.0);
-			fflush(stdout);
-		}
-		err = vhd_util_coalesce_block_out(&dst, &src, i);
+	for (i = 0; i < vhd.bat.entries; i++) {
+		err = vhd_util_coalesce_block(&vhd, &parent, parent_fd, i);
 		if (err)
 			goto done;
 	}
 
 	err = 0;
 
-	if (progress)
-		printf("\r100.00%%\n");
-
-done:
-	if (err)
-		unlink(dst.file);
-	vhd_close(&src);
-	vhd_close(&dst);
-	return err;
-}
-
-int
-vhd_util_coalesce(int argc, char **argv)
-{
-	char *name, *oname, *ancestor;
-	int err, c, progress, sparse;
-
-	name      = NULL;
-	oname     = NULL;
-	ancestor  = NULL;
-	sparse    = 0;
-	progress  = 0;
-
-	if (!argc || !argv)
-		goto usage;
-
-	optind = 0;
-	while ((c = getopt(argc, argv, "n:o:a:sph")) != -1) {
-		switch (c) {
-		case 'n':
-			name = optarg;
-			break;
-		case 'o':
-			oname = optarg;
-			break;
-		case 'a':
-			ancestor = optarg;
-			break;
-		case 's':
-			sparse = 1;
-			break;
-		case 'p':
-			progress = 1;
-			break;
-		case 'h':
-		default:
-			goto usage;
-		}
-	}
-
-	if (!name || optind != argc)
-		goto usage;
-
-	if (oname && ancestor)
-		goto usage;
-
-	if (oname)
-		err = vhd_util_coalesce_out(name, oname, sparse, progress);
-	else if (ancestor)
-		err = vhd_util_coalesce_ancestor(name, ancestor,
-						 sparse, progress);
+ done:
+	free(pname);
+	vhd_close(&vhd);
+	if (parent.file)
+		vhd_close(&parent);
 	else
-		err = vhd_util_coalesce_parent(name, sparse, progress);
-
-	if (err)
-		printf("error coalescing: %d\n", err);
-
+		close(parent_fd);
 	return err;
 
 usage:
-	printf("options: <-n name> [-a ancestor] "
-	       "[-o output] [-s sparse] [-p progress] [-h help]\n");
+	printf("options: <-n name> [-h help]\n");
 	return -EINVAL;
 }
diff -Nur blktap2_oxt//vhd/lib/vhd-util-create.c blktap2_xen//vhd/lib/vhd-util-create.c
--- blktap2_oxt//vhd/lib/vhd-util-create.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-create.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -39,13 +35,12 @@
 vhd_util_create(int argc, char **argv)
 {
 	char *name;
-	uint64_t size, msize;
+	uint64_t size;
 	int c, sparse, err;
 	vhd_flag_creat_t flags;
 
 	err       = -EINVAL;
 	size      = 0;
-	msize     = 0;
 	sparse    = 1;
 	name      = NULL;
 	flags     = 0;
@@ -54,7 +49,7 @@
 		goto usage;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "n:s:S:rh")) != -1) {
+	while ((c = getopt(argc, argv, "n:s:rh")) != -1) {
 		switch (c) {
 		case 'n':
 			name = optarg;
@@ -63,10 +58,6 @@
 			err  = 0;
 			size = strtoull(optarg, NULL, 10);
 			break;
-		case 'S':
-			err = 0;
-			msize = strtoull(optarg, NULL, 10);
-			break;
 		case 'r':
 			sparse = 0;
 			break;
@@ -79,18 +70,11 @@
 	if (err || !name || optind != argc)
 		goto usage;
 
-	if (msize && msize < size) {
-		printf("Error: <-S size> must be greater than <-s size>\n");
-		return -EINVAL;
-	}
-
 	return vhd_create(name, size << 20,
 				  (sparse ? HD_TYPE_DYNAMIC : HD_TYPE_FIXED),
-				  msize << 20, flags);
+				  flags);
 
 usage:
-	printf("options: <-n name> <-s size (MB)> [-r reserve] [-h help] "
-			"[<-S size (MB) for metadata preallocation "
-			"(see vhd-util resize)>]\n");
+	printf("options: <-n name> <-s size (MB)> [-r reserve] [-h help]\n");
 	return -EINVAL;
 }
diff -Nur blktap2_oxt//vhd/lib/vhd-util-modify.c blktap2_xen//vhd/lib/vhd-util-modify.c
--- blktap2_oxt//vhd/lib/vhd-util-modify.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-modify.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,6 +23,21 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Altering operations:
+ *
+ * 1. Change the parent pointer to another file.
+ * 2. Change the size of the file containing the VHD image. This does NOT 
+ * affect the VHD disk capacity, only the physical size of the file containing 
+ * the VHD. Naturally, it is not possible to set the file size to be less than  
+ * the what VHD utilizes.
+ * The operation doesn't actually change the file size, but it writes the 
+ * footer in the right location such that resizing the file (manually, as a 
+ * separate step) will produce the correct results. If the new file size is 
+ * greater than the current file size, the file must first be expanded and then 
+ * altered with this operation. If the new size is smaller than the current 
+ * size, the VHD must first be altered with this operation and then the file 
+ * must be shrunk. Failing to resize the file will result in a corrupted VHD.
  */
 
 #include <errno.h>
@@ -38,51 +50,22 @@
 
 TEST_FAIL_EXTERN_VARS;
 
-static int
-vhd_util_zero_bat(vhd_context_t *vhd)
-{
-	int err, map_bytes;
-	uint64_t i;
-
-	err = vhd_get_bat(vhd);
-	if (err)
-		return err;
-
-	if (vhd_has_batmap(vhd)) {
-		err = vhd_get_batmap(vhd);
-		if (err)
-			return err;
-	}
-
-	for (i = 0; i < vhd->header.max_bat_size; i++)
-		vhd->bat.bat[i] = DD_BLK_UNUSED;
-	err = vhd_write_bat(vhd, &vhd->bat);
-	if (err)
-		return err;
-
-	map_bytes = vhd_sectors_to_bytes(vhd->batmap.header.batmap_size);
-	memset(vhd->batmap.map, 0, map_bytes);
-	return vhd_write_batmap(vhd, &vhd->batmap);
-}
-
 int
 vhd_util_modify(int argc, char **argv)
 {
-	char *name, *type;
+	char *name;
 	vhd_context_t vhd;
-	int err, c, size, parent, parent_raw, kill_data;
-	off64_t newsize = 0;
+	int err, c, size, parent, parent_raw;
+	off_t newsize = 0;
 	char *newparent = NULL;
 
 	name       = NULL;
-	type       = NULL;
 	size       = 0;
 	parent     = 0;
 	parent_raw = 0;
-	kill_data  = 0;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "n:s:p:mt:zh")) != -1) {
+	while ((c = getopt(argc, argv, "n:s:p:mh")) != -1) {
 		switch (c) {
 		case 'n':
 			name = optarg;
@@ -103,12 +86,7 @@
 		case 'm':
 			parent_raw = 1;
 			break;
-		case 't':
-			type = optarg;
-			break;
-		case 'z':
-			kill_data = 1;
-			break;
+
 		case 'h':
 		default:
 			goto usage;
@@ -124,24 +102,6 @@
 		return err;
 	}
 
-	if (kill_data) {
-		if (vhd_type_dynamic(&vhd))
-			err = vhd_util_zero_bat(&vhd);
-		else
-			err = -ENOSYS;
-
-		if (!err) {
-			err = vhd_end_of_headers(&vhd, &newsize);
-			newsize += sizeof(vhd_footer_t);
-		}
-
-		if (!err)
-			err = vhd_set_phys_size(&vhd, newsize);
-
-		if (err)
-			printf("failed to zero VHD: %d\n", err);
-	}
-
 	if (size) {
 		err = vhd_set_phys_size(&vhd, newsize);
 		if (err)
@@ -160,41 +120,6 @@
 		TEST_FAIL_AT(FAIL_REPARENT_END);
 	}
 
-	if (type) {
-		if (vhd.footer.type == HD_TYPE_FIXED) {
-			printf("changing fixed vhd type not supported\n");
-			err = -EINVAL;
-			goto done;
-		}
-
-		if (!strcmp(type, "differencing"))
-			vhd.footer.type = HD_TYPE_DIFF;
-		else if (!strcmp(type, "dynamic"))
-			vhd.footer.type = HD_TYPE_DYNAMIC;
-		else if (!strcmp(type, "original")) {
-			char *n;
-
-			err = vhd_header_decode_parent(&vhd, &vhd.header, &n);
-			if (err) {
-				printf("error inferring type: %d\n", err);
-				goto done;
-			}
-
-			if (!strcmp(n, ""))
-				vhd.footer.type = HD_TYPE_DYNAMIC;
-			else
-				vhd.footer.type = HD_TYPE_DIFF;
-
-			free(n);
-		} else {
-			printf("invalid type %s (must be 'differencing or "
-			       "dynamic')\n", type);
-			err = -EINVAL;
-			goto done;
-		}
-		err = vhd_write_footer(&vhd, &vhd.footer);
-	}
-
 done:
 	vhd_close(&vhd);
 	return err;
@@ -202,7 +127,6 @@
 usage:
 	printf("*** Dangerous operations, use with care ***\n");
 	printf("options: <-n name> [-p NEW_PARENT set parent [-m raw]] "
-	       "[-s NEW_SIZE set size] [-z zero (kill data)] "
-	       "[-t TYPE (differencing|dynamic|original)] [-h help]\n");
+			"[-s NEW_SIZE set size] [-h help]\n");
 	return -EINVAL;
 }
diff -Nur blktap2_oxt//vhd/lib/vhd-util-query.c blktap2_xen//vhd/lib/vhd-util-query.c
--- blktap2_oxt//vhd/lib/vhd-util-query.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-query.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <errno.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -41,19 +37,15 @@
 {
 	char *name;
 	vhd_context_t vhd;
-	off64_t currsize;
-	int ret, err, c, size, physize, parent, fields, depth, fastresize;
-	int marker, allocated;
-
-	name       = NULL;
-	size       = 0;
-	physize    = 0;
-	parent     = 0;
-	fields     = 0;
-	depth      = 0;
-	fastresize = 0;
-	marker     = 0;
-	allocated  = 0;
+	off_t currsize;
+	int ret, err, c, size, physize, parent, fields, depth;
+
+	name    = NULL;
+	size    = 0;
+	physize = 0;
+	parent  = 0;
+	fields  = 0;
+	depth   = 0;
 
 	if (!argc || !argv) {
 		err = -EINVAL;
@@ -61,7 +53,7 @@
 	}
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "n:vspfdSmah")) != -1) {
+	while ((c = getopt(argc, argv, "n:vspfdh")) != -1) {
 		switch (c) {
 		case 'n':
 			name = optarg;
@@ -81,15 +73,6 @@
 		case 'd':
 			depth = 1;
 			break;
-		case 'S':
-			fastresize = 1;
-			break;
-		case 'm':
-			marker = 1;
-			break;
-		case 'a':
-			allocated = 1;
-			break;
 		case 'h':
 			err = 0;
 			goto usage;
@@ -111,7 +94,7 @@
 	}
 
 	if (size)
-		printf("%llu\n", vhd.footer.curr_size >> 20);
+		printf("%"PRIu64"\n", vhd.footer.curr_size >> 20);
 
 	if (physize) {
 		err = vhd_get_phys_size(&vhd, &currsize);
@@ -153,18 +136,6 @@
 		err = (err ? : ret);
 	}
 
-	if (marker) {
-		char marker;
-
-		ret = vhd_marker(&vhd, &marker);
-		if (ret)
-			printf("error checking 'marker' field: %d\n", ret);
-		else
-			printf("marker: %d\n", marker);
-
-		err = (err ? : ret);
-	}
-
 	if (depth) {
 		int length;
 
@@ -176,30 +147,6 @@
 
 		err = (err ? : ret);
 	}
-
-	if (fastresize) {
-		uint64_t max_size;
-
-		max_size = vhd.header.max_bat_size << (VHD_BLOCK_SHIFT - 20);
-		printf("%llu\n", max_size);
-	}
-
-	if (allocated) {
-		ret = vhd_get_bat(&vhd);
-		if (ret)
-			printf("error reading bat: %d\n", ret);
-		else {
-			uint32_t i, used;
-
-			for (i = 0, used = 0; i < vhd.bat.entries; i++)
-				if (vhd.bat.bat[i] != DD_BLK_UNUSED)
-					used++;
-
-			printf("%u\n", used);
-		}
-
-		err = (err ? : ret);
-	}
 		
 	vhd_close(&vhd);
 	return err;
@@ -207,8 +154,6 @@
 usage:
 	printf("options: <-n name> [-v print virtual size (in MB)] "
 	       "[-s print physical utilization (bytes)] [-p print parent] "
-	       "[-f print fields] [-m print marker] [-d print chain depth] "
-	       "[-S print max virtual size (MB) for fast resize] "
-	       "[-a print allocated block count] [-h help]\n");
+	       "[-f print fields] [-d print chain depth] [-h help]\n");
 	return err;
 }
diff -Nur blktap2_oxt//vhd/lib/vhd-util-read.c blktap2_xen//vhd/lib/vhd-util-read.c
--- blktap2_oxt//vhd/lib/vhd-util-read.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-read.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -38,16 +34,6 @@
 #include "libvhd.h"
 #include "vhd-util.h"
 
-const char *HD_TYPE_STR[7] = {
-        "None",                    /* 0 */
-        "Reserved (deprecated)",   /* 1 */
-        "Fixed hard disk",         /* 2 */
-        "Dynamic hard disk",       /* 3 */
-        "Differencing hard disk",  /* 4 */
-        "Reserved (deprecated)",   /* 5 */
-        "Reserved (deprecated)"    /* 6 */
-};
-
 #define nsize     15
 static char nbuf[nsize];
 
@@ -73,11 +59,11 @@
 {
 	int err;
 	uint32_t  cksm;
-	char      uuid[37], time_str[26], cookie[9], *name;
+	char      uuid[39], time_str[26], cookie[9], out[512], *name;
 
 	printf("VHD Header Summary:\n-------------------\n");
 
-	snprintf(cookie, 9, "%s", h->cookie);
+	snprintf(cookie, sizeof(cookie), "%s", h->cookie);
 	printf("Cookie              : %s\n", cookie);
 
 	printf("Data offset (unusd) : %s\n", conv(hex, h->data_offset));
@@ -92,7 +78,7 @@
 	       (err ? "failed to read name" : name));
 	free(name);
 
-	uuid_unparse(h->prt_uuid, uuid);
+	vhd_uuid_to_string(&h->prt_uuid, uuid, sizeof(uuid));
 	printf("Parent UUID         : %s\n", uuid);
     
 	vhd_time_to_string(h->prt_ts, time_str);
@@ -108,12 +94,12 @@
 vhd_print_footer(vhd_footer_t *f, int hex)
 {
 	uint64_t  c, h, s;
-	uint32_t  ff_maj, ff_min, cr_maj, cr_min, cksm;
-	char      time_str[26], creator[5], uuid[37], cookie[9];
+	uint32_t  ff_maj, ff_min, cr_maj, cr_min, cksm, cksm_save;
+	char      time_str[26], creator[5], uuid[39], cookie[9];
 
 	printf("VHD Footer Summary:\n-------------------\n");
 
-	snprintf(cookie, 9, "%s", f->cookie);
+	snprintf(cookie, sizeof(cookie), "%s", f->cookie);
 	printf("Cookie              : %s\n", cookie);
 
 	printf("Features            : (0x%08x) %s%s\n", f->features,
@@ -167,7 +153,7 @@
 	printf("Checksum            : 0x%x|0x%x (%s)\n", f->checksum, cksm,
 		f->checksum == cksm ? "Good!" : "Bad!");
 
-	uuid_unparse(f->uuid, uuid);
+	vhd_uuid_to_string(&f->uuid, uuid, sizeof(uuid));
 	printf("UUID                : %s\n", uuid);
 
 	printf("Saved state         : %s\n", f->saved == 0 ? "No" : "Yes");
@@ -211,7 +197,6 @@
 	}
 
 	printf("       decoded name : %s\n", buf);
-	free(buf);
 }
 
 static void
@@ -244,31 +229,7 @@
 }
 
 static void
-vhd_print_keyhash(vhd_context_t *vhd)
-{
-	int ret;
-	struct vhd_keyhash keyhash;
-
-	ret = vhd_get_keyhash(vhd, &keyhash);
-	if (ret)
-		printf("error reading keyhash: %d\n", ret);
-	else if (keyhash.cookie == 1) {
-		int i;
-
-		printf("Batmap keyhash nonce: ");
-		for (i = 0; i < sizeof(keyhash.nonce); i++)
-			printf("%02x", keyhash.nonce[i]);
-
-		printf("\nBatmap keyhash hash : ");
-		for (i = 0; i < sizeof(keyhash.hash); i++)
-			printf("%02x", keyhash.hash[i]);
-
-		printf("\n");
-	}
-}
-
-static void
-vhd_print_batmap_header(vhd_context_t *vhd, vhd_batmap_t *batmap, int hex)
+vhd_print_batmap_header(vhd_batmap_t *batmap, int hex)
 {
 	uint32_t cksm;
 
@@ -279,9 +240,8 @@
 	       conv(hex, batmap->header.batmap_size));
 	printf("Batmap version      : 0x%08x\n",
 	       batmap->header.batmap_version);
-	vhd_print_keyhash(vhd);
 
-	cksm = vhd_checksum_batmap(vhd, batmap);
+	cksm = vhd_checksum_batmap(batmap);
 	printf("Checksum            : 0x%x|0x%x (%s)\n",
 	       batmap->header.checksum, cksm,
 	       (batmap->header.checksum == cksm ? "Good!" : "Bad!"));
@@ -291,7 +251,7 @@
 static inline int
 check_block_range(vhd_context_t *vhd, uint64_t block, int hex)
 {
-	if (block > vhd_cur_capacity(vhd) / vhd->header.block_size) {
+	if (block > vhd->header.max_bat_size) {
 		fprintf(stderr, "block %s past end of file\n",
 			conv(hex, block));
 		return -ERANGE;
@@ -300,7 +260,7 @@
 	return 0;
 }
 
-int
+static int
 vhd_print_headers(vhd_context_t *vhd, int hex)
 {
 	int err;
@@ -316,22 +276,11 @@
 		if (vhd_has_batmap(vhd)) {
 			err = vhd_get_batmap(vhd);
 			if (err) {
-				err = vhd_read_batmap_header(vhd,
-							     &vhd->batmap);
-				if (err) {
-					printf("failed to get batmap header\n");
-					return err;
-				}
-
-				err = vhd_read_batmap_map(vhd,
-							  &vhd->batmap);
-				if (err) {
-					printf("failed to get batmap map\n");
-					return err;
-				}
+				printf("failed to get batmap header\n");
+				return err;
 			}
 
-			vhd_print_batmap_header(vhd, &vhd->batmap, hex);
+			vhd_print_batmap_header(&vhd->batmap, hex);
 		}
 	}
 
@@ -423,33 +372,26 @@
 	return 0;
 }
 
-static int
-vhd_print_bat_str(vhd_context_t *vhd)
+static inline void
+write_full(int fd, void* buf, size_t count)
 {
-	int i, gcc, total_blocks, bitmap_size;
-	char *bitmap;
-
-	if (!vhd_type_dynamic(vhd))
-		return -EINVAL;
-
-	total_blocks = vhd->footer.curr_size / vhd->header.block_size;
-	bitmap_size = total_blocks >> 3;
-	if (bitmap_size << 3 < total_blocks)
-		bitmap_size++;
-
-	bitmap = malloc(bitmap_size);
-	if (!bitmap)
-		return -ENOMEM;
-	memset(bitmap, 0, bitmap_size);
-
-	for (i = 0; i < total_blocks; i++) {
-		if (vhd->bat.bat[i] != DD_BLK_UNUSED)
-			set_bit(bitmap, i);
+	ssize_t num_written = 0;
+	if (!buf) return;
+	
+	
+	while(count > 0) {
+		
+		num_written = write(fd, buf, count);
+		if (num_written == -1) {
+			if (errno == EINTR) 
+				continue;
+			else
+				return;
+		}
+		
+		count -= num_written;
+		buf   += num_written;
 	}
-
-	gcc = write(STDOUT_FILENO, bitmap, bitmap_size);
-	free(bitmap);
-	return 0;
 }
 
 static int
@@ -463,7 +405,6 @@
 		return -ERANGE;
 
 	for (i = 0; i < count; i++) {
-		int gcc;
 		cur = block + i;
 
 		if (vhd->bat.bat[cur] == DD_BLK_UNUSED) {
@@ -475,7 +416,8 @@
 		if (err)
 			goto out;
 
-		gcc = write(STDOUT_FILENO, buf, vhd_sectors_to_bytes(vhd->bm_secs));
+		write_full(STDOUT_FILENO, buf, 
+			   vhd_sectors_to_bytes(vhd->bm_secs));
 		free(buf);
 	}
 
@@ -520,8 +462,9 @@
 		if (vhd->bat.bat[blk] == DD_BLK_UNUSED)
 			bit = 0;
 		else
-			bit = vhd_bitmap_test(vhd, buf, sec);
+			bit = vhd_bitmap_test(vhd, buf, blk);
 
+	print:
 		printf("block %s: ", conv(hex, blk));
 		printf("sec: %s: %d\n", conv(hex, sec), bit);
 	}
@@ -533,74 +476,9 @@
 }
 
 static int
-vhd_print_bitmap_extents(vhd_context_t *vhd, uint64_t sector, int count,
-			 int hex)
-{
-	char *buf;
-	uint64_t cur;
-	int i, err, bit;
-	uint32_t blk, bm_blk, sec;
-	int64_t s, r;
-
-	if (vhd_sectors_to_bytes(sector + count) > vhd->footer.curr_size) {
-		printf("sector %s past end of file\n", conv(hex, sector));
-		return -ERANGE;
-	}
-
-	bm_blk = -1;
-	buf    = NULL;
-	s = -1;
-	r = 0;
-
-	for (i = 0; i < count; i++) {
-		cur = sector + i;
-		blk = cur / vhd->spb;
-		sec = cur % vhd->spb;
-
-		if (blk != bm_blk) {
-			bm_blk = blk;
-			free(buf);
-			buf = NULL;
-
-			if (vhd->bat.bat[blk] != DD_BLK_UNUSED) {
-				err = vhd_read_bitmap(vhd, blk, &buf);
-				if (err)
-					goto out;
-			}
-		}
-
-		if (vhd->bat.bat[blk] == DD_BLK_UNUSED)
-			bit = 0;
-		else
-			bit = vhd_bitmap_test(vhd, buf, sec);
-
-		if (bit) {
-			if (r == 0)
-				s = cur;
-			r++;
-		} else {
-			if (r > 0) {
-				printf("%s ", conv(hex, s));
-				printf("%s\n", conv(hex, r));
-			}
-			r = 0;
-		}
-	}
-	if (r > 0) {
-		printf("%s ", conv(hex, s));
-		printf("%s\n", conv(hex, r));
-	}
-
-	err = 0;
- out:
-	free(buf);
-	return err;
-}
-
-static int
 vhd_print_batmap(vhd_context_t *vhd)
 {
-	int err, gcc;
+	int err;
 	size_t size;
 
 	err = vhd_get_batmap(vhd);
@@ -610,7 +488,7 @@
 	}
 
 	size = vhd_sectors_to_bytes(vhd->batmap.header.batmap_size);
-	gcc = write(STDOUT_FILENO, vhd->batmap.map, size);
+	write_full(STDOUT_FILENO, vhd->batmap.map, size);
 
 	return 0;
 }
@@ -652,7 +530,6 @@
 		return -ERANGE;
 
 	for (i = 0; i < count; i++) {
-		int gcc;
 		cur = block + i;
 
 		if (vhd->bat.bat[cur] == DD_BLK_UNUSED) {
@@ -664,7 +541,7 @@
 		if (err)
 			break;
 
-		gcc = write(STDOUT_FILENO, buf, vhd->header.block_size);
+		write_full(STDOUT_FILENO, buf, vhd->header.block_size);
 		free(buf);
 	}
 
@@ -688,14 +565,12 @@
 
 	cur = sec;
 	while (count) {
-		int gcc;
-
 		secs = MIN((max >> VHD_SECTOR_SHIFT), count);
 		err  = vhd_io_read(vhd, buf, cur, secs);
 		if (err)
 			break;
 
-		gcc = write(STDOUT_FILENO, buf, vhd_sectors_to_bytes(secs));
+		write_full(STDOUT_FILENO, buf, vhd_sectors_to_bytes(secs));
 
 		cur   += secs;
 		count -= secs;
@@ -705,72 +580,33 @@
 	return err;
 }
 
-static int
-vhd_read_bytes(vhd_context_t *vhd, uint64_t byte, int count, int hex)
-{
-	char *buf;
-	uint64_t cur;
-	int err, max, bytes;
-
-	if (byte + count > vhd->footer.curr_size)
-		return -ERANGE;
-
-	max = MIN(count, VHD_BLOCK_SIZE);
-	err = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, max);
-	if (err)
-		return -err;
-
-	cur = byte;
-	while (count) {
-		int gcc;
-
-		bytes = MIN(max, count);
-		err   = vhd_io_read_bytes(vhd, buf, bytes, cur);
-		if (err)
-			break;
-
-		gcc = write(STDOUT_FILENO, buf, bytes);
-
-		cur   += bytes;
-		count -= bytes;
-	}
-
-	free(buf);
-	return err;
-}
-
 int
 vhd_util_read(int argc, char **argv)
 {
 	char *name;
 	vhd_context_t vhd;
-	int c, err, headers, hex, bat_str, cache, flags;
-	uint64_t bat, bitmap, tbitmap, ebitmap, batmap, tbatmap, data, lsec, count, read;
-	uint64_t bread;
+	int c, err, headers, hex;
+	uint64_t bat, bitmap, tbitmap, batmap, tbatmap, data, lsec, count, read;
 
 	err     = 0;
 	hex     = 0;
-	cache   = 0;
 	headers = 0;
-	bat_str = 0;
 	count   = 1;
 	bat     = -1;
 	bitmap  = -1;
 	tbitmap = -1;
-	ebitmap = -1;
 	batmap  = -1;
 	tbatmap = -1;
 	data    = -1;
 	lsec    = -1;
 	read    = -1;
-	bread   = -1;
 	name    = NULL;
 
 	if (!argc || !argv)
 		goto usage;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "n:pt:b:Bm:i:e:aj:d:c:r:R:xCh")) != -1) {
+	while ((c = getopt(argc, argv, "n:pt:b:m:i:aj:d:c:r:xh")) != -1) {
 		switch(c) {
 		case 'n':
 			name = optarg;
@@ -778,12 +614,6 @@
 		case 'p':
 			headers = 1;
 			break;
-		case 'C':
-			cache = 1;
-			break;
-		case 'B':
-			bat_str = 1;
-			break;
 		case 't':
 			lsec = strtoul(optarg, NULL, 10);
 			break;
@@ -796,9 +626,6 @@
 		case 'i':
 			tbitmap = strtoul(optarg, NULL, 10);
 			break;
-		case 'e':
-			ebitmap = strtoul(optarg, NULL, 10);
-			break;
 		case 'a':
 			batmap = 1;
 			break;
@@ -811,9 +638,6 @@
 		case 'r':
 			read = strtoull(optarg, NULL, 10);
 			break;
-		case 'R':
-			bread = strtoull(optarg, NULL, 10);
-			break;
 		case 'c':
 			count = strtoul(optarg, NULL, 10);
 			break;
@@ -829,10 +653,7 @@
 	if (!name || optind != argc)
 		goto usage;
 
-	flags = VHD_OPEN_RDONLY | VHD_OPEN_IGNORE_DISABLED;
-	if (cache)
-		flags |= VHD_OPEN_CACHED | VHD_OPEN_FAST;
-	err = vhd_open(&vhd, name, flags);
+	err = vhd_open(&vhd, name, VHD_OPEN_RDONLY | VHD_OPEN_IGNORE_DISABLED);
 	if (err) {
 		printf("Failed to open %s: %d\n", name, err);
 		vhd_dump_headers(name, hex);
@@ -860,12 +681,6 @@
 			goto out;
 	}
 
-	if (bat_str) {
-		err = vhd_print_bat_str(&vhd);
-		if (err)
-			goto out;
-	}
-
 	if (bitmap != -1) {
 		err = vhd_print_bitmap(&vhd, bitmap, count, hex);
 		if (err)
@@ -878,12 +693,6 @@
 			goto out;
 	}
 
-	if (ebitmap != -1) {
-		err = vhd_print_bitmap_extents(&vhd, ebitmap, count, hex);
-		if (err)
-			goto out;
-	}
-
 	if (batmap != -1) {
 		err = vhd_print_batmap(&vhd);
 		if (err)
@@ -908,12 +717,6 @@
 			goto out;
 	}
 
-	if (bread != -1) {
-		err = vhd_read_bytes(&vhd, bread, count, hex);
-		if (err)
-			goto out;
-	}
-
 	err = 0;
 
  out:
@@ -927,16 +730,13 @@
 	       "-p          print VHD headers\n"
 	       "-t sec      translate logical sector to VHD location\n"
 	       "-b blk      print bat entry\n"
-	       "-B          print entire bat as a bitmap\n"
 	       "-m blk      print bitmap\n"
 	       "-i sec      test bitmap for logical sector\n"
-	       "-e sec      output extent list of allocated logical sectors\n"
 	       "-a          print batmap\n"
 	       "-j blk      test batmap for block\n"
 	       "-d blk      print data\n"
 	       "-c num      num units\n"
 	       "-r sec      read num sectors at sec\n"
-	       "-R byte     read num bytes at byte\n"
 	       "-x          print in hex\n");
 	return EINVAL;
 }
diff -Nur blktap2_oxt//vhd/lib/vhd-util-repair.c blktap2_xen//vhd/lib/vhd-util-repair.c
--- blktap2_oxt//vhd/lib/vhd-util-repair.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-repair.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <errno.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -41,6 +37,7 @@
 {
 	char *name;
 	int err, c;
+	off_t eof;
 	vhd_context_t vhd;
 
 	name = NULL;
@@ -69,10 +66,15 @@
 		return err;
 	}
 
-	err = vhd_write_footer(&vhd, &vhd.footer);
-	if (err)
-		printf("error writing footer: %d\n", err);
+	err = vhd_end_of_data(&vhd, &eof);
+	if (err) {
+		printf("error finding end of data: %d\n", err);
+		goto done;
+	}
+
+	err = vhd_write_footer_at(&vhd, &vhd.footer, eof);
 
+ done:
 	vhd_close(&vhd);
 	return err;
 
diff -Nur blktap2_oxt//vhd/lib/vhd-util-resize.c blktap2_xen//vhd/lib/vhd-util-resize.c
--- blktap2_oxt//vhd/lib/vhd-util-resize.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-resize.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <errno.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -99,7 +95,7 @@
 }
 
 static int
-vhd_write_zeros(vhd_journal_t *journal, off64_t off, uint64_t size)
+vhd_write_zeros(vhd_journal_t *journal, off_t off, uint64_t size)
 {
 	int err;
 	char *buf;
@@ -113,7 +109,7 @@
 	if (err)
 		return err;
 
-	buf = mmap(0, map, PROT_READ, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
+	buf = mmap(0, map, PROT_READ, MAP_SHARED | MAP_ANON, -1, 0);
 	if (buf == MAP_FAILED)
 		return -errno;
 
@@ -147,7 +143,7 @@
 		goto out;
 
 	eof = vhd_position(vhd);
-	if (eof == (off64_t)-1) {
+	if (eof == (off_t)-1) {
 		err = -errno;
 		goto out;
 	}
@@ -238,13 +234,13 @@
 }
 
 static int
-vhd_move_block(vhd_journal_t *journal, uint32_t src, off64_t offset)
+vhd_move_block(vhd_journal_t *journal, uint32_t src, off_t offset)
 {
 	int err;
 	char *buf;
 	size_t size;
 	vhd_context_t *vhd;
-	off64_t off, src_off;
+	off_t off, src_off;
 
 	buf     = NULL;
 	vhd     = &journal->vhd;
@@ -304,7 +300,7 @@
 vhd_clobber_block(vhd_journal_t *journal, uint32_t src, uint32_t dest)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	vhd_context_t *vhd;
 
 	vhd = &journal->vhd;
@@ -408,7 +404,7 @@
 {
 	int i, err;
 	vhd_context_t *vhd;
-	off64_t orig_map_off, new_map_off;
+	off_t orig_map_off, new_map_off;
 	uint32_t orig_entries, new_entries;
 
 	vhd          = &journal->vhd;
@@ -477,7 +473,7 @@
 static int
 vhd_dynamic_shrink(vhd_journal_t *journal, uint64_t secs)
 {
-	off64_t eof;
+	off_t eof;
 	uint32_t blocks;
 	vhd_context_t *vhd;
 	int i, j, err, free_cnt;
@@ -585,7 +581,7 @@
 }
 
 static inline int
-in_range(off64_t off, off64_t start, off64_t size)
+in_range(off_t off, off_t start, off_t size)
 {
 	return (start < off && start + size > off);
 }
@@ -603,7 +599,7 @@
 }
 
 static int
-vhd_check_for_clobber(vhd_context_t *vhd, off64_t off, int mode)
+vhd_check_for_clobber(vhd_context_t *vhd, off_t off, int mode)
 {
 	int i, n;
 	char *msg;
@@ -680,7 +676,7 @@
  * take any metadata after the bat (@eob) and shift it
  */
 static int
-vhd_shift_metadata(vhd_journal_t *journal, off64_t eob,
+vhd_shift_metadata(vhd_journal_t *journal, off_t eob,
 		   size_t bat_needed, size_t map_needed)
 {
 	int i, n, err;
@@ -728,7 +724,7 @@
 	}
 
 	for (i = 0; i < n; i++) {
-		off64_t off;
+		off_t off;
 		size_t size;
 
 		if (!locators[i])
@@ -779,7 +775,7 @@
 vhd_add_bat_entries(vhd_journal_t *journal, int entries)
 {
 	int i, err;
-	off64_t off;
+	off_t off;
 	vhd_bat_t new_bat;
 	vhd_context_t *vhd;
 	uint32_t new_entries;
@@ -799,7 +795,7 @@
 	off = vhd->header.table_offset + new_bat_size;
 	if (vhd_check_for_clobber(vhd, off, SKIP_BAT | SKIP_BATMAP)) {
 		EPRINTF("%s: writing new bat of 0x%"PRIx64" bytes "
-			"at 0x%08llx would clobber data\n", 
+			"at 0x%08"PRIx64" would clobber data\n", 
 			vhd->file, new_bat_size, vhd->header.table_offset);
 		return -EINVAL;
 	}
@@ -808,7 +804,7 @@
 		off = vhd->batmap.header.batmap_offset + new_map_size;
 		if (vhd_check_for_clobber(vhd, off, 0)) {
 			EPRINTF("%s: writing new batmap of 0x%"PRIx64" bytes"
-				" at 0x%08llx would clobber data\n", vhd->file,
+				" at 0x%08"PRIx64" would clobber data\n", vhd->file,
 				new_map_size, vhd->batmap.header.batmap_offset);
 			return -EINVAL;
 		}
@@ -820,6 +816,14 @@
 	if (err)
 		return err;
 
+	/* update footer */
+	vhd->footer.curr_size = (uint64_t)new_entries * vhd->header.block_size;
+	vhd->footer.geometry  = vhd_chs(vhd->footer.curr_size);
+	vhd->footer.checksum  = vhd_checksum_footer(&vhd->footer);
+	err = vhd_write_footer(vhd, &vhd->footer);
+	if (err)
+		return err;
+
 	/* allocate new bat */
 	err = posix_memalign((void **)&new_bat.bat, VHD_SECTOR_SIZE, new_bat_size);
 	if (err)
@@ -867,22 +871,14 @@
 	free(vhd->batmap.map);
 	vhd->batmap = new_batmap;
 
-	/* update footer */
-	vhd->footer.curr_size = (uint64_t)new_entries * vhd->header.block_size;
-	vhd->footer.geometry  = vhd_chs(vhd->footer.curr_size);
-	vhd->footer.checksum  = vhd_checksum_footer(&vhd->footer);
-	err = vhd_write_footer(vhd, &vhd->footer);
-	if (err)
-		return err;
-
 	return 0;
 }
 
 static int
 vhd_dynamic_grow(vhd_journal_t *journal, uint64_t secs)
 {
-	int err;
-	off64_t eob, eom;
+	int i, err;
+	off_t eob, eom;
 	vhd_context_t *vhd;
 	vhd_block_t first_block;
 	uint64_t blocks, size_needed;
@@ -957,7 +953,7 @@
 	 * move vhd data blocks to the end of the file to make room 
 	 */
 	do {
-		off64_t new_off, bm_size, gap_size;
+		off_t new_off, bm_size, gap_size;
 
 		new_off = vhd_sectors_to_bytes(vhd_next_block_offset(vhd));
 
@@ -1052,51 +1048,12 @@
 	return err;
 }
 
-static int
-vhd_dynamic_grow_fast(const char *name, uint64_t bytes)
-{
-	vhd_context_t vhd;
-	uint64_t blks, size;
-	int err;
-
-	err = vhd_open(&vhd, name, VHD_OPEN_RDWR);
-	if (err)
-		return err;
-
-	err = vhd_get_bat(&vhd);
-	if (err)
-		goto done;
-
-	if (vhd_has_batmap(&vhd)) {
-		err = vhd_get_batmap(&vhd);
-		if (err)
-			goto done;
-	}
-
-	blks   = (bytes + VHD_BLOCK_SIZE - 1) >> VHD_BLOCK_SHIFT;
-	size   = blks << VHD_BLOCK_SHIFT;
-	if (size < vhd.footer.curr_size) {
-		printf("%s: size (%llu) < curr size (%llu)\n", 
-				name, size, vhd.footer.curr_size);
-		err = -EINVAL;
-		goto done;
-	}
-	if (size == vhd.footer.curr_size)
-		goto done;
-
-	err = vhd_set_virt_size(&vhd, size);
-
-done:
-	vhd_close(&vhd);
-	return err;
-}
-
 int
 vhd_util_resize(int argc, char **argv)
 {
 	char *name, *jname;
 	uint64_t size;
-	int fast, c, err, jerr;
+	int c, err, jerr;
 	vhd_journal_t journal;
 	vhd_context_t *vhd;
 
@@ -1104,10 +1061,9 @@
 	size  = 0;
 	name  = NULL;
 	jname = NULL;
-	fast  = 0;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "n:s:j:fh")) != -1) {
+	while ((c = getopt(argc, argv, "n:j:s:h")) != -1) {
 		switch (c) {
 		case 'n':
 			name = optarg;
@@ -1115,9 +1071,6 @@
 		case 'j':
 			jname = optarg;
 			break;
-		case 'f':
-			fast = 1;
-			break;
 		case 's':
 			err  = 0;
 			size = strtoull(optarg, NULL, 10);
@@ -1128,10 +1081,7 @@
 		}
 	}
 
-	if (err || !name || (!jname && !fast) || argc != optind)
-		goto usage;
-
-	if (jname && fast)
+	if (err || !name || !jname || argc != optind)
 		goto usage;
 
 	err = vhd_util_resize_check_creator(name);
@@ -1139,10 +1089,6 @@
 		return err;
 
 	libvhd_set_log_level(1);
-
-	if (fast)
-		return vhd_dynamic_grow_fast(name, size << 20);
-
 	err = vhd_journal_create(&journal, name, jname);
 	if (err) {
 		printf("creating journal failed: %d\n", err);
@@ -1180,15 +1126,6 @@
 	return (err ? : jerr);
 
 usage:
-	printf("options: <-n name> <-s size (in MB)> (<-j journal>|<-f fast>) "
-			"[-h help]\n\n"
-			"The resize operation can only be performed offline "
-			"and must be journaled because resizing the metadata "
-			"might require moving data blocks. However, if a "
-			"VHD was created with -S <msize> option (during "
-			"vhd-util create/snapshot), which preallocates the "
-			"metadata for growing the VHD up to size <msize>, then "
-			"resizing such a VHD up to <msize> can be performed "
-			"online without journaling (-f option).\n");
+	printf("options: <-n name> <-j journal> <-s size (in MB)> [-h help]\n");
 	return -EINVAL;
 }
diff -Nur blktap2_oxt//vhd/lib/vhd-util-scan.c blktap2_xen//vhd/lib/vhd-util-scan.c
--- blktap2_oxt//vhd/lib/vhd-util-scan.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-scan.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,7 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
+*/
 
 #include <glob.h>
 #include <errno.h>
@@ -36,7 +33,7 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <fnmatch.h>
-#include <syslog.h>
+#include <libgen.h>	/* for basename() */
 #include <sys/stat.h>
 
 #include "list.h"
@@ -49,18 +46,12 @@
 #define VHD_SCAN_NOFAIL      0x08
 #define VHD_SCAN_VERBOSE     0x10
 #define VHD_SCAN_PARENTS     0x20
-#define VHD_SCAN_MARKERS     0x40
 
 #define VHD_TYPE_RAW_FILE    0x01
 #define VHD_TYPE_VHD_FILE    0x02
 #define VHD_TYPE_RAW_VOLUME  0x04
 #define VHD_TYPE_VHD_VOLUME  0x08
 
-#define EPRINTF(_f, _a...)					\
-	do {							\
-		syslog(LOG_INFO, "%s: " _f, __func__, ##_a);	\
-	} while (0)
-
 static inline int
 target_volume(uint8_t type)
 {
@@ -93,10 +84,8 @@
 	char                *name;
 	char                *parent;
 	uint64_t             capacity;
-	off64_t              size;
+	off_t                size;
 	uint8_t              hidden;
-	char                 marker;
-	struct vhd_keyhash   keyhash;
 	int                  error;
 	char                *message;
 
@@ -126,6 +115,7 @@
 vhd_util_scan_pretty_allocate_list(int cnt)
 {
 	int i;
+	struct vhd_image *list;
 
 	memset(&scan, 0, sizeof(scan));
 
@@ -227,10 +217,8 @@
 	img->capacity = image->capacity;
 	img->size     = image->size;
 	img->hidden   = image->hidden;
-	img->marker   = image->marker;
 	img->error    = image->error;
 	img->message  = image->message;
-	memcpy(&img->keyhash, &image->keyhash, sizeof(img->keyhash));
 
 	img->name = strdup(image->name);
 	if (!img->name)
@@ -286,28 +274,10 @@
 	if (image->error)
 		printf("%*svhd=%s scan-error=%d error-message='%s'\n",
 		       tab, pad, image->name, image->error, image->message);
-	else if (!(flags & VHD_SCAN_MARKERS))
+	else
 		printf("%*svhd=%s capacity=%"PRIu64" size=%"PRIu64" hidden=%u "
 		       "parent=%s%s\n", tab, pad, name, image->capacity,
 		       image->size, image->hidden, parent, pmsg);
-	else {
-		int i;
-		uint8_t *hash;
-		char *p, str[65];
-
-		str[0] = 0;
-		hash   = image->keyhash.hash;
-
-		if (image->keyhash.cookie)
-			for (i = 0, p = str;
-			     i < sizeof(image->keyhash.hash); i++)
-				p += sprintf(p, "%02x", hash[i]);
-
-		printf("%*svhd=%s capacity=%"PRIu64" size=%"PRIu64" hidden=%u "
-		       "marker=%u keyhash=%s parent=%s%s\n", tab, pad, name,
-		       image->capacity, image->size, image->hidden,
-		       (uint8_t)image->marker, str, parent, pmsg);
-	}
 }
 
 static void
@@ -473,6 +443,7 @@
 static int
 vhd_util_scan_extract_volume_name(char *dst, const char *src)
 {
+	int err;
 	char copy[VHD_MAX_NAME_LEN], *name, *s, *c;
 
 	name = strrchr(src, '/');
@@ -539,7 +510,7 @@
 static int
 vhd_util_scan_get_parent(vhd_context_t *vhd, struct vhd_image *image)
 {
-	int err;
+	int i, err;
 	vhd_parent_locator_t *loc;
 
 	if (!target_vhd(image->target->type)) {
@@ -597,32 +568,6 @@
 }
 
 static int
-vhd_util_scan_get_markers(vhd_context_t *vhd, struct vhd_image *image)
-{
-	int err;
-	char marker;
-	struct vhd_keyhash keyhash;
-
-	err    = 0;
-	marker = 0;
-
-	if (target_vhd(image->target->type) /* && vhd_has_batmap(vhd) */) {
-		err = vhd_marker(vhd, &marker);
-		if (err)
-			return err;
-
-		err = vhd_get_keyhash(vhd, &keyhash);
-		if (err)
-			return err;
-	}
-
-	image->marker = marker;
-	memcpy(&image->keyhash, &keyhash, sizeof(image->keyhash));
-
-	return err;
-}
-
-static int
 vhd_util_scan_get_size(vhd_context_t *vhd, struct vhd_image *image)
 {
 	image->size = image->target->size;
@@ -733,6 +678,7 @@
 static int
 vhd_util_scan_open_volume(vhd_context_t *vhd, struct vhd_image *image)
 {
+	int err;
 	struct target *target;
 
 	target = image->target;
@@ -778,7 +724,7 @@
 	if (target_volume(image->target->type) || !(flags & VHD_SCAN_PRETTY))
 		image->name = target->name;
 	else {
-		image->name = vhd_realpath(target->name, NULL);
+		image->name = realpath(target->name, NULL);
 		if (!image->name) {
 			image->name    = target->name;
 			image->message = "resolving name";
@@ -830,17 +776,12 @@
 		return -ENOSYS;
 
 	err = copy_name(target->name, lv->name);
-	if (err) {
-		EPRINTF("copy target name failed: '%s'\n", lv->name);
+	if (err)
 		return err;
-	}
 
 	err = copy_name(target->device, lv->first_segment.device);
-	if (err) {
-		EPRINTF("copy target device failed: '%s'\n",
-				lv->first_segment.device);
+	if (err)
 		return err;
-	}
 
 	target->type  = type;
 	target->size  = lv->size;
@@ -1032,16 +973,6 @@
 			goto end;
 		}
 
-		if (flags & VHD_SCAN_MARKERS) {
-			err = vhd_util_scan_get_markers(&vhd, &image);
-			if (err) {
-				ret           = -EAGAIN;
-				image.message = "checking markers";
-				image.error   = err;
-				goto end;
-			}
-		}
-
 		if (vhd.footer.type == HD_TYPE_DIFF) {
 			err = vhd_util_scan_get_parent(&vhd, &image);
 			if (err) {
@@ -1214,8 +1145,6 @@
 		err = fnmatch(filter, lv->name, FNM_PATHNAME);
 		if (err) {
 			if (err != FNM_NOMATCH) {
-				EPRINTF("fnmatch failed: '%s', '%s'\n", 
-						filter, lv->name);
 				vhd_util_scan_error(lv->name, err);
 				if (!(flags & VHD_SCAN_NOFAIL))
 					return err;
@@ -1306,7 +1235,7 @@
 int
 vhd_util_scan(int argc, char **argv)
 {
-	int c, ret, err, cnt, markers;
+	int c, ret, err, cnt;
 	char *filter, *volume;
 	struct target *targets;
 
@@ -1314,13 +1243,12 @@
 	ret     = 0;
 	err     = 0;
 	flags   = 0;
-	markers = 0;
 	filter  = NULL;
 	volume  = NULL;
 	targets = NULL;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "m:fcl:pavMh")) != -1) {
+	while ((c = getopt(argc, argv, "m:fcl:pavh")) != -1) {
 		switch (c) {
 		case 'm':
 			filter = optarg;
@@ -1344,9 +1272,6 @@
 		case 'v':
 			flags |= VHD_SCAN_VERBOSE;
 			break;
-		case 'M':
-			flags |= VHD_SCAN_MARKERS;
-			break;
 		case 'h':
 			goto usage;
 		default:
@@ -1387,6 +1312,6 @@
 	printf("usage: [OPTIONS] FILES\n"
 	       "options: [-m match filter] [-f fast] [-c continue on failure] "
 	       "[-l LVM volume] [-p pretty print] [-a scan parents] "
-	       "[-v verbose] [-h help] [-M show markers]\n");
+	       "[-v verbose] [-h help]\n");
 	return err;
 }
diff -Nur blktap2_oxt//vhd/lib/vhd-util-set-field.c blktap2_xen//vhd/lib/vhd-util-set-field.c
--- blktap2_oxt//vhd/lib/vhd-util-set-field.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-set-field.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <errno.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -41,6 +37,7 @@
 {
 	long value;
 	int err, c;
+	off_t eof;
 	vhd_context_t vhd;
 	char *name, *field;
 
@@ -79,7 +76,7 @@
 		goto usage;
 	}
 
-	if (strcmp(field, "hidden") && strcmp(field, "marker")) {
+	if (strcmp(field, "hidden")) {
 		printf("invalid field %s\n", field);
 		goto usage;
 	}
@@ -95,17 +92,11 @@
 		return err;
 	}
 
-	if (!strcmp(field, "hidden")) {
-		vhd.footer.hidden = (char)value;
-		err = vhd_write_footer(&vhd, &vhd.footer);
-		if (err == -ENOSPC && vhd_type_dynamic(&vhd) && value)
-			/* if no space to write the primary footer, at least write the 
-			 * backup footer so that it's possible to delete the VDI */
-			err = vhd_write_footer_at(&vhd, &vhd.footer, 0);
-	} else {
-		err = vhd_set_marker(&vhd, (char)value);
-	}
+	vhd.footer.hidden = (char)value;
+
+	err = vhd_write_footer(&vhd, &vhd.footer);
 		
+ done:
 	vhd_close(&vhd);
 	return err;
 
diff -Nur blktap2_oxt//vhd/lib/vhd-util-snapshot.c blktap2_xen//vhd/lib/vhd-util-snapshot.c
--- blktap2_oxt//vhd/lib/vhd-util-snapshot.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-snapshot.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <errno.h>
 #include <stdio.h>
 #include <fcntl.h>
@@ -111,7 +107,7 @@
 	vhd_flag_creat_t flags;
 	int c, err, prt_raw, limit;
 	char *name, *pname, *ppath, *backing;
-	uint64_t size, msize;
+	uint64_t size;
 	vhd_context_t vhd;
 
 	name    = NULL;
@@ -119,7 +115,6 @@
 	ppath   = NULL;
 	backing = NULL;
 	size    = 0;
-	msize   = 0;
 	flags   = 0;
 	limit   = 0;
 
@@ -129,7 +124,7 @@
 	}
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "n:p:S:l:mh")) != -1) {
+	while ((c = getopt(argc, argv, "n:p:l:mh")) != -1) {
 		switch (c) {
 		case 'n':
 			name = optarg;
@@ -137,9 +132,6 @@
 		case 'p':
 			pname = optarg;
 			break;
-		case 'S':
-			msize = strtoull(optarg, NULL, 10);
-			break;
 		case 'l':
 			limit = strtol(optarg, NULL, 10);
 			break;
@@ -160,7 +152,7 @@
 		goto usage;
 	}
 
-	ppath = vhd_realpath(pname, NULL);
+	ppath = realpath(pname, NULL);
 	if (!ppath)
 		return -errno;
 
@@ -209,7 +201,7 @@
 			goto out;
 	}
 
-	err = vhd_snapshot(name, size, backing, msize << 20, flags);
+	err = vhd_snapshot(name, size, backing, flags);
 
 out:
 	free(ppath);
@@ -219,7 +211,6 @@
 
 usage:
 	printf("options: <-n name> <-p parent name> [-l snapshot depth limit]"
-	       " [-m parent_is_raw] [-S size (MB) for metadata preallocation "
-	       "(see vhd-util resize)] [-h help]\n");
+	       " [-m parent_is_raw] [-h help]\n");
 	return err;
 }
diff -Nur blktap2_oxt//vhd/Makefile blktap2_xen//vhd/Makefile
--- blktap2_oxt//vhd/Makefile	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/Makefile	2015-03-19 11:08:36.000000000 -0400
@@ -1,56 +1,49 @@
-#
-# Copyright (c) 2012 Citrix Systems, Inc.
-#
+XEN_ROOT=$(CURDIR)/../../..
+BLKTAP_ROOT := ..
+include $(XEN_ROOT)/tools/Rules.mk
 
-BLKTAP_ROOT := ../
-include $(BLKTAP_ROOT)/Rules.mk
+SUBDIRS-y         :=
+SUBDIRS-y         += lib
 
-IBIN               = vhd-util vhd-index vhd-update
-INST_DIR           = /usr/sbin
+IBIN               = vhd-util vhd-update
+INST_DIR           = $(SBINDIR)
 
-CFLAGS            += -Wall
 CFLAGS            += -Werror
 CFLAGS            += -Wno-unused
 CFLAGS            += -I../include
 CFLAGS            += -D_GNU_SOURCE
 
+ifeq ($(CONFIG_X86_64),y)
+CFLAGS            += -fPIC
+endif
+
 ifeq ($(VHD_STATIC),y)
 CFLAGS            += -static
 endif
 
-LIBS              := -Llib -lvhd -licbinn_resolved -ldl -lpthread
-LIBS              += -luuid -lcrypto
-
-# Get gcc to generate the dependencies for us.
-CFLAGS            += -Wp,-MD,.$(@F).d
-DEPS               = .*.d
-
-all: build
+LIBS              := -Llib -lvhd
 
-build: libvhd $(IBIN)
+all: subdirs-all build
 
-libvhd:
-	@set -e
-	$(MAKE) -C lib all
+build: $(IBIN)
 
-vhd-util: vhd-util.o
-	$(CC) $(CFLAGS) -o vhd-util vhd-util.o $(LIBS)
+LIBS_DEPENDS	  := lib/libvhd.so lib/vhd.a
+$(LIBS_DEPENDS):subdirs-all
 
-vhd-index: vhd-index.o
-	$(CC) $(CFLAGS) -o vhd-index vhd-index.o $(LIBS)
+vhd-util: vhd-util.o $(LIBS_DEPENDS)
+	$(CC) $(LDFLAGS) -o vhd-util vhd-util.o $(LIBS)
 
-vhd-update: vhd-update.o
-	$(CC) $(CFLAGS) -o vhd-update vhd-update.o $(LIBS)
+vhd-update: vhd-update.o $(LIBS_DEPENDS)
+	$(CC) $(LDFLAGS) -o vhd-update vhd-update.o $(LIBS)
 
 install: all
-	$(MAKE) -C lib install
+	$(MAKE) subdirs-install
 	$(INSTALL_DIR) -p $(DESTDIR)$(INST_DIR)
 	$(INSTALL_PROG) $(IBIN) $(DESTDIR)$(INST_DIR)
 
-clean:
-	$(MAKE) -C lib clean
+clean: subdirs-clean
 	rm -rf *.o *~ $(DEPS) $(IBIN)
 
-.PHONY: all build clean install libvhd
+.PHONY: all build clean install vhd-util vhd-update
 
 -include $(DEPS)
diff -Nur blktap2_oxt//vhd/vhd-util.c blktap2_xen//vhd/vhd-util.c
--- blktap2_oxt//vhd/vhd-util.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/vhd-util.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -63,11 +59,6 @@
 	{ .name = "scan",        .func = vhd_util_scan          },
 	{ .name = "check",       .func = vhd_util_check         },
 	{ .name = "revert",      .func = vhd_util_revert        },
-	{ .name = "dm-encrypt",  .func = vhd_util_dm_encrypt    },
-	{ .name = "dm-decrypt",  .func = vhd_util_dm_decrypt    },
-	{ .name = "key",         .func = vhd_util_key           },
-	{ .name = "clone-metadata", .func = vhd_util_clone_metadata },
-	{ .name = "stream-coalesce", .func = vhd_util_stream_coalesce },
 };
 
 #define print_commands()					\
