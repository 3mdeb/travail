diff -Nur blktap2_oxt//control/blktap.rules blktap2_xen//control/blktap.rules
--- blktap2_oxt//control/blktap.rules	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/blktap.rules	1969-12-31 19:00:00.000000000 -0500
@@ -1,3 +0,0 @@
-SUBSYSTEM=="misc",	KERNEL=="blktap-control",	NAME="blktap/control"
-SUBSYSTEM=="blktap2",	KERNEL=="blktap[0-9]*",		NAME="blktap/%k"
-SUBSYSTEM=="block",	KERNEL=="td[a-z]*",		NAME="%k"
diff -Nur blktap2_oxt//control/Makefile blktap2_xen//control/Makefile
--- blktap2_oxt//control/Makefile	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/Makefile	2015-03-19 11:08:36.000000000 -0400
@@ -1,22 +1,21 @@
-#
-# Copyright (c) 2012 Citrix Systems, Inc.
-#
+XEN_ROOT := $(CURDIR)/../../../
+include $(XEN_ROOT)/tools/Rules.mk
 
-BLKTAP_ROOT := ../
-include $(BLKTAP_ROOT)/Rules.mk
+MAJOR              = 1.0
+MINOR              = 0
+LIBNAME            = libblktapctl
+LIBSONAME          = $(LIBNAME).so.$(MAJOR)
 
 IBIN               = tap-ctl
 
-#CFLAGS            += -Werror
+CFLAGS            += -Werror
 CFLAGS            += -Wno-unused
 CFLAGS            += -I../include -I../drivers
+CFLAGS            += $(CFLAGS_xeninclude)
+CFLAGS            += $(CFLAGS_libxenctrl)
 CFLAGS            += -D_GNU_SOURCE
 CFLAGS            += -DTAPCTL
 
-# Get gcc to generate the dependencies for us.
-CFLAGS            += -Wp,-MD,.$(@F).d
-DEPS               = .*.d
-
 CTL_OBJS  := tap-ctl-ipc.o
 CTL_OBJS  += tap-ctl-list.o
 CTL_OBJS  += tap-ctl-allocate.o
@@ -32,43 +31,46 @@
 CTL_OBJS  += tap-ctl-unpause.o
 CTL_OBJS  += tap-ctl-major.o
 CTL_OBJS  += tap-ctl-check.o
-CTL_OBJS  += tap-ctl-stats.o
 
 CTL_PICS  = $(patsubst %.o,%.opic,$(CTL_OBJS))
 
 OBJS = $(CTL_OBJS) tap-ctl.o
 PICS = $(CTL_PICS)
 
-LIBTAPCTL_MAJOR = 0.1
-LIBTAPCTL_MINOR = 0
-
-LIBS = libblktapctl.a libblktapctl.so.$(LIBTAPCTL_MAJOR).$(LIBTAPCTL_MINOR)
+LIB_STATIC = $(LIBNAME).a
+LIB_SHARED = $(LIBSONAME).$(MINOR)
 IBIN = tap-ctl
 
 all: build
 
-build: $(IBIN) $(LIBS)
+build: $(IBIN) $(LIB_STATIC) $(LIB_SHARED)
+
+$(LIBNAME).so: $(LIBSONAME)
+	ln -sf $< $@
+
+$(LIBSONAME): $(LIB_SHARED)
+	ln -sf $< $@
 
-tap-ctl: tap-ctl.o libblktapctl.so.$(LIBTAPCTL_MAJOR).$(LIBTAPCTL_MINOR)
-	$(CC) $(CFLAGS) -o $@ $^
+tap-ctl: tap-ctl.o $(LIBNAME).so
+	$(CC) $(LDFLAGS) -o $@ $^
 
-libblktapctl.a: $(CTL_OBJS)
+$(LIB_STATIC): $(CTL_OBJS)
 	$(AR) r $@ $^
 
-libblktapctl.so.$(LIBTAPCTL_MAJOR).$(LIBTAPCTL_MINOR): $(CTL_PICS)
-	$(CC) $(CFLAGS) -fPIC -shared -rdynamic $^ -o $@
+$(LIB_SHARED): $(CTL_PICS)
+	$(CC) $(LDFLAGS) -fPIC  -Wl,$(SONAME_LDFLAG) -Wl,$(LIBSONAME) $(SHLIB_LDFLAGS) -rdynamic $^ -o $@
 
-install: $(IBIN) $(LIBS)
+install: $(IBIN) $(LIB_STATIC) $(LIB_SHARED)
 	$(INSTALL_DIR) -p $(DESTDIR)$(SBINDIR)
 	$(INSTALL_PROG) $(IBIN) $(DESTDIR)$(SBINDIR)
-	$(INSTALL_DIR) -p $(DESTDIR)$(LIBDIR)
-	$(INSTALL_DATA) $(LIBS) $(DESTDIR)$(LIBDIR)
-	ln -sf libblktapctl.so.$(LIBTAPCTL_MAJOR).$(LIBTAPCTL_MINOR) libblktapctl.so
-#	$(INSTALL_DIR) -p $(DESTDIR)$(SYSCONFDIR)/udev/rules.d
-#	$(INSTALL_DATA) blktap.rules $(DESTDIR)$(SYSCONFDIR)/udev/rules.d/
+	$(INSTALL_DATA) $(LIB_STATIC) $(DESTDIR)$(LIBDIR)
+	$(INSTALL_PROG) $(LIB_SHARED) $(DESTDIR)$(LIBDIR)
+	ln -sf $(LIBSONAME) $(DESTDIR)$(LIBDIR)/$(LIBNAME).so
+	ln -sf $(LIB_SHARED) $(DESTDIR)$(LIBDIR)/$(LIBSONAME)
 
 clean:
-	rm -f $(OBJS) $(PICS) $(DEPS) $(IBIN) $(LIBS) libblktapctl.so*
+	rm -f $(OBJS) $(PICS) $(DEPS) $(IBIN) $(LIB_STATIC) $(LIB_SHARED)
+	rm -f $(LIBNAME).so $(LIBSONAME)
 	rm -f *~
 
 .PHONY: all build clean install
diff -Nur blktap2_oxt//control/tap-ctl-allocate.c blktap2_xen//control/tap-ctl-allocate.c
--- blktap2_oxt//control/tap-ctl-allocate.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-allocate.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
diff -Nur blktap2_oxt//control/tap-ctl-attach.c blktap2_xen//control/tap-ctl-attach.c
--- blktap2_oxt//control/tap-ctl-attach.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-attach.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -48,7 +43,7 @@
 	message.type = TAPDISK_MESSAGE_ATTACH;
 	message.cookie = minor;
 
-	err = tap_ctl_connect_send_and_receive(id, &message, NULL);
+	err = tap_ctl_connect_send_and_receive(id, &message, 5);
 	if (err)
 		return err;
 
diff -Nur blktap2_oxt//control/tap-ctl.c blktap2_xen//control/tap-ctl.c
--- blktap2_oxt//control/tap-ctl.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//control/tap-ctl.c	2015-03-19 11:08:36.000000000 -0400
@@ -26,20 +26,11 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 #include <getopt.h>
-#include <signal.h>
-#include <sys/time.h>
-#include <sys/stat.h>
-#include <sys/types.h>
 
 #include "tap-ctl.h"
 
@@ -58,7 +49,7 @@
 }
 
 static void
-tap_cli_list_row(tap_list_t *entry)
+tap_ctl_list_row(tap_list_t *entry)
 {
 	char minor_str[10] = "-";
 	char state_str[10] = "-";
@@ -71,15 +62,15 @@
 		sprintf(minor_str, "%d", entry->minor);
 
 	if (entry->state != -1)
-		sprintf(state_str, "%#x", entry->state);
+		sprintf(state_str, "%x", entry->state);
 
-	printf("%8s %4s %4s %10s %s\n",
+	printf("%8s %2s %4s %10s %s\n",
 	       pid_str, minor_str, state_str,
 	       entry->type ? : "-", entry->path ? : "-");
 }
 
 static void
-tap_cli_list_dict(tap_list_t *entry)
+tap_ctl_list_dict(tap_list_t *entry)
 {
 	int d = 0;
 
@@ -95,7 +86,7 @@
 
 	if (entry->state != -1) {
 		if (d) putc(' ', stdout);
-		d = printf("state=%#x", entry->state);
+		d = printf("state=%d", entry->state);
 	}
 
 	if (entry->type && entry->path) {
@@ -109,12 +100,15 @@
 int
 tap_cli_list(int argc, char **argv)
 {
-	struct list_head list = LIST_HEAD_INIT(list);
+	tap_list_t **list, **_entry;
 	int c, minor, tty, err;
 	const char *type, *file;
-	tap_list_t *entry;
 	pid_t pid;
 
+	err = tap_ctl_list(&list);
+	if (err)
+		return -err;
+
 	pid   = -1;
 	minor = -1;
 	type  = NULL;
@@ -142,35 +136,30 @@
 		}
 	}
 
-	if (pid != -1)
-		err = tap_ctl_list_pid(pid, &list);
-	else
-		err = tap_ctl_list(&list);
-	if (err)
-		return -err;
-
 	tty = isatty(STDOUT_FILENO);
 
-	tap_list_for_each_entry(entry, &list) {
+	for (_entry = list; *_entry != NULL; ++_entry) {
+		tap_list_t *entry  = *_entry;
+
 		if (minor >= 0 && entry->minor != minor)
 			continue;
 
 		if (pid >= 0 && entry->pid != pid)
 			continue;
 
-		if (type && entry->type && strcmp(entry->type, type))
+		if (type && (!entry->type || strcmp(entry->type, type)))
 			continue;
 
-		if (file && entry->path && strcmp(entry->path, file))
+		if (file && (!entry->path || strcmp(entry->path, file)))
 			continue;
 
 		if (tty)
-			tap_cli_list_row(entry);
+			tap_ctl_list_row(entry);
 		else
-			tap_cli_list_dict(entry);
+			tap_ctl_list_dict(entry);
 	}
 
-	tap_ctl_list_free(&list);
+	tap_ctl_free_list(list);
 
 	return 0;
 
@@ -258,27 +247,20 @@
 static void
 tap_cli_create_usage(FILE *stream)
 {
-	fprintf(stream, "usage: create <-a args> [-d device name] [-R readonly] "
-		"[-e <minor> stack on existing tapdisk for the parent chain] "
-		"[-r turn on read caching into leaf node] [-2 <path> "
-		"use secondary image (in mirror mode if no -s)] [-s "
-		"fail over to the secondary image on ENOSPC]\n");
+	fprintf(stream, "usage: create <-a args> [-d device name]\n");
 }
 
 static int
 tap_cli_create(int argc, char **argv)
 {
-	int c, err, flags, prt_minor;
-	char *args, *devname, *secondary;
+	int c, err;
+	char *args, *devname;
 
-	args      = NULL;
-	devname   = NULL;
-	secondary = NULL;
-	prt_minor = -1;
-	flags     = 0;
+	args    = NULL;
+	devname = NULL;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "a:Rd:e:r2:sh")) != -1) {
+	while ((c = getopt(argc, argv, "a:d:h")) != -1) {
 		switch (c) {
 		case 'a':
 			args = optarg;
@@ -286,23 +268,6 @@
 		case 'd':
 			devname = optarg;
 			break;
-		case 'R':
-			flags |= TAPDISK_MESSAGE_FLAG_RDONLY;
-			break;
-		case 'r':
-			flags |= TAPDISK_MESSAGE_FLAG_ADD_LCACHE;
-			break;
-		case 'e':
-			flags |= TAPDISK_MESSAGE_FLAG_REUSE_PRT;
-			prt_minor = atoi(optarg);
-			break;
-		case '2':
-			flags |= TAPDISK_MESSAGE_FLAG_SECONDARY;
-			secondary = optarg;
-			break;
-		case 's':
-			flags |= TAPDISK_MESSAGE_FLAG_STANDBY;
-			break;
 		case '?':
 			goto usage;
 		case 'h':
@@ -314,7 +279,7 @@
 	if (!args)
 		goto usage;
 
-	err = tap_ctl_create(args, &devname, flags, prt_minor, secondary);
+	err = tap_ctl_create(args, &devname);
 	if (!err)
 		printf("%s\n", devname);
 
@@ -328,38 +293,19 @@
 static void
 tap_cli_destroy_usage(FILE *stream)
 {
-	fprintf(stream, "usage: destroy (<-m minor> [-p pid] | <-d dev>)\n");
-}
-
-static struct timeval*
-tap_cli_timeout(const char *optarg)
-{
-	static struct timeval tv;
-	struct timeval now;
-
-	tv.tv_sec  = atoi(optarg);
-	tv.tv_usec = 0;
-
-	gettimeofday(&now, NULL);
-	timeradd(&tv, &now, &tv);
-
-	return &tv;
+	fprintf(stream, "usage: destroy <-p pid> <-m minor>\n");
 }
 
 static int
 tap_cli_destroy(int argc, char **argv)
 {
 	int c, pid, minor;
-	const char *device;
-	struct timeval *timeout;
 
-	pid     = -1;
-	minor   = -1;
-	device  = NULL;
-	timeout = NULL;
+	pid   = -1;
+	minor = -1;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "p:m:d:t:h")) != -1) {
+	while ((c = getopt(argc, argv, "p:m:h")) != -1) {
 		switch (c) {
 		case 'p':
 			pid = atoi(optarg);
@@ -367,14 +313,6 @@
 		case 'm':
 			minor = atoi(optarg);
 			break;
-		case 'd':
-			device = optarg;
-			break;
-		case 't':
-			timeout = tap_cli_timeout(optarg);
-			if (!timeout)
-				goto usage;
-			break;
 		case '?':
 			goto usage;
 		case 'h':
@@ -383,41 +321,10 @@
 		}
 	}
 
-	if (device) {
-		int maj;
-		struct stat sb;
-
-		if (stat(device, &sb)) {
-			perror("stat");
-			return -errno;
-		}
-
-		maj = tap_ctl_blk_major();
-		if (maj < 0) {
-			fprintf(stderr, "failed to find td major: %d\n", maj);
-			return maj;
-		}
-
-		if (!S_ISBLK(sb.st_mode) || major(sb.st_rdev) != maj) {
-			fprintf(stderr, "invalid device %s\n", device);
-			return -EINVAL;
-		}
-
-		minor = minor(sb.st_rdev);
-	}
-
-	if (minor == -1)
+	if (pid == -1 || minor == -1)
 		goto usage;
 
-	if (pid == -1) {
-		pid = tap_ctl_find_pid(minor);
-		if (pid == -1) {
-			fprintf(stderr, "failed to find pid for %d\n", minor);
-			return pid;
-		}
-	}
-
-	return tap_ctl_destroy(pid, minor, 0, timeout);
+	return tap_ctl_destroy(pid, minor);
 
 usage:
 	tap_cli_destroy_usage(stderr);
@@ -433,8 +340,8 @@
 static int
 tap_cli_spawn(int argc, char **argv)
 {
-	int c, tty;
-	pid_t pid;
+	int c;
+	pid_t task;
 
 	optind = 0;
 	while ((c = getopt(argc, argv, "h")) != -1) {
@@ -447,16 +354,13 @@
 		}
 	}
 
-	pid = tap_ctl_spawn();
-	if (pid < 0)
-		return pid;
-
-	tty = isatty(STDOUT_FILENO);
-	if (tty)
-		printf("tapdisk spawned with pid %d\n", pid);
-	else
-		printf("%d\n", pid);
+	task = tap_ctl_spawn();
+	if (task < 0) {
+		printf("spawn failed: %d\n", errno);
+		return task;
+	}
 
+	printf("tapdisk spawned with pid %d\n", task);
 	return 0;
 
 usage:
@@ -556,15 +460,13 @@
 tap_cli_close(int argc, char **argv)
 {
 	int c, pid, minor, force;
-	struct timeval *timeout;
 
-	pid     = -1;
-	minor   = -1;
-	force   = 0;
-	timeout = NULL;
+	pid   = -1;
+	minor = -1;
+	force = 0;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "p:m:ft:h")) != -1) {
+	while ((c = getopt(argc, argv, "p:m:fh")) != -1) {
 		switch (c) {
 		case 'p':
 			pid = atoi(optarg);
@@ -575,11 +477,6 @@
 		case 'f':
 			force = -1;
 			break;
-		case 't':
-			timeout = tap_cli_timeout(optarg);
-			if (!timeout)
-				goto usage;
-			break;
 		case '?':
 			goto usage;
 		case 'h':
@@ -591,7 +488,7 @@
 	if (pid == -1 || minor == -1)
 		goto usage;
 
-	return tap_ctl_close(pid, minor, force, timeout);
+	return tap_ctl_close(pid, minor, force);
 
 usage:
 	tap_cli_close_usage(stderr);
@@ -601,21 +498,19 @@
 static void
 tap_cli_pause_usage(FILE *stream)
 {
-	fprintf(stream, "usage: pause <-m minor> [-p pid]\n");
+	fprintf(stream, "usage: pause <-p pid> <-m minor>\n");
 }
 
 static int
 tap_cli_pause(int argc, char **argv)
 {
 	int c, pid, minor;
-	struct timeval *timeout;
 
-	pid     = -1;
-	minor   = -1;
-	timeout = NULL;
+	pid   = -1;
+	minor = -1;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "p:m:t:h")) != -1) {
+	while ((c = getopt(argc, argv, "p:m:h")) != -1) {
 		switch (c) {
 		case 'p':
 			pid = atoi(optarg);
@@ -623,10 +518,6 @@
 		case 'm':
 			minor = atoi(optarg);
 			break;
-		case 't':
-			timeout = tap_cli_timeout(optarg);
-			if (!timeout)
-				goto usage;
 		case '?':
 			goto usage;
 		case 'h':
@@ -635,18 +526,10 @@
 		}
 	}
 
-	if (minor == -1)
+	if (pid == -1 || minor == -1)
 		goto usage;
 
-	if (pid == -1) {
-		pid = tap_ctl_find_pid(minor);
-		if (pid == -1) {
-			fprintf(stderr, "failed to find pid for %d\n", minor);
-			return pid;
-		}
-	}
-
-	return tap_ctl_pause(pid, minor, timeout);
+	return tap_ctl_pause(pid, minor);
 
 usage:
 	tap_cli_pause_usage(stderr);
@@ -656,7 +539,7 @@
 static void
 tap_cli_unpause_usage(FILE *stream)
 {
-	fprintf(stream, "usage: unpause <-m minor> [-p pid] [-a args]\n");
+	fprintf(stream, "usage: unpause <-p pid> <-m minor> [-a args]\n");
 }
 
 int
@@ -689,17 +572,9 @@
 		}
 	}
 
-	if (minor == -1)
+	if (pid == -1 || minor == -1)
 		goto usage;
 
-	if (pid == -1) {
-		pid = tap_ctl_find_pid(minor);
-		if (pid == -1) {
-			fprintf(stderr, "failed to find pid for %d\n", minor);
-			return pid;
-		}
-	}
-
 	return tap_ctl_unpause(pid, minor, args);
 
 usage:
@@ -758,28 +633,21 @@
 static void
 tap_cli_open_usage(FILE *stream)
 {
-	fprintf(stream, "usage: open <-p pid> <-m minor> <-a args> [-R readonly] "
-		"[-e <minor> stack on existing tapdisk for the parent chain] "
-		"[-r turn on read caching into leaf node] [-2 <path> "
-		"use secondary image (in mirror mode if no -s)] [-s "
-		"fail over to the secondary image on ENOSPC]\n");
+	fprintf(stream, "usage: open <-p pid> <-m minor> <-a args>\n");
 }
 
 static int
 tap_cli_open(int argc, char **argv)
 {
-	const char *args, *secondary;
-	int c, pid, minor, flags, prt_minor;
+	const char *args;
+	int c, pid, minor;
 
-	flags     = 0;
-	pid       = -1;
-	minor     = -1;
-	prt_minor = -1;
-	args      = NULL;
-	secondary = NULL;
+	pid   = -1;
+	minor = -1;
+	args  = NULL;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "a:Rm:p:e:r2:sh")) != -1) {
+	while ((c = getopt(argc, argv, "a:m:p:h")) != -1) {
 		switch (c) {
 		case 'p':
 			pid = atoi(optarg);
@@ -790,23 +658,6 @@
 		case 'a':
 			args = optarg;
 			break;
-		case 'R':
-			flags |= TAPDISK_MESSAGE_FLAG_RDONLY;
-			break;
-		case 'r':
-			flags |= TAPDISK_MESSAGE_FLAG_ADD_LCACHE;
-			break;
-		case 'e':
-			flags |= TAPDISK_MESSAGE_FLAG_REUSE_PRT;
-			prt_minor = atoi(optarg);
-			break;
-		case '2':
-			flags |= TAPDISK_MESSAGE_FLAG_SECONDARY;
-			secondary = optarg;
-			break;
-		case 's':
-			flags |= TAPDISK_MESSAGE_FLAG_STANDBY;
-			break;
 		case '?':
 			goto usage;
 		case 'h':
@@ -818,7 +669,7 @@
 	if (pid == -1 || minor == -1 || !args)
 		goto usage;
 
-	return tap_ctl_open(pid, minor, args, flags, prt_minor, secondary);
+	return tap_ctl_open(pid, minor, args);
 
 usage:
 	tap_cli_open_usage(stderr);
@@ -826,54 +677,6 @@
 }
 
 static void
-tap_cli_stats_usage(FILE *stream)
-{
-	fprintf(stream, "usage: info <-p pid> <-m minor>\n");
-}
-
-static int
-tap_cli_stats(int argc, char **argv)
-{
-	pid_t pid;
-	int c, minor, err;
-
-	pid     = -1;
-	minor   = -1;
-
-	optind = 0;
-	while ((c = getopt(argc, argv, "p:m:h")) != -1) {
-		switch (c) {
-		case 'p':
-			pid = atoi(optarg);
-			break;
-		case 'm':
-			minor = atoi(optarg);
-			break;
-		case '?':
-			goto usage;
-		case 'h':
-			tap_cli_stats_usage(stdout);
-			return 0;
-		}
-	}
-
-	if (pid == -1 || minor == -1)
-		goto usage;
-
-	err = tap_ctl_stats_fwrite(pid, minor, stdout);
-	if (err)
-		return err;
-
-	fprintf(stdout, "\n");
-
-	return 0;
-
-usage:
-	tap_cli_stats_usage(stderr);
-	return EINVAL;
-}
-
-static void
 tap_cli_check_usage(FILE *stream)
 {
 	fprintf(stream, "usage: check\n"
@@ -912,7 +715,6 @@
 	{ .name = "close",        .func = tap_cli_close         },
 	{ .name = "pause",        .func = tap_cli_pause         },
 	{ .name = "unpause",      .func = tap_cli_unpause       },
-	{ .name = "stats",        .func = tap_cli_stats         },
 	{ .name = "major",        .func = tap_cli_major         },
 	{ .name = "check",        .func = tap_cli_check         },
 };
@@ -970,8 +772,6 @@
 		PERROR("setrlimit failed");
 #endif
 
-	signal(SIGPIPE, SIG_IGN);
-
 	ret = 0;
 
 	if (argc < 2)
diff -Nur blktap2_oxt//control/tap-ctl-check.c blktap2_xen//control/tap-ctl-check.c
--- blktap2_oxt//control/tap-ctl-check.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-check.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <unistd.h>
diff -Nur blktap2_oxt//control/tap-ctl-close.c blktap2_xen//control/tap-ctl-close.c
--- blktap2_oxt//control/tap-ctl-close.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-close.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -39,9 +34,8 @@
 
 #include "tap-ctl.h"
 
-int
-tap_ctl_close(const int id, const int minor, const int force,
-	      struct timeval *timeout)
+static int
+__tap_ctl_close(const int id, const int minor, const int force)
 {
 	int err;
 	tapdisk_message_t message;
@@ -52,7 +46,7 @@
 		message.type = TAPDISK_MESSAGE_FORCE_SHUTDOWN;
 	message.cookie = minor;
 
-	err = tap_ctl_connect_send_and_receive(id, &message, timeout);
+	err = tap_ctl_connect_send_and_receive(id, &message, 5);
 	if (err)
 		return err;
 
@@ -68,3 +62,26 @@
 
 	return err;
 }
+
+int
+tap_ctl_close(const int id, const int minor, const int force)
+{
+	int i, err;
+
+	for (i = 0; i < 20; i++) {
+		err = __tap_ctl_close(id, minor, force);
+		if (!err)
+			return 0;
+
+		err = (err < 0 ? -err : err);
+		if (err != EAGAIN) {
+			EPRINTF("close failed: %d\n", err);
+			return err;
+		}
+
+		usleep(1000);
+	}
+
+	EPRINTF("close timed out\n");
+	return EIO;
+}
diff -Nur blktap2_oxt//control/tap-ctl-create.c blktap2_xen//control/tap-ctl-create.c
--- blktap2_oxt//control/tap-ctl-create.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-create.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -40,8 +35,7 @@
 #include "blktap2.h"
 
 int
-tap_ctl_create(const char *params, char **devname, int flags, int parent_minor,
-		char *secondary)
+tap_ctl_create(const char *params, char **devname)
 {
 	int err, id, minor;
 
@@ -59,7 +53,7 @@
 	if (err)
 		goto destroy;
 
-	err = tap_ctl_open(id, minor, params, flags, parent_minor, secondary);
+	err = tap_ctl_open(id, minor, params);
 	if (err)
 		goto detach;
 
diff -Nur blktap2_oxt//control/tap-ctl-destroy.c blktap2_xen//control/tap-ctl-destroy.c
--- blktap2_oxt//control/tap-ctl-destroy.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-destroy.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -41,12 +36,11 @@
 #include "blktap2.h"
 
 int
-tap_ctl_destroy(const int id, const int minor,
-		int force, struct timeval *timeout)
+tap_ctl_destroy(const int id, const int minor)
 {
 	int err;
 
-	err = tap_ctl_close(id, minor, 0, timeout);
+	err = tap_ctl_close(id, minor, 0);
 	if (err)
 		return err;
 
diff -Nur blktap2_oxt//control/tap-ctl-detach.c blktap2_xen//control/tap-ctl-detach.c
--- blktap2_oxt//control/tap-ctl-detach.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-detach.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -48,7 +43,7 @@
 	message.type = TAPDISK_MESSAGE_DETACH;
 	message.cookie = minor;
 
-	err = tap_ctl_connect_send_and_receive(id, &message, NULL);
+	err = tap_ctl_connect_send_and_receive(id, &message, 5);
 	if (err)
 		return err;
 
diff -Nur blktap2_oxt//control/tap-ctl-free.c blktap2_xen//control/tap-ctl-free.c
--- blktap2_oxt//control/tap-ctl-free.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-free.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -55,5 +50,5 @@
 	err = ioctl(fd, BLKTAP2_IOCTL_FREE_TAP, minor);
 	close(fd);
 
-	return err ? -errno : 0;
+	return err;
 }
diff -Nur blktap2_oxt//control/tap-ctl.h blktap2_xen//control/tap-ctl.h
--- blktap2_oxt//control/tap-ctl.h	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//control/tap-ctl.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,18 +25,12 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #ifndef __TAP_CTL_H__
 #define __TAP_CTL_H__
 
 #include <syslog.h>
 #include <errno.h>
 #include <tapdisk-message.h>
-#include <list.h>
 
 extern int tap_ctl_debug;
 
@@ -62,48 +56,33 @@
 
 int tap_ctl_connect(const char *path, int *socket);
 int tap_ctl_connect_id(int id, int *socket);
-int tap_ctl_read_raw(int fd, void *buf, size_t sz, struct timeval *timeout);
-int tap_ctl_read_message(int fd, tapdisk_message_t *message,
-			 struct timeval *timeout);
-int tap_ctl_write_message(int fd, tapdisk_message_t *message,
-			  struct timeval *timeout);
-int tap_ctl_send_and_receive(int fd, tapdisk_message_t *message,
-			     struct timeval *timeout);
+int tap_ctl_read_message(int fd, tapdisk_message_t *message, int timeout);
+int tap_ctl_write_message(int fd, tapdisk_message_t *message, int timeout);
+int tap_ctl_send_and_receive(int fd, tapdisk_message_t *message, int timeout);
 int tap_ctl_connect_send_and_receive(int id,
-				     tapdisk_message_t *message,
-				     struct timeval *timeout);
+				     tapdisk_message_t *message, int timeout);
 char *tap_ctl_socket_name(int id);
 
 typedef struct {
+	int         id;
 	pid_t       pid;
 	int         minor;
 	int         state;
 	char       *type;
 	char       *path;
-
-	struct list_head entry;
 } tap_list_t;
 
-#define tap_list_for_each_entry(_pos, _head) \
-	list_for_each_entry(_pos, _head, entry)
+int tap_ctl_get_driver_id(const char *handle);
 
-#define tap_list_for_each_entry_safe(_pos, _n, _head) \
-	list_for_each_entry_safe(_pos, _n, _head, entry)
-
-int tap_ctl_list(struct list_head *list);
-int tap_ctl_list_pid(pid_t pid, struct list_head *list);
-void tap_ctl_list_free(struct list_head *list);
-
-int tap_ctl_find_pid(int minor);
-int tap_ctl_find_minor(const char *type, const char *path);
+int tap_ctl_list(tap_list_t ***list);
+void tap_ctl_free_list(tap_list_t **list);
+int tap_ctl_find(const char *type, const char *path, tap_list_t *tap);
 
 int tap_ctl_allocate(int *minor, char **devname);
 int tap_ctl_free(const int minor);
 
-int tap_ctl_create(const char *params, char **devname, int flags, 
-		int prt_minor, char *secondary);
-int tap_ctl_destroy(const int id, const int minor, int force,
-		    struct timeval *timeout);
+int tap_ctl_create(const char *params, char **devname);
+int tap_ctl_destroy(const int id, const int minor);
 
 int tap_ctl_spawn(void);
 pid_t tap_ctl_get_pid(const int id);
@@ -111,17 +90,12 @@
 int tap_ctl_attach(const int id, const int minor);
 int tap_ctl_detach(const int id, const int minor);
 
-int tap_ctl_open(const int id, const int minor, const char *params, int flags,
-		const int prt_minor, const char *secondary);
-int tap_ctl_close(const int id, const int minor, const int force,
-		  struct timeval *timeout);
+int tap_ctl_open(const int id, const int minor, const char *params);
+int tap_ctl_close(const int id, const int minor, const int force);
 
-int tap_ctl_pause(const int id, const int minor, struct timeval *timeout);
+int tap_ctl_pause(const int id, const int minor);
 int tap_ctl_unpause(const int id, const int minor, const char *params);
 
-ssize_t tap_ctl_stats(pid_t pid, int minor, char *buf, size_t size);
-int tap_ctl_stats_fwrite(pid_t pid, int minor, FILE *out);
-
 int tap_ctl_blk_major(void);
 
 #endif
diff -Nur blktap2_oxt//control/tap-ctl-ipc.c blktap2_xen//control/tap-ctl-ipc.c
--- blktap2_oxt//control/tap-ctl-ipc.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-ipc.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,17 +25,11 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
+#include <unistd.h>
 #include <stdlib.h>
 #include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
 #include <sys/un.h>
 #include <sys/stat.h>
 #include <sys/types.h>
@@ -47,47 +41,51 @@
 int tap_ctl_debug = 0;
 
 int
-tap_ctl_read_raw(int fd, void *buf, size_t size, struct timeval *timeout)
+tap_ctl_read_message(int fd, tapdisk_message_t *message, int timeout)
 {
 	fd_set readfds;
-	size_t offset = 0;
-	int ret;
+	int ret, len, offset;
+	struct timeval tv, *t;
 
-	while (offset < size) {
+	t      = NULL;
+	offset = 0;
+	len    = sizeof(tapdisk_message_t);
+
+	if (timeout) {
+		tv.tv_sec  = timeout;
+		tv.tv_usec = 0;
+		t = &tv;
+	}
+
+	memset(message, 0, sizeof(tapdisk_message_t));
+
+	while (offset < len) {
 		FD_ZERO(&readfds);
 		FD_SET(fd, &readfds);
 
-		ret = select(fd + 1, &readfds, NULL, NULL, timeout);
-		if (ret == -1)
+		ret = select(fd + 1, &readfds, NULL, NULL, t);
+		if (ret == -1) {
+			if (errno == EINTR)
+				continue;
 			break;
+		}
 		else if (FD_ISSET(fd, &readfds)) {
-			ret = read(fd, (char*)buf + offset, size - offset);
-			if (ret <= 0)
+			ret = read(fd, message + offset, len - offset);
+			if (ret <= 0) {
+				if (errno == EINTR)
+					continue;
 				break;
+			}
 			offset += ret;
 		} else
 			break;
 	}
 
-	if (offset != size) {
-		EPRINTF("failure reading data %zd/%zd\n", offset, size);
+	if (offset != len) {
+		EPRINTF("failure reading message\n");
 		return -EIO;
 	}
 
-	return 0;
-}
-
-int
-tap_ctl_read_message(int fd, tapdisk_message_t *message,
-		     struct timeval *timeout)
-{
-	size_t size = sizeof(tapdisk_message_t);
-	int err;
-
-	err = tap_ctl_read_raw(fd, message, size, timeout);
-	if (err)
-		return err;
-
 	DBG("received '%s' message (uuid = %u)\n",
 	    tapdisk_message_name(message->type), message->cookie);
 
@@ -95,14 +93,22 @@
 }
 
 int
-tap_ctl_write_message(int fd, tapdisk_message_t *message, struct timeval *timeout)
+tap_ctl_write_message(int fd, tapdisk_message_t *message, int timeout)
 {
 	fd_set writefds;
 	int ret, len, offset;
+	struct timeval tv, *t;
 
+	t      = NULL;
 	offset = 0;
 	len    = sizeof(tapdisk_message_t);
 
+	if (timeout) {
+		tv.tv_sec  = timeout;
+		tv.tv_usec = 0;
+		t = &tv;
+	}
+
 	DBG("sending '%s' message (uuid = %u)\n",
 	    tapdisk_message_name(message->type), message->cookie);
 
@@ -113,13 +119,19 @@
 		/* we don't bother reinitializing tv. at worst, it will wait a
 		 * bit more time than expected. */
 
-		ret = select(fd + 1, NULL, &writefds, NULL, timeout);
-		if (ret == -1)
+		ret = select(fd + 1, NULL, &writefds, NULL, t);
+		if (ret == -1) {
+			if (errno == EINTR)
+				continue;
 			break;
+		}
 		else if (FD_ISSET(fd, &writefds)) {
-			ret = write(fd, (char*)message + offset, len - offset);
-			if (ret <= 0)
+			ret = write(fd, message + offset, len - offset);
+			if (ret <= 0) {
+				if (errno == EINTR)
+					continue;
 				break;
+			}
 			offset += ret;
 		} else
 			break;
@@ -134,8 +146,7 @@
 }
 
 int
-tap_ctl_send_and_receive(int sfd, tapdisk_message_t *message,
-			 struct timeval *timeout)
+tap_ctl_send_and_receive(int sfd, tapdisk_message_t *message, int timeout)
 {
 	int err;
 
@@ -217,15 +228,13 @@
 	}
 
 	err = tap_ctl_connect(name, sfd);
-
 	free(name);
 
 	return err;
 }
 
 int
-tap_ctl_connect_send_and_receive(int id, tapdisk_message_t *message,
-				 struct timeval *timeout)
+tap_ctl_connect_send_and_receive(int id, tapdisk_message_t *message, int timeout)
 {
 	int err, sfd;
 
diff -Nur blktap2_oxt//control/tap-ctl-list.c blktap2_xen//control/tap-ctl-list.c
--- blktap2_oxt//control/tap-ctl-list.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-list.c	2015-03-19 11:08:36.000000000 -0400
@@ -26,11 +26,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -42,43 +37,20 @@
 #include "blktap2.h"
 #include "list.h"
 
-static tap_list_t*
-_tap_list_alloc(void)
-{
-	const size_t sz = sizeof(tap_list_t);
-	tap_list_t *tl;
-
-	tl = malloc(sz);
-	if (!tl)
-		return NULL;
-
-	tl->pid   = -1;
-	tl->minor = -1;
-	tl->state = -1;
-	tl->type  = NULL;
-	tl->path  = NULL;
-
-	INIT_LIST_HEAD(&tl->entry);
-
-	return tl;
-}
-
 static void
-_tap_list_free(tap_list_t *tl)
+free_list(tap_list_t *entry)
 {
-	list_del_init(&tl->entry);
-
-	if (tl->type) {
-		free(tl->type);
-		tl->type = NULL;
+	if (entry->type) {
+		free(entry->type);
+		entry->type = NULL;
 	}
 
-	if (tl->path) {
-		free(tl->path);
-		tl->path = NULL;
+	if (entry->path) {
+		free(entry->path);
+		entry->path = NULL;
 	}
 
-	free(tl);
+	free(entry);
 }
 
 int
@@ -109,28 +81,103 @@
 	return 0;
 }
 
+static int
+init_list(tap_list_t *entry,
+	  int tap_id, pid_t tap_pid, int vbd_minor, int vbd_state,
+	  const char *params)
+{
+	int err = 0;
+
+	entry->id     = tap_id;
+	entry->pid    = tap_pid;
+	entry->minor  = vbd_minor;
+	entry->state  = vbd_state;
+
+	if (params)
+		err = _parse_params(params, &entry->type, &entry->path);
+
+	return err;
+}
+
 void
-tap_ctl_list_free(struct list_head *list)
+tap_ctl_free_list(tap_list_t **list)
 {
-	tap_list_t *tl, *n;
+	tap_list_t **_entry;
+
+	for (_entry = list; *_entry != NULL; ++_entry)
+		free_list(*_entry);
 
-	tap_list_for_each_entry_safe(tl, n, list)
-		_tap_list_free(tl);
+	free(list);
+}
+
+static tap_list_t**
+tap_ctl_alloc_list(int n)
+{
+	tap_list_t **list, *entry;
+	size_t size;
+	int i;
+
+	size = sizeof(tap_list_t*) * (n+1);
+	list = malloc(size);
+	if (!list)
+		goto fail;
+
+	memset(list, 0, size);
+
+	for (i = 0; i < n; ++i) {
+		tap_list_t *entry;
+
+		entry = malloc(sizeof(tap_list_t));
+		if (!entry)
+			goto fail;
+
+		memset(entry, 0, sizeof(tap_list_t));
+
+		list[i] = entry;
+	}
+
+	return list;
+
+fail:
+	if (list)
+		tap_ctl_free_list(list);
+
+	return NULL;
 }
 
 static int
-_tap_ctl_find_minors(struct list_head *list)
+tap_ctl_list_length(const tap_list_t **list)
 {
-	const char *pattern, *format;
-	glob_t glbuf = { 0 };
-	tap_list_t *tl;
-	int i, err;
+	const tap_list_t **_entry;
+	int n;
+
+	n = 0;
+	for (_entry = list; *_entry != NULL; ++_entry)
+		n++;
 
-	INIT_LIST_HEAD(list);
+	return n;
+}
+
+static int
+_tap_minor_cmp(const void *a, const void *b)
+{
+	return *(int*)a - *(int*)b;
+}
+
+int
+_tap_ctl_find_minors(int **_minorv)
+{
+	glob_t glbuf = { 0 };
+	const char *pattern, *format;
+	int *minorv = NULL, n_minors = 0;
+	int err, i;
 
 	pattern = BLKTAP2_SYSFS_DIR"/blktap*";
 	format  = BLKTAP2_SYSFS_DIR"/blktap%d";
 
+	n_minors = 0;
+	minorv   = NULL;
+
 	err = glob(pattern, 0, NULL, &glbuf);
 	switch (err) {
 	case GLOB_NOMATCH:
@@ -143,48 +190,66 @@
 		goto fail;
 	}
 
+	minorv = malloc(sizeof(int) * glbuf.gl_pathc);
+	if (!minorv) {
+		err = -errno;
+		goto fail;
+	}
+
 	for (i = 0; i < glbuf.gl_pathc; ++i) {
 		int n;
 
-		tl = _tap_list_alloc();
-		if (!tl) {
-			err = -ENOMEM;
-			goto fail;
-		}
-
-		n = sscanf(glbuf.gl_pathv[i], format, &tl->minor);
-		if (n != 1) {
-			_tap_list_free(tl);
+		n = sscanf(glbuf.gl_pathv[i], format, &minorv[n_minors]);
+		if (n != 1)
 			continue;
-		}
 
-		list_add_tail(&tl->entry, list);
+		n_minors++;
 	}
 
+	qsort(minorv, n_minors, sizeof(int), _tap_minor_cmp);
+
 done:
+	*_minorv = minorv;
 	err = 0;
+
 out:
 	if (glbuf.gl_pathv)
 		globfree(&glbuf);
 
-	return err;
+	return err ? : n_minors;
 
 fail:
-	tap_ctl_list_free(list);
+	if (minorv)
+		free(minorv);
+
 	goto out;
 }
 
+struct tapdisk {
+	int    id;
+	pid_t  pid;
+	struct list_head list;
+};
+
+static int
+_tap_tapdisk_cmp(const void *a, const void *b)
+{
+	return ((struct tapdisk*)a)->id - ((struct tapdisk*)b)->id;
+}
+
 int
-_tap_ctl_find_tapdisks(struct list_head *list)
+_tap_ctl_find_tapdisks(struct tapdisk **_tapv)
 {
-	const char *pattern, *format;
 	glob_t glbuf = { 0 };
+	const char *pattern, *format;
+	struct tapdisk *tapv = NULL;
 	int err, i, n_taps = 0;
 
 	pattern = BLKTAP2_CONTROL_DIR"/"BLKTAP2_CONTROL_SOCKET"*";
 	format  = BLKTAP2_CONTROL_DIR"/"BLKTAP2_CONTROL_SOCKET"%d";
 
-	INIT_LIST_HEAD(list);
+	n_taps = 0;
+	tapv   = NULL;
 
 	err = glob(pattern, 0, NULL, &glbuf);
 	switch (err) {
@@ -198,34 +263,38 @@
 		goto fail;
 	}
 
+	tapv = malloc(sizeof(struct tapdisk) * glbuf.gl_pathc);
+	if (!tapv) {
+		err = -errno;
+		goto fail;
+	}
+
 	for (i = 0; i < glbuf.gl_pathc; ++i) {
-		tap_list_t *tl;
+		struct tapdisk *tap;
 		int n;
 
-		tl = _tap_list_alloc();
-		if (!tl) {
-			err = -ENOMEM;
-			goto fail;
-		}
+		tap = &tapv[n_taps];
 
-		n = sscanf(glbuf.gl_pathv[i], format, &tl->pid);
-		if (n != 1)
-			goto skip;
+		err = sscanf(glbuf.gl_pathv[i], format, &tap->id);
+		if (err != 1)
+			continue;
 
-		tl->pid = tap_ctl_get_pid(tl->pid);
-		if (tl->pid < 0)
-			goto skip;
+		tap->pid = tap_ctl_get_pid(tap->id);
+		if (tap->pid < 0)
+			continue;
 
-		list_add_tail(&tl->entry, list);
 		n_taps++;
-		continue;
-
-skip:
-		_tap_list_free(tl);
 	}
 
+	qsort(tapv, n_taps, sizeof(struct tapdisk), _tap_tapdisk_cmp);
+
+	for (i = 0; i < n_taps; ++i)
+		INIT_LIST_HEAD(&tapv[i].list);
+
 done:
+	*_tapv = tapv;
 	err = 0;
+
 out:
 	if (glbuf.gl_pathv)
 		globfree(&glbuf);
@@ -233,19 +302,28 @@
 	return err ? : n_taps;
 
 fail:
-	tap_ctl_list_free(list);
+	if (tapv)
+		free(tapv);
+
 	goto out;
 }
 
+struct tapdisk_list {
+	int  minor;
+	int  state;
+	char *params;
+	struct list_head entry;
+};
+
 int
-_tap_ctl_list_tapdisk(pid_t pid, struct list_head *list)
+_tap_ctl_list_tapdisk(int id, struct list_head *_list)
 {
-	struct timeval timeout = { .tv_sec = 10, .tv_usec = 0 };
 	tapdisk_message_t message;
-	tap_list_t *tl;
+	struct list_head list;
+	struct tapdisk_list *tl, *next;
 	int err, sfd;
 
-	err = tap_ctl_connect_id(pid, &sfd);
+	err = tap_ctl_connect_id(id, &sfd);
 	if (err)
 		return err;
 
@@ -253,152 +331,192 @@
 	message.type   = TAPDISK_MESSAGE_LIST;
 	message.cookie = -1;
 
-	err = tap_ctl_write_message(sfd, &message, &timeout);
+	err = tap_ctl_write_message(sfd, &message, 2);
 	if (err)
 		return err;
 
-	INIT_LIST_HEAD(list);
-
+	INIT_LIST_HEAD(&list);
 	do {
-		err = tap_ctl_read_message(sfd, &message, &timeout);
+		err = tap_ctl_read_message(sfd, &message, 2);
 		if (err) {
 			err = -EPROTO;
-			goto fail;
+			break;
 		}
 
 		if (message.u.list.count == 0)
 			break;
 
-		tl = _tap_list_alloc();
+		tl = malloc(sizeof(struct tapdisk_list));
 		if (!tl) {
 			err = -ENOMEM;
-			goto fail;
+			break;
 		}
 
-		tl->pid    = pid;
 		tl->minor  = message.u.list.minor;
 		tl->state  = message.u.list.state;
-
 		if (message.u.list.path[0] != 0) {
-			err = _parse_params(message.u.list.path,
-					    &tl->type, &tl->path);
-			if (err) {
-				_tap_list_free(tl);
-				goto fail;
+			tl->params = strndup(message.u.list.path,
+					     sizeof(message.u.list.path));
+			if (!tl->params) {
+				err = -errno;
+				break;
 			}
-		}
+		} else
+			tl->params = NULL;
 
-		list_add(&tl->entry, list);
+		list_add(&tl->entry, &list);
 	} while (1);
 
-	err = 0;
-out:
-	close(sfd);
-	return 0;
+	if (err)
+		list_for_each_entry_safe(tl, next, &list, entry) {
+			list_del(&tl->entry);
+			free(tl->params);
+			free(tl);
+		}
 
-fail:
-	tap_ctl_list_free(list);
-	goto out;
+	close(sfd);
+	list_splice(&list, _list);
+	return err;
 }
 
-int
-tap_ctl_list(struct list_head *list)
+void
+_tap_ctl_free_tapdisks(struct tapdisk *tapv, int n_taps)
 {
-	struct list_head minors, tapdisks, vbds;
-	tap_list_t *t, *next_t, *v, *next_v, *m, *next_m;
-	int err;
-
-	/*
-	 * Find all minors, find all tapdisks, then list all minors
-	 * they attached to. Output is a 3-way outer join.
-	 */
+	struct tapdisk *tap;
 
-	err = _tap_ctl_find_minors(&minors);
-	if (err < 0)
-		goto fail;
+	for (tap = tapv; tap < &tapv[n_taps]; ++tap) {
+		struct tapdisk_list *tl, *next;
 
-	err = _tap_ctl_find_tapdisks(&tapdisks);
-	if (err < 0)
-		goto fail;
+		list_for_each_entry_safe(tl, next, &tap->list, entry) {
+			free(tl->params);
+			free(tl);
+		}
+	}
 
-	INIT_LIST_HEAD(list);
+	free(tapv);
+}
 
-	tap_list_for_each_entry_safe(t, next_t, &tapdisks) {
+int
+_tap_list_join3(int n_minors, int *minorv, int n_taps, struct tapdisk *tapv,
+		tap_list_t ***_list)
+{
+	tap_list_t **list, **_entry, *entry;
+	int i, _m, err;
 
-		err = _tap_ctl_list_tapdisk(t->pid, &vbds);
+	list = tap_ctl_alloc_list(n_minors + n_taps);
+	if (!list) {
+		err = -ENOMEM;
+		goto fail;
+	}
+
+	_entry = list;
 
-		if (err || list_empty(&vbds)) {
-			list_move_tail(&t->entry, list);
+	for (i = 0; i < n_taps; ++i) {
+		struct tapdisk *tap = &tapv[i];
+		struct tapdisk_list *tl;
+
+		/* orphaned tapdisk */
+		if (list_empty(&tap->list)) {
+			err = init_list(*_entry++, tap->id, tap->pid, -1, -1, NULL);
+			if (err)
+				goto fail;
 			continue;
 		}
 
-		tap_list_for_each_entry_safe(v, next_v, &vbds) {
+		list_for_each_entry(tl, &tap->list, entry) {
+
+			err = init_list(*_entry++,
+					tap->id, tap->pid,
+					tl->minor, tl->state, tl->params);
+			if (err)
+				goto fail;
 
-			tap_list_for_each_entry_safe(m, next_m, &minors)
-				if (m->minor == v->minor) {
-					_tap_list_free(m);
-					break;
+			if (tl->minor >= 0) {
+				/* clear minor */
+				for (_m = 0; _m < n_minors; ++_m) {
+					if (minorv[_m] == tl->minor) {
+						minorv[_m] = -1;
+						break;
+					}
 				}
+			}
+		}
+	}
 
-			list_move_tail(&v->entry, list);
+	/* orphaned minors */
+	for (_m = 0; _m < n_minors; ++_m) {
+		int minor = minorv[_m];
+		if (minor >= 0) {
+			err = init_list(*_entry++, -1, -1, minor, -1, NULL);
+			if (err)
+				goto fail;
 		}
+	}
 
-		_tap_list_free(t);
+	/* free extraneous list entries */
+	for (; *_entry != NULL; ++entry) {
+		free_list(*_entry);
+		*_entry = NULL;
 	}
 
-	/* orphaned minors */
-	list_splice_tail(&minors, list);
+	*_list = list;
 
 	return 0;
 
 fail:
-	tap_ctl_list_free(list);
-
-	tap_ctl_list_free(&vbds);
-	tap_ctl_list_free(&tapdisks);
-	tap_ctl_list_free(&minors);
+	if (list)
+		tap_ctl_free_list(list);
 
 	return err;
 }
 
 int
-tap_ctl_list_pid(pid_t pid, struct list_head *list)
+tap_ctl_list(tap_list_t ***list)
 {
-	tap_list_t *t;
-	int err;
+	int n_taps, n_minors, err, *minorv;
+	struct tapdisk *tapv, *tap;
 
-	t = _tap_list_alloc();
-	if (!t)
-		return -ENOMEM;
+	n_taps   = -1;
+	n_minors = -1;
 
-	t->pid = tap_ctl_get_pid(pid);
-	if (t->pid < 0) {
-		_tap_list_free(t);
-		return 0;
+	err = n_minors = _tap_ctl_find_minors(&minorv);
+	if (err < 0)
+		goto out;
+
+	err = n_taps = _tap_ctl_find_tapdisks(&tapv);
+	if (err < 0)
+		goto out;
+
+	for (tap = tapv; tap < &tapv[n_taps]; ++tap) {
+		err = _tap_ctl_list_tapdisk(tap->id, &tap->list);
+		if (err)
+			goto out;
 	}
 
-	err = _tap_ctl_list_tapdisk(t->pid, list);
+	err = _tap_list_join3(n_minors, minorv, n_taps, tapv, list);
+
+out:
+	if (n_taps > 0)
+		_tap_ctl_free_tapdisks(tapv, n_taps);
 
-	if (err || list_empty(list))
-		list_add_tail(&t->entry, list);
+	if (n_minors > 0)
+		free(minorv);
 
-	return 0;
+	return err;
 }
 
 int
-tap_ctl_find_minor(const char *type, const char *path)
+tap_ctl_find(const char *type, const char *path, tap_list_t *tap)
 {
-	struct list_head list = LIST_HEAD_INIT(list);
-	tap_list_t *entry;
-	int minor, err;
+	tap_list_t **list, **_entry;
+	int ret = -ENOENT, err;
 
 	err = tap_ctl_list(&list);
 	if (err)
 		return err;
 
-	minor = -1;
-
-	tap_list_for_each_entry(entry, &list) {
+	for (_entry = list; *_entry != NULL; ++_entry) {
+		tap_list_t *entry  = *_entry;
 
 		if (type && (!entry->type || strcmp(entry->type, type)))
 			continue;
@@ -406,36 +524,13 @@
 		if (path && (!entry->path || strcmp(entry->path, path)))
 			continue;
 
-		minor = entry->minor;
+		*tap = *entry;
+		tap->type = tap->path = NULL;
+		ret = 0;
 		break;
 	}
 
-	tap_ctl_list_free(&list);
-
-	return minor >= 0 ? minor : -ENOENT;
-}
-
-int
-tap_ctl_find_pid(int minor)
-{
-	int pid, err;
-	tap_list_t *entry;
-	struct list_head list = LIST_HEAD_INIT(list);
-
-	err = tap_ctl_list(&list);
-	if (err)
-		return err;
-
-	pid = -1;
-
-	tap_list_for_each_entry(entry, &list) {
-		if (entry->minor == minor) {
-			pid = entry->pid;
-			break;
-		}
-	}
-
-	tap_ctl_list_free(&list);
+	tap_ctl_free_list(list);
 
-	return pid >= 0 ? pid : -ENOENT;
+	return ret;
 }
diff -Nur blktap2_oxt//control/tap-ctl-major.c blktap2_xen//control/tap-ctl-major.c
--- blktap2_oxt//control/tap-ctl-major.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-major.c	2015-03-19 11:08:36.000000000 -0400
@@ -26,11 +26,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
 #include <stdio.h>
 #include <errno.h>
 
diff -Nur blktap2_oxt//control/tap-ctl-open.c blktap2_xen//control/tap-ctl-open.c
--- blktap2_oxt//control/tap-ctl-open.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-open.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -41,8 +36,7 @@
 #include "blktaplib.h"
 
 int
-tap_ctl_open(const int id, const int minor, const char *params, int flags,
-		const int prt_minor, const char *secondary)
+tap_ctl_open(const int id, const int minor, const char *params)
 {
 	int err;
 	tapdisk_message_t message;
@@ -50,9 +44,8 @@
 	memset(&message, 0, sizeof(message));
 	message.type = TAPDISK_MESSAGE_OPEN;
 	message.cookie = minor;
+	message.u.params.storage = TAPDISK_STORAGE_TYPE_DEFAULT;
 	message.u.params.devnum = minor;
-	message.u.params.prt_devnum = prt_minor;
-	message.u.params.flags = flags;
 
 	err = snprintf(message.u.params.path,
 		       sizeof(message.u.params.path) - 1, "%s", params);
@@ -61,17 +54,7 @@
 		return ENAMETOOLONG;
 	}
 
-	if (secondary) {
-		err = snprintf(message.u.params.secondary,
-			       sizeof(message.u.params.secondary) - 1, "%s",
-			       secondary);
-		if (err >= sizeof(message.u.params.secondary)) {
-			EPRINTF("secondary image name too long\n");
-			return ENAMETOOLONG;
-		}
-	}
-
-	err = tap_ctl_connect_send_and_receive(id, &message, NULL);
+	err = tap_ctl_connect_send_and_receive(id, &message, 5);
 	if (err)
 		return err;
 
diff -Nur blktap2_oxt//control/tap-ctl-pause.c blktap2_xen//control/tap-ctl-pause.c
--- blktap2_oxt//control/tap-ctl-pause.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-pause.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -39,7 +34,7 @@
 #include "tap-ctl.h"
 
 int
-tap_ctl_pause(const int id, const int minor, struct timeval *timeout)
+tap_ctl_pause(const int id, const int minor)
 {
 	int err;
 	tapdisk_message_t message;
@@ -48,7 +43,7 @@
 	message.type = TAPDISK_MESSAGE_PAUSE;
 	message.cookie = minor;
 
-	err = tap_ctl_connect_send_and_receive(id, &message, timeout);
+	err = tap_ctl_connect_send_and_receive(id, &message, 5);
 	if (err)
 		return err;
 
diff -Nur blktap2_oxt//control/tap-ctl-spawn.c blktap2_xen//control/tap-ctl-spawn.c
--- blktap2_oxt//control/tap-ctl-spawn.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-spawn.c	2015-03-19 11:08:36.000000000 -0400
@@ -26,11 +26,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
 #include <stdio.h>
 #include <errno.h>
 #include <unistd.h>
@@ -95,7 +90,7 @@
 	memset(&message, 0, sizeof(message));
 	message.type = TAPDISK_MESSAGE_PID;
 
-	err = tap_ctl_connect_send_and_receive(id, &message, NULL);
+	err = tap_ctl_connect_send_and_receive(id, &message, 2);
 	if (err)
 		return err;
 
diff -Nur blktap2_oxt//control/tap-ctl-stats.c blktap2_xen//control/tap-ctl-stats.c
--- blktap2_oxt//control/tap-ctl-stats.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-stats.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,160 +0,0 @@
-/*
- * Copyright (c) 2010, Citrix 
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/mman.h>
-
-#include "tap-ctl.h"
-
-int
-_tap_ctl_stats_connect_and_send(pid_t pid, int minor)
-{
-	struct timeval timeout = { .tv_sec = 10, .tv_usec = 0 };
-	tapdisk_message_t message;
-	int sfd, err;
-	size_t len;
-
-	err = tap_ctl_connect_id(pid, &sfd);
-	if (err)
-		return err;
-
-	memset(&message, 0, sizeof(message));
-	message.type   = TAPDISK_MESSAGE_STATS;
-	message.cookie = minor;
-
-	err = tap_ctl_write_message(sfd, &message, &timeout);
-	if (err)
-		return err;
-
-	return sfd;
-}
-
-ssize_t
-tap_ctl_stats(pid_t pid, int minor, char *buf, size_t size)
-{
-	tapdisk_message_t message;
-	int sfd, err;
-	size_t len;
-
-	sfd = _tap_ctl_stats_connect_and_send(pid, minor);
-	if (sfd < 0)
-		return sfd;
-
-	err = tap_ctl_read_message(sfd, &message, NULL);
-	if (err)
-		return err;
-
-	len= message.u.info.length;
-	if (len < 0) {
-		err = len;
-		goto out;
-	}
-	if (size < len + 1)
-		len = size - 1;
-
-	err = tap_ctl_read_raw(sfd, buf, len, NULL);
-	if (err)
-		goto out;
-
-	buf[len] = 0;
-
-out:
-	close(sfd);
-	return err;
-}
-
-int
-tap_ctl_stats_fwrite(pid_t pid, int minor, FILE *stream)
-{
-	tapdisk_message_t message;
-	int sfd = -1, prot, flags, err;
-	size_t len, bufsz;
-	char *buf = MAP_FAILED;
-
-	prot  = PROT_READ|PROT_WRITE;
-	flags = MAP_ANONYMOUS|MAP_PRIVATE;
-	bufsz = sysconf(_SC_PAGE_SIZE);
-
-	buf = mmap(NULL, bufsz, prot, flags, -1, 0);
-	if (buf == MAP_FAILED) {
-		buf = NULL;
-		err = -ENOMEM;
-		goto out;
-	}
-
-	sfd = _tap_ctl_stats_connect_and_send(pid, minor);
-	if (sfd < 0) {
-		err = sfd;
-		goto out;
-	}
-
-	err = tap_ctl_read_message(sfd, &message, NULL);
-	if (err)
-		goto out;
-
-	len = message.u.info.length;
-	err = len;
-	if (len < 0)
-		goto out;
-
-	while (len) {
-		fd_set rfds;
-		size_t in, out;
-		int n;
-
-		FD_ZERO(&rfds);
-		FD_SET(sfd, &rfds);
-
-		n = select(sfd + 1, &rfds, NULL, NULL, NULL);
-		err = n;
-		if (n < 0)
-			goto out;
-
-		in = read(sfd, buf, bufsz);
-		err = in;
-		if (in <= 0)
-			goto out;
-
-		len -= in;
-
-		out = fwrite(buf, in, 1, stream);
-		if (out != in) {
-			err = -errno;
-			goto out;
-		}
-	}
-
-out:
-	if (sfd >= 0)
-		close(sfd);
-	if (buf != MAP_FAILED)
-		munmap(buf, bufsz);
-
-	return err;
-}
diff -Nur blktap2_oxt//control/tap-ctl-unpause.c blktap2_xen//control/tap-ctl-unpause.c
--- blktap2_oxt//control/tap-ctl-unpause.c	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//control/tap-ctl-unpause.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -53,7 +48,7 @@
 		strncpy(message.u.params.path, params,
 			sizeof(message.u.params.path) - 1);
 
-	err = tap_ctl_connect_send_and_receive(id, &message, NULL);
+	err = tap_ctl_connect_send_and_receive(id, &message, 15);
 	if (err)
 		return err;
 
diff -Nur blktap2_oxt//drivers/aes.c blktap2_xen//drivers/aes.c
--- blktap2_oxt//drivers/aes.c	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/aes.c	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,1319 @@
+/**
+ * 
+ * aes.c - integrated in QEMU by Fabrice Bellard from the OpenSSL project.
+ */
+/*
+ * rijndael-alg-fst.c
+ *
+ * @version 3.0 (December 2000)
+ *
+ * Optimised ANSI C code for the Rijndael cipher (now AES)
+ *
+ * @author Vincent Rijmen <vincent.rijmen@esat.kuleuven.ac.be>
+ * @author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.ac.be>
+ * @author Paulo Barreto <paulo.barreto@terra.com.br>
+ *
+ * This code is hereby placed in the public domain.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+//#include "vl.h"
+#include <inttypes.h>
+#include <string.h>
+#include "aes.h"
+
+//#define NDEBUG
+#include <assert.h>
+
+typedef uint32_t u32;
+typedef uint16_t u16;
+typedef uint8_t u8;
+
+#define MAXKC   (256/32)
+#define MAXKB   (256/8)
+#define MAXNR   14
+
+/* This controls loop-unrolling in aes_core.c */
+#undef FULL_UNROLL
+# define GETU32(pt) (((u32)(pt)[0] << 24) ^ ((u32)(pt)[1] << 16) ^ ((u32)(pt)[2] <<  8) ^ ((u32)(pt)[3]))
+# define PUTU32(ct, st) { (ct)[0] = (u8)((st) >> 24); (ct)[1] = (u8)((st) >> 16); (ct)[2] = (u8)((st) >>  8); (ct)[3] = (u8)(st); }
+
+/*
+Te0[x] = S [x].[02, 01, 01, 03];
+Te1[x] = S [x].[03, 02, 01, 01];
+Te2[x] = S [x].[01, 03, 02, 01];
+Te3[x] = S [x].[01, 01, 03, 02];
+Te4[x] = S [x].[01, 01, 01, 01];
+
+Td0[x] = Si[x].[0e, 09, 0d, 0b];
+Td1[x] = Si[x].[0b, 0e, 09, 0d];
+Td2[x] = Si[x].[0d, 0b, 0e, 09];
+Td3[x] = Si[x].[09, 0d, 0b, 0e];
+Td4[x] = Si[x].[01, 01, 01, 01];
+*/
+
+static const u32 Te0[256] = {
+    0xc66363a5U, 0xf87c7c84U, 0xee777799U, 0xf67b7b8dU,
+    0xfff2f20dU, 0xd66b6bbdU, 0xde6f6fb1U, 0x91c5c554U,
+    0x60303050U, 0x02010103U, 0xce6767a9U, 0x562b2b7dU,
+    0xe7fefe19U, 0xb5d7d762U, 0x4dababe6U, 0xec76769aU,
+    0x8fcaca45U, 0x1f82829dU, 0x89c9c940U, 0xfa7d7d87U,
+    0xeffafa15U, 0xb25959ebU, 0x8e4747c9U, 0xfbf0f00bU,
+    0x41adadecU, 0xb3d4d467U, 0x5fa2a2fdU, 0x45afafeaU,
+    0x239c9cbfU, 0x53a4a4f7U, 0xe4727296U, 0x9bc0c05bU,
+    0x75b7b7c2U, 0xe1fdfd1cU, 0x3d9393aeU, 0x4c26266aU,
+    0x6c36365aU, 0x7e3f3f41U, 0xf5f7f702U, 0x83cccc4fU,
+    0x6834345cU, 0x51a5a5f4U, 0xd1e5e534U, 0xf9f1f108U,
+    0xe2717193U, 0xabd8d873U, 0x62313153U, 0x2a15153fU,
+    0x0804040cU, 0x95c7c752U, 0x46232365U, 0x9dc3c35eU,
+    0x30181828U, 0x379696a1U, 0x0a05050fU, 0x2f9a9ab5U,
+    0x0e070709U, 0x24121236U, 0x1b80809bU, 0xdfe2e23dU,
+    0xcdebeb26U, 0x4e272769U, 0x7fb2b2cdU, 0xea75759fU,
+    0x1209091bU, 0x1d83839eU, 0x582c2c74U, 0x341a1a2eU,
+    0x361b1b2dU, 0xdc6e6eb2U, 0xb45a5aeeU, 0x5ba0a0fbU,
+    0xa45252f6U, 0x763b3b4dU, 0xb7d6d661U, 0x7db3b3ceU,
+    0x5229297bU, 0xdde3e33eU, 0x5e2f2f71U, 0x13848497U,
+    0xa65353f5U, 0xb9d1d168U, 0x00000000U, 0xc1eded2cU,
+    0x40202060U, 0xe3fcfc1fU, 0x79b1b1c8U, 0xb65b5bedU,
+    0xd46a6abeU, 0x8dcbcb46U, 0x67bebed9U, 0x7239394bU,
+    0x944a4adeU, 0x984c4cd4U, 0xb05858e8U, 0x85cfcf4aU,
+    0xbbd0d06bU, 0xc5efef2aU, 0x4faaaae5U, 0xedfbfb16U,
+    0x864343c5U, 0x9a4d4dd7U, 0x66333355U, 0x11858594U,
+    0x8a4545cfU, 0xe9f9f910U, 0x04020206U, 0xfe7f7f81U,
+    0xa05050f0U, 0x783c3c44U, 0x259f9fbaU, 0x4ba8a8e3U,
+    0xa25151f3U, 0x5da3a3feU, 0x804040c0U, 0x058f8f8aU,
+    0x3f9292adU, 0x219d9dbcU, 0x70383848U, 0xf1f5f504U,
+    0x63bcbcdfU, 0x77b6b6c1U, 0xafdada75U, 0x42212163U,
+    0x20101030U, 0xe5ffff1aU, 0xfdf3f30eU, 0xbfd2d26dU,
+    0x81cdcd4cU, 0x180c0c14U, 0x26131335U, 0xc3ecec2fU,
+    0xbe5f5fe1U, 0x359797a2U, 0x884444ccU, 0x2e171739U,
+    0x93c4c457U, 0x55a7a7f2U, 0xfc7e7e82U, 0x7a3d3d47U,
+    0xc86464acU, 0xba5d5de7U, 0x3219192bU, 0xe6737395U,
+    0xc06060a0U, 0x19818198U, 0x9e4f4fd1U, 0xa3dcdc7fU,
+    0x44222266U, 0x542a2a7eU, 0x3b9090abU, 0x0b888883U,
+    0x8c4646caU, 0xc7eeee29U, 0x6bb8b8d3U, 0x2814143cU,
+    0xa7dede79U, 0xbc5e5ee2U, 0x160b0b1dU, 0xaddbdb76U,
+    0xdbe0e03bU, 0x64323256U, 0x743a3a4eU, 0x140a0a1eU,
+    0x924949dbU, 0x0c06060aU, 0x4824246cU, 0xb85c5ce4U,
+    0x9fc2c25dU, 0xbdd3d36eU, 0x43acacefU, 0xc46262a6U,
+    0x399191a8U, 0x319595a4U, 0xd3e4e437U, 0xf279798bU,
+    0xd5e7e732U, 0x8bc8c843U, 0x6e373759U, 0xda6d6db7U,
+    0x018d8d8cU, 0xb1d5d564U, 0x9c4e4ed2U, 0x49a9a9e0U,
+    0xd86c6cb4U, 0xac5656faU, 0xf3f4f407U, 0xcfeaea25U,
+    0xca6565afU, 0xf47a7a8eU, 0x47aeaee9U, 0x10080818U,
+    0x6fbabad5U, 0xf0787888U, 0x4a25256fU, 0x5c2e2e72U,
+    0x381c1c24U, 0x57a6a6f1U, 0x73b4b4c7U, 0x97c6c651U,
+    0xcbe8e823U, 0xa1dddd7cU, 0xe874749cU, 0x3e1f1f21U,
+    0x964b4bddU, 0x61bdbddcU, 0x0d8b8b86U, 0x0f8a8a85U,
+    0xe0707090U, 0x7c3e3e42U, 0x71b5b5c4U, 0xcc6666aaU,
+    0x904848d8U, 0x06030305U, 0xf7f6f601U, 0x1c0e0e12U,
+    0xc26161a3U, 0x6a35355fU, 0xae5757f9U, 0x69b9b9d0U,
+    0x17868691U, 0x99c1c158U, 0x3a1d1d27U, 0x279e9eb9U,
+    0xd9e1e138U, 0xebf8f813U, 0x2b9898b3U, 0x22111133U,
+    0xd26969bbU, 0xa9d9d970U, 0x078e8e89U, 0x339494a7U,
+    0x2d9b9bb6U, 0x3c1e1e22U, 0x15878792U, 0xc9e9e920U,
+    0x87cece49U, 0xaa5555ffU, 0x50282878U, 0xa5dfdf7aU,
+    0x038c8c8fU, 0x59a1a1f8U, 0x09898980U, 0x1a0d0d17U,
+    0x65bfbfdaU, 0xd7e6e631U, 0x844242c6U, 0xd06868b8U,
+    0x824141c3U, 0x299999b0U, 0x5a2d2d77U, 0x1e0f0f11U,
+    0x7bb0b0cbU, 0xa85454fcU, 0x6dbbbbd6U, 0x2c16163aU,
+};
+static const u32 Te1[256] = {
+    0xa5c66363U, 0x84f87c7cU, 0x99ee7777U, 0x8df67b7bU,
+    0x0dfff2f2U, 0xbdd66b6bU, 0xb1de6f6fU, 0x5491c5c5U,
+    0x50603030U, 0x03020101U, 0xa9ce6767U, 0x7d562b2bU,
+    0x19e7fefeU, 0x62b5d7d7U, 0xe64dababU, 0x9aec7676U,
+    0x458fcacaU, 0x9d1f8282U, 0x4089c9c9U, 0x87fa7d7dU,
+    0x15effafaU, 0xebb25959U, 0xc98e4747U, 0x0bfbf0f0U,
+    0xec41adadU, 0x67b3d4d4U, 0xfd5fa2a2U, 0xea45afafU,
+    0xbf239c9cU, 0xf753a4a4U, 0x96e47272U, 0x5b9bc0c0U,
+    0xc275b7b7U, 0x1ce1fdfdU, 0xae3d9393U, 0x6a4c2626U,
+    0x5a6c3636U, 0x417e3f3fU, 0x02f5f7f7U, 0x4f83ccccU,
+    0x5c683434U, 0xf451a5a5U, 0x34d1e5e5U, 0x08f9f1f1U,
+    0x93e27171U, 0x73abd8d8U, 0x53623131U, 0x3f2a1515U,
+    0x0c080404U, 0x5295c7c7U, 0x65462323U, 0x5e9dc3c3U,
+    0x28301818U, 0xa1379696U, 0x0f0a0505U, 0xb52f9a9aU,
+    0x090e0707U, 0x36241212U, 0x9b1b8080U, 0x3ddfe2e2U,
+    0x26cdebebU, 0x694e2727U, 0xcd7fb2b2U, 0x9fea7575U,
+    0x1b120909U, 0x9e1d8383U, 0x74582c2cU, 0x2e341a1aU,
+    0x2d361b1bU, 0xb2dc6e6eU, 0xeeb45a5aU, 0xfb5ba0a0U,
+    0xf6a45252U, 0x4d763b3bU, 0x61b7d6d6U, 0xce7db3b3U,
+    0x7b522929U, 0x3edde3e3U, 0x715e2f2fU, 0x97138484U,
+    0xf5a65353U, 0x68b9d1d1U, 0x00000000U, 0x2cc1ededU,
+    0x60402020U, 0x1fe3fcfcU, 0xc879b1b1U, 0xedb65b5bU,
+    0xbed46a6aU, 0x468dcbcbU, 0xd967bebeU, 0x4b723939U,
+    0xde944a4aU, 0xd4984c4cU, 0xe8b05858U, 0x4a85cfcfU,
+    0x6bbbd0d0U, 0x2ac5efefU, 0xe54faaaaU, 0x16edfbfbU,
+    0xc5864343U, 0xd79a4d4dU, 0x55663333U, 0x94118585U,
+    0xcf8a4545U, 0x10e9f9f9U, 0x06040202U, 0x81fe7f7fU,
+    0xf0a05050U, 0x44783c3cU, 0xba259f9fU, 0xe34ba8a8U,
+    0xf3a25151U, 0xfe5da3a3U, 0xc0804040U, 0x8a058f8fU,
+    0xad3f9292U, 0xbc219d9dU, 0x48703838U, 0x04f1f5f5U,
+    0xdf63bcbcU, 0xc177b6b6U, 0x75afdadaU, 0x63422121U,
+    0x30201010U, 0x1ae5ffffU, 0x0efdf3f3U, 0x6dbfd2d2U,
+    0x4c81cdcdU, 0x14180c0cU, 0x35261313U, 0x2fc3ececU,
+    0xe1be5f5fU, 0xa2359797U, 0xcc884444U, 0x392e1717U,
+    0x5793c4c4U, 0xf255a7a7U, 0x82fc7e7eU, 0x477a3d3dU,
+    0xacc86464U, 0xe7ba5d5dU, 0x2b321919U, 0x95e67373U,
+    0xa0c06060U, 0x98198181U, 0xd19e4f4fU, 0x7fa3dcdcU,
+    0x66442222U, 0x7e542a2aU, 0xab3b9090U, 0x830b8888U,
+    0xca8c4646U, 0x29c7eeeeU, 0xd36bb8b8U, 0x3c281414U,
+    0x79a7dedeU, 0xe2bc5e5eU, 0x1d160b0bU, 0x76addbdbU,
+    0x3bdbe0e0U, 0x56643232U, 0x4e743a3aU, 0x1e140a0aU,
+    0xdb924949U, 0x0a0c0606U, 0x6c482424U, 0xe4b85c5cU,
+    0x5d9fc2c2U, 0x6ebdd3d3U, 0xef43acacU, 0xa6c46262U,
+    0xa8399191U, 0xa4319595U, 0x37d3e4e4U, 0x8bf27979U,
+    0x32d5e7e7U, 0x438bc8c8U, 0x596e3737U, 0xb7da6d6dU,
+    0x8c018d8dU, 0x64b1d5d5U, 0xd29c4e4eU, 0xe049a9a9U,
+    0xb4d86c6cU, 0xfaac5656U, 0x07f3f4f4U, 0x25cfeaeaU,
+    0xafca6565U, 0x8ef47a7aU, 0xe947aeaeU, 0x18100808U,
+    0xd56fbabaU, 0x88f07878U, 0x6f4a2525U, 0x725c2e2eU,
+    0x24381c1cU, 0xf157a6a6U, 0xc773b4b4U, 0x5197c6c6U,
+    0x23cbe8e8U, 0x7ca1ddddU, 0x9ce87474U, 0x213e1f1fU,
+    0xdd964b4bU, 0xdc61bdbdU, 0x860d8b8bU, 0x850f8a8aU,
+    0x90e07070U, 0x427c3e3eU, 0xc471b5b5U, 0xaacc6666U,
+    0xd8904848U, 0x05060303U, 0x01f7f6f6U, 0x121c0e0eU,
+    0xa3c26161U, 0x5f6a3535U, 0xf9ae5757U, 0xd069b9b9U,
+    0x91178686U, 0x5899c1c1U, 0x273a1d1dU, 0xb9279e9eU,
+    0x38d9e1e1U, 0x13ebf8f8U, 0xb32b9898U, 0x33221111U,
+    0xbbd26969U, 0x70a9d9d9U, 0x89078e8eU, 0xa7339494U,
+    0xb62d9b9bU, 0x223c1e1eU, 0x92158787U, 0x20c9e9e9U,
+    0x4987ceceU, 0xffaa5555U, 0x78502828U, 0x7aa5dfdfU,
+    0x8f038c8cU, 0xf859a1a1U, 0x80098989U, 0x171a0d0dU,
+    0xda65bfbfU, 0x31d7e6e6U, 0xc6844242U, 0xb8d06868U,
+    0xc3824141U, 0xb0299999U, 0x775a2d2dU, 0x111e0f0fU,
+    0xcb7bb0b0U, 0xfca85454U, 0xd66dbbbbU, 0x3a2c1616U,
+};
+static const u32 Te2[256] = {
+    0x63a5c663U, 0x7c84f87cU, 0x7799ee77U, 0x7b8df67bU,
+    0xf20dfff2U, 0x6bbdd66bU, 0x6fb1de6fU, 0xc55491c5U,
+    0x30506030U, 0x01030201U, 0x67a9ce67U, 0x2b7d562bU,
+    0xfe19e7feU, 0xd762b5d7U, 0xabe64dabU, 0x769aec76U,
+    0xca458fcaU, 0x829d1f82U, 0xc94089c9U, 0x7d87fa7dU,
+    0xfa15effaU, 0x59ebb259U, 0x47c98e47U, 0xf00bfbf0U,
+    0xadec41adU, 0xd467b3d4U, 0xa2fd5fa2U, 0xafea45afU,
+    0x9cbf239cU, 0xa4f753a4U, 0x7296e472U, 0xc05b9bc0U,
+    0xb7c275b7U, 0xfd1ce1fdU, 0x93ae3d93U, 0x266a4c26U,
+    0x365a6c36U, 0x3f417e3fU, 0xf702f5f7U, 0xcc4f83ccU,
+    0x345c6834U, 0xa5f451a5U, 0xe534d1e5U, 0xf108f9f1U,
+    0x7193e271U, 0xd873abd8U, 0x31536231U, 0x153f2a15U,
+    0x040c0804U, 0xc75295c7U, 0x23654623U, 0xc35e9dc3U,
+    0x18283018U, 0x96a13796U, 0x050f0a05U, 0x9ab52f9aU,
+    0x07090e07U, 0x12362412U, 0x809b1b80U, 0xe23ddfe2U,
+    0xeb26cdebU, 0x27694e27U, 0xb2cd7fb2U, 0x759fea75U,
+    0x091b1209U, 0x839e1d83U, 0x2c74582cU, 0x1a2e341aU,
+    0x1b2d361bU, 0x6eb2dc6eU, 0x5aeeb45aU, 0xa0fb5ba0U,
+    0x52f6a452U, 0x3b4d763bU, 0xd661b7d6U, 0xb3ce7db3U,
+    0x297b5229U, 0xe33edde3U, 0x2f715e2fU, 0x84971384U,
+    0x53f5a653U, 0xd168b9d1U, 0x00000000U, 0xed2cc1edU,
+    0x20604020U, 0xfc1fe3fcU, 0xb1c879b1U, 0x5bedb65bU,
+    0x6abed46aU, 0xcb468dcbU, 0xbed967beU, 0x394b7239U,
+    0x4ade944aU, 0x4cd4984cU, 0x58e8b058U, 0xcf4a85cfU,
+    0xd06bbbd0U, 0xef2ac5efU, 0xaae54faaU, 0xfb16edfbU,
+    0x43c58643U, 0x4dd79a4dU, 0x33556633U, 0x85941185U,
+    0x45cf8a45U, 0xf910e9f9U, 0x02060402U, 0x7f81fe7fU,
+    0x50f0a050U, 0x3c44783cU, 0x9fba259fU, 0xa8e34ba8U,
+    0x51f3a251U, 0xa3fe5da3U, 0x40c08040U, 0x8f8a058fU,
+    0x92ad3f92U, 0x9dbc219dU, 0x38487038U, 0xf504f1f5U,
+    0xbcdf63bcU, 0xb6c177b6U, 0xda75afdaU, 0x21634221U,
+    0x10302010U, 0xff1ae5ffU, 0xf30efdf3U, 0xd26dbfd2U,
+    0xcd4c81cdU, 0x0c14180cU, 0x13352613U, 0xec2fc3ecU,
+    0x5fe1be5fU, 0x97a23597U, 0x44cc8844U, 0x17392e17U,
+    0xc45793c4U, 0xa7f255a7U, 0x7e82fc7eU, 0x3d477a3dU,
+    0x64acc864U, 0x5de7ba5dU, 0x192b3219U, 0x7395e673U,
+    0x60a0c060U, 0x81981981U, 0x4fd19e4fU, 0xdc7fa3dcU,
+    0x22664422U, 0x2a7e542aU, 0x90ab3b90U, 0x88830b88U,
+    0x46ca8c46U, 0xee29c7eeU, 0xb8d36bb8U, 0x143c2814U,
+    0xde79a7deU, 0x5ee2bc5eU, 0x0b1d160bU, 0xdb76addbU,
+    0xe03bdbe0U, 0x32566432U, 0x3a4e743aU, 0x0a1e140aU,
+    0x49db9249U, 0x060a0c06U, 0x246c4824U, 0x5ce4b85cU,
+    0xc25d9fc2U, 0xd36ebdd3U, 0xacef43acU, 0x62a6c462U,
+    0x91a83991U, 0x95a43195U, 0xe437d3e4U, 0x798bf279U,
+    0xe732d5e7U, 0xc8438bc8U, 0x37596e37U, 0x6db7da6dU,
+    0x8d8c018dU, 0xd564b1d5U, 0x4ed29c4eU, 0xa9e049a9U,
+    0x6cb4d86cU, 0x56faac56U, 0xf407f3f4U, 0xea25cfeaU,
+    0x65afca65U, 0x7a8ef47aU, 0xaee947aeU, 0x08181008U,
+    0xbad56fbaU, 0x7888f078U, 0x256f4a25U, 0x2e725c2eU,
+    0x1c24381cU, 0xa6f157a6U, 0xb4c773b4U, 0xc65197c6U,
+    0xe823cbe8U, 0xdd7ca1ddU, 0x749ce874U, 0x1f213e1fU,
+    0x4bdd964bU, 0xbddc61bdU, 0x8b860d8bU, 0x8a850f8aU,
+    0x7090e070U, 0x3e427c3eU, 0xb5c471b5U, 0x66aacc66U,
+    0x48d89048U, 0x03050603U, 0xf601f7f6U, 0x0e121c0eU,
+    0x61a3c261U, 0x355f6a35U, 0x57f9ae57U, 0xb9d069b9U,
+    0x86911786U, 0xc15899c1U, 0x1d273a1dU, 0x9eb9279eU,
+    0xe138d9e1U, 0xf813ebf8U, 0x98b32b98U, 0x11332211U,
+    0x69bbd269U, 0xd970a9d9U, 0x8e89078eU, 0x94a73394U,
+    0x9bb62d9bU, 0x1e223c1eU, 0x87921587U, 0xe920c9e9U,
+    0xce4987ceU, 0x55ffaa55U, 0x28785028U, 0xdf7aa5dfU,
+    0x8c8f038cU, 0xa1f859a1U, 0x89800989U, 0x0d171a0dU,
+    0xbfda65bfU, 0xe631d7e6U, 0x42c68442U, 0x68b8d068U,
+    0x41c38241U, 0x99b02999U, 0x2d775a2dU, 0x0f111e0fU,
+    0xb0cb7bb0U, 0x54fca854U, 0xbbd66dbbU, 0x163a2c16U,
+};
+static const u32 Te3[256] = {
+
+    0x6363a5c6U, 0x7c7c84f8U, 0x777799eeU, 0x7b7b8df6U,
+    0xf2f20dffU, 0x6b6bbdd6U, 0x6f6fb1deU, 0xc5c55491U,
+    0x30305060U, 0x01010302U, 0x6767a9ceU, 0x2b2b7d56U,
+    0xfefe19e7U, 0xd7d762b5U, 0xababe64dU, 0x76769aecU,
+    0xcaca458fU, 0x82829d1fU, 0xc9c94089U, 0x7d7d87faU,
+    0xfafa15efU, 0x5959ebb2U, 0x4747c98eU, 0xf0f00bfbU,
+    0xadadec41U, 0xd4d467b3U, 0xa2a2fd5fU, 0xafafea45U,
+    0x9c9cbf23U, 0xa4a4f753U, 0x727296e4U, 0xc0c05b9bU,
+    0xb7b7c275U, 0xfdfd1ce1U, 0x9393ae3dU, 0x26266a4cU,
+    0x36365a6cU, 0x3f3f417eU, 0xf7f702f5U, 0xcccc4f83U,
+    0x34345c68U, 0xa5a5f451U, 0xe5e534d1U, 0xf1f108f9U,
+    0x717193e2U, 0xd8d873abU, 0x31315362U, 0x15153f2aU,
+    0x04040c08U, 0xc7c75295U, 0x23236546U, 0xc3c35e9dU,
+    0x18182830U, 0x9696a137U, 0x05050f0aU, 0x9a9ab52fU,
+    0x0707090eU, 0x12123624U, 0x80809b1bU, 0xe2e23ddfU,
+    0xebeb26cdU, 0x2727694eU, 0xb2b2cd7fU, 0x75759feaU,
+    0x09091b12U, 0x83839e1dU, 0x2c2c7458U, 0x1a1a2e34U,
+    0x1b1b2d36U, 0x6e6eb2dcU, 0x5a5aeeb4U, 0xa0a0fb5bU,
+    0x5252f6a4U, 0x3b3b4d76U, 0xd6d661b7U, 0xb3b3ce7dU,
+    0x29297b52U, 0xe3e33eddU, 0x2f2f715eU, 0x84849713U,
+    0x5353f5a6U, 0xd1d168b9U, 0x00000000U, 0xeded2cc1U,
+    0x20206040U, 0xfcfc1fe3U, 0xb1b1c879U, 0x5b5bedb6U,
+    0x6a6abed4U, 0xcbcb468dU, 0xbebed967U, 0x39394b72U,
+    0x4a4ade94U, 0x4c4cd498U, 0x5858e8b0U, 0xcfcf4a85U,
+    0xd0d06bbbU, 0xefef2ac5U, 0xaaaae54fU, 0xfbfb16edU,
+    0x4343c586U, 0x4d4dd79aU, 0x33335566U, 0x85859411U,
+    0x4545cf8aU, 0xf9f910e9U, 0x02020604U, 0x7f7f81feU,
+    0x5050f0a0U, 0x3c3c4478U, 0x9f9fba25U, 0xa8a8e34bU,
+    0x5151f3a2U, 0xa3a3fe5dU, 0x4040c080U, 0x8f8f8a05U,
+    0x9292ad3fU, 0x9d9dbc21U, 0x38384870U, 0xf5f504f1U,
+    0xbcbcdf63U, 0xb6b6c177U, 0xdada75afU, 0x21216342U,
+    0x10103020U, 0xffff1ae5U, 0xf3f30efdU, 0xd2d26dbfU,
+    0xcdcd4c81U, 0x0c0c1418U, 0x13133526U, 0xecec2fc3U,
+    0x5f5fe1beU, 0x9797a235U, 0x4444cc88U, 0x1717392eU,
+    0xc4c45793U, 0xa7a7f255U, 0x7e7e82fcU, 0x3d3d477aU,
+    0x6464acc8U, 0x5d5de7baU, 0x19192b32U, 0x737395e6U,
+    0x6060a0c0U, 0x81819819U, 0x4f4fd19eU, 0xdcdc7fa3U,
+    0x22226644U, 0x2a2a7e54U, 0x9090ab3bU, 0x8888830bU,
+    0x4646ca8cU, 0xeeee29c7U, 0xb8b8d36bU, 0x14143c28U,
+    0xdede79a7U, 0x5e5ee2bcU, 0x0b0b1d16U, 0xdbdb76adU,
+    0xe0e03bdbU, 0x32325664U, 0x3a3a4e74U, 0x0a0a1e14U,
+    0x4949db92U, 0x06060a0cU, 0x24246c48U, 0x5c5ce4b8U,
+    0xc2c25d9fU, 0xd3d36ebdU, 0xacacef43U, 0x6262a6c4U,
+    0x9191a839U, 0x9595a431U, 0xe4e437d3U, 0x79798bf2U,
+    0xe7e732d5U, 0xc8c8438bU, 0x3737596eU, 0x6d6db7daU,
+    0x8d8d8c01U, 0xd5d564b1U, 0x4e4ed29cU, 0xa9a9e049U,
+    0x6c6cb4d8U, 0x5656faacU, 0xf4f407f3U, 0xeaea25cfU,
+    0x6565afcaU, 0x7a7a8ef4U, 0xaeaee947U, 0x08081810U,
+    0xbabad56fU, 0x787888f0U, 0x25256f4aU, 0x2e2e725cU,
+    0x1c1c2438U, 0xa6a6f157U, 0xb4b4c773U, 0xc6c65197U,
+    0xe8e823cbU, 0xdddd7ca1U, 0x74749ce8U, 0x1f1f213eU,
+    0x4b4bdd96U, 0xbdbddc61U, 0x8b8b860dU, 0x8a8a850fU,
+    0x707090e0U, 0x3e3e427cU, 0xb5b5c471U, 0x6666aaccU,
+    0x4848d890U, 0x03030506U, 0xf6f601f7U, 0x0e0e121cU,
+    0x6161a3c2U, 0x35355f6aU, 0x5757f9aeU, 0xb9b9d069U,
+    0x86869117U, 0xc1c15899U, 0x1d1d273aU, 0x9e9eb927U,
+    0xe1e138d9U, 0xf8f813ebU, 0x9898b32bU, 0x11113322U,
+    0x6969bbd2U, 0xd9d970a9U, 0x8e8e8907U, 0x9494a733U,
+    0x9b9bb62dU, 0x1e1e223cU, 0x87879215U, 0xe9e920c9U,
+    0xcece4987U, 0x5555ffaaU, 0x28287850U, 0xdfdf7aa5U,
+    0x8c8c8f03U, 0xa1a1f859U, 0x89898009U, 0x0d0d171aU,
+    0xbfbfda65U, 0xe6e631d7U, 0x4242c684U, 0x6868b8d0U,
+    0x4141c382U, 0x9999b029U, 0x2d2d775aU, 0x0f0f111eU,
+    0xb0b0cb7bU, 0x5454fca8U, 0xbbbbd66dU, 0x16163a2cU,
+};
+static const u32 Te4[256] = {
+    0x63636363U, 0x7c7c7c7cU, 0x77777777U, 0x7b7b7b7bU,
+    0xf2f2f2f2U, 0x6b6b6b6bU, 0x6f6f6f6fU, 0xc5c5c5c5U,
+    0x30303030U, 0x01010101U, 0x67676767U, 0x2b2b2b2bU,
+    0xfefefefeU, 0xd7d7d7d7U, 0xababababU, 0x76767676U,
+    0xcacacacaU, 0x82828282U, 0xc9c9c9c9U, 0x7d7d7d7dU,
+    0xfafafafaU, 0x59595959U, 0x47474747U, 0xf0f0f0f0U,
+    0xadadadadU, 0xd4d4d4d4U, 0xa2a2a2a2U, 0xafafafafU,
+    0x9c9c9c9cU, 0xa4a4a4a4U, 0x72727272U, 0xc0c0c0c0U,
+    0xb7b7b7b7U, 0xfdfdfdfdU, 0x93939393U, 0x26262626U,
+    0x36363636U, 0x3f3f3f3fU, 0xf7f7f7f7U, 0xccccccccU,
+    0x34343434U, 0xa5a5a5a5U, 0xe5e5e5e5U, 0xf1f1f1f1U,
+    0x71717171U, 0xd8d8d8d8U, 0x31313131U, 0x15151515U,
+    0x04040404U, 0xc7c7c7c7U, 0x23232323U, 0xc3c3c3c3U,
+    0x18181818U, 0x96969696U, 0x05050505U, 0x9a9a9a9aU,
+    0x07070707U, 0x12121212U, 0x80808080U, 0xe2e2e2e2U,
+    0xebebebebU, 0x27272727U, 0xb2b2b2b2U, 0x75757575U,
+    0x09090909U, 0x83838383U, 0x2c2c2c2cU, 0x1a1a1a1aU,
+    0x1b1b1b1bU, 0x6e6e6e6eU, 0x5a5a5a5aU, 0xa0a0a0a0U,
+    0x52525252U, 0x3b3b3b3bU, 0xd6d6d6d6U, 0xb3b3b3b3U,
+    0x29292929U, 0xe3e3e3e3U, 0x2f2f2f2fU, 0x84848484U,
+    0x53535353U, 0xd1d1d1d1U, 0x00000000U, 0xededededU,
+    0x20202020U, 0xfcfcfcfcU, 0xb1b1b1b1U, 0x5b5b5b5bU,
+    0x6a6a6a6aU, 0xcbcbcbcbU, 0xbebebebeU, 0x39393939U,
+    0x4a4a4a4aU, 0x4c4c4c4cU, 0x58585858U, 0xcfcfcfcfU,
+    0xd0d0d0d0U, 0xefefefefU, 0xaaaaaaaaU, 0xfbfbfbfbU,
+    0x43434343U, 0x4d4d4d4dU, 0x33333333U, 0x85858585U,
+    0x45454545U, 0xf9f9f9f9U, 0x02020202U, 0x7f7f7f7fU,
+    0x50505050U, 0x3c3c3c3cU, 0x9f9f9f9fU, 0xa8a8a8a8U,
+    0x51515151U, 0xa3a3a3a3U, 0x40404040U, 0x8f8f8f8fU,
+    0x92929292U, 0x9d9d9d9dU, 0x38383838U, 0xf5f5f5f5U,
+    0xbcbcbcbcU, 0xb6b6b6b6U, 0xdadadadaU, 0x21212121U,
+    0x10101010U, 0xffffffffU, 0xf3f3f3f3U, 0xd2d2d2d2U,
+    0xcdcdcdcdU, 0x0c0c0c0cU, 0x13131313U, 0xececececU,
+    0x5f5f5f5fU, 0x97979797U, 0x44444444U, 0x17171717U,
+    0xc4c4c4c4U, 0xa7a7a7a7U, 0x7e7e7e7eU, 0x3d3d3d3dU,
+    0x64646464U, 0x5d5d5d5dU, 0x19191919U, 0x73737373U,
+    0x60606060U, 0x81818181U, 0x4f4f4f4fU, 0xdcdcdcdcU,
+    0x22222222U, 0x2a2a2a2aU, 0x90909090U, 0x88888888U,
+    0x46464646U, 0xeeeeeeeeU, 0xb8b8b8b8U, 0x14141414U,
+    0xdedededeU, 0x5e5e5e5eU, 0x0b0b0b0bU, 0xdbdbdbdbU,
+    0xe0e0e0e0U, 0x32323232U, 0x3a3a3a3aU, 0x0a0a0a0aU,
+    0x49494949U, 0x06060606U, 0x24242424U, 0x5c5c5c5cU,
+    0xc2c2c2c2U, 0xd3d3d3d3U, 0xacacacacU, 0x62626262U,
+    0x91919191U, 0x95959595U, 0xe4e4e4e4U, 0x79797979U,
+    0xe7e7e7e7U, 0xc8c8c8c8U, 0x37373737U, 0x6d6d6d6dU,
+    0x8d8d8d8dU, 0xd5d5d5d5U, 0x4e4e4e4eU, 0xa9a9a9a9U,
+    0x6c6c6c6cU, 0x56565656U, 0xf4f4f4f4U, 0xeaeaeaeaU,
+    0x65656565U, 0x7a7a7a7aU, 0xaeaeaeaeU, 0x08080808U,
+    0xbabababaU, 0x78787878U, 0x25252525U, 0x2e2e2e2eU,
+    0x1c1c1c1cU, 0xa6a6a6a6U, 0xb4b4b4b4U, 0xc6c6c6c6U,
+    0xe8e8e8e8U, 0xddddddddU, 0x74747474U, 0x1f1f1f1fU,
+    0x4b4b4b4bU, 0xbdbdbdbdU, 0x8b8b8b8bU, 0x8a8a8a8aU,
+    0x70707070U, 0x3e3e3e3eU, 0xb5b5b5b5U, 0x66666666U,
+    0x48484848U, 0x03030303U, 0xf6f6f6f6U, 0x0e0e0e0eU,
+    0x61616161U, 0x35353535U, 0x57575757U, 0xb9b9b9b9U,
+    0x86868686U, 0xc1c1c1c1U, 0x1d1d1d1dU, 0x9e9e9e9eU,
+    0xe1e1e1e1U, 0xf8f8f8f8U, 0x98989898U, 0x11111111U,
+    0x69696969U, 0xd9d9d9d9U, 0x8e8e8e8eU, 0x94949494U,
+    0x9b9b9b9bU, 0x1e1e1e1eU, 0x87878787U, 0xe9e9e9e9U,
+    0xcecececeU, 0x55555555U, 0x28282828U, 0xdfdfdfdfU,
+    0x8c8c8c8cU, 0xa1a1a1a1U, 0x89898989U, 0x0d0d0d0dU,
+    0xbfbfbfbfU, 0xe6e6e6e6U, 0x42424242U, 0x68686868U,
+    0x41414141U, 0x99999999U, 0x2d2d2d2dU, 0x0f0f0f0fU,
+    0xb0b0b0b0U, 0x54545454U, 0xbbbbbbbbU, 0x16161616U,
+};
+static const u32 Td0[256] = {
+    0x51f4a750U, 0x7e416553U, 0x1a17a4c3U, 0x3a275e96U,
+    0x3bab6bcbU, 0x1f9d45f1U, 0xacfa58abU, 0x4be30393U,
+    0x2030fa55U, 0xad766df6U, 0x88cc7691U, 0xf5024c25U,
+    0x4fe5d7fcU, 0xc52acbd7U, 0x26354480U, 0xb562a38fU,
+    0xdeb15a49U, 0x25ba1b67U, 0x45ea0e98U, 0x5dfec0e1U,
+    0xc32f7502U, 0x814cf012U, 0x8d4697a3U, 0x6bd3f9c6U,
+    0x038f5fe7U, 0x15929c95U, 0xbf6d7aebU, 0x955259daU,
+    0xd4be832dU, 0x587421d3U, 0x49e06929U, 0x8ec9c844U,
+    0x75c2896aU, 0xf48e7978U, 0x99583e6bU, 0x27b971ddU,
+    0xbee14fb6U, 0xf088ad17U, 0xc920ac66U, 0x7dce3ab4U,
+    0x63df4a18U, 0xe51a3182U, 0x97513360U, 0x62537f45U,
+    0xb16477e0U, 0xbb6bae84U, 0xfe81a01cU, 0xf9082b94U,
+    0x70486858U, 0x8f45fd19U, 0x94de6c87U, 0x527bf8b7U,
+    0xab73d323U, 0x724b02e2U, 0xe31f8f57U, 0x6655ab2aU,
+    0xb2eb2807U, 0x2fb5c203U, 0x86c57b9aU, 0xd33708a5U,
+    0x302887f2U, 0x23bfa5b2U, 0x02036abaU, 0xed16825cU,
+    0x8acf1c2bU, 0xa779b492U, 0xf307f2f0U, 0x4e69e2a1U,
+    0x65daf4cdU, 0x0605bed5U, 0xd134621fU, 0xc4a6fe8aU,
+    0x342e539dU, 0xa2f355a0U, 0x058ae132U, 0xa4f6eb75U,
+    0x0b83ec39U, 0x4060efaaU, 0x5e719f06U, 0xbd6e1051U,
+    0x3e218af9U, 0x96dd063dU, 0xdd3e05aeU, 0x4de6bd46U,
+    0x91548db5U, 0x71c45d05U, 0x0406d46fU, 0x605015ffU,
+    0x1998fb24U, 0xd6bde997U, 0x894043ccU, 0x67d99e77U,
+    0xb0e842bdU, 0x07898b88U, 0xe7195b38U, 0x79c8eedbU,
+    0xa17c0a47U, 0x7c420fe9U, 0xf8841ec9U, 0x00000000U,
+    0x09808683U, 0x322bed48U, 0x1e1170acU, 0x6c5a724eU,
+    0xfd0efffbU, 0x0f853856U, 0x3daed51eU, 0x362d3927U,
+    0x0a0fd964U, 0x685ca621U, 0x9b5b54d1U, 0x24362e3aU,
+    0x0c0a67b1U, 0x9357e70fU, 0xb4ee96d2U, 0x1b9b919eU,
+    0x80c0c54fU, 0x61dc20a2U, 0x5a774b69U, 0x1c121a16U,
+    0xe293ba0aU, 0xc0a02ae5U, 0x3c22e043U, 0x121b171dU,
+    0x0e090d0bU, 0xf28bc7adU, 0x2db6a8b9U, 0x141ea9c8U,
+    0x57f11985U, 0xaf75074cU, 0xee99ddbbU, 0xa37f60fdU,
+    0xf701269fU, 0x5c72f5bcU, 0x44663bc5U, 0x5bfb7e34U,
+    0x8b432976U, 0xcb23c6dcU, 0xb6edfc68U, 0xb8e4f163U,
+    0xd731dccaU, 0x42638510U, 0x13972240U, 0x84c61120U,
+    0x854a247dU, 0xd2bb3df8U, 0xaef93211U, 0xc729a16dU,
+    0x1d9e2f4bU, 0xdcb230f3U, 0x0d8652ecU, 0x77c1e3d0U,
+    0x2bb3166cU, 0xa970b999U, 0x119448faU, 0x47e96422U,
+    0xa8fc8cc4U, 0xa0f03f1aU, 0x567d2cd8U, 0x223390efU,
+    0x87494ec7U, 0xd938d1c1U, 0x8ccaa2feU, 0x98d40b36U,
+    0xa6f581cfU, 0xa57ade28U, 0xdab78e26U, 0x3fadbfa4U,
+    0x2c3a9de4U, 0x5078920dU, 0x6a5fcc9bU, 0x547e4662U,
+    0xf68d13c2U, 0x90d8b8e8U, 0x2e39f75eU, 0x82c3aff5U,
+    0x9f5d80beU, 0x69d0937cU, 0x6fd52da9U, 0xcf2512b3U,
+    0xc8ac993bU, 0x10187da7U, 0xe89c636eU, 0xdb3bbb7bU,
+    0xcd267809U, 0x6e5918f4U, 0xec9ab701U, 0x834f9aa8U,
+    0xe6956e65U, 0xaaffe67eU, 0x21bccf08U, 0xef15e8e6U,
+    0xbae79bd9U, 0x4a6f36ceU, 0xea9f09d4U, 0x29b07cd6U,
+    0x31a4b2afU, 0x2a3f2331U, 0xc6a59430U, 0x35a266c0U,
+    0x744ebc37U, 0xfc82caa6U, 0xe090d0b0U, 0x33a7d815U,
+    0xf104984aU, 0x41ecdaf7U, 0x7fcd500eU, 0x1791f62fU,
+    0x764dd68dU, 0x43efb04dU, 0xccaa4d54U, 0xe49604dfU,
+    0x9ed1b5e3U, 0x4c6a881bU, 0xc12c1fb8U, 0x4665517fU,
+    0x9d5eea04U, 0x018c355dU, 0xfa877473U, 0xfb0b412eU,
+    0xb3671d5aU, 0x92dbd252U, 0xe9105633U, 0x6dd64713U,
+    0x9ad7618cU, 0x37a10c7aU, 0x59f8148eU, 0xeb133c89U,
+    0xcea927eeU, 0xb761c935U, 0xe11ce5edU, 0x7a47b13cU,
+    0x9cd2df59U, 0x55f2733fU, 0x1814ce79U, 0x73c737bfU,
+    0x53f7cdeaU, 0x5ffdaa5bU, 0xdf3d6f14U, 0x7844db86U,
+    0xcaaff381U, 0xb968c43eU, 0x3824342cU, 0xc2a3405fU,
+    0x161dc372U, 0xbce2250cU, 0x283c498bU, 0xff0d9541U,
+    0x39a80171U, 0x080cb3deU, 0xd8b4e49cU, 0x6456c190U,
+    0x7bcb8461U, 0xd532b670U, 0x486c5c74U, 0xd0b85742U,
+};
+static const u32 Td1[256] = {
+    0x5051f4a7U, 0x537e4165U, 0xc31a17a4U, 0x963a275eU,
+    0xcb3bab6bU, 0xf11f9d45U, 0xabacfa58U, 0x934be303U,
+    0x552030faU, 0xf6ad766dU, 0x9188cc76U, 0x25f5024cU,
+    0xfc4fe5d7U, 0xd7c52acbU, 0x80263544U, 0x8fb562a3U,
+    0x49deb15aU, 0x6725ba1bU, 0x9845ea0eU, 0xe15dfec0U,
+    0x02c32f75U, 0x12814cf0U, 0xa38d4697U, 0xc66bd3f9U,
+    0xe7038f5fU, 0x9515929cU, 0xebbf6d7aU, 0xda955259U,
+    0x2dd4be83U, 0xd3587421U, 0x2949e069U, 0x448ec9c8U,
+    0x6a75c289U, 0x78f48e79U, 0x6b99583eU, 0xdd27b971U,
+    0xb6bee14fU, 0x17f088adU, 0x66c920acU, 0xb47dce3aU,
+    0x1863df4aU, 0x82e51a31U, 0x60975133U, 0x4562537fU,
+    0xe0b16477U, 0x84bb6baeU, 0x1cfe81a0U, 0x94f9082bU,
+    0x58704868U, 0x198f45fdU, 0x8794de6cU, 0xb7527bf8U,
+    0x23ab73d3U, 0xe2724b02U, 0x57e31f8fU, 0x2a6655abU,
+    0x07b2eb28U, 0x032fb5c2U, 0x9a86c57bU, 0xa5d33708U,
+    0xf2302887U, 0xb223bfa5U, 0xba02036aU, 0x5ced1682U,
+    0x2b8acf1cU, 0x92a779b4U, 0xf0f307f2U, 0xa14e69e2U,
+    0xcd65daf4U, 0xd50605beU, 0x1fd13462U, 0x8ac4a6feU,
+    0x9d342e53U, 0xa0a2f355U, 0x32058ae1U, 0x75a4f6ebU,
+    0x390b83ecU, 0xaa4060efU, 0x065e719fU, 0x51bd6e10U,
+    0xf93e218aU, 0x3d96dd06U, 0xaedd3e05U, 0x464de6bdU,
+    0xb591548dU, 0x0571c45dU, 0x6f0406d4U, 0xff605015U,
+    0x241998fbU, 0x97d6bde9U, 0xcc894043U, 0x7767d99eU,
+    0xbdb0e842U, 0x8807898bU, 0x38e7195bU, 0xdb79c8eeU,
+    0x47a17c0aU, 0xe97c420fU, 0xc9f8841eU, 0x00000000U,
+    0x83098086U, 0x48322bedU, 0xac1e1170U, 0x4e6c5a72U,
+    0xfbfd0effU, 0x560f8538U, 0x1e3daed5U, 0x27362d39U,
+    0x640a0fd9U, 0x21685ca6U, 0xd19b5b54U, 0x3a24362eU,
+    0xb10c0a67U, 0x0f9357e7U, 0xd2b4ee96U, 0x9e1b9b91U,
+    0x4f80c0c5U, 0xa261dc20U, 0x695a774bU, 0x161c121aU,
+    0x0ae293baU, 0xe5c0a02aU, 0x433c22e0U, 0x1d121b17U,
+    0x0b0e090dU, 0xadf28bc7U, 0xb92db6a8U, 0xc8141ea9U,
+    0x8557f119U, 0x4caf7507U, 0xbbee99ddU, 0xfda37f60U,
+    0x9ff70126U, 0xbc5c72f5U, 0xc544663bU, 0x345bfb7eU,
+    0x768b4329U, 0xdccb23c6U, 0x68b6edfcU, 0x63b8e4f1U,
+    0xcad731dcU, 0x10426385U, 0x40139722U, 0x2084c611U,
+    0x7d854a24U, 0xf8d2bb3dU, 0x11aef932U, 0x6dc729a1U,
+    0x4b1d9e2fU, 0xf3dcb230U, 0xec0d8652U, 0xd077c1e3U,
+    0x6c2bb316U, 0x99a970b9U, 0xfa119448U, 0x2247e964U,
+    0xc4a8fc8cU, 0x1aa0f03fU, 0xd8567d2cU, 0xef223390U,
+    0xc787494eU, 0xc1d938d1U, 0xfe8ccaa2U, 0x3698d40bU,
+    0xcfa6f581U, 0x28a57adeU, 0x26dab78eU, 0xa43fadbfU,
+    0xe42c3a9dU, 0x0d507892U, 0x9b6a5fccU, 0x62547e46U,
+    0xc2f68d13U, 0xe890d8b8U, 0x5e2e39f7U, 0xf582c3afU,
+    0xbe9f5d80U, 0x7c69d093U, 0xa96fd52dU, 0xb3cf2512U,
+    0x3bc8ac99U, 0xa710187dU, 0x6ee89c63U, 0x7bdb3bbbU,
+    0x09cd2678U, 0xf46e5918U, 0x01ec9ab7U, 0xa8834f9aU,
+    0x65e6956eU, 0x7eaaffe6U, 0x0821bccfU, 0xe6ef15e8U,
+    0xd9bae79bU, 0xce4a6f36U, 0xd4ea9f09U, 0xd629b07cU,
+    0xaf31a4b2U, 0x312a3f23U, 0x30c6a594U, 0xc035a266U,
+    0x37744ebcU, 0xa6fc82caU, 0xb0e090d0U, 0x1533a7d8U,
+    0x4af10498U, 0xf741ecdaU, 0x0e7fcd50U, 0x2f1791f6U,
+    0x8d764dd6U, 0x4d43efb0U, 0x54ccaa4dU, 0xdfe49604U,
+    0xe39ed1b5U, 0x1b4c6a88U, 0xb8c12c1fU, 0x7f466551U,
+    0x049d5eeaU, 0x5d018c35U, 0x73fa8774U, 0x2efb0b41U,
+    0x5ab3671dU, 0x5292dbd2U, 0x33e91056U, 0x136dd647U,
+    0x8c9ad761U, 0x7a37a10cU, 0x8e59f814U, 0x89eb133cU,
+    0xeecea927U, 0x35b761c9U, 0xede11ce5U, 0x3c7a47b1U,
+    0x599cd2dfU, 0x3f55f273U, 0x791814ceU, 0xbf73c737U,
+    0xea53f7cdU, 0x5b5ffdaaU, 0x14df3d6fU, 0x867844dbU,
+    0x81caaff3U, 0x3eb968c4U, 0x2c382434U, 0x5fc2a340U,
+    0x72161dc3U, 0x0cbce225U, 0x8b283c49U, 0x41ff0d95U,
+    0x7139a801U, 0xde080cb3U, 0x9cd8b4e4U, 0x906456c1U,
+    0x617bcb84U, 0x70d532b6U, 0x74486c5cU, 0x42d0b857U,
+};
+static const u32 Td2[256] = {
+    0xa75051f4U, 0x65537e41U, 0xa4c31a17U, 0x5e963a27U,
+    0x6bcb3babU, 0x45f11f9dU, 0x58abacfaU, 0x03934be3U,
+    0xfa552030U, 0x6df6ad76U, 0x769188ccU, 0x4c25f502U,
+    0xd7fc4fe5U, 0xcbd7c52aU, 0x44802635U, 0xa38fb562U,
+    0x5a49deb1U, 0x1b6725baU, 0x0e9845eaU, 0xc0e15dfeU,
+    0x7502c32fU, 0xf012814cU, 0x97a38d46U, 0xf9c66bd3U,
+    0x5fe7038fU, 0x9c951592U, 0x7aebbf6dU, 0x59da9552U,
+    0x832dd4beU, 0x21d35874U, 0x692949e0U, 0xc8448ec9U,
+    0x896a75c2U, 0x7978f48eU, 0x3e6b9958U, 0x71dd27b9U,
+    0x4fb6bee1U, 0xad17f088U, 0xac66c920U, 0x3ab47dceU,
+    0x4a1863dfU, 0x3182e51aU, 0x33609751U, 0x7f456253U,
+    0x77e0b164U, 0xae84bb6bU, 0xa01cfe81U, 0x2b94f908U,
+    0x68587048U, 0xfd198f45U, 0x6c8794deU, 0xf8b7527bU,
+    0xd323ab73U, 0x02e2724bU, 0x8f57e31fU, 0xab2a6655U,
+    0x2807b2ebU, 0xc2032fb5U, 0x7b9a86c5U, 0x08a5d337U,
+    0x87f23028U, 0xa5b223bfU, 0x6aba0203U, 0x825ced16U,
+    0x1c2b8acfU, 0xb492a779U, 0xf2f0f307U, 0xe2a14e69U,
+    0xf4cd65daU, 0xbed50605U, 0x621fd134U, 0xfe8ac4a6U,
+    0x539d342eU, 0x55a0a2f3U, 0xe132058aU, 0xeb75a4f6U,
+    0xec390b83U, 0xefaa4060U, 0x9f065e71U, 0x1051bd6eU,
+
+    0x8af93e21U, 0x063d96ddU, 0x05aedd3eU, 0xbd464de6U,
+    0x8db59154U, 0x5d0571c4U, 0xd46f0406U, 0x15ff6050U,
+    0xfb241998U, 0xe997d6bdU, 0x43cc8940U, 0x9e7767d9U,
+    0x42bdb0e8U, 0x8b880789U, 0x5b38e719U, 0xeedb79c8U,
+    0x0a47a17cU, 0x0fe97c42U, 0x1ec9f884U, 0x00000000U,
+    0x86830980U, 0xed48322bU, 0x70ac1e11U, 0x724e6c5aU,
+    0xfffbfd0eU, 0x38560f85U, 0xd51e3daeU, 0x3927362dU,
+    0xd9640a0fU, 0xa621685cU, 0x54d19b5bU, 0x2e3a2436U,
+    0x67b10c0aU, 0xe70f9357U, 0x96d2b4eeU, 0x919e1b9bU,
+    0xc54f80c0U, 0x20a261dcU, 0x4b695a77U, 0x1a161c12U,
+    0xba0ae293U, 0x2ae5c0a0U, 0xe0433c22U, 0x171d121bU,
+    0x0d0b0e09U, 0xc7adf28bU, 0xa8b92db6U, 0xa9c8141eU,
+    0x198557f1U, 0x074caf75U, 0xddbbee99U, 0x60fda37fU,
+    0x269ff701U, 0xf5bc5c72U, 0x3bc54466U, 0x7e345bfbU,
+    0x29768b43U, 0xc6dccb23U, 0xfc68b6edU, 0xf163b8e4U,
+    0xdccad731U, 0x85104263U, 0x22401397U, 0x112084c6U,
+    0x247d854aU, 0x3df8d2bbU, 0x3211aef9U, 0xa16dc729U,
+    0x2f4b1d9eU, 0x30f3dcb2U, 0x52ec0d86U, 0xe3d077c1U,
+    0x166c2bb3U, 0xb999a970U, 0x48fa1194U, 0x642247e9U,
+    0x8cc4a8fcU, 0x3f1aa0f0U, 0x2cd8567dU, 0x90ef2233U,
+    0x4ec78749U, 0xd1c1d938U, 0xa2fe8ccaU, 0x0b3698d4U,
+    0x81cfa6f5U, 0xde28a57aU, 0x8e26dab7U, 0xbfa43fadU,
+    0x9de42c3aU, 0x920d5078U, 0xcc9b6a5fU, 0x4662547eU,
+    0x13c2f68dU, 0xb8e890d8U, 0xf75e2e39U, 0xaff582c3U,
+    0x80be9f5dU, 0x937c69d0U, 0x2da96fd5U, 0x12b3cf25U,
+    0x993bc8acU, 0x7da71018U, 0x636ee89cU, 0xbb7bdb3bU,
+    0x7809cd26U, 0x18f46e59U, 0xb701ec9aU, 0x9aa8834fU,
+    0x6e65e695U, 0xe67eaaffU, 0xcf0821bcU, 0xe8e6ef15U,
+    0x9bd9bae7U, 0x36ce4a6fU, 0x09d4ea9fU, 0x7cd629b0U,
+    0xb2af31a4U, 0x23312a3fU, 0x9430c6a5U, 0x66c035a2U,
+    0xbc37744eU, 0xcaa6fc82U, 0xd0b0e090U, 0xd81533a7U,
+    0x984af104U, 0xdaf741ecU, 0x500e7fcdU, 0xf62f1791U,
+    0xd68d764dU, 0xb04d43efU, 0x4d54ccaaU, 0x04dfe496U,
+    0xb5e39ed1U, 0x881b4c6aU, 0x1fb8c12cU, 0x517f4665U,
+    0xea049d5eU, 0x355d018cU, 0x7473fa87U, 0x412efb0bU,
+    0x1d5ab367U, 0xd25292dbU, 0x5633e910U, 0x47136dd6U,
+    0x618c9ad7U, 0x0c7a37a1U, 0x148e59f8U, 0x3c89eb13U,
+    0x27eecea9U, 0xc935b761U, 0xe5ede11cU, 0xb13c7a47U,
+    0xdf599cd2U, 0x733f55f2U, 0xce791814U, 0x37bf73c7U,
+    0xcdea53f7U, 0xaa5b5ffdU, 0x6f14df3dU, 0xdb867844U,
+    0xf381caafU, 0xc43eb968U, 0x342c3824U, 0x405fc2a3U,
+    0xc372161dU, 0x250cbce2U, 0x498b283cU, 0x9541ff0dU,
+    0x017139a8U, 0xb3de080cU, 0xe49cd8b4U, 0xc1906456U,
+    0x84617bcbU, 0xb670d532U, 0x5c74486cU, 0x5742d0b8U,
+};
+static const u32 Td3[256] = {
+    0xf4a75051U, 0x4165537eU, 0x17a4c31aU, 0x275e963aU,
+    0xab6bcb3bU, 0x9d45f11fU, 0xfa58abacU, 0xe303934bU,
+    0x30fa5520U, 0x766df6adU, 0xcc769188U, 0x024c25f5U,
+    0xe5d7fc4fU, 0x2acbd7c5U, 0x35448026U, 0x62a38fb5U,
+    0xb15a49deU, 0xba1b6725U, 0xea0e9845U, 0xfec0e15dU,
+    0x2f7502c3U, 0x4cf01281U, 0x4697a38dU, 0xd3f9c66bU,
+    0x8f5fe703U, 0x929c9515U, 0x6d7aebbfU, 0x5259da95U,
+    0xbe832dd4U, 0x7421d358U, 0xe0692949U, 0xc9c8448eU,
+    0xc2896a75U, 0x8e7978f4U, 0x583e6b99U, 0xb971dd27U,
+    0xe14fb6beU, 0x88ad17f0U, 0x20ac66c9U, 0xce3ab47dU,
+    0xdf4a1863U, 0x1a3182e5U, 0x51336097U, 0x537f4562U,
+    0x6477e0b1U, 0x6bae84bbU, 0x81a01cfeU, 0x082b94f9U,
+    0x48685870U, 0x45fd198fU, 0xde6c8794U, 0x7bf8b752U,
+    0x73d323abU, 0x4b02e272U, 0x1f8f57e3U, 0x55ab2a66U,
+    0xeb2807b2U, 0xb5c2032fU, 0xc57b9a86U, 0x3708a5d3U,
+    0x2887f230U, 0xbfa5b223U, 0x036aba02U, 0x16825cedU,
+    0xcf1c2b8aU, 0x79b492a7U, 0x07f2f0f3U, 0x69e2a14eU,
+    0xdaf4cd65U, 0x05bed506U, 0x34621fd1U, 0xa6fe8ac4U,
+    0x2e539d34U, 0xf355a0a2U, 0x8ae13205U, 0xf6eb75a4U,
+    0x83ec390bU, 0x60efaa40U, 0x719f065eU, 0x6e1051bdU,
+    0x218af93eU, 0xdd063d96U, 0x3e05aeddU, 0xe6bd464dU,
+    0x548db591U, 0xc45d0571U, 0x06d46f04U, 0x5015ff60U,
+    0x98fb2419U, 0xbde997d6U, 0x4043cc89U, 0xd99e7767U,
+    0xe842bdb0U, 0x898b8807U, 0x195b38e7U, 0xc8eedb79U,
+    0x7c0a47a1U, 0x420fe97cU, 0x841ec9f8U, 0x00000000U,
+    0x80868309U, 0x2bed4832U, 0x1170ac1eU, 0x5a724e6cU,
+    0x0efffbfdU, 0x8538560fU, 0xaed51e3dU, 0x2d392736U,
+    0x0fd9640aU, 0x5ca62168U, 0x5b54d19bU, 0x362e3a24U,
+    0x0a67b10cU, 0x57e70f93U, 0xee96d2b4U, 0x9b919e1bU,
+    0xc0c54f80U, 0xdc20a261U, 0x774b695aU, 0x121a161cU,
+    0x93ba0ae2U, 0xa02ae5c0U, 0x22e0433cU, 0x1b171d12U,
+    0x090d0b0eU, 0x8bc7adf2U, 0xb6a8b92dU, 0x1ea9c814U,
+    0xf1198557U, 0x75074cafU, 0x99ddbbeeU, 0x7f60fda3U,
+    0x01269ff7U, 0x72f5bc5cU, 0x663bc544U, 0xfb7e345bU,
+    0x4329768bU, 0x23c6dccbU, 0xedfc68b6U, 0xe4f163b8U,
+    0x31dccad7U, 0x63851042U, 0x97224013U, 0xc6112084U,
+    0x4a247d85U, 0xbb3df8d2U, 0xf93211aeU, 0x29a16dc7U,
+    0x9e2f4b1dU, 0xb230f3dcU, 0x8652ec0dU, 0xc1e3d077U,
+    0xb3166c2bU, 0x70b999a9U, 0x9448fa11U, 0xe9642247U,
+    0xfc8cc4a8U, 0xf03f1aa0U, 0x7d2cd856U, 0x3390ef22U,
+    0x494ec787U, 0x38d1c1d9U, 0xcaa2fe8cU, 0xd40b3698U,
+    0xf581cfa6U, 0x7ade28a5U, 0xb78e26daU, 0xadbfa43fU,
+    0x3a9de42cU, 0x78920d50U, 0x5fcc9b6aU, 0x7e466254U,
+    0x8d13c2f6U, 0xd8b8e890U, 0x39f75e2eU, 0xc3aff582U,
+    0x5d80be9fU, 0xd0937c69U, 0xd52da96fU, 0x2512b3cfU,
+    0xac993bc8U, 0x187da710U, 0x9c636ee8U, 0x3bbb7bdbU,
+    0x267809cdU, 0x5918f46eU, 0x9ab701ecU, 0x4f9aa883U,
+    0x956e65e6U, 0xffe67eaaU, 0xbccf0821U, 0x15e8e6efU,
+    0xe79bd9baU, 0x6f36ce4aU, 0x9f09d4eaU, 0xb07cd629U,
+    0xa4b2af31U, 0x3f23312aU, 0xa59430c6U, 0xa266c035U,
+    0x4ebc3774U, 0x82caa6fcU, 0x90d0b0e0U, 0xa7d81533U,
+    0x04984af1U, 0xecdaf741U, 0xcd500e7fU, 0x91f62f17U,
+    0x4dd68d76U, 0xefb04d43U, 0xaa4d54ccU, 0x9604dfe4U,
+    0xd1b5e39eU, 0x6a881b4cU, 0x2c1fb8c1U, 0x65517f46U,
+    0x5eea049dU, 0x8c355d01U, 0x877473faU, 0x0b412efbU,
+    0x671d5ab3U, 0xdbd25292U, 0x105633e9U, 0xd647136dU,
+    0xd7618c9aU, 0xa10c7a37U, 0xf8148e59U, 0x133c89ebU,
+    0xa927eeceU, 0x61c935b7U, 0x1ce5ede1U, 0x47b13c7aU,
+    0xd2df599cU, 0xf2733f55U, 0x14ce7918U, 0xc737bf73U,
+    0xf7cdea53U, 0xfdaa5b5fU, 0x3d6f14dfU, 0x44db8678U,
+    0xaff381caU, 0x68c43eb9U, 0x24342c38U, 0xa3405fc2U,
+    0x1dc37216U, 0xe2250cbcU, 0x3c498b28U, 0x0d9541ffU,
+    0xa8017139U, 0x0cb3de08U, 0xb4e49cd8U, 0x56c19064U,
+    0xcb84617bU, 0x32b670d5U, 0x6c5c7448U, 0xb85742d0U,
+};
+static const u32 Td4[256] = {
+    0x52525252U, 0x09090909U, 0x6a6a6a6aU, 0xd5d5d5d5U,
+    0x30303030U, 0x36363636U, 0xa5a5a5a5U, 0x38383838U,
+    0xbfbfbfbfU, 0x40404040U, 0xa3a3a3a3U, 0x9e9e9e9eU,
+    0x81818181U, 0xf3f3f3f3U, 0xd7d7d7d7U, 0xfbfbfbfbU,
+    0x7c7c7c7cU, 0xe3e3e3e3U, 0x39393939U, 0x82828282U,
+    0x9b9b9b9bU, 0x2f2f2f2fU, 0xffffffffU, 0x87878787U,
+    0x34343434U, 0x8e8e8e8eU, 0x43434343U, 0x44444444U,
+    0xc4c4c4c4U, 0xdedededeU, 0xe9e9e9e9U, 0xcbcbcbcbU,
+    0x54545454U, 0x7b7b7b7bU, 0x94949494U, 0x32323232U,
+    0xa6a6a6a6U, 0xc2c2c2c2U, 0x23232323U, 0x3d3d3d3dU,
+    0xeeeeeeeeU, 0x4c4c4c4cU, 0x95959595U, 0x0b0b0b0bU,
+    0x42424242U, 0xfafafafaU, 0xc3c3c3c3U, 0x4e4e4e4eU,
+    0x08080808U, 0x2e2e2e2eU, 0xa1a1a1a1U, 0x66666666U,
+    0x28282828U, 0xd9d9d9d9U, 0x24242424U, 0xb2b2b2b2U,
+    0x76767676U, 0x5b5b5b5bU, 0xa2a2a2a2U, 0x49494949U,
+    0x6d6d6d6dU, 0x8b8b8b8bU, 0xd1d1d1d1U, 0x25252525U,
+    0x72727272U, 0xf8f8f8f8U, 0xf6f6f6f6U, 0x64646464U,
+    0x86868686U, 0x68686868U, 0x98989898U, 0x16161616U,
+    0xd4d4d4d4U, 0xa4a4a4a4U, 0x5c5c5c5cU, 0xccccccccU,
+    0x5d5d5d5dU, 0x65656565U, 0xb6b6b6b6U, 0x92929292U,
+    0x6c6c6c6cU, 0x70707070U, 0x48484848U, 0x50505050U,
+    0xfdfdfdfdU, 0xededededU, 0xb9b9b9b9U, 0xdadadadaU,
+    0x5e5e5e5eU, 0x15151515U, 0x46464646U, 0x57575757U,
+    0xa7a7a7a7U, 0x8d8d8d8dU, 0x9d9d9d9dU, 0x84848484U,
+    0x90909090U, 0xd8d8d8d8U, 0xababababU, 0x00000000U,
+    0x8c8c8c8cU, 0xbcbcbcbcU, 0xd3d3d3d3U, 0x0a0a0a0aU,
+    0xf7f7f7f7U, 0xe4e4e4e4U, 0x58585858U, 0x05050505U,
+    0xb8b8b8b8U, 0xb3b3b3b3U, 0x45454545U, 0x06060606U,
+    0xd0d0d0d0U, 0x2c2c2c2cU, 0x1e1e1e1eU, 0x8f8f8f8fU,
+    0xcacacacaU, 0x3f3f3f3fU, 0x0f0f0f0fU, 0x02020202U,
+    0xc1c1c1c1U, 0xafafafafU, 0xbdbdbdbdU, 0x03030303U,
+    0x01010101U, 0x13131313U, 0x8a8a8a8aU, 0x6b6b6b6bU,
+    0x3a3a3a3aU, 0x91919191U, 0x11111111U, 0x41414141U,
+    0x4f4f4f4fU, 0x67676767U, 0xdcdcdcdcU, 0xeaeaeaeaU,
+    0x97979797U, 0xf2f2f2f2U, 0xcfcfcfcfU, 0xcecececeU,
+    0xf0f0f0f0U, 0xb4b4b4b4U, 0xe6e6e6e6U, 0x73737373U,
+    0x96969696U, 0xacacacacU, 0x74747474U, 0x22222222U,
+    0xe7e7e7e7U, 0xadadadadU, 0x35353535U, 0x85858585U,
+    0xe2e2e2e2U, 0xf9f9f9f9U, 0x37373737U, 0xe8e8e8e8U,
+    0x1c1c1c1cU, 0x75757575U, 0xdfdfdfdfU, 0x6e6e6e6eU,
+    0x47474747U, 0xf1f1f1f1U, 0x1a1a1a1aU, 0x71717171U,
+    0x1d1d1d1dU, 0x29292929U, 0xc5c5c5c5U, 0x89898989U,
+    0x6f6f6f6fU, 0xb7b7b7b7U, 0x62626262U, 0x0e0e0e0eU,
+    0xaaaaaaaaU, 0x18181818U, 0xbebebebeU, 0x1b1b1b1bU,
+    0xfcfcfcfcU, 0x56565656U, 0x3e3e3e3eU, 0x4b4b4b4bU,
+    0xc6c6c6c6U, 0xd2d2d2d2U, 0x79797979U, 0x20202020U,
+    0x9a9a9a9aU, 0xdbdbdbdbU, 0xc0c0c0c0U, 0xfefefefeU,
+    0x78787878U, 0xcdcdcdcdU, 0x5a5a5a5aU, 0xf4f4f4f4U,
+    0x1f1f1f1fU, 0xddddddddU, 0xa8a8a8a8U, 0x33333333U,
+    0x88888888U, 0x07070707U, 0xc7c7c7c7U, 0x31313131U,
+    0xb1b1b1b1U, 0x12121212U, 0x10101010U, 0x59595959U,
+    0x27272727U, 0x80808080U, 0xececececU, 0x5f5f5f5fU,
+    0x60606060U, 0x51515151U, 0x7f7f7f7fU, 0xa9a9a9a9U,
+    0x19191919U, 0xb5b5b5b5U, 0x4a4a4a4aU, 0x0d0d0d0dU,
+    0x2d2d2d2dU, 0xe5e5e5e5U, 0x7a7a7a7aU, 0x9f9f9f9fU,
+    0x93939393U, 0xc9c9c9c9U, 0x9c9c9c9cU, 0xefefefefU,
+    0xa0a0a0a0U, 0xe0e0e0e0U, 0x3b3b3b3bU, 0x4d4d4d4dU,
+    0xaeaeaeaeU, 0x2a2a2a2aU, 0xf5f5f5f5U, 0xb0b0b0b0U,
+    0xc8c8c8c8U, 0xebebebebU, 0xbbbbbbbbU, 0x3c3c3c3cU,
+    0x83838383U, 0x53535353U, 0x99999999U, 0x61616161U,
+    0x17171717U, 0x2b2b2b2bU, 0x04040404U, 0x7e7e7e7eU,
+    0xbabababaU, 0x77777777U, 0xd6d6d6d6U, 0x26262626U,
+    0xe1e1e1e1U, 0x69696969U, 0x14141414U, 0x63636363U,
+    0x55555555U, 0x21212121U, 0x0c0c0c0cU, 0x7d7d7d7dU,
+};
+static const u32 rcon[] = {
+	0x01000000, 0x02000000, 0x04000000, 0x08000000,
+	0x10000000, 0x20000000, 0x40000000, 0x80000000,
+	0x1B000000, 0x36000000, /* for 128-bit blocks, Rijndael never uses more than 10 rcon values */
+};
+
+/**
+ * Expand the cipher key into the encryption key schedule.
+ */
+int AES_set_encrypt_key(const unsigned char *userKey, const int bits,
+			AES_KEY *key) {
+
+	u32 *rk;
+   	int i = 0;
+	u32 temp;
+
+	if (!userKey || !key)
+		return -1;
+	if (bits != 128 && bits != 192 && bits != 256)
+		return -2;
+
+	rk = key->rd_key;
+
+	if (bits==128)
+		key->rounds = 10;
+	else if (bits==192)
+		key->rounds = 12;
+	else
+		key->rounds = 14;
+
+	rk[0] = GETU32(userKey     );
+	rk[1] = GETU32(userKey +  4);
+	rk[2] = GETU32(userKey +  8);
+	rk[3] = GETU32(userKey + 12);
+	if (bits == 128) {
+		while (1) {
+			temp  = rk[3];
+			rk[4] = rk[0] ^
+				(Te4[(temp >> 16) & 0xff] & 0xff000000) ^
+				(Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
+				(Te4[(temp      ) & 0xff] & 0x0000ff00) ^
+				(Te4[(temp >> 24)       ] & 0x000000ff) ^
+				rcon[i];
+			rk[5] = rk[1] ^ rk[4];
+			rk[6] = rk[2] ^ rk[5];
+			rk[7] = rk[3] ^ rk[6];
+			if (++i == 10) {
+				return 0;
+			}
+			rk += 4;
+		}
+	}
+	rk[4] = GETU32(userKey + 16);
+	rk[5] = GETU32(userKey + 20);
+	if (bits == 192) {
+		while (1) {
+			temp = rk[ 5];
+			rk[ 6] = rk[ 0] ^
+				(Te4[(temp >> 16) & 0xff] & 0xff000000) ^
+				(Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
+				(Te4[(temp      ) & 0xff] & 0x0000ff00) ^
+				(Te4[(temp >> 24)       ] & 0x000000ff) ^
+				rcon[i];
+			rk[ 7] = rk[ 1] ^ rk[ 6];
+			rk[ 8] = rk[ 2] ^ rk[ 7];
+			rk[ 9] = rk[ 3] ^ rk[ 8];
+			if (++i == 8) {
+				return 0;
+			}
+			rk[10] = rk[ 4] ^ rk[ 9];
+			rk[11] = rk[ 5] ^ rk[10];
+			rk += 6;
+		}
+	}
+	rk[6] = GETU32(userKey + 24);
+	rk[7] = GETU32(userKey + 28);
+	if (bits == 256) {
+		while (1) {
+			temp = rk[ 7];
+			rk[ 8] = rk[ 0] ^
+				(Te4[(temp >> 16) & 0xff] & 0xff000000) ^
+				(Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
+				(Te4[(temp      ) & 0xff] & 0x0000ff00) ^
+				(Te4[(temp >> 24)       ] & 0x000000ff) ^
+				rcon[i];
+			rk[ 9] = rk[ 1] ^ rk[ 8];
+			rk[10] = rk[ 2] ^ rk[ 9];
+			rk[11] = rk[ 3] ^ rk[10];
+			if (++i == 7) {
+				return 0;
+			}
+			temp = rk[11];
+			rk[12] = rk[ 4] ^
+				(Te4[(temp >> 24)       ] & 0xff000000) ^
+				(Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^
+				(Te4[(temp >>  8) & 0xff] & 0x0000ff00) ^
+				(Te4[(temp      ) & 0xff] & 0x000000ff);
+			rk[13] = rk[ 5] ^ rk[12];
+			rk[14] = rk[ 6] ^ rk[13];
+			rk[15] = rk[ 7] ^ rk[14];
+
+			rk += 8;
+        	}
+	}
+	return 0;
+}
+
+/**
+ * Expand the cipher key into the decryption key schedule.
+ */
+int AES_set_decrypt_key(const unsigned char *userKey, const int bits,
+			 AES_KEY *key) {
+
+        u32 *rk;
+	int i, j, status;
+	u32 temp;
+
+	/* first, start with an encryption schedule */
+	status = AES_set_encrypt_key(userKey, bits, key);
+	if (status < 0)
+		return status;
+
+	rk = key->rd_key;
+
+	/* invert the order of the round keys: */
+	for (i = 0, j = 4*(key->rounds); i < j; i += 4, j -= 4) {
+		temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;
+		temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;
+		temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;
+		temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;
+	}
+	/* apply the inverse MixColumn transform to all round keys but the first and the last: */
+	for (i = 1; i < (key->rounds); i++) {
+		rk += 4;
+		rk[0] =
+			Td0[Te4[(rk[0] >> 24)       ] & 0xff] ^
+			Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^
+			Td2[Te4[(rk[0] >>  8) & 0xff] & 0xff] ^
+			Td3[Te4[(rk[0]      ) & 0xff] & 0xff];
+		rk[1] =
+			Td0[Te4[(rk[1] >> 24)       ] & 0xff] ^
+			Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^
+			Td2[Te4[(rk[1] >>  8) & 0xff] & 0xff] ^
+			Td3[Te4[(rk[1]      ) & 0xff] & 0xff];
+		rk[2] =
+			Td0[Te4[(rk[2] >> 24)       ] & 0xff] ^
+			Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^
+			Td2[Te4[(rk[2] >>  8) & 0xff] & 0xff] ^
+			Td3[Te4[(rk[2]      ) & 0xff] & 0xff];
+		rk[3] =
+			Td0[Te4[(rk[3] >> 24)       ] & 0xff] ^
+			Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^
+			Td2[Te4[(rk[3] >>  8) & 0xff] & 0xff] ^
+			Td3[Te4[(rk[3]      ) & 0xff] & 0xff];
+	}
+	return 0;
+}
+
+#ifndef AES_ASM
+/*
+ * Encrypt a single block
+ * in and out can overlap
+ */
+void AES_encrypt(const unsigned char *in, unsigned char *out,
+		 const AES_KEY *key) {
+
+	const u32 *rk;
+	u32 s0, s1, s2, s3, t0, t1, t2, t3;
+#ifndef FULL_UNROLL
+	int r;
+#endif /* ?FULL_UNROLL */
+
+	assert(in && out && key);
+	rk = key->rd_key;
+
+	/*
+	 * map byte array block to cipher state
+	 * and add initial round key:
+	 */
+	s0 = GETU32(in     ) ^ rk[0];
+	s1 = GETU32(in +  4) ^ rk[1];
+	s2 = GETU32(in +  8) ^ rk[2];
+	s3 = GETU32(in + 12) ^ rk[3];
+#ifdef FULL_UNROLL
+	/* round 1: */
+   	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[ 4];
+   	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[ 5];
+   	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[ 6];
+   	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[ 7];
+   	/* round 2: */
+   	s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[ 8];
+   	s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[ 9];
+   	s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[10];
+   	s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[11];
+	/* round 3: */
+   	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[12];
+   	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[13];
+   	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[14];
+   	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[15];
+   	/* round 4: */
+   	s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[16];
+   	s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[17];
+   	s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[18];
+   	s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[19];
+	/* round 5: */
+   	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[20];
+   	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[21];
+   	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[22];
+   	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[23];
+   	/* round 6: */
+   	s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[24];
+   	s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[25];
+   	s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[26];
+   	s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[27];
+	/* round 7: */
+   	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[28];
+   	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[29];
+   	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[30];
+   	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[31];
+   	/* round 8: */
+   	s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[32];
+   	s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[33];
+   	s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[34];
+   	s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[35];
+	/* round 9: */
+   	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[36];
+   	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[37];
+   	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[38];
+   	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[39];
+    if (key->rounds > 10) {
+        /* round 10: */
+        s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[40];
+        s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[41];
+        s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[42];
+        s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[43];
+        /* round 11: */
+        t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[44];
+        t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[45];
+        t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[46];
+        t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[47];
+        if (key->rounds > 12) {
+            /* round 12: */
+            s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[48];
+            s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[49];
+            s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[50];
+            s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[51];
+            /* round 13: */
+            t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[52];
+            t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[53];
+            t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[54];
+            t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[55];
+        }
+    }
+    rk += key->rounds << 2;
+#else  /* !FULL_UNROLL */
+    /*
+     * Nr - 1 full rounds:
+     */
+    r = key->rounds >> 1;
+    for (;;) {
+        t0 =
+            Te0[(s0 >> 24)       ] ^
+            Te1[(s1 >> 16) & 0xff] ^
+            Te2[(s2 >>  8) & 0xff] ^
+            Te3[(s3      ) & 0xff] ^
+            rk[4];
+        t1 =
+            Te0[(s1 >> 24)       ] ^
+            Te1[(s2 >> 16) & 0xff] ^
+            Te2[(s3 >>  8) & 0xff] ^
+            Te3[(s0      ) & 0xff] ^
+            rk[5];
+        t2 =
+            Te0[(s2 >> 24)       ] ^
+            Te1[(s3 >> 16) & 0xff] ^
+            Te2[(s0 >>  8) & 0xff] ^
+            Te3[(s1      ) & 0xff] ^
+            rk[6];
+        t3 =
+            Te0[(s3 >> 24)       ] ^
+            Te1[(s0 >> 16) & 0xff] ^
+            Te2[(s1 >>  8) & 0xff] ^
+            Te3[(s2      ) & 0xff] ^
+            rk[7];
+
+        rk += 8;
+        if (--r == 0) {
+            break;
+        }
+
+        s0 =
+            Te0[(t0 >> 24)       ] ^
+            Te1[(t1 >> 16) & 0xff] ^
+            Te2[(t2 >>  8) & 0xff] ^
+            Te3[(t3      ) & 0xff] ^
+            rk[0];
+        s1 =
+            Te0[(t1 >> 24)       ] ^
+            Te1[(t2 >> 16) & 0xff] ^
+            Te2[(t3 >>  8) & 0xff] ^
+            Te3[(t0      ) & 0xff] ^
+            rk[1];
+        s2 =
+            Te0[(t2 >> 24)       ] ^
+            Te1[(t3 >> 16) & 0xff] ^
+            Te2[(t0 >>  8) & 0xff] ^
+            Te3[(t1      ) & 0xff] ^
+            rk[2];
+        s3 =
+            Te0[(t3 >> 24)       ] ^
+            Te1[(t0 >> 16) & 0xff] ^
+            Te2[(t1 >>  8) & 0xff] ^
+            Te3[(t2      ) & 0xff] ^
+            rk[3];
+    }
+#endif /* ?FULL_UNROLL */
+    /*
+	 * apply last round and
+	 * map cipher state to byte array block:
+	 */
+	s0 =
+		(Te4[(t0 >> 24)       ] & 0xff000000) ^
+		(Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^
+		(Te4[(t2 >>  8) & 0xff] & 0x0000ff00) ^
+		(Te4[(t3      ) & 0xff] & 0x000000ff) ^
+		rk[0];
+	PUTU32(out     , s0);
+	s1 =
+		(Te4[(t1 >> 24)       ] & 0xff000000) ^
+		(Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^
+		(Te4[(t3 >>  8) & 0xff] & 0x0000ff00) ^
+		(Te4[(t0      ) & 0xff] & 0x000000ff) ^
+		rk[1];
+	PUTU32(out +  4, s1);
+	s2 =
+		(Te4[(t2 >> 24)       ] & 0xff000000) ^
+		(Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^
+		(Te4[(t0 >>  8) & 0xff] & 0x0000ff00) ^
+		(Te4[(t1      ) & 0xff] & 0x000000ff) ^
+		rk[2];
+	PUTU32(out +  8, s2);
+	s3 =
+		(Te4[(t3 >> 24)       ] & 0xff000000) ^
+		(Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^
+		(Te4[(t1 >>  8) & 0xff] & 0x0000ff00) ^
+		(Te4[(t2      ) & 0xff] & 0x000000ff) ^
+		rk[3];
+	PUTU32(out + 12, s3);
+}
+
+/*
+ * Decrypt a single block
+ * in and out can overlap
+ */
+void AES_decrypt(const unsigned char *in, unsigned char *out,
+		 const AES_KEY *key) {
+
+	const u32 *rk;
+	u32 s0, s1, s2, s3, t0, t1, t2, t3;
+#ifndef FULL_UNROLL
+	int r;
+#endif /* ?FULL_UNROLL */
+
+	assert(in && out && key);
+	rk = key->rd_key;
+
+	/*
+	 * map byte array block to cipher state
+	 * and add initial round key:
+	 */
+    s0 = GETU32(in     ) ^ rk[0];
+    s1 = GETU32(in +  4) ^ rk[1];
+    s2 = GETU32(in +  8) ^ rk[2];
+    s3 = GETU32(in + 12) ^ rk[3];
+#ifdef FULL_UNROLL
+    /* round 1: */
+    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[ 4];
+    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[ 5];
+    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[ 6];
+    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[ 7];
+    /* round 2: */
+    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[ 8];
+    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[ 9];
+    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[10];
+    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[11];
+    /* round 3: */
+    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[12];
+    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[13];
+    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[14];
+    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[15];
+    /* round 4: */
+    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[16];
+    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[17];
+    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[18];
+    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[19];
+    /* round 5: */
+    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[20];
+    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[21];
+    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[22];
+    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[23];
+    /* round 6: */
+    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[24];
+    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[25];
+    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[26];
+    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[27];
+    /* round 7: */
+    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[28];
+    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[29];
+    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[30];
+    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[31];
+    /* round 8: */
+    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[32];
+    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[33];
+    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[34];
+    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[35];
+    /* round 9: */
+    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[36];
+    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[37];
+    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[38];
+    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[39];
+    if (key->rounds > 10) {
+        /* round 10: */
+        s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[40];
+        s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[41];
+        s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[42];
+        s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[43];
+        /* round 11: */
+        t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[44];
+        t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[45];
+        t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[46];
+        t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[47];
+        if (key->rounds > 12) {
+            /* round 12: */
+            s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[48];
+            s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[49];
+            s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[50];
+            s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[51];
+            /* round 13: */
+            t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[52];
+            t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[53];
+            t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[54];
+            t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[55];
+        }
+    }
+	rk += key->rounds << 2;
+#else  /* !FULL_UNROLL */
+    /*
+     * Nr - 1 full rounds:
+     */
+    r = key->rounds >> 1;
+    for (;;) {
+        t0 =
+            Td0[(s0 >> 24)       ] ^
+            Td1[(s3 >> 16) & 0xff] ^
+            Td2[(s2 >>  8) & 0xff] ^
+            Td3[(s1      ) & 0xff] ^
+            rk[4];
+        t1 =
+            Td0[(s1 >> 24)       ] ^
+            Td1[(s0 >> 16) & 0xff] ^
+            Td2[(s3 >>  8) & 0xff] ^
+            Td3[(s2      ) & 0xff] ^
+            rk[5];
+        t2 =
+            Td0[(s2 >> 24)       ] ^
+            Td1[(s1 >> 16) & 0xff] ^
+            Td2[(s0 >>  8) & 0xff] ^
+            Td3[(s3      ) & 0xff] ^
+            rk[6];
+        t3 =
+            Td0[(s3 >> 24)       ] ^
+            Td1[(s2 >> 16) & 0xff] ^
+            Td2[(s1 >>  8) & 0xff] ^
+            Td3[(s0      ) & 0xff] ^
+            rk[7];
+
+        rk += 8;
+        if (--r == 0) {
+            break;
+        }
+
+        s0 =
+            Td0[(t0 >> 24)       ] ^
+            Td1[(t3 >> 16) & 0xff] ^
+            Td2[(t2 >>  8) & 0xff] ^
+            Td3[(t1      ) & 0xff] ^
+            rk[0];
+        s1 =
+            Td0[(t1 >> 24)       ] ^
+            Td1[(t0 >> 16) & 0xff] ^
+            Td2[(t3 >>  8) & 0xff] ^
+            Td3[(t2      ) & 0xff] ^
+            rk[1];
+        s2 =
+            Td0[(t2 >> 24)       ] ^
+            Td1[(t1 >> 16) & 0xff] ^
+            Td2[(t0 >>  8) & 0xff] ^
+            Td3[(t3      ) & 0xff] ^
+            rk[2];
+        s3 =
+            Td0[(t3 >> 24)       ] ^
+            Td1[(t2 >> 16) & 0xff] ^
+            Td2[(t1 >>  8) & 0xff] ^
+            Td3[(t0      ) & 0xff] ^
+            rk[3];
+    }
+#endif /* ?FULL_UNROLL */
+    /*
+	 * apply last round and
+	 * map cipher state to byte array block:
+	 */
+   	s0 =
+   		(Td4[(t0 >> 24)       ] & 0xff000000) ^
+   		(Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^
+   		(Td4[(t2 >>  8) & 0xff] & 0x0000ff00) ^
+   		(Td4[(t1      ) & 0xff] & 0x000000ff) ^
+   		rk[0];
+	PUTU32(out     , s0);
+   	s1 =
+   		(Td4[(t1 >> 24)       ] & 0xff000000) ^
+   		(Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^
+   		(Td4[(t3 >>  8) & 0xff] & 0x0000ff00) ^
+   		(Td4[(t2      ) & 0xff] & 0x000000ff) ^
+   		rk[1];
+	PUTU32(out +  4, s1);
+   	s2 =
+   		(Td4[(t2 >> 24)       ] & 0xff000000) ^
+   		(Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^
+   		(Td4[(t0 >>  8) & 0xff] & 0x0000ff00) ^
+   		(Td4[(t3      ) & 0xff] & 0x000000ff) ^
+   		rk[2];
+	PUTU32(out +  8, s2);
+   	s3 =
+   		(Td4[(t3 >> 24)       ] & 0xff000000) ^
+   		(Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^
+   		(Td4[(t1 >>  8) & 0xff] & 0x0000ff00) ^
+   		(Td4[(t0      ) & 0xff] & 0x000000ff) ^
+   		rk[3];
+	PUTU32(out + 12, s3);
+}
+
+#endif /* AES_ASM */
+
+void AES_cbc_encrypt(const unsigned char *in, unsigned char *out,
+		     const unsigned long length, const AES_KEY *key,
+		     unsigned char *ivec, const int enc) 
+{
+
+	unsigned long n;
+	unsigned long len = length;
+	unsigned char tmp[AES_BLOCK_SIZE];
+
+	assert(in && out && key && ivec);
+
+	if (enc) {
+		while (len >= AES_BLOCK_SIZE) {
+			for(n=0; n < AES_BLOCK_SIZE; ++n)
+				tmp[n] = in[n] ^ ivec[n];
+			AES_encrypt(tmp, out, key);
+			memcpy(ivec, out, AES_BLOCK_SIZE);
+			len -= AES_BLOCK_SIZE;
+			in += AES_BLOCK_SIZE;
+			out += AES_BLOCK_SIZE;
+		}
+		if (len) {
+			for(n=0; n < len; ++n)
+				tmp[n] = in[n] ^ ivec[n];
+			for(n=len; n < AES_BLOCK_SIZE; ++n)
+				tmp[n] = ivec[n];
+			AES_encrypt(tmp, tmp, key);
+			memcpy(out, tmp, AES_BLOCK_SIZE);
+			memcpy(ivec, tmp, AES_BLOCK_SIZE);
+		}			
+	} else {
+		while (len >= AES_BLOCK_SIZE) {
+			memcpy(tmp, in, AES_BLOCK_SIZE);
+			AES_decrypt(in, out, key);
+			for(n=0; n < AES_BLOCK_SIZE; ++n)
+				out[n] ^= ivec[n];
+			memcpy(ivec, tmp, AES_BLOCK_SIZE);
+			len -= AES_BLOCK_SIZE;
+			in += AES_BLOCK_SIZE;
+			out += AES_BLOCK_SIZE;
+		}
+		if (len) {
+			memcpy(tmp, in, AES_BLOCK_SIZE);
+			AES_decrypt(tmp, tmp, key);
+			for(n=0; n < len; ++n)
+				out[n] = tmp[n] ^ ivec[n];
+			memcpy(ivec, tmp, AES_BLOCK_SIZE);
+		}			
+	}
+}
diff -Nur blktap2_oxt//drivers/aes.h blktap2_xen//drivers/aes.h
--- blktap2_oxt//drivers/aes.h	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/aes.h	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,28 @@
+#ifndef QEMU_AES_H
+#define QEMU_AES_H
+
+#include <stdint.h>
+
+#define AES_MAXNR 14
+#define AES_BLOCK_SIZE 16
+
+struct aes_key_st {
+    uint32_t rd_key[4 *(AES_MAXNR + 1)];
+    int rounds;
+};
+typedef struct aes_key_st AES_KEY;
+
+int AES_set_encrypt_key(const unsigned char *userKey, const int bits,
+	AES_KEY *key);
+int AES_set_decrypt_key(const unsigned char *userKey, const int bits,
+	AES_KEY *key);
+
+void AES_encrypt(const unsigned char *in, unsigned char *out,
+	const AES_KEY *key);
+void AES_decrypt(const unsigned char *in, unsigned char *out,
+	const AES_KEY *key);
+void AES_cbc_encrypt(const unsigned char *in, unsigned char *out,
+		     const unsigned long length, const AES_KEY *key,
+		     unsigned char *ivec, const int enc);
+
+#endif
diff -Nur blktap2_oxt//drivers/atomicio.c blktap2_xen//drivers/atomicio.c
--- blktap2_oxt//drivers/atomicio.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/atomicio.c	2015-03-19 11:08:36.000000000 -0400
@@ -24,11 +24,6 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2008 Citrix Systems, Inc.
- */
-
-
 #include <stdlib.h>
 #include <errno.h>
 #include "atomicio.h"
diff -Nur blktap2_oxt//drivers/blk.h blktap2_xen//drivers/blk.h
--- blktap2_oxt//drivers/blk.h	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/blk.h	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,36 @@
+/* 
+ * Copyright (c) 2008, XenSource Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of XenSource Inc. nor the names of its contributors
+ *       may be used to endorse or promote products derived from this software
+ *       without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <inttypes.h>
+
+int blk_getimagesize(int fd, uint64_t *size);
+int blk_getsectorsize(int fd, uint64_t *sector_size);
+
+#ifndef O_LARGEFILE
+#define O_LARGEFILE	0
+#endif
diff -Nur blktap2_oxt//drivers/blk_linux.c blktap2_xen//drivers/blk_linux.c
--- blktap2_oxt//drivers/blk_linux.c	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/blk_linux.c	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,43 @@
+#include <inttypes.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <sys/mount.h>
+#include "tapdisk.h"
+#include "blk.h"
+
+int blk_getimagesize(int fd, uint64_t *size)
+{
+	int rc;
+
+	*size = 0;
+	rc = ioctl(fd, BLKGETSIZE, size);
+	if (rc) {
+		DPRINTF("ERR: BLKGETSIZE failed, couldn't stat image");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int blk_getsectorsize(int fd, uint64_t *sector_size)
+{
+#if defined(BLKSSZGET)
+	int rc;
+
+	*sector_size = DEFAULT_SECTOR_SIZE;
+	rc = ioctl(fd, BLKSSZGET, sector_size);
+	if (rc) {
+		DPRINTF("ERR: BLKSSZGET failed. Falling back to use default sector size");
+		*sector_size = DEFAULT_SECTOR_SIZE;
+	}
+
+	if (*sector_size != DEFAULT_SECTOR_SIZE)
+		DPRINTF("Note: sector size is %"PRIu64" (not %u)\n",
+			*sector_size, DEFAULT_SECTOR_SIZE);
+#else
+	*sector_size = DEFAULT_SECTOR_SIZE;
+#endif
+
+	return 0;
+}
+
diff -Nur blktap2_oxt//drivers/blk_netbsd.c blktap2_xen//drivers/blk_netbsd.c
--- blktap2_oxt//drivers/blk_netbsd.c	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/blk_netbsd.c	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,41 @@
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#include <sys/disklabel.h>
+#include <errno.h>
+#include <inttypes.h>
+#include "tapdisk.h"
+#include "blk.h"
+
+int blk_getimagesize(int fd, uint64_t *size)
+{
+	int rc;
+	struct disklabel dl;
+
+	*size = 0;
+	rc = ioctl(fd, DIOCGDINFO, &dl);
+	if (rc) {
+		DPRINTF("ERR: DIOCGDINFO failed, couldn't stat image");
+		return -EINVAL;
+	}
+
+	*size = dl.d_secsize * dl.d_secpercyl;
+
+	return 0;
+}
+
+int blk_getsectorsize(int fd, uint64_t *sector_size)
+{
+	int rc;
+	struct disklabel dl;
+
+	*sector_size = DEV_BSIZE;
+	rc = ioctl(fd, DIOCGDINFO, &dl);
+	if (rc) {
+		DPRINTF("ERR: DIOCGDINFO failed, couldn't stat image");
+		return 0; /* fallback to DEV_BSIZE */
+	}
+
+	*sector_size = dl.d_secsize;
+	return 0;
+}
+
diff -Nur blktap2_oxt//drivers/block-aio.c blktap2_xen//drivers/block-aio.c
--- blktap2_oxt//drivers/block-aio.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/block-aio.c	2015-03-19 11:08:36.000000000 -0400
@@ -26,11 +26,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
 
 #include <errno.h>
 #include <fcntl.h>
@@ -40,8 +35,8 @@
 #include <sys/statvfs.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
-#include <linux/fs.h>
 
+#include "blk.h"
 #include "tapdisk.h"
 #include "tapdisk-driver.h"
 #include "tapdisk-interface.h"
@@ -71,7 +66,6 @@
 	int ret;
 	long size;
 	unsigned long total_size;
-	unsigned long long bytes;
 	struct statvfs statBuf;
 	struct stat stat;
 
@@ -84,12 +78,8 @@
 	if (S_ISBLK(stat.st_mode)) {
 		/*Accessing block device directly*/
 		info->size = 0;
-		if (ioctl(fd,BLKGETSIZE64,&bytes)==0) {
-			info->size = bytes >> SECTOR_SHIFT;
-		} else if (ioctl(fd,BLKGETSIZE,&info->size)!=0) {
-			DPRINTF("ERR: BLKGETSIZE and BLKGETSIZE64 failed, couldn't stat image");
+		if (blk_getimagesize(fd, &info->size) != 0)
 			return -EINVAL;
-		}
 
 		DPRINTF("Image size: \n\tpre sector_shift  [%llu]\n\tpost "
 			"sector_shift [%llu]\n",
@@ -97,19 +87,8 @@
 			(long long unsigned)info->size);
 
 		/*Get the sector size*/
-#if defined(BLKSSZGET)
-		{
-			int arg;
+		if (blk_getsectorsize(fd, &info->sector_size) != 0)
 			info->sector_size = DEFAULT_SECTOR_SIZE;
-			ioctl(fd, BLKSSZGET, &info->sector_size);
-			
-			if (info->sector_size != DEFAULT_SECTOR_SIZE)
-				DPRINTF("Note: sector size is %ld (not %d)\n",
-					info->sector_size, DEFAULT_SECTOR_SIZE);
-		}
-#else
-		info->sector_size = DEFAULT_SECTOR_SIZE;
-#endif
 
 	} else {
 		/*Local file? try fstat instead*/
@@ -265,19 +244,6 @@
 	return -EINVAL;
 }
 
-void tdaio_stats(td_driver_t *driver, td_stats_t *st)
-{
-	struct tdaio_state *prv = (struct tdaio_state *)driver->data;
-	int n_pending;
-
-	n_pending = MAX_AIO_REQS - prv->aio_free_count;
-
-	tapdisk_stats_field(st, "reqs", "{");
-	tapdisk_stats_field(st, "max", "lu", MAX_AIO_REQS);
-	tapdisk_stats_field(st, "pending", "d", n_pending);
-	tapdisk_stats_leave(st, '}');
-}
-
 struct tap_disk tapdisk_aio = {
 	.disk_type          = "tapdisk_aio",
 	.flags              = 0,
@@ -289,5 +255,4 @@
 	.td_get_parent_id   = tdaio_get_parent_id,
 	.td_validate_parent = tdaio_validate_parent,
 	.td_debug           = NULL,
-	.td_stats           = tdaio_stats,
 };
diff -Nur blktap2_oxt//drivers/block-cache.c blktap2_xen//drivers/block-cache.c
--- blktap2_oxt//drivers/block-cache.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/block-cache.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2008 Citrix Systems, Inc.
- */
-
 #include <errno.h>
 #include <fcntl.h>
 #include <unistd.h>
@@ -774,7 +769,7 @@
 	stats = &cache->stats;
 
 	WARN("BLOCK CACHE %s\n", cache->name);
-	WARN("reads: %llu, hits: %llu, misses: %llu, prunes: %llu\n",
+	WARN("reads: %"PRIu64", hits: %"PRIu64", misses: %"PRIu64", prunes: %"PRIu64"\n",
 	     stats->reads, stats->hits, stats->misses, stats->prunes);
 }
 
diff -Nur blktap2_oxt//drivers/block-crypto.c blktap2_xen//drivers/block-crypto.c
--- blktap2_oxt//drivers/block-crypto.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/block-crypto.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,469 +0,0 @@
-/*
- * Copyright (c) 2010, XenSource Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2014 Citrix Systems, Inc.
- */
-
-
-#include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <unistd.h>
-
-#include "list.h"
-#include "libvhd.h"
-#include "tapdisk.h"
-#include "vhd-util.h"
-
-#include "crypto/compat-crypto-openssl.h"
-#include "crypto/xts_aes.h"
-
-#define MAX_AES_XTS_PLAIN_KEYSIZE 1024
-
-struct keystore_entry {
-    struct list_head    next;
-    uint8_t             key[MAX_AES_XTS_PLAIN_KEYSIZE / 8];
-    int                 keysize;
-    struct vhd_keyhash  keyhash;
-};
-
-static LIST_HEAD(keystore);
-
-static int
-check_key(const uint8_t *keybuf, unsigned int keysize,
-	  const struct vhd_keyhash *vhdhash)
-{
-	int err;
-	struct vhd_keyhash keyhash;
-
-	if (!vhdhash->cookie) {
-		DPRINTF("missing key hash\n");
-		err = 1;
-		goto out;
-	}
-
-	memcpy(keyhash.nonce, vhdhash->nonce, sizeof(keyhash.nonce));
-	err = __vhd_util_calculate_keyhash(&keyhash, keybuf, keysize / 8);
-	if (err) {
-		DPRINTF("failed to calculate keyhash: %d\n", err);
-		goto out;
-	}
-
-	if (memcmp(keyhash.hash, vhdhash->hash, sizeof(keyhash.hash))) {
-		DPRINTF("key hash mismatch\n");
-		err = 1;
-		goto out;
-	}
-
-out:
-	if (err) {
-		DPRINTF("key check failed\n");
-		err = -ENOKEY;
-	}
-	return err;
-}
-
-static void
-keystore_free_entry(struct keystore_entry *ent)
-{
-	if (ent) {
-		memset(ent->key, 0, sizeof(ent->key));
-		free(ent);
-	}
-}
-
-static int
-keystore_add_entry(const uint8_t *keybuf,
-		   size_t keysize, struct vhd_keyhash *keyhash)
-{
-	int err;
-	struct keystore_entry *ent = NULL;
-
-	list_for_each_entry(ent, &keystore, next) {
-		if (!memcmp(&ent->keyhash, keyhash, sizeof(ent->keyhash))) {
-			err = 0;
-			goto out;
-		}
-	}
-
-	ent = calloc(1, sizeof(*ent));
-	if (!ent) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	INIT_LIST_HEAD(&ent->next);
-	memcpy(ent->key, keybuf, keysize / 8);
-	memcpy(&ent->keyhash, keyhash, sizeof(ent->keyhash));
-        ent->keysize = keysize;
-
-	list_add(&ent->next, &keystore);
-
-out:
-	if (err)
-		keystore_free_entry(ent);
-	return err;
-}
-
-static int
-keystore_read_entry(uint8_t *keybuf, int *keysize, const struct vhd_keyhash *keyhash)
-{
-	int err;
-	struct keystore_entry *ent;
-        *keysize = 0;
-	/*
-	 * in the offline backup case, we won't have an entry for the
-	 * newest snapshot (since it didn't exist when we first opened
-	 * the chain). instead, we check all cached keys for a keyhash
-	 * match, assuming the snapshot shares the same key as one of
-	 * its ancestors.
-	 */
-
-	list_for_each_entry(ent, &keystore, next) {
-		if (!check_key(ent->key, ent->keysize, &ent->keyhash)) {
-			DPRINTF("using key from keystore\n");
-			memcpy(keybuf, ent->key, ent->keysize / 8);
-                        *keysize = ent->keysize;
-			err = 0;
-		} else {
-			err = -EINVAL;
-		}
-		goto out;
-	}
-
-	err = -ENOENT;
-
-out:
-	return err;
-}
-
-static int
-find_keyfile(char **keyfile, const char *dirs,
-	     const char *basename, int keysize)
-{
-	char *sep = NULL;
-	*keyfile  = NULL;
-
-	while (dirs && strlen(dirs) > 0) {
-		char keydir[256] = { 0 }, path[256] = { 0 };
-		struct stat st;
-		int err;
-
-		sep = strchr(dirs, ',');
-		/* get directory element */
-		if (sep == NULL) {
-			strncpy(keydir, dirs, sizeof(keydir));
-			dirs = NULL;
-		} else {
-			size_t len = sep - dirs;
-			strncpy(keydir, dirs, len);
-			dirs = sep+1;
-		}
-
-		/* check if keyfile is inside dir */
-		snprintf(path, sizeof(path),
-			 "%s/%s,aes-xts-plain,%d.key",
-			 keydir, basename, keysize);
-		err = stat(path, &st);
-		if (err == 0) {
-			/* found */
-			*keyfile = strdup(path);
-			if (*keyfile == NULL) {
-				return -ENOMEM;
-			}
-			return 0;
-		} else if (err < 0 && errno != ENOENT) {
-			return -errno;
-		}
-	}
-
-	return -ENOENT;
-}
-
-static int
-read_keyfile(const char *keydir, const char *basename,
-	     uint8_t *keybuf, size_t keysize)
-{
-	int err, fd = -1;
-	char *keyfile = NULL;
-
-	err = find_keyfile(&keyfile, keydir, basename, keysize);
-	if (err) {
-		keyfile = NULL;
-		goto out;
-	}
-
-	fd = open(keyfile, O_RDONLY);
-	if (fd == -1) {
-		err = -errno;
-		goto out;
-	}
-
-	err = read(fd, keybuf, keysize / 8);
-	if (err != keysize / 8) {
-		err = err == -1 ? -errno : -EINVAL;
-		goto out;
-	}
-
-	DPRINTF("using keyfile %s, keysize %d\n", keyfile, keysize);
-	err = 0;
-
-out:
-	if (fd != -1)
-		close(fd);
-	free(keyfile);
-	return err;
-}
-
-// try 512bit, 256bit keys
-static int
-read_preferred_keyfile(const char *keydir, const char *basename, uint8_t *keybuf, int *keysize)
-{
-    int sizes[] = { 512, 256 };
-    int err, i;
-    *keysize = 0;
-    for (i = 0; i < 2; ++i) {
-        err = read_keyfile(keydir, basename, keybuf, sizes[i]);
-        if (err == 0) {
-            *keysize = sizes[i];
-            return 0;
-        }
-    }
-    return err;
-}
-
-
-static vhd_context_t *
-vhd_open_parent(vhd_context_t *ctx)
-{
-    vhd_context_t *parent = NULL;
-    char *next = NULL;
-    int err;
-    if (ctx->footer.type != HD_TYPE_DIFF)
-        goto out;
-    if (vhd_parent_raw(ctx))
-        goto out;
-    err = vhd_parent_locator_get(ctx, &next);
-    if (err)
-        goto out;
-
-    parent = calloc(1, sizeof(*parent));
-    if (!parent)
-        goto out;
-
-    err = vhd_open(parent, next, VHD_OPEN_RDONLY);
-    if (err) {
-        DPRINTF("vhd_open failed: %d\n", err);
-        free(parent);
-        parent = NULL;
-        goto out;
-    }
-out:
-    free(next);
-    return parent;
-}
-
-static char *
-get_vhd_basename(vhd_context_t *vhd)
-{
-    char *basename, *ext;
-
-    /* strip path */
-    basename = strrchr(vhd->file, '/');
-    if (basename == NULL)
-        basename = vhd->file;
-    else
-        basename++;
-
-    basename = strdup(basename);
-    if (!basename)
-        return NULL;
-
-    /* cut off .vhd extension */
-    ext = strstr(basename, ".vhd");
-    if (ext)
-        basename[ext - basename] = 0;
-    return basename;
-}
-
-/* look up the chain for first parent VHD with encryption key */
-static int
-chain_find_keyed_vhd(vhd_context_t *vhd, uint8_t *key, int *keysize, struct vhd_keyhash *out_keyhash)
-{
-    int err;
-    struct vhd_keyhash keyhash;
-    vhd_context_t *p = vhd, *p2;
-    char *basename;
-    const char *keydir;
-    int found = 0;
-
-    memset(out_keyhash, 0, sizeof(*out_keyhash));
-
-    keydir = getenv("TAPDISK2_CRYPTO_KEYDIR");
-
-    while (p) {
-        err = vhd_get_keyhash(p, &keyhash);
-        if (err) {
-            DPRINTF("error getting keyhash: %d\n", err);
-            return err;
-        }
-
-        if (keyhash.cookie && keydir == NULL) {
-            DPRINTF("this vhd requires TAPDISK2_CRYPTO_KEYDIR\n");
-            return -ENOKEY;
-        }
-
-        /* if keydir is set, we check if a key exists (with the same basename)
-         * regardless the keyhash.cookie value to prevent an issue where
-         * the vhd has been replaced by another one that is clear */
-        if (keydir) {
-            basename = get_vhd_basename(p);
-            if (!basename) {
-                err = -ENOMEM;
-                goto out;
-            }
-
-            err = read_preferred_keyfile(keydir, basename, key, keysize);
-            free(basename);
-            switch (err) {
-            case 0: /* a key has been found with the same basename */
-                if (keyhash.cookie == NULL) {
-                    DPRINTF("key found for %s but no hash set\n", p->file);
-                    err = -EACCES;
-                    goto out;
-                }
-                err = check_key(key, *keysize, &keyhash);
-                if (err)
-                    goto out;
-                DPRINTF("using key from vhd: %s\n", p->file);
-                *out_keyhash = keyhash;
-                found = 1;
-                break;
-            case -ENOENT: /* no key found, get to the next one if the cookie's not set */
-                if (keyhash.cookie != NULL) {
-                    err = -ENOKEY;
-                    goto out;
-                }
-                break;
-            default: /* some another error */
-                goto out;
-            }
-        }
-
-        if (found)
-            goto out;
-
-        p2 = p;
-        p = vhd_open_parent(p);
-
-        if (p2 != vhd) {
-            vhd_close(p2);
-            free(p2);
-        }
-    }
-    return 0;
-out:
-    if (p != vhd) {
-        vhd_close(p);
-        free(p);
-    }
-    return err;
-}
-
-int
-vhd_open_crypto(vhd_context_t *vhd, const char *_name)
-{
-	struct vhd_keyhash keyhash;
-	int err;
-        uint8_t key[MAX_AES_XTS_PLAIN_KEYSIZE / 8] = { 0 };
-        int keysize = 0;
-        vhd_context_t *keyed_vhd = NULL;
-
-	if (vhd->xts_tfm)
-		return 0;
-
-        err = chain_find_keyed_vhd(vhd, key, &keysize, &keyhash);
-        if (err) {
-            DPRINTF("error in vhd chain: %d\n", err);
-            return err;
-        }
-
-        if (keyhash.cookie == NULL) {
-            return 0;
-        }
-
-	vhd->xts_tfm = xts_aes_setup();
-	if (vhd->xts_tfm == NULL) {
-		err = -EINVAL;
-		return err;
-	}
-
-	xts_aes_setkey(vhd->xts_tfm, key, keysize / 8);
-	err = 0;
-}
-
-void
-vhd_crypto_decrypt(vhd_context_t *vhd, td_request_t *t)
-{
-	int sec, ret;
-
-	for (sec = 0; sec < t->secs; sec++) {
-		ret = xts_aes_plain_decrypt(vhd->xts_tfm, t->sec + sec,
-					    (uint8_t *)t->buf +
-					    sec * VHD_SECTOR_SIZE,
-					    (uint8_t *)t->buf +
-					    sec * VHD_SECTOR_SIZE,
-					    VHD_SECTOR_SIZE);
-		if (ret) {
-			DPRINTF("crypto decrypt failed: %d : TERMINATED\n", ret);
-			exit(1); /* XXX */
-		}
-	}
-}
-
-void
-vhd_crypto_encrypt(vhd_context_t *vhd, td_request_t *t, char *orig_buf)
-{
-	int sec, ret;
-
-	for (sec = 0; sec < t->secs; sec++) {
-		ret = xts_aes_plain_encrypt(vhd->xts_tfm, t->sec + sec,
-					    (uint8_t *)t->buf +
-					    sec * VHD_SECTOR_SIZE,
-					    (uint8_t *)orig_buf +
-					    sec * VHD_SECTOR_SIZE,
-					    VHD_SECTOR_SIZE);
-		if (ret) {
-			DPRINTF("crypto encrypt failed: %d : TERMINATED\n", ret);
-			exit(1); /* XXX */
-		}
-	}
-}
diff -Nur blktap2_oxt//drivers/block-crypto.h blktap2_xen//drivers/block-crypto.h
--- blktap2_oxt//drivers/block-crypto.h	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/block-crypto.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,36 +0,0 @@
-/*
- * Copyright (c) 2010, XenSource Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
-int vhd_open_crypto(vhd_context_t *vhd, const char *name);
-void vhd_crypto_encrypt(vhd_context_t *vhd, td_request_t *t, char *orig_buf);
-void vhd_crypto_decrypt(vhd_context_t *vhd, td_request_t *t);
diff -Nur blktap2_oxt//drivers/block-lcache.c blktap2_xen//drivers/block-lcache.c
--- blktap2_oxt//drivers/block-lcache.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/block-lcache.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,307 +0,0 @@
-/* 
- * Copyright (c) 2010, XenSource Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
-/* Local persistent cache: write any sectors not found in the leaf back to the 
- * leaf.
- */
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <sys/mman.h>
-
-#include "vhd.h"
-#include "tapdisk.h"
-#include "tapdisk-utils.h"
-#include "tapdisk-driver.h"
-#include "tapdisk-server.h"
-#include "tapdisk-interface.h"
-
-#ifdef DEBUG
-#define DBG(_f, _a...) tlog_write(TLOG_DBG, _f, ##_a)
-#else
-#define DBG(_f, _a...) ((void)0)
-#endif
-
-#define WARN(_f, _a...) tlog_write(TLOG_WARN, _f, ##_a)
-#define BUG()           td_panic()
-#define BUG_ON(_cond)   if (_cond) { td_panic(); }
-
-#define LOCAL_CACHE_REQUESTS            (BLK_RING_SIZE*2)
-
-typedef struct local_cache              local_cache_t;
-
-struct local_cache_request {
-	int                             err;
-	char                           *buf;
-	int                             secs;
-	td_request_t                    treq;
-	local_cache_t                  *cache;
-	enum { LC_READ = 1, LC_WRITE }  phase;
-};
-typedef struct local_cache_request      local_cache_request_t;
-
-struct local_cache {
-	char                           *name;
-
-	local_cache_request_t           requests[LOCAL_CACHE_REQUESTS];
-	local_cache_request_t          *request_free_list[LOCAL_CACHE_REQUESTS];
-	int                             requests_free;
-
-	char                           *buf;
-	size_t                          bufsz;
-};
-
-static void local_cache_complete_req(td_request_t, int);
-
-static inline local_cache_request_t *
-local_cache_get_request(local_cache_t *cache)
-{
-	if (!cache->requests_free)
-		return NULL;
-
-	return cache->request_free_list[--cache->requests_free];
-}
-
-static inline void
-local_cache_put_request(local_cache_t *cache, local_cache_request_t *lreq)
-{
-	cache->request_free_list[cache->requests_free++] = lreq;
-}
-
-static int
-local_cache_close(td_driver_t *driver)
-{
-	local_cache_t *cache = driver->data;
-
-	DPRINTF("Closing local cache for %s\n", cache->name);
-
-	if (cache->buf)
-		munmap(cache->buf, cache->bufsz);
-
-	free(cache->name);
-	return 0;
-}
-
-static int
-local_cache_open(td_driver_t *driver, const char *name, td_flag_t flags)
-{
-	local_cache_t *cache = driver->data;
-	int i, err;
-	int prot, _flags;
-	size_t lreq_bufsz;
-
-	err   = tapdisk_namedup(&cache->name, (char *)name);
-	if (err)
-		goto fail;
-
-	lreq_bufsz   = BLKIF_MAX_SEGMENTS_PER_REQUEST * sysconf(_SC_PAGE_SIZE);
-	cache->bufsz = LOCAL_CACHE_REQUESTS * lreq_bufsz;
-
-	prot   = PROT_READ|PROT_WRITE;
-	_flags = MAP_ANONYMOUS|MAP_PRIVATE;
-	cache->buf = mmap(NULL, cache->bufsz, prot, _flags, -1, 0);
-	if (cache->buf == MAP_FAILED) {
-		cache->buf == NULL;
-		err = -errno;
-		goto fail;
-	}
-
-	err = mlock(cache->buf, cache->bufsz);
-	if (err) {
-		err = -errno;
-		goto fail;
-	}
-
-	cache->requests_free = LOCAL_CACHE_REQUESTS;
-	for (i = 0; i < LOCAL_CACHE_REQUESTS; i++) {
-		local_cache_request_t *lreq = &cache->requests[i];
-		lreq->buf = cache->buf + i * lreq_bufsz;
-		cache->request_free_list[i] = lreq;
-	}
-
-	DPRINTF("Opening local cache for %s\n", cache->name);
-	return 0;
-
-fail:
-	local_cache_close(driver);
-	return err;
-}
-
-static void
-local_cache_complete_read(local_cache_t *cache, local_cache_request_t *lreq)
-{
-	td_vbd_t *vbd = lreq->treq.image->private;
-	td_request_t clone;
-
-	if (!lreq->err) {
-		size_t sz = lreq->treq.secs << SECTOR_SHIFT;
-		memcpy(lreq->treq.buf, lreq->buf, sz);
-	}
-
-	td_complete_request(lreq->treq, lreq->err);
-
-	if (lreq->err) {
-		local_cache_put_request(cache, lreq);
-		return;
-	}
-
-	lreq->phase   = LC_WRITE;
-	lreq->secs    = lreq->treq.secs;
-	lreq->err     = 0;
-
-	clone         = lreq->treq;
-	clone.op      = TD_OP_WRITE;
-	clone.buf     = lreq->buf;
-	clone.cb      = local_cache_complete_req;
-	clone.cb_data = lreq;
-	clone.image   = tapdisk_vbd_first_image(vbd);
-
-	td_queue_write(clone.image, clone);
-}
-
-static void
-local_cache_complete_write(local_cache_t *cache, local_cache_request_t *lreq)
-{
-	local_cache_put_request(cache, lreq);
-}
-
-static void
-local_cache_complete_req(td_request_t treq, int err)
-{
-	local_cache_request_t *lreq = treq.cb_data;
-	local_cache_t *cache = lreq->cache;
-
-	BUG_ON(lreq->secs == 0);
-	BUG_ON(lreq->secs < treq.secs);
-
-	lreq->secs -= treq.secs;
-	lreq->err   = lreq->err ? : err;
-
-	if (lreq->secs)
-		return;
-
-	switch (lreq->phase) {
-	case LC_READ:
-		local_cache_complete_read(cache, lreq);
-		break;
-
-	case LC_WRITE:
-		local_cache_complete_write(cache, lreq);
-		break;
-
-	default:
-		BUG();
-	}
-}
-
-static void
-local_cache_queue_read(td_driver_t *driver, td_request_t treq)
-{
-	local_cache_t *cache = driver->data;
-	int err;
-	size_t size;
-	td_request_t clone;
-	local_cache_request_t *lreq;
-
-	//DPRINTF("LocalCache: read request! %lld (%d secs)\n", treq.sec, 
-	//treq.secs);
-
-	lreq = local_cache_get_request(cache);
-	if (!lreq) {
-		td_forward_request(treq);
-		return;
-	}
-
-	lreq->treq    = treq;
-	lreq->cache   = cache;
-
-	lreq->phase   = LC_READ;
-	lreq->secs    = lreq->treq.secs;
-	lreq->err     = 0;
-
-	clone         = treq;
-	clone.buf     = lreq->buf;
-	clone.cb      = local_cache_complete_req;
-	clone.cb_data = lreq;
-
-out:
-	td_forward_request(clone);
-}
-
-
-static void
-local_cache_queue_write(td_driver_t *driver, td_request_t treq)
-{
-	DPRINTF("Local cache: write request! (ERROR)\n");
-	td_complete_request(treq, -EPERM);
-}
-
-static int
-local_cache_get_parent_id(td_driver_t *driver, td_disk_id_t *id)
-{
-	return -EINVAL;
-}
-
-static int
-local_cache_validate_parent(td_driver_t *driver,
-			    td_driver_t *pdriver, td_flag_t flags)
-{
-	if (strcmp(driver->name, pdriver->name))
-		return -EINVAL;
-
-	return 0;
-}
-
-static void
-local_cache_debug(td_driver_t *driver)
-{
-	local_cache_t *cache;
-
-	cache = (local_cache_t *)driver->data;
-
-	WARN("LOCAL CACHE %s\n", cache->name);
-}
-
-struct tap_disk tapdisk_local_cache = {
-	.disk_type                  = "tapdisk_local_cache",
-	.flags                      = 0,
-	.private_data_size          = sizeof(local_cache_t),
-	.td_open                    = local_cache_open,
-	.td_close                   = local_cache_close,
-	.td_queue_read              = local_cache_queue_read,
-	.td_queue_write             = local_cache_queue_write,
-	.td_get_parent_id           = local_cache_get_parent_id,
-	.td_validate_parent         = local_cache_validate_parent,
-	.td_debug                   = local_cache_debug,
-};
diff -Nur blktap2_oxt//drivers/block-log.c blktap2_xen//drivers/block-log.c
--- blktap2_oxt//drivers/block-log.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/block-log.c	2015-03-19 11:08:36.000000000 -0400
@@ -26,11 +26,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2008 Citrix Systems, Inc.
- */
-
-
 /* Driver to sit on top of another disk and log writes, in order
  * to synchronize two distinct disks
  *
@@ -52,6 +47,7 @@
 #include <sys/socket.h>
 #include <sys/un.h>
 
+#include "xc_bitops.h"
 #include "log.h"
 #include "tapdisk.h"
 #include "tapdisk-server.h"
@@ -94,31 +90,6 @@
 
 /* large flat bitmaps don't scale particularly well either in size or scan
  * time, but they'll do for now */
-#define BITS_PER_LONG (sizeof(unsigned long) * 8)
-#define BITS_TO_LONGS(bits) (((bits)+BITS_PER_LONG-1)/BITS_PER_LONG)
-
-#define BITMAP_ENTRY(_nr, _bmap) ((unsigned long*)(_bmap))[(_nr)/BITS_PER_LONG]
-#define BITMAP_SHIFT(_nr) ((_nr) % BITS_PER_LONG)
-
-static inline int test_bit(int nr, void* bmap)
-{
-  return (BITMAP_ENTRY(nr, bmap) >> BITMAP_SHIFT(nr)) & 1;
-}
-
-static inline void clear_bit(int nr, void* bmap)
-{
-  BITMAP_ENTRY(nr, bmap) &= ~(1UL << BITMAP_SHIFT(nr));
-}
-
-static inline void set_bit(int nr, void* bmap)
-{
-  BITMAP_ENTRY(nr, bmap) |= (1UL << BITMAP_SHIFT(nr));
-}
-
-static inline int bitmap_size(uint64_t sz)
-{
-  return sz >> 3;
-}
 
 static int writelog_create(struct tdlog_state *s)
 {
@@ -128,7 +99,8 @@
 
   BDPRINTF("allocating %"PRIu64" bytes for dirty bitmap", bmsize);
 
-  if (!(s->writelog = calloc(bmsize, 1))) {
+  s->writelog = bitmap_alloc(s->size);
+  if (!s->writelog) {
     BWPRINTF("could not allocate dirty bitmap of size %"PRIu64, bmsize);
     return -1;
   }
@@ -319,7 +291,7 @@
     goto err_sock;
   }
     
-  if (bind(s->ctl.fd, &saddr, sizeof(saddr)) < 0) {
+  if (bind(s->ctl.fd, (const struct sockaddr *)&saddr, sizeof(saddr)) < 0) {
     BWPRINTF("error binding control socket to %s: %s", s->ctlpath,
 	     strerror(errno));
     goto err_sock;
@@ -352,11 +324,11 @@
 static int ctl_close(struct tdlog_state* s)
 {
   while (s->connected) {
+    s->connected--;
     tapdisk_server_unregister_event(s->connections[s->connected].id);
     close(s->connections[s->connected].fd);
     s->connections[s->connected].fd = -1;
     s->connections[s->connected].id = 0;
-    s->connected--;
   }
 
   if (s->ctl.fd >= 0) {
@@ -387,7 +359,7 @@
 {
   int i;
 
-  for (i = 0; i <= s->connected; i++) {
+  for (i = 0; i < s->connected; i++) {
     if (s->connections[i].fd == fd) {
       tapdisk_server_unregister_event(s->connections[i].id);
       close(s->connections[i].fd);
diff -Nur blktap2_oxt//drivers/block-qcow.c blktap2_xen//drivers/block-qcow.c
--- blktap2_oxt//drivers/block-qcow.c	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/block-qcow.c	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,1501 @@
+/* block-qcow.c
+ *
+ * Asynchronous Qemu copy-on-write disk implementation.
+ * Code based on the Qemu implementation
+ * (see copyright notice below)
+ *
+ * (c) 2006 Andrew Warfield and Julian Chesterfield
+ *
+ */
+
+/*
+ * Block driver for the QCOW format
+ * 
+ * Copyright (c) 2004 Fabrice Bellard
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files(the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/statvfs.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <string.h>
+#include <zlib.h>
+#include <inttypes.h>
+#include <libaio.h>
+#include <limits.h>
+#include "bswap.h"
+#include "aes.h"
+#include "md5.h"
+
+#include "tapdisk.h"
+#include "tapdisk-driver.h"
+#include "tapdisk-interface.h"
+#include "tapdisk-disktype.h"
+#include "qcow.h"
+#include "blk.h"
+#include "atomicio.h"
+
+/* *BSD has no O_LARGEFILE */
+#ifndef O_LARGEFILE
+#define O_LARGEFILE     0
+#endif
+
+#if 1
+#define ASSERT(_p) \
+    if ( !(_p) ) { DPRINTF("Assertion '%s' failed, line %d, file %s", #_p , \
+    __LINE__, __FILE__); *(int*)0=0; }
+#else
+#define ASSERT(_p) ((void)0)
+#endif
+
+struct pending_aio {
+        td_callback_t cb;
+        int id;
+        void *private;
+	int nb_sectors;
+	char *buf;
+	uint64_t sector;
+};
+
+#undef IOCB_IDX
+#define IOCB_IDX(_s, _io) ((_io) - (_s)->iocb_list)
+
+#define ZERO_TEST(_b) (_b | 0x00)
+
+struct qcow_request {
+	td_request_t         treq;
+	struct tiocb         tiocb;
+	struct tdqcow_state  *state;
+};
+
+static int decompress_cluster(struct tdqcow_state *s, uint64_t cluster_offset);
+
+uint32_t gen_cksum(char *ptr, int len)
+{
+  int i;
+  uint32_t md[4];
+
+  /* Generate checksum */
+  md5_sum((const uint8_t*)ptr, len, (uint8_t*)md);
+
+  return md[0];
+}
+
+static void free_aio_state(struct tdqcow_state* s)
+{
+	free(s->aio_requests);
+	free(s->aio_free_list);
+}
+
+static int init_aio_state(td_driver_t *driver)
+{
+	int i, ret;
+	td_disk_info_t *bs = &(driver->info);
+	struct tdqcow_state   *s  = (struct tdqcow_state *)driver->data;
+	
+        // A segment (i.e. a page) can span multiple clusters
+        s->max_aio_reqs = ((getpagesize() / s->cluster_size) + 1) *
+	  MAX_SEGMENTS_PER_REQ * MAX_REQUESTS;
+
+	s->aio_free_count = s->max_aio_reqs;
+
+	if (!(s->aio_requests  = calloc(s->max_aio_reqs, sizeof(struct qcow_request))) || 
+	    !(s->aio_free_list = calloc(s->max_aio_reqs, sizeof(struct qcow_request)))) {
+	    DPRINTF("Failed to allocate AIO structs (max_aio_reqs = %d)\n",
+		    s->max_aio_reqs);
+	    goto fail;
+	}
+
+	for (i = 0; i < s->max_aio_reqs; i++)
+		s->aio_free_list[i] = &s->aio_requests[i];
+
+        DPRINTF("AIO state initialised\n");
+
+        return 0;
+ fail:
+	return -1;
+}
+
+int get_filesize(char *filename, uint64_t *size, struct stat *st)
+{
+	int fd;
+	QCowHeader header;
+
+	/*Set to the backing file size*/
+	fd = open(filename, O_RDONLY);
+	if (fd < 0)
+		return -1;
+	if (read(fd, &header, sizeof(header)) < sizeof(header)) {
+		close(fd);
+		return -1;
+	}
+	close(fd);
+	
+	be32_to_cpus(&header.magic);
+	be64_to_cpus(&header.size);
+	if (header.magic == QCOW_MAGIC) {
+		*size = header.size >> SECTOR_SHIFT;
+		return 0;
+	}
+
+	if(S_ISBLK(st->st_mode)) {
+		fd = open(filename, O_RDONLY);
+		if (fd < 0)
+			return -1;
+		if (blk_getimagesize(fd, size) != 0) {
+			printf("Unable to get Block device size\n");
+			close(fd);
+			return -1;
+		}
+		close(fd);
+	} else *size = (st->st_size >> SECTOR_SHIFT);	
+	return 0;
+}
+
+static int qcow_set_key(struct tdqcow_state *s, const char *key)
+{
+	uint8_t keybuf[16];
+	int len, i;
+	
+	memset(keybuf, 0, 16);
+	len = strlen(key);
+	if (len > 16)
+		len = 16;
+	/* XXX: we could compress the chars to 7 bits to increase
+	   entropy */
+	for (i = 0; i < len; i++) {
+		keybuf[i] = key[i];
+	}
+	s->crypt_method = s->crypt_method_header;
+	
+	if (AES_set_encrypt_key(keybuf, 128, &s->aes_encrypt_key) != 0)
+		return -1;
+	if (AES_set_decrypt_key(keybuf, 128, &s->aes_decrypt_key) != 0)
+		return -1;
+#if 0
+	/* test */
+	{
+		uint8_t in[16];
+		uint8_t out[16];
+		uint8_t tmp[16];
+		for (i=0; i<16; i++)
+			in[i] = i;
+		AES_encrypt(in, tmp, &s->aes_encrypt_key);
+		AES_decrypt(tmp, out, &s->aes_decrypt_key);
+		for (i = 0; i < 16; i++)
+			DPRINTF(" %02x", tmp[i]);
+		DPRINTF("\n");
+		for (i = 0; i < 16; i++)
+			DPRINTF(" %02x", out[i]);
+		DPRINTF("\n");
+	}
+#endif
+	return 0;
+}
+
+void tdqcow_complete(void *arg, struct tiocb *tiocb, int err)
+{
+	struct qcow_request *aio = (struct qcow_request *)arg;
+	struct tdqcow_state *s = aio->state;
+
+	td_complete_request(aio->treq, err);
+
+	s->aio_free_list[s->aio_free_count++] = aio;
+}
+
+static void async_read(td_driver_t *driver, td_request_t treq)
+{
+	int size;
+	uint64_t offset;
+	struct qcow_request *aio;
+	struct tdqcow_state *prv;
+
+	prv    = (struct tdqcow_state *)driver->data;
+	size   = treq.secs * driver->info.sector_size;
+	offset = treq.sec  * (uint64_t)driver->info.sector_size;
+
+	if (prv->aio_free_count == 0)
+		goto fail;
+
+	aio        = prv->aio_free_list[--prv->aio_free_count];
+	aio->treq  = treq;
+	aio->state = prv;
+
+	td_prep_read(&aio->tiocb, prv->fd, treq.buf,
+		     size, offset, tdqcow_complete, aio);
+	td_queue_tiocb(driver, &aio->tiocb);
+
+	return;
+
+fail:
+	td_complete_request(treq, -EBUSY);
+}
+
+static void async_write(td_driver_t *driver, td_request_t treq)
+{
+	int size;
+	uint64_t offset;
+	struct qcow_request *aio;
+	struct tdqcow_state *prv;
+
+	prv     = (struct tdqcow_state *)driver->data;
+	size    = treq.secs * driver->info.sector_size;
+	offset  = treq.sec  * (uint64_t)driver->info.sector_size;
+
+	if (prv->aio_free_count == 0)
+		goto fail;
+
+	aio        = prv->aio_free_list[--prv->aio_free_count];
+	aio->treq  = treq;
+	aio->state = prv;
+
+	td_prep_write(&aio->tiocb, prv->fd, treq.buf,
+		      size, offset, tdqcow_complete, aio);
+	td_queue_tiocb(driver, &aio->tiocb);
+
+	return;
+
+fail:
+	td_complete_request(treq, -EBUSY);
+}
+
+/* 
+ * The crypt function is compatible with the linux cryptoloop
+ * algorithm for < 4 GB images. NOTE: out_buf == in_buf is
+ * supported .
+ */
+static void encrypt_sectors(struct tdqcow_state *s, int64_t sector_num,
+                            uint8_t *out_buf, const uint8_t *in_buf,
+                            int nb_sectors, int enc,
+                            const AES_KEY *key)
+{
+	union {
+		uint64_t ll[2];
+		uint8_t b[16];
+	} ivec;
+	int i;
+	
+	for (i = 0; i < nb_sectors; i++) {
+		ivec.ll[0] = cpu_to_le64(sector_num);
+		ivec.ll[1] = 0;
+		AES_cbc_encrypt(in_buf, out_buf, 512, key, 
+				ivec.b, enc);
+		sector_num++;
+		in_buf += 512;
+		out_buf += 512;
+	}
+}
+
+int qtruncate(int fd, off_t length, int sparse)
+{
+	int ret, i; 
+	int current = 0, rem = 0;
+	uint64_t sectors;
+	struct stat st;
+	char *buf;
+
+	/* If length is greater than the current file len
+	 * we synchronously write zeroes to the end of the 
+	 * file, otherwise we truncate the length down
+	 */
+	ret = fstat(fd, &st);
+	if (ret == -1) 
+		return -1;
+	if (S_ISBLK(st.st_mode))
+		return 0;
+
+	sectors = (length + DEFAULT_SECTOR_SIZE - 1)/DEFAULT_SECTOR_SIZE;
+	current = (st.st_size + DEFAULT_SECTOR_SIZE - 1)/DEFAULT_SECTOR_SIZE;
+	rem     = st.st_size % DEFAULT_SECTOR_SIZE;
+
+	/* If we are extending this file, we write zeros to the end --
+	 * this tries to ensure that the extents allocated wind up being
+	 * contiguous on disk.
+	 */
+	if(st.st_size < sectors * DEFAULT_SECTOR_SIZE) {
+		/*We are extending the file*/
+		if ((ret = posix_memalign((void **)&buf, 
+					  512, DEFAULT_SECTOR_SIZE))) {
+			DPRINTF("posix_memalign failed: %d\n", ret);
+			return -1;
+		}
+		memset(buf, 0x00, DEFAULT_SECTOR_SIZE);
+		if (lseek(fd, 0, SEEK_END)==-1) {
+			DPRINTF("Lseek EOF failed (%d), internal error\n",
+				errno);
+			free(buf);
+			return -1;
+		}
+		if (rem) {
+			ret = write(fd, buf, rem);
+			if (ret != rem) {
+				DPRINTF("write failed: ret = %d, err = %s\n",
+					ret, strerror(errno));
+				free(buf);
+				return -1;
+			}
+		}
+		for (i = current; i < sectors; i++ ) {
+			ret = write(fd, buf, DEFAULT_SECTOR_SIZE);
+			if (ret != DEFAULT_SECTOR_SIZE) {
+				DPRINTF("write failed: ret = %d, err = %s\n",
+					ret, strerror(errno));
+				free(buf);
+				return -1;
+			}
+		}
+		free(buf);
+	} else if(sparse && (st.st_size > sectors * DEFAULT_SECTOR_SIZE))
+		if (ftruncate(fd, (off_t)sectors * DEFAULT_SECTOR_SIZE)==-1) {
+			DPRINTF("Ftruncate failed (%s)\n", strerror(errno));
+			return -1;
+		}
+	return 0;
+}
+
+/* 'allocate' is:
+ *
+ * 0 to not allocate.
+ *
+ * 1 to allocate a normal cluster (for sector indexes 'n_start' to
+ * 'n_end')
+ *
+ * 2 to allocate a compressed cluster of size
+ * 'compressed_size'. 'compressed_size' must be > 0 and <
+ * cluster_size 
+ *
+ * return 0 if not allocated.
+ */
+static uint64_t get_cluster_offset(struct tdqcow_state *s,
+                                   uint64_t offset, int allocate,
+                                   int compressed_size,
+                                   int n_start, int n_end)
+{
+	int min_index, i, j, l1_index, l2_index, l2_sector, l1_sector;
+	char *tmp_ptr2, *l2_ptr, *l1_ptr;
+	uint64_t *tmp_ptr;
+	uint64_t l2_offset, *l2_table, cluster_offset, tmp;
+	uint32_t min_count;
+	int new_l2_table;
+
+	/*Check L1 table for the extent offset*/
+	l1_index = offset >> (s->l2_bits + s->cluster_bits);
+	l2_offset = s->l1_table[l1_index];
+	new_l2_table = 0;
+	if (!l2_offset) {
+		if (!allocate)
+			return 0;
+		/* 
+		 * allocating a new l2 entry + extent 
+		 * at the end of the file, we must also
+		 * update the L1 entry safely.
+		 */
+		l2_offset = s->fd_end;
+
+		/* round to cluster size */
+		l2_offset = (l2_offset + s->cluster_size - 1) 
+			& ~(s->cluster_size - 1);
+
+		/* update the L1 entry */
+		s->l1_table[l1_index] = l2_offset;
+		
+		/*Truncate file for L2 table 
+		 *(initialised to zero in case we crash)*/
+		if (qtruncate(s->fd, 
+			      l2_offset + (s->l2_size * sizeof(uint64_t)),
+			      s->sparse) != 0) {
+			DPRINTF("ERROR truncating file\n");
+			return 0;
+		}
+		s->fd_end = l2_offset + (s->l2_size * sizeof(uint64_t));
+
+		/*Update the L1 table entry on disk
+                 * (for O_DIRECT we write 4KByte blocks)*/
+		l1_sector = (l1_index * sizeof(uint64_t)) >> 12;
+		l1_ptr = (char *)s->l1_table + (l1_sector << 12);
+
+		if (posix_memalign((void **)&tmp_ptr, 4096, 4096) != 0) {
+			DPRINTF("ERROR allocating memory for L1 table\n");
+                        return 0;
+		}
+		memcpy(tmp_ptr, l1_ptr, 4096);
+
+		/* Convert block to write to big endian */
+		for(i = 0; i < 4096 / sizeof(uint64_t); i++) {
+			cpu_to_be64s(&tmp_ptr[i]);
+		}
+
+		/*
+		 * Issue non-asynchronous L1 write.
+		 * For safety, we must ensure that
+		 * entry is written before blocks.
+		 */
+		lseek(s->fd, s->l1_table_offset + (l1_sector << 12), SEEK_SET);
+		if (write(s->fd, tmp_ptr, 4096) != 4096) {
+			free(tmp_ptr);
+		 	return 0;
+		}
+		free(tmp_ptr);
+
+		new_l2_table = 1;
+		goto cache_miss;
+	} else if (s->min_cluster_alloc == s->l2_size) {
+		/*Fast-track the request*/
+		cluster_offset = l2_offset + (s->l2_size * sizeof(uint64_t));
+		l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1);
+		return cluster_offset + (l2_index * s->cluster_size);
+	}
+
+	/*Check to see if L2 entry is already cached*/
+	for (i = 0; i < L2_CACHE_SIZE; i++) {
+		if (l2_offset == s->l2_cache_offsets[i]) {
+			/* increment the hit count */
+			if (++s->l2_cache_counts[i] == 0xffffffff) {
+				for (j = 0; j < L2_CACHE_SIZE; j++) {
+					s->l2_cache_counts[j] >>= 1;
+				}
+			}
+			l2_table = s->l2_cache + (i << s->l2_bits);
+			goto found;
+		}
+	}
+
+cache_miss:
+	/* not found: load a new entry in the least used one */
+	min_index = 0;
+	min_count = 0xffffffff;
+	for (i = 0; i < L2_CACHE_SIZE; i++) {
+		if (s->l2_cache_counts[i] < min_count) {
+			min_count = s->l2_cache_counts[i];
+			min_index = i;
+		}
+	}
+	l2_table = s->l2_cache + (min_index << s->l2_bits);
+
+	/*If extent pre-allocated, read table from disk, 
+	 *otherwise write new table to disk*/
+	if (new_l2_table) {
+		/*Should we allocate the whole extent? Adjustable parameter.*/
+		if (s->cluster_alloc == s->l2_size) {
+			cluster_offset = l2_offset + 
+				(s->l2_size * sizeof(uint64_t));
+			cluster_offset = (cluster_offset + s->cluster_size - 1)
+				& ~(s->cluster_size - 1);
+			if (qtruncate(s->fd, cluster_offset + 
+				  (s->cluster_size * s->l2_size), 
+				      s->sparse) != 0) {
+				DPRINTF("ERROR truncating file\n");
+				return 0;
+			}
+			s->fd_end = cluster_offset + 
+				(s->cluster_size * s->l2_size);
+			for (i = 0; i < s->l2_size; i++) {
+				l2_table[i] = cpu_to_be64(cluster_offset + 
+							  (i*s->cluster_size));
+			}  
+		} else memset(l2_table, 0, s->l2_size * sizeof(uint64_t));
+
+		lseek(s->fd, l2_offset, SEEK_SET);
+		if (write(s->fd, l2_table, s->l2_size * sizeof(uint64_t)) !=
+		   s->l2_size * sizeof(uint64_t))
+			return 0;
+	} else {
+		lseek(s->fd, l2_offset, SEEK_SET);
+		if (read(s->fd, l2_table, s->l2_size * sizeof(uint64_t)) != 
+		    s->l2_size * sizeof(uint64_t))
+			return 0;
+	}
+	
+	/*Update the cache entries*/ 
+	s->l2_cache_offsets[min_index] = l2_offset;
+	s->l2_cache_counts[min_index] = 1;
+
+found:
+	/*The extent is split into 's->l2_size' blocks of 
+	 *size 's->cluster_size'*/
+	l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1);
+	cluster_offset = be64_to_cpu(l2_table[l2_index]);
+
+	if (!cluster_offset || 
+	    ((cluster_offset & QCOW_OFLAG_COMPRESSED) && allocate == 1) ) {
+		if (!allocate)
+			return 0;
+		
+		if ((cluster_offset & QCOW_OFLAG_COMPRESSED) &&
+		    (n_end - n_start) < s->cluster_sectors) {
+			/* cluster is already allocated but compressed, we must
+			   decompress it in the case it is not completely
+			   overwritten */
+			if (decompress_cluster(s, cluster_offset) < 0)
+				return 0;
+			cluster_offset = lseek(s->fd, s->fd_end, SEEK_SET);
+			cluster_offset = (cluster_offset + s->cluster_size - 1)
+				& ~(s->cluster_size - 1);
+			/* write the cluster content - not asynchronous */
+			lseek(s->fd, cluster_offset, SEEK_SET);
+			if (write(s->fd, s->cluster_cache, s->cluster_size) != 
+			    s->cluster_size)
+			    return -1;
+		} else {
+			/* allocate a new cluster */
+			cluster_offset = lseek(s->fd, s->fd_end, SEEK_SET);
+			if (allocate == 1) {
+				/* round to cluster size */
+				cluster_offset = 
+					(cluster_offset + s->cluster_size - 1) 
+					& ~(s->cluster_size - 1);
+				if (qtruncate(s->fd, cluster_offset + 
+					      s->cluster_size, s->sparse)!=0) {
+					DPRINTF("ERROR truncating file\n");
+					return 0;
+				}
+				s->fd_end = (cluster_offset + s->cluster_size);
+				/* if encrypted, we must initialize the cluster
+				   content which won't be written */
+				if (s->crypt_method && 
+				    (n_end - n_start) < s->cluster_sectors) {
+					uint64_t start_sect;
+					start_sect = (offset & 
+						      ~(s->cluster_size - 1)) 
+							      >> 9;
+					memset(s->cluster_data + 512, 
+					       0xaa, 512);
+					for (i = 0; i < s->cluster_sectors;i++)
+					{
+						if (i < n_start || i >= n_end) 
+						{
+							encrypt_sectors(s, start_sect + i, 
+									s->cluster_data, 
+									s->cluster_data + 512, 1, 1,
+									&s->aes_encrypt_key);
+							lseek(s->fd, cluster_offset + i * 512, SEEK_SET);
+							if (write(s->fd, s->cluster_data, 512) != 512)
+								return -1;
+						}
+					}
+				}
+			} else {
+				cluster_offset |= QCOW_OFLAG_COMPRESSED | 
+					(uint64_t)compressed_size 
+						<< (63 - s->cluster_bits);
+			}
+		}
+		/* update L2 table */
+		tmp = cpu_to_be64(cluster_offset);
+		l2_table[l2_index] = tmp;
+
+		/*For IO_DIRECT we write 4KByte blocks*/
+		l2_sector = (l2_index * sizeof(uint64_t)) >> 12;
+		l2_ptr = (char *)l2_table + (l2_sector << 12);
+		
+		if (posix_memalign((void **)&tmp_ptr2, 4096, 4096) != 0) {
+			DPRINTF("ERROR allocating memory for L1 table\n");
+                        return 0;
+		}
+		memcpy(tmp_ptr2, l2_ptr, 4096);
+		lseek(s->fd, l2_offset + (l2_sector << 12), SEEK_SET);
+		if (write(s->fd, tmp_ptr2, 4096) != 4096) {
+			free(tmp_ptr2);
+			return -1;
+		}
+		free(tmp_ptr2);
+	}
+	return cluster_offset;
+}
+
+static int qcow_is_allocated(struct tdqcow_state *s, int64_t sector_num,
+                             int nb_sectors, int *pnum)
+{
+	int index_in_cluster, n;
+	uint64_t cluster_offset;
+
+	cluster_offset = get_cluster_offset(s, sector_num << 9, 0, 0, 0, 0);
+	index_in_cluster = sector_num & (s->cluster_sectors - 1);
+	n = s->cluster_sectors - index_in_cluster;
+	if (n > nb_sectors)
+		n = nb_sectors;
+	*pnum = n;
+	return (cluster_offset != 0);
+}
+
+static int decompress_buffer(uint8_t *out_buf, int out_buf_size,
+                             const uint8_t *buf, int buf_size)
+{
+	z_stream strm1, *strm = &strm1;
+	int ret, out_len;
+	
+	memset(strm, 0, sizeof(*strm));
+	
+	strm->next_in = (uint8_t *)buf;
+	strm->avail_in = buf_size;
+	strm->next_out = out_buf;
+	strm->avail_out = out_buf_size;
+	
+	ret = inflateInit2(strm, -12);
+	if (ret != Z_OK)
+		return -1;
+	ret = inflate(strm, Z_FINISH);
+	out_len = strm->next_out - out_buf;
+	if ( (ret != Z_STREAM_END && ret != Z_BUF_ERROR) ||
+	    (out_len != out_buf_size) ) {
+		inflateEnd(strm);
+		return -1;
+	}
+	inflateEnd(strm);
+	return 0;
+}
+                              
+static int decompress_cluster(struct tdqcow_state *s, uint64_t cluster_offset)
+{
+	int ret, csize;
+	uint64_t coffset;
+
+	coffset = cluster_offset & s->cluster_offset_mask;
+	if (s->cluster_cache_offset != coffset) {
+		csize = cluster_offset >> (63 - s->cluster_bits);
+		csize &= (s->cluster_size - 1);
+		lseek(s->fd, coffset, SEEK_SET);
+		ret = read(s->fd, s->cluster_data, csize);
+		if (ret != csize) 
+			return -1;
+		if (decompress_buffer(s->cluster_cache, s->cluster_size,
+				      s->cluster_data, csize) < 0) {
+			return -1;
+		}
+		s->cluster_cache_offset = coffset;
+	}
+	return 0;
+}
+
+static int
+tdqcow_read_header(int fd, QCowHeader *header)
+{
+	int err;
+	char *buf;
+	struct stat st;
+	size_t size, expected;
+
+	memset(header, 0, sizeof(*header));
+
+	err = fstat(fd, &st);
+	if (err)
+		return -errno;
+
+	err = lseek(fd, 0, SEEK_SET);
+	if (err == (off_t)-1)
+		return -errno;
+
+	size = (sizeof(*header) + 511) & ~511;
+	err = posix_memalign((void **)&buf, 512, size);
+	if (err)
+		return err;
+
+	expected = size;
+	if (st.st_size < size)
+		expected = st.st_size;
+
+	errno = 0;
+	err = read(fd, buf, size);
+	if (err != expected) {
+		err = (errno ? -errno : -EIO);
+		goto out;
+	}
+
+	memcpy(header, buf, sizeof(*header));
+	be32_to_cpus(&header->magic);
+	be32_to_cpus(&header->version);
+	be64_to_cpus(&header->backing_file_offset);
+	be32_to_cpus(&header->backing_file_size);
+	be32_to_cpus(&header->mtime);
+	be64_to_cpus(&header->size);
+	be32_to_cpus(&header->crypt_method);
+	be64_to_cpus(&header->l1_table_offset);
+
+	err = 0;
+
+out:
+	free(buf);
+	return err;
+}
+
+static int
+tdqcow_load_l1_table(struct tdqcow_state *s, QCowHeader *header)
+{
+	char *buf;
+	struct stat st;
+	size_t expected;
+	int i, err, shift;
+	QCowHeader_ext *exthdr;
+	uint32_t l1_table_bytes, l1_table_block, l1_table_size;
+
+	buf         = NULL;
+	s->l1_table = NULL;
+
+	shift = s->cluster_bits + s->l2_bits;
+
+	s->l1_size = (header->size + (1LL << shift) - 1) >> shift;
+	s->l1_table_offset = header->l1_table_offset;
+
+	s->min_cluster_alloc = 1; /* default */
+
+	l1_table_bytes = s->l1_size * sizeof(uint64_t);
+	l1_table_size  = (l1_table_bytes + 4095) & ~4095;
+	l1_table_block = (l1_table_bytes + s->l1_table_offset + 4095) & ~4095;
+
+	DPRINTF("L1 Table offset detected: %"PRIu64", size %d (%d)\n",
+		(uint64_t)s->l1_table_offset,
+		(int) (s->l1_size * sizeof(uint64_t)), 
+		l1_table_size);
+
+	err = fstat(s->fd, &st);
+	if (err) {
+		err = -errno;
+		goto out;
+	}
+
+	err = lseek(s->fd, 0, SEEK_SET);
+	if (err == (off_t)-1) {
+		err = -errno;
+		goto out;
+	}
+
+	err = posix_memalign((void **)&buf, 512, l1_table_block);
+	if (err) {
+		buf = NULL;
+		goto out;
+	}
+
+	err = posix_memalign((void **)&s->l1_table, 4096, l1_table_size);
+	if (err) {
+		s->l1_table = NULL;
+		goto out;
+	}
+
+	memset(buf, 0, l1_table_block);
+	memset(s->l1_table, 0, l1_table_size);
+
+	expected = l1_table_block;
+	if (st.st_size < l1_table_block)
+		expected = st.st_size;
+
+	errno = 0;
+	err = read(s->fd, buf, l1_table_block);
+	if (err != expected) {
+		err = (errno ? -errno : -EIO);
+		goto out;
+	}
+
+	memcpy(s->l1_table, buf + s->l1_table_offset, l1_table_size);
+	exthdr = (QCowHeader_ext *)(buf + sizeof(QCowHeader));
+
+	/* check for xen extended header */
+	if (s->l1_table_offset % 4096 == 0 &&
+	    be32_to_cpu(exthdr->xmagic) == XEN_MAGIC) {
+		uint32_t flags = be32_to_cpu(exthdr->flags);
+		uint32_t cksum = be32_to_cpu(exthdr->cksum);
+
+		/*
+		 * Try to detect old tapdisk images. They have to be fixed
+		 * because they use big endian rather than native endian for
+		 * the L1 table.  After this block, the l1 table will
+		 * definitely be in BIG endian.
+		 */
+		if (!(flags & EXTHDR_L1_BIG_ENDIAN)) {
+			DPRINTF("qcow: converting to big endian L1 table\n");
+
+			/* convert to big endian */
+			for (i = 0; i < s->l1_size; i++)
+				cpu_to_be64s(&s->l1_table[i]);
+
+			flags |= EXTHDR_L1_BIG_ENDIAN;
+			exthdr->flags = cpu_to_be32(flags);
+
+			memcpy(buf + s->l1_table_offset,
+			       s->l1_table, l1_table_size);
+			
+			err = lseek(s->fd, 0, SEEK_SET);
+			if (err == (off_t)-1) {
+				err = -errno;
+				goto out;
+			}
+
+			err = atomicio(vwrite, s->fd, buf, l1_table_block);
+			if (err != l1_table_block) {
+				err = -errno;
+				goto out;
+			}
+		}
+
+		/* check the L1 table checksum */
+		if (cksum != gen_cksum((char *)s->l1_table,
+				       s->l1_size * sizeof(uint64_t)))
+			DPRINTF("qcow: bad L1 checksum\n");
+		else {
+			s->extended = 1;
+			s->sparse = (be32_to_cpu(exthdr->flags) & SPARSE_FILE);
+			s->min_cluster_alloc =
+				be32_to_cpu(exthdr->min_cluster_alloc);
+		}
+	}
+
+	/* convert L1 table to native endian for operation */
+	for (i = 0; i < s->l1_size; i++)
+		be64_to_cpus(&s->l1_table[i]);
+
+	err = 0;
+
+out:
+	if (err) {
+		free(buf);
+		free(s->l1_table);
+		s->l1_table = NULL;
+	}
+	return err;
+}
+
+/* Open the disk file and initialize qcow state. */
+int tdqcow_open (td_driver_t *driver, const char *name, td_flag_t flags)
+{
+	int fd, len, i, ret, size, o_flags;
+	td_disk_info_t *bs = &(driver->info);
+	struct tdqcow_state   *s  = (struct tdqcow_state *)driver->data;
+	QCowHeader header;
+	uint64_t final_cluster = 0;
+
+ 	DPRINTF("QCOW: Opening %s\n", name);
+
+	o_flags = O_DIRECT | O_LARGEFILE | 
+		((flags == TD_OPEN_RDONLY) ? O_RDONLY : O_RDWR);
+	fd = open(name, o_flags);
+	if (fd < 0) {
+		DPRINTF("Unable to open %s (%d)\n", name, -errno);
+		return -1;
+	}
+
+	s->fd = fd;
+	s->name = strdup(name);
+	if (!s->name)
+		goto fail;
+
+	if (tdqcow_read_header(fd, &header))
+		goto fail;
+
+	if (header.magic != QCOW_MAGIC)
+		goto fail;
+
+	switch (header.version) {
+	case QCOW_VERSION:
+		break;
+	case 2:
+	  //TODO: Port qcow2 to new blktap framework.
+	  //		close(fd);
+	  //		dd->drv = &tapdisk_qcow2;
+	  //		return dd->drv->td_open(dd, name, flags);
+	  goto fail;
+	default:
+		goto fail;
+	}
+
+	if (header.size <= 1 || header.cluster_bits < 9)
+		goto fail;
+	if (header.crypt_method > QCOW_CRYPT_AES)
+		goto fail;
+	s->crypt_method_header = header.crypt_method;
+	if (s->crypt_method_header)
+		s->encrypted = 1;
+	s->cluster_bits = header.cluster_bits;
+	s->cluster_size = 1 << s->cluster_bits;
+	s->cluster_sectors = 1 << (s->cluster_bits - 9);
+	s->l2_bits = header.l2_bits;
+	s->l2_size = 1 << s->l2_bits;
+	s->cluster_alloc = s->l2_size;
+	bs->size = header.size / 512;
+	s->cluster_offset_mask = (1LL << (63 - s->cluster_bits)) - 1;
+	s->backing_file_offset = header.backing_file_offset;
+	s->backing_file_size   = header.backing_file_size;
+
+	/* allocate and load l1 table */
+	if (tdqcow_load_l1_table(s, &header))
+		goto fail;
+
+	/* alloc L2 cache */
+	size = s->l2_size * L2_CACHE_SIZE * sizeof(uint64_t);
+	ret = posix_memalign((void **)&s->l2_cache, 4096, size);
+	if(ret != 0) goto fail;
+
+	size = s->cluster_size;
+	ret = posix_memalign((void **)&s->cluster_cache, 4096, size);
+	if(ret != 0) goto fail;
+
+	ret = posix_memalign((void **)&s->cluster_data, 4096, size);
+	if(ret != 0) goto fail;
+	s->cluster_cache_offset = -1;
+
+	if (s->backing_file_offset != 0)
+		s->cluster_alloc = 1; /*Cannot use pre-alloc*/
+
+        bs->sector_size = 512;
+        bs->info = 0;
+
+	for(i = 0; i < s->l1_size; i++)
+		if (s->l1_table[i] > final_cluster)
+			final_cluster = s->l1_table[i];
+
+	if (init_aio_state(driver)!=0) {
+	  DPRINTF("Unable to initialise AIO state\n");
+	  free_aio_state(s);
+	  goto fail;
+	}
+
+	if (!final_cluster)
+		s->fd_end = s->l1_table_offset +
+			((s->l1_size * sizeof(uint64_t) + 4095) & ~4095);
+	else {
+		s->fd_end = lseek(fd, 0, SEEK_END);
+		if (s->fd_end == (off_t)-1)
+			goto fail;
+	}
+
+	return 0;
+	
+fail:
+	DPRINTF("QCOW Open failed\n");
+
+	free_aio_state(s);
+	free(s->l1_table);
+	free(s->l2_cache);
+	free(s->cluster_cache);
+	free(s->cluster_data);
+	close(fd);
+	return -1;
+}
+
+void tdqcow_queue_read(td_driver_t *driver, td_request_t treq)
+{
+	struct tdqcow_state   *s  = (struct tdqcow_state *)driver->data;
+	int ret = 0, index_in_cluster, n, i;
+	uint64_t cluster_offset, sector, nb_sectors;
+	struct qcow_prv* prv;
+	td_request_t clone = treq;
+	char* buf = treq.buf;
+
+	sector     = treq.sec;
+	nb_sectors = treq.secs;
+
+	/*We store a local record of the request*/
+	while (nb_sectors > 0) {
+		cluster_offset = 
+			get_cluster_offset(s, sector << 9, 0, 0, 0, 0);
+		index_in_cluster = sector & (s->cluster_sectors - 1);
+		n = s->cluster_sectors - index_in_cluster;
+		if (n > nb_sectors)
+			n = nb_sectors;
+
+		if (s->aio_free_count == 0) {
+			td_complete_request(treq, -EBUSY);
+			return;
+		}
+		
+		if(!cluster_offset) {
+            int i;
+            /* Forward entire request if possible. */
+            for(i=0; i<nb_sectors; i++)
+                if(get_cluster_offset(s, (sector+i) << 9, 0, 0, 0, 0))
+                    goto coalesce_failed;
+            treq.buf  = buf;
+            treq.sec  = sector;
+            treq.secs = nb_sectors;
+			td_forward_request(treq);
+            return;
+coalesce_failed:            
+			treq.buf  = buf;
+			treq.sec  = sector;
+			treq.secs = n;
+			td_forward_request(treq);
+
+		} else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {
+			if (decompress_cluster(s, cluster_offset) < 0) {
+				td_complete_request(treq, -EIO);
+				goto done;
+			}
+			memcpy(buf, s->cluster_cache + index_in_cluster * 512, 
+			       512 * n);
+			
+			treq.buf  = buf;
+			treq.sec  = sector;
+			treq.secs = n;
+			td_complete_request(treq, 0);
+		} else {
+		  clone.buf  = buf;
+		  clone.sec  = (cluster_offset>>9)+index_in_cluster;
+		  clone.secs = n;
+		  async_read(driver, clone);
+		}
+		nb_sectors -= n;
+		sector += n;
+		buf += n * 512;
+	}
+done:
+	return;
+}
+
+void tdqcow_queue_write(td_driver_t *driver, td_request_t treq)
+{
+	struct tdqcow_state   *s  = (struct tdqcow_state *)driver->data;
+	int ret = 0, index_in_cluster, n, i;
+	uint64_t cluster_offset, sector, nb_sectors;
+	td_callback_t cb;
+	struct qcow_prv* prv;
+	char* buf = treq.buf;
+	td_request_t clone=treq;
+
+	sector     = treq.sec;
+	nb_sectors = treq.secs;
+		   
+	/*We store a local record of the request*/
+	while (nb_sectors > 0) {
+		index_in_cluster = sector & (s->cluster_sectors - 1);
+		n = s->cluster_sectors - index_in_cluster;
+		if (n > nb_sectors)
+			n = nb_sectors;
+
+		if (s->aio_free_count == 0) {
+			td_complete_request(treq, -EBUSY);
+			return;
+		}
+
+		cluster_offset = get_cluster_offset(s, sector << 9, 1, 0,
+						    index_in_cluster, 
+						    index_in_cluster+n);
+		if (!cluster_offset) {
+			DPRINTF("Ooops, no write cluster offset!\n");
+			td_complete_request(treq, -EIO);
+			return;
+		}
+
+		if (s->crypt_method) {
+			encrypt_sectors(s, sector, s->cluster_data, 
+					(unsigned char *)buf, n, 1,
+					&s->aes_encrypt_key);
+
+			clone.buf  = buf;
+			clone.sec  = (cluster_offset>>9) + index_in_cluster;
+			clone.secs = n;
+			async_write(driver, clone);
+		} else {
+		  clone.buf  = buf;
+		  clone.sec  = (cluster_offset>>9) + index_in_cluster;
+		  clone.secs = n;
+
+		  async_write(driver, clone);
+		}
+		
+		nb_sectors -= n;
+		sector += n;
+		buf += n * 512;
+	}
+	s->cluster_cache_offset = -1; /* disable compressed cache */
+
+	return;
+}
+
+static int
+tdqcow_update_checksum(struct tdqcow_state *s)
+{
+	int i, fd, err;
+	uint32_t offset, cksum, out;
+
+	if (!s->extended)
+		return 0;
+
+	fd = open(s->name, O_WRONLY | O_LARGEFILE); /* open without O_DIRECT */
+	if (fd == -1) {
+		err = errno;
+		goto out;
+	}
+
+	offset = sizeof(QCowHeader) + offsetof(QCowHeader_ext, cksum);
+	if (lseek(fd, offset, SEEK_SET) == (off_t)-1) {
+		err = errno;
+		goto out;
+	}
+
+	/* convert to big endian for checksum */
+	for (i = 0; i < s->l1_size; i++)
+		cpu_to_be64s(&s->l1_table[i]);
+
+	cksum = gen_cksum((char *)s->l1_table, s->l1_size * sizeof(uint64_t));
+
+	/* and back again... */
+	for (i = 0; i < s->l1_size; i++)
+		be64_to_cpus(&s->l1_table[i]);
+
+	DPRINTF("Writing cksum: %d", cksum);
+
+	out = cpu_to_be32(cksum);
+	if (write(fd, &out, sizeof(out)) != sizeof(out)) {
+		err = errno;
+		goto out;
+	}
+
+	err = 0;
+
+out:
+	if (err)
+		DPRINTF("failed to update checksum: %d\n", err);
+	if (fd != -1)
+		close(fd);
+	return err;
+}
+ 		
+int tdqcow_close(td_driver_t *driver)
+{
+	struct tdqcow_state *s = (struct tdqcow_state *)driver->data;
+
+	/*Update the hdr cksum*/
+	tdqcow_update_checksum(s);
+
+	free_aio_state(s);
+	free(s->name);
+	free(s->l1_table);
+	free(s->l2_cache);
+	free(s->cluster_cache);
+	free(s->cluster_data);
+	close(s->fd);	
+	return 0;
+}
+
+int qcow_create(const char *filename, uint64_t total_size,
+		const char *backing_file, int sparse)
+{
+	int fd, header_size, backing_filename_len, l1_size, i;
+	int shift, length, adjust, flags = 0, ret = 0;
+	QCowHeader header;
+	QCowHeader_ext exthdr;
+	char backing_filename[PATH_MAX], *ptr;
+	uint64_t tmp, size, total_length;
+	struct stat st;
+
+	DPRINTF("Qcow_create: size %"PRIu64"\n",total_size);
+
+	fd = open(filename, 
+		  O_WRONLY | O_CREAT | O_TRUNC | O_BINARY | O_LARGEFILE,
+		  0644);
+	if (fd < 0)
+		return -1;
+
+	memset(&header, 0, sizeof(header));
+	header.magic = cpu_to_be32(QCOW_MAGIC);
+	header.version = cpu_to_be32(QCOW_VERSION);
+
+	/*Create extended header fields*/
+	exthdr.xmagic = cpu_to_be32(XEN_MAGIC);
+
+	header_size = sizeof(header) + sizeof(QCowHeader_ext);
+	backing_filename_len = 0;
+	size = (total_size >> SECTOR_SHIFT);
+	if (backing_file) {
+		if (strcmp(backing_file, "fat:")) {
+			const char *p;
+			/* XXX: this is a hack: we do not attempt to 
+			 *check for URL like syntax */
+			p = strchr(backing_file, ':');
+			if (p && (p - backing_file) >= 2) {
+				/* URL like but exclude "c:" like filenames */
+				strncpy(backing_filename, backing_file,
+					sizeof(backing_filename));
+			} else {
+				if (realpath(backing_file, backing_filename) == NULL ||
+				    stat(backing_filename, &st) != 0) {
+					return -1;
+				}
+			}
+			header.backing_file_offset = cpu_to_be64(header_size);
+			backing_filename_len = strlen(backing_filename);
+			header.backing_file_size = cpu_to_be32(
+				backing_filename_len);
+			header_size += backing_filename_len;
+			
+			/*Set to the backing file size*/
+			if(get_filesize(backing_filename, &size, &st)) {
+				return -1;
+			}
+			DPRINTF("Backing file size detected: %"PRId64" sectors" 
+				"(total %"PRId64" [%"PRId64" MB])\n", 
+				size, 
+				(uint64_t)(size << SECTOR_SHIFT), 
+				(uint64_t)(size >> 11));
+		} else {
+			backing_file = NULL;
+			DPRINTF("Setting file size: %"PRId64" (total %"PRId64")\n", 
+				total_size, 
+				(uint64_t) (total_size << SECTOR_SHIFT));
+		}
+		header.mtime = cpu_to_be32(st.st_mtime);
+		header.cluster_bits = 9; /* 512 byte cluster to avoid copying
+					    unmodifyed sectors */
+		header.l2_bits = 12; /* 32 KB L2 tables */
+		exthdr.min_cluster_alloc = cpu_to_be32(1);
+	} else {
+		DPRINTF("Setting file size: %"PRId64" sectors" 
+			"(total %"PRId64" [%"PRId64" MB])\n", 
+			size, 
+			(uint64_t) (size << SECTOR_SHIFT), 
+			(uint64_t) (size >> 11));
+		header.cluster_bits = 12; /* 4 KB clusters */
+		header.l2_bits = 9; /* 4 KB L2 tables */
+		exthdr.min_cluster_alloc = cpu_to_be32(1 << 9);
+	}
+	/*Set the header size value*/
+	header.size = cpu_to_be64(size * 512);
+	
+	header_size = (header_size + 7) & ~7;
+	if (header_size % 4096 > 0) {
+		header_size = ((header_size >> 12) + 1) << 12;
+	}
+
+	shift = header.cluster_bits + header.l2_bits;
+	l1_size = ((size * 512) + (1LL << shift) - 1) >> shift;
+
+	header.l1_table_offset = cpu_to_be64(header_size);
+	DPRINTF("L1 Table offset: %d, size %d\n",
+		header_size,
+		(int)(l1_size * sizeof(uint64_t)));
+	header.crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);
+
+	ptr = calloc(1, l1_size * sizeof(uint64_t));
+	exthdr.cksum = cpu_to_be32(gen_cksum(ptr, l1_size * sizeof(uint64_t)));
+	printf("Created cksum: %d\n",exthdr.cksum);
+	free(ptr);
+
+	/*adjust file length to system page size boundary*/
+	length = ROUNDUP(header_size + (l1_size * sizeof(uint64_t)),
+		getpagesize());
+	if (qtruncate(fd, length, 0)!=0) {
+		DPRINTF("ERROR truncating file\n");
+		return -1;
+	}
+
+	if (sparse == 0) {
+		/*Filesize is length+l1_size*(1 << s->l2_bits)+(size*512)*/
+		total_length = length + (l1_size * (1 << 9)) + (size * 512);
+		if (qtruncate(fd, total_length, 0)!=0) {
+                        DPRINTF("ERROR truncating file\n");
+                        return -1;
+		}
+		printf("File truncated to length %"PRIu64"\n",total_length);
+	} else
+		flags = SPARSE_FILE;
+
+	flags |= EXTHDR_L1_BIG_ENDIAN;
+	exthdr.flags = cpu_to_be32(flags);
+	
+	/* write all the data */
+	lseek(fd, 0, SEEK_SET);
+	ret += write(fd, &header, sizeof(header));
+	ret += write(fd, &exthdr, sizeof(exthdr));
+	if (backing_file)
+		ret += write(fd, backing_filename, backing_filename_len);
+
+	lseek(fd, header_size, SEEK_SET);
+	tmp = 0;
+	for (i = 0;i < l1_size; i++) {
+		ret += write(fd, &tmp, sizeof(tmp));
+	}
+
+	close(fd);
+
+	return 0;
+}
+
+static int qcow_make_empty(struct tdqcow_state *s)
+{
+	uint32_t l1_length = s->l1_size * sizeof(uint64_t);
+
+	memset(s->l1_table, 0, l1_length);
+	lseek(s->fd, s->l1_table_offset, SEEK_SET);
+	if (write(s->fd, s->l1_table, l1_length) < 0)
+		return -1;
+	if (qtruncate(s->fd, s->l1_table_offset + l1_length, s->sparse)!=0) {
+		DPRINTF("ERROR truncating file\n");
+		return -1;
+	}
+
+	memset(s->l2_cache, 0, s->l2_size * L2_CACHE_SIZE * sizeof(uint64_t));
+	memset(s->l2_cache_offsets, 0, L2_CACHE_SIZE * sizeof(uint64_t));
+	memset(s->l2_cache_counts, 0, L2_CACHE_SIZE * sizeof(uint32_t));
+
+	return 0;
+}
+
+static int qcow_get_cluster_size(struct tdqcow_state *s)
+{
+	return s->cluster_size;
+}
+
+/* XXX: put compressed sectors first, then all the cluster aligned
+   tables to avoid losing bytes in alignment */
+static int qcow_compress_cluster(struct tdqcow_state *s, int64_t sector_num, 
+                          const uint8_t *buf)
+{
+	z_stream strm;
+	int ret, out_len;
+	uint8_t *out_buf;
+	uint64_t cluster_offset;
+
+	out_buf = malloc(s->cluster_size + (s->cluster_size / 1000) + 128);
+	if (!out_buf)
+		return -1;
+
+	/* best compression, small window, no zlib header */
+	memset(&strm, 0, sizeof(strm));
+	ret = deflateInit2(&strm, Z_DEFAULT_COMPRESSION,
+			   Z_DEFLATED, -12, 
+			   9, Z_DEFAULT_STRATEGY);
+	if (ret != 0) {
+		free(out_buf);
+		return -1;
+	}
+
+	strm.avail_in = s->cluster_size;
+	strm.next_in = (uint8_t *)buf;
+	strm.avail_out = s->cluster_size;
+	strm.next_out = out_buf;
+
+	ret = deflate(&strm, Z_FINISH);
+	if (ret != Z_STREAM_END && ret != Z_OK) {
+		free(out_buf);
+		deflateEnd(&strm);
+		return -1;
+	}
+	out_len = strm.next_out - out_buf;
+
+	deflateEnd(&strm);
+
+	if (ret != Z_STREAM_END || out_len >= s->cluster_size) {
+		/* could not compress: write normal cluster */
+		//tdqcow_queue_write(bs, sector_num, buf, s->cluster_sectors);
+	} else {
+		cluster_offset = get_cluster_offset(s, sector_num << 9, 2, 
+                                            out_len, 0, 0);
+		cluster_offset &= s->cluster_offset_mask;
+		lseek(s->fd, cluster_offset, SEEK_SET);
+		if (write(s->fd, out_buf, out_len) != out_len) {
+			free(out_buf);
+			return -1;
+		}
+	}
+	
+	free(out_buf);
+	return 0;
+}
+
+static int
+tdqcow_get_image_type(const char *file, int *type)
+{
+	int fd;
+	size_t size;
+	QCowHeader header;
+
+	fd = open(file, O_RDONLY);
+	if (fd == -1)
+		return -errno;
+
+	size = read(fd, &header, sizeof(header));
+	close(fd);
+	if (size != sizeof(header))
+		return (errno ? -errno : -EIO);
+
+	be32_to_cpus(&header.magic);
+	if (header.magic == QCOW_MAGIC)
+		*type = DISK_TYPE_QCOW;
+	else
+		*type = DISK_TYPE_AIO;
+
+	return 0;
+}
+
+int tdqcow_get_parent_id(td_driver_t *driver, td_disk_id_t *id)
+{
+	off_t off;
+	char *buf, *filename;
+	int len, secs, type = 0, err = -EINVAL;
+	struct tdqcow_state *child  = (struct tdqcow_state *)driver->data;
+
+	if (!child->backing_file_offset)
+		return TD_NO_PARENT;
+
+	/* read the backing file name */
+	len  = child->backing_file_size;
+	off  = child->backing_file_offset - (child->backing_file_offset % 512);
+	secs = (len + (child->backing_file_offset - off) + 511) >> 9;
+
+	if (posix_memalign((void **)&buf, 512, secs << 9)) 
+		return -1;
+
+	if (lseek(child->fd, off, SEEK_SET) == (off_t)-1)
+		goto out;
+
+	if (read(child->fd, buf, secs << 9) != secs << 9)
+		goto out;
+	filename       = buf + (child->backing_file_offset - off);
+	filename[len]  = '\0';
+
+	if (tdqcow_get_image_type(filename, &type))
+		goto out;
+
+	id->name       = strdup(filename);
+	id->drivertype = type;
+	err            = 0;
+ out:
+	free(buf);
+	return err;
+}
+
+int tdqcow_validate_parent(td_driver_t *driver,
+			  td_driver_t *pdriver, td_flag_t flags)
+{
+	struct stat stats;
+	uint64_t psize, csize;
+	struct tdqcow_state *c = (struct tdqcow_state *)driver->data;
+	struct tdqcow_state *p = (struct tdqcow_state *)pdriver->data;
+	
+	if (stat(p->name, &stats))
+		return -EINVAL;
+	if (get_filesize(p->name, &psize, &stats))
+		return -EINVAL;
+
+	if (stat(c->name, &stats))
+		return -EINVAL;
+	if (get_filesize(c->name, &csize, &stats))
+		return -EINVAL;
+
+	if (csize != psize)
+		return -EINVAL;
+
+	return 0;
+}
+
+struct tap_disk tapdisk_qcow = {
+	.disk_type           = "tapdisk_qcow",
+	.flags              = 0,
+	.private_data_size   = sizeof(struct tdqcow_state),
+	.td_open             = tdqcow_open,
+	.td_close            = tdqcow_close,
+	.td_queue_read       = tdqcow_queue_read,
+	.td_queue_write      = tdqcow_queue_write,
+	.td_get_parent_id    = tdqcow_get_parent_id,
+	.td_validate_parent  = tdqcow_validate_parent,
+	.td_debug           = NULL,
+};
diff -Nur blktap2_oxt//drivers/block-ram.c blktap2_xen//drivers/block-ram.c
--- blktap2_oxt//drivers/block-ram.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/block-ram.c	2015-03-19 11:08:36.000000000 -0400
@@ -26,11 +26,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2008 Citrix Systems, Inc.
- */
-
-
 #include <errno.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -39,9 +34,9 @@
 #include <sys/statvfs.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
-#include <linux/fs.h>
 #include <string.h>
 
+#include "blk.h"
 #include "tapdisk.h"
 #include "tapdisk-driver.h"
 #include "tapdisk-interface.h"
@@ -74,10 +69,8 @@
 	if (S_ISBLK(stat.st_mode)) {
 		/*Accessing block device directly*/
 		info->size = 0;
-		if (ioctl(fd,BLKGETSIZE,&info->size)!=0) {
-			DPRINTF("ERR: BLKGETSIZE failed, couldn't stat image");
+		if (blk_getimagesize(fd, &info->size) != 0)
 			return -EINVAL;
-		}
 
 		DPRINTF("Image size: \n\tpre sector_shift  [%llu]\n\tpost "
 			"sector_shift [%llu]\n",
@@ -85,19 +78,8 @@
 			(long long unsigned)info->size);
 
 		/*Get the sector size*/
-#if defined(BLKSSZGET)
-		{
-			int arg;
+		if (blk_getsectorsize(fd, &info->sector_size) != 0)
 			info->sector_size = DEFAULT_SECTOR_SIZE;
-			ioctl(fd, BLKSSZGET, &info->sector_size);
-			
-			if (info->sector_size != DEFAULT_SECTOR_SIZE)
-				DPRINTF("Note: sector size is %ld (not %d)\n",
-					info->sector_size, DEFAULT_SECTOR_SIZE);
-		}
-#else
-		info->sector_size = DEFAULT_SECTOR_SIZE;
-#endif
 
 	} else {
 		/*Local file? try fstat instead*/
@@ -119,7 +101,7 @@
 	disksector_size = info->sector_size;
 	disksize        = info->size;
 	diskinfo        = info->info;
-	DPRINTF("Image sector_size: \n\t[%lu]\n",
+	DPRINTF("Image sector_size: \n\t[%"PRIu64"]\n",
 		info->sector_size);
 
 	return 0;
@@ -144,7 +126,7 @@
 			"sector_shift [%llu]\n",
 			(long long unsigned)(driver->info.size << SECTOR_SHIFT),
 			(long long unsigned)driver->info.size);
-		DPRINTF("Image sector_size: \n\t[%lu]\n",
+		DPRINTF("Image sector_size: \n\t[%"PRIu64"]\n",
 			driver->info.sector_size);
 
 		prv->fd = -1;
diff -Nur blktap2_oxt//drivers/block-remus.c blktap2_xen//drivers/block-remus.c
--- blktap2_oxt//drivers/block-remus.c	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/block-remus.c	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,1733 @@
+/* block-remus.c
+ *
+ * This disk sends all writes to a backup via a network interface before
+ * passing them to an underlying device.
+ * The backup is a bit more complicated:
+ *  1. It applies all incoming writes to a ramdisk.
+ *  2. When a checkpoint request arrives, it moves the ramdisk to
+ *     a committing state and uses a new ramdisk for subsequent writes.
+ *     It also acknowledges the request, to let the sender know it can
+ *     release output.
+ *  3. The ramdisk flushes its contents to the underlying driver.
+ *  4. At failover, the backup waits for the in-flight ramdisk (if any) to
+ *     drain before letting the domain be activated.
+ *
+ * The driver determines whether it is the client or server by attempting
+ * to bind to the replication address. If the address is not local,
+ * the driver acts as client.
+ *
+ * The following messages are defined for the replication stream:
+ * 1. write request
+ *    "wreq"      4
+ *    num_sectors 4
+ *    sector      8
+ *    buffer      (num_sectors * sector_size)
+ * 2. submit request (may be used as a barrier
+ *    "sreq"      4
+ * 3. commit request
+ *    "creq"      4
+ * After a commit request, the client must wait for a competion message:
+ * 4. completion
+ *    "done"      4
+ */
+
+/* due to architectural choices in tapdisk, block-buffer is forced to
+ * reimplement some code which is meant to be private */
+#include "tapdisk.h"
+#include "tapdisk-server.h"
+#include "tapdisk-driver.h"
+#include "tapdisk-interface.h"
+#include "hashtable.h"
+#include "hashtable_itr.h"
+#include "hashtable_utility.h"
+
+#include <errno.h>
+#include <inttypes.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+
+/* timeout for reads and writes in ms */
+#define HEARTBEAT_MS 1000
+#define RAMDISK_HASHSIZE 128
+
+/* connect retry timeout (seconds) */
+#define REMUS_CONNRETRY_TIMEOUT 10
+
+#define RPRINTF(_f, _a...) syslog (LOG_DEBUG, "remus: " _f, ## _a)
+
+enum tdremus_mode {
+	mode_invalid = 0,
+	mode_unprotected,
+	mode_primary,
+	mode_backup
+};
+
+struct tdremus_req {
+	uint64_t sector;
+	int nb_sectors;
+	char buf[4096];
+};
+
+struct req_ring {
+	/* waste one slot to distinguish between empty and full */
+	struct tdremus_req requests[MAX_REQUESTS * 2 + 1];
+	unsigned int head;
+	unsigned int tail;
+};
+
+/* TODO: This isn't very pretty, but to properly generate our own treqs (needed
+ * by the backup) we need to know our td_vbt_t and td_image_t (blktap2
+ * internals). As a proper fix, we should consider extending the tapdisk
+ * interface with a td_create_request() function, or something similar.
+ *
+ * For now, we just grab the vbd in the td_open() command, and the td_image_t
+ * from the first read request.
+ */
+td_vbd_t *device_vbd = NULL;
+td_image_t *remus_image = NULL;
+struct tap_disk tapdisk_remus;
+
+struct ramdisk {
+	size_t sector_size;
+	struct hashtable* h;
+	/* when a ramdisk is flushed, h is given a new empty hash for writes
+	 * while the old ramdisk (prev) is drained asynchronously.
+	 */
+	struct hashtable* prev;
+	/* count of outstanding requests to the base driver */
+	size_t inflight;
+	/* prev holds the requests to be flushed, while inprogress holds
+	 * requests being flushed. When requests complete, they are removed
+	 * from inprogress.
+	 * Whenever a new flush is merged with ongoing flush (i.e, prev),
+	 * we have to make sure that none of the new requests overlap with
+	 * ones in "inprogress". If it does, keep it back in prev and dont issue
+	 * IO until the current one finishes. If we allow this IO to proceed,
+	 * we might end up with two "overlapping" requests in the disk's queue and
+	 * the disk may not offer any guarantee on which one is written first.
+	 * IOW, make sure we dont create a write-after-write time ordering constraint.
+	 * 
+	 */
+	struct hashtable* inprogress;
+};
+
+/* the ramdisk intercepts the original callback for reads and writes.
+ * This holds the original data. */
+/* Might be worth making this a static array in struct ramdisk to avoid
+ * a malloc per request */
+
+struct tdremus_state;
+
+struct ramdisk_cbdata {
+	td_callback_t cb;
+	void* private;
+	char* buf;
+	struct tdremus_state* state;
+};
+
+struct ramdisk_write_cbdata {
+	struct tdremus_state* state;
+	char* buf;
+};
+
+typedef void (*queue_rw_t) (td_driver_t *driver, td_request_t treq);
+
+/* poll_fd type for blktap2 fd system. taken from block_log.c */
+typedef struct poll_fd {
+	int        fd;
+	event_id_t id;
+} poll_fd_t;
+
+struct tdremus_state {
+//  struct tap_disk* driver;
+	void* driver_data;
+
+  /* XXX: this is needed so that the server can perform operations on
+   * the driver from the stream_fd event handler. fix this. */
+	td_driver_t *tdremus_driver;
+
+	/* TODO: we may wish to replace these two FIFOs with a unix socket */
+	char*     ctl_path; /* receive flush instruction here */
+	poll_fd_t ctl_fd;     /* io_fd slot for control FIFO */
+	char*     msg_path; /* output completion message here */
+	poll_fd_t msg_fd;
+
+  /* replication host */
+	struct sockaddr_in sa;
+	poll_fd_t server_fd;    /* server listen port */
+	poll_fd_t stream_fd;     /* replication channel */
+
+	/* queue write requests, batch-replicate at submit */
+	struct req_ring write_ring;
+
+	/* ramdisk data*/
+	struct ramdisk ramdisk;
+
+	/* mode methods */
+	enum tdremus_mode mode;
+	int (*queue_flush)(td_driver_t *driver);
+};
+
+typedef struct tdremus_wire {
+	uint32_t op;
+	uint64_t id;
+	uint64_t sec;
+	uint32_t secs;
+} tdremus_wire_t;
+
+#define TDREMUS_READ "rreq"
+#define TDREMUS_WRITE "wreq"
+#define TDREMUS_SUBMIT "sreq"
+#define TDREMUS_COMMIT "creq"
+#define TDREMUS_DONE "done"
+#define TDREMUS_FAIL "fail"
+
+/* primary read/write functions */
+static void primary_queue_read(td_driver_t *driver, td_request_t treq);
+static void primary_queue_write(td_driver_t *driver, td_request_t treq);
+
+/* backup read/write functions */
+static void backup_queue_read(td_driver_t *driver, td_request_t treq);
+static void backup_queue_write(td_driver_t *driver, td_request_t treq);
+
+/* unpritected read/write functions */
+static void unprotected_queue_read(td_driver_t *driver, td_request_t treq);
+static void unprotected_queue_write(td_driver_t *driver, td_request_t treq);
+
+static int tdremus_close(td_driver_t *driver);
+
+static int switch_mode(td_driver_t *driver, enum tdremus_mode mode);
+static int ctl_respond(struct tdremus_state *s, const char *response);
+
+/* ring functions */
+static inline unsigned int ring_next(struct req_ring* ring, unsigned int pos)
+{
+	if (++pos >= MAX_REQUESTS * 2 + 1)
+		return 0;
+
+	return pos;
+}
+
+static inline int ring_isempty(struct req_ring* ring)
+{
+	return ring->head == ring->tail;
+}
+
+static inline int ring_isfull(struct req_ring* ring)
+{
+	return ring_next(ring, ring->tail) == ring->head;
+}
+/* Prototype declarations */
+static int ramdisk_flush(td_driver_t *driver, struct tdremus_state* s);
+
+/* functions to create and sumbit treq's */
+
+static void
+replicated_write_callback(td_request_t treq, int err)
+{
+	struct tdremus_state *s = (struct tdremus_state *) treq.cb_data;
+	td_vbd_request_t *vreq;
+	int i;
+	uint64_t start;
+	vreq = (td_vbd_request_t *) treq.private;
+
+	/* the write failed for now, lets panic. this is very bad */
+	if (err) {
+		RPRINTF("ramdisk write failed, disk image is not consistent\n");
+		exit(-1);
+	}
+
+	/* The write succeeded. let's pull the vreq off whatever request list
+	 * it is on and free() it */
+	list_del(&vreq->next);
+	free(vreq);
+
+	s->ramdisk.inflight--;
+	start = treq.sec;
+	for (i = 0; i < treq.secs; i++) {
+		hashtable_remove(s->ramdisk.inprogress, &start);
+		start++;
+	}
+	free(treq.buf);
+
+	if (!s->ramdisk.inflight && !s->ramdisk.prev) {
+		/* TODO: the ramdisk has been flushed */
+	}
+}
+
+static inline int
+create_write_request(struct tdremus_state *state, td_sector_t sec, int secs, char *buf)
+{
+	td_request_t treq;
+	td_vbd_request_t *vreq;
+
+	treq.op      = TD_OP_WRITE;
+	treq.buf     = buf;
+	treq.sec     = sec;
+	treq.secs    = secs;
+	treq.image   = remus_image;
+	treq.cb      = replicated_write_callback;
+	treq.cb_data = state;
+	treq.id      = 0;
+	treq.sidx    = 0;
+
+	vreq         = calloc(1, sizeof(td_vbd_request_t));
+	treq.private = vreq;
+
+	if(!vreq)
+		return -1;
+
+	vreq->submitting = 1;
+	INIT_LIST_HEAD(&vreq->next);
+	tapdisk_vbd_move_request(treq.private, &device_vbd->pending_requests);
+
+	/* TODO:
+	 * we should probably leave it up to the caller to forward the request */
+	td_forward_request(treq);
+
+	vreq->submitting--;
+
+	return 0;
+}
+
+
+/* http://www.concentric.net/~Ttwang/tech/inthash.htm */
+static unsigned int uint64_hash(void* k)
+{
+	uint64_t key = *(uint64_t*)k;
+
+	key = (~key) + (key << 18);
+	key = key ^ (key >> 31);
+	key = key * 21;
+	key = key ^ (key >> 11);
+	key = key + (key << 6);
+	key = key ^ (key >> 22);
+
+	return (unsigned int)key;
+}
+
+static int rd_hash_equal(void* k1, void* k2)
+{
+	uint64_t key1, key2;
+
+	key1 = *(uint64_t*)k1;
+	key2 = *(uint64_t*)k2;
+
+	return key1 == key2;
+}
+
+static int ramdisk_read(struct ramdisk* ramdisk, uint64_t sector,
+			int nb_sectors, char* buf)
+{
+	int i;
+	char* v;
+	uint64_t key;
+
+	for (i = 0; i < nb_sectors; i++) {
+		key = sector + i;
+		/* check whether it is queued in a previous flush request */
+		if (!(ramdisk->prev && (v = hashtable_search(ramdisk->prev, &key)))) {
+			/* check whether it is an ongoing flush */
+			if (!(ramdisk->inprogress && (v = hashtable_search(ramdisk->inprogress, &key))))
+				return -1;
+		}
+		memcpy(buf + i * ramdisk->sector_size, v, ramdisk->sector_size);
+	}
+
+	return 0;
+}
+
+static int ramdisk_write_hash(struct hashtable* h, uint64_t sector, char* buf,
+			      size_t len)
+{
+	char* v;
+	uint64_t* key;
+
+	if ((v = hashtable_search(h, &sector))) {
+		memcpy(v, buf, len);
+		return 0;
+	}
+
+	if (!(v = malloc(len))) {
+		DPRINTF("ramdisk_write_hash: malloc failed\n");
+		return -1;
+	}
+	memcpy(v, buf, len);
+	if (!(key = malloc(sizeof(*key)))) {
+		DPRINTF("ramdisk_write_hash: error allocating key\n");
+		free(v);
+		return -1;
+	}
+	*key = sector;
+	if (!hashtable_insert(h, key, v)) {
+		DPRINTF("ramdisk_write_hash failed on sector %" PRIu64 "\n", sector);
+		free(key);
+		free(v);
+		return -1;
+	}
+
+	return 0;
+}
+
+static inline int ramdisk_write(struct ramdisk* ramdisk, uint64_t sector,
+				int nb_sectors, char* buf)
+{
+	int i, rc;
+
+	for (i = 0; i < nb_sectors; i++) {
+		rc = ramdisk_write_hash(ramdisk->h, sector + i,
+					buf + i * ramdisk->sector_size,
+					ramdisk->sector_size);
+		if (rc)
+			return rc;
+	}
+
+	return 0;
+}
+
+static int uint64_compare(const void* k1, const void* k2)
+{
+	uint64_t u1 = *(uint64_t*)k1;
+	uint64_t u2 = *(uint64_t*)k2;
+
+	/* u1 - u2 is unsigned */
+	return u1 < u2 ? -1 : u1 > u2 ? 1 : 0;
+}
+
+/* set psectors to an array of the sector numbers in the hash, returning
+ * the number of entries (or -1 on error) */
+static int ramdisk_get_sectors(struct hashtable* h, uint64_t** psectors)
+{
+	struct hashtable_itr* itr;
+	uint64_t* sectors;
+	int count;
+
+	if (!(count = hashtable_count(h)))
+		return 0;
+
+	if (!(*psectors = malloc(count * sizeof(uint64_t)))) {
+		DPRINTF("ramdisk_get_sectors: error allocating sector map\n");
+		return -1;
+	}
+	sectors = *psectors;
+
+	itr = hashtable_iterator(h);
+	count = 0;
+	do {
+		sectors[count++] = *(uint64_t*)hashtable_iterator_key(itr);
+	} while (hashtable_iterator_advance(itr));
+	free(itr);
+
+	return count;
+}
+
+/*
+  return -1 for OOM
+  return -2 for merge lookup failure
+  return -3 for WAW race
+  return 0 on success.
+*/
+static int merge_requests(struct ramdisk* ramdisk, uint64_t start,
+			size_t count, char **mergedbuf)
+{
+	char* buf;
+	char* sector;
+	int i;
+	uint64_t *key;
+	int rc = 0;
+
+	if (!(buf = valloc(count * ramdisk->sector_size))) {
+		DPRINTF("merge_request: allocation failed\n");
+		return -1;
+	}
+
+	for (i = 0; i < count; i++) {
+		if (!(sector = hashtable_search(ramdisk->prev, &start))) {
+			DPRINTF("merge_request: lookup failed on %"PRIu64"\n", start);
+			free(buf);
+			rc = -2;
+			goto fail;
+		}
+
+		/* Check inprogress requests to avoid waw non-determinism */
+		if (hashtable_search(ramdisk->inprogress, &start)) {
+			DPRINTF("merge_request: WAR RACE on %"PRIu64"\n", start);
+			free(buf);
+			rc = -3;
+			goto fail;
+		}
+		/* Insert req into inprogress (brief period of duplication of hash entries until
+		 * they are removed from prev. Read tracking would not be reading wrong entries)
+		 */
+		if (!(key = malloc(sizeof(*key)))) {
+			DPRINTF("%s: error allocating key\n", __FUNCTION__);
+			free(buf);			
+			rc = -1;
+			goto fail;
+		}
+		*key = start;
+		if (!hashtable_insert(ramdisk->inprogress, key, NULL)) {
+			DPRINTF("%s failed to insert sector %" PRIu64 " into inprogress hash\n", 
+				__FUNCTION__, start);
+			free(key);
+			free(buf);
+			rc = -1;
+			goto fail;
+		}
+		memcpy(buf + i * ramdisk->sector_size, sector, ramdisk->sector_size);
+		start++;
+	}
+
+	*mergedbuf = buf;
+	return 0;
+fail:
+	for (start--; i >0; i--, start--)
+		hashtable_remove(ramdisk->inprogress, &start);
+	return rc;
+}
+
+/* The underlying driver may not handle having the whole ramdisk queued at
+ * once. We queue what we can and let the callbacks attempt to queue more. */
+/* NOTE: may be called from callback, while dd->private still belongs to
+ * the underlying driver */
+static int ramdisk_flush(td_driver_t *driver, struct tdremus_state* s)
+{
+	uint64_t* sectors;
+	char* buf = NULL;
+	uint64_t base, batchlen;
+	int i, j, count = 0;
+
+	// RPRINTF("ramdisk flush\n");
+
+	if ((count = ramdisk_get_sectors(s->ramdisk.prev, &sectors)) <= 0)
+		return count;
+
+	/* Create the inprogress table if empty */
+	if (!s->ramdisk.inprogress)
+		s->ramdisk.inprogress = create_hashtable(RAMDISK_HASHSIZE,
+							uint64_hash,
+							rd_hash_equal);
+	
+	/*
+	  RPRINTF("ramdisk: flushing %d sectors\n", count);
+	*/
+
+	/* sort and merge sectors to improve disk performance */
+	qsort(sectors, count, sizeof(*sectors), uint64_compare);
+
+	for (i = 0; i < count;) {
+		base = sectors[i++];
+		while (i < count && sectors[i] == sectors[i-1] + 1)
+			i++;
+		batchlen = sectors[i-1] - base + 1;
+
+		j = merge_requests(&s->ramdisk, base, batchlen, &buf);
+			
+		if (j) {
+			RPRINTF("ramdisk_flush: merge_requests failed:%s\n",
+				j == -1? "OOM": (j==-2? "missing sector" : "WAW race"));
+			if (j == -3) continue;
+			free(sectors);
+			return -1;
+		}
+
+		/* NOTE: create_write_request() creates a treq AND forwards it down
+		 * the driver chain */
+		// RPRINTF("forwarding write request at %" PRIu64 ", length: %" PRIu64 "\n", base, batchlen);
+		create_write_request(s, base, batchlen, buf);
+		//RPRINTF("write request at %" PRIu64 ", length: %" PRIu64 " forwarded\n", base, batchlen);
+
+		s->ramdisk.inflight++;
+
+		for (j = 0; j < batchlen; j++) {
+			buf = hashtable_search(s->ramdisk.prev, &base);
+			free(buf);
+			hashtable_remove(s->ramdisk.prev, &base);
+			base++;
+		}
+	}
+
+	if (!hashtable_count(s->ramdisk.prev)) {
+		/* everything is in flight */
+		hashtable_destroy(s->ramdisk.prev, 0);
+		s->ramdisk.prev = NULL;
+	}
+
+	free(sectors);
+
+	// RPRINTF("ramdisk flush done\n");
+	return 0;
+}
+
+/* flush ramdisk contents to disk */
+static int ramdisk_start_flush(td_driver_t *driver)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+	uint64_t* key;
+	char* buf;
+	int rc = 0;
+	int i, j, count, batchlen;
+	uint64_t* sectors;
+
+	if (!hashtable_count(s->ramdisk.h)) {
+		/*
+		  RPRINTF("Nothing to flush\n");
+		*/
+		return 0;
+	}
+
+	if (s->ramdisk.prev) {
+		/* a flush request issued while a previous flush is still in progress
+		 * will merge with the previous request. If you want the previous
+		 * request to be consistent, wait for it to complete. */
+		if ((count = ramdisk_get_sectors(s->ramdisk.h, &sectors)) < 0)
+			return count;
+
+		for (i = 0; i < count; i++) {
+			buf = hashtable_search(s->ramdisk.h, sectors + i);
+			ramdisk_write_hash(s->ramdisk.prev, sectors[i], buf,
+					   s->ramdisk.sector_size);
+		}
+		free(sectors);
+
+		hashtable_destroy (s->ramdisk.h, 0);
+	} else
+		s->ramdisk.prev = s->ramdisk.h;
+
+	/* We create a new hashtable so that new writes can be performed before
+	 * the old hashtable is completely drained. */
+	s->ramdisk.h = create_hashtable(RAMDISK_HASHSIZE, uint64_hash,
+					rd_hash_equal);
+
+	return ramdisk_flush(driver, s);
+}
+
+
+static int ramdisk_start(td_driver_t *driver)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+
+	if (s->ramdisk.h) {
+		RPRINTF("ramdisk already allocated\n");
+		return 0;
+	}
+
+	s->ramdisk.sector_size = driver->info.sector_size;
+	s->ramdisk.h = create_hashtable(RAMDISK_HASHSIZE, uint64_hash,
+					rd_hash_equal);
+
+	DPRINTF("Ramdisk started, %zu bytes/sector\n", s->ramdisk.sector_size);
+
+	return 0;
+}
+
+/* common client/server functions */
+/* mayberead: Time out after a certain interval. */
+static int mread(int fd, void* buf, size_t len)
+{
+	fd_set rfds;
+	int rc;
+	size_t cur = 0;
+	struct timeval tv = {
+		.tv_sec = HEARTBEAT_MS / 1000,
+		.tv_usec = (HEARTBEAT_MS % 1000) * 1000
+	};
+
+	if (!len)
+		return 0;
+
+	/* read first. Only select if read is incomplete. */
+	rc = read(fd, buf, len);
+	while (rc < 0 || cur + rc < len) {
+		if (!rc) {
+			RPRINTF("end-of-file");
+			return -1;
+		}
+		if (rc < 0 && errno != EAGAIN) {
+			RPRINTF("error during read: %s\n", strerror(errno));
+			return -1;
+		}
+		if (rc > 0)
+			cur += rc;
+
+		FD_ZERO(&rfds);
+		FD_SET(fd, &rfds);
+		if (!(rc = select(fd + 1, &rfds, NULL, NULL, &tv))) {
+			RPRINTF("time out during read\n");
+			return -1;
+		} else if (rc < 0) {
+			RPRINTF("error during select: %d\n", errno);
+			return -1;
+		}
+		rc = read(fd, buf + cur, len - cur);
+	}
+	/*
+	  RPRINTF("read %d bytes\n", cur + rc);
+	*/
+
+	return 0;
+}
+
+static int mwrite(int fd, void* buf, size_t len)
+{
+	fd_set wfds;
+	size_t cur = 0;
+	int rc;
+	struct timeval tv = {
+		.tv_sec = HEARTBEAT_MS / 1000,
+		.tv_usec = (HEARTBEAT_MS % 1000) * 1000
+	};
+
+	if (!len)
+		return 0;
+
+	/* read first. Only select if read is incomplete. */
+	rc = write(fd, buf, len);
+	while (rc < 0 || cur + rc < len) {
+		if (!rc) {
+			RPRINTF("end-of-file");
+			return -1;
+		}
+		if (rc < 0 && errno != EAGAIN) {
+			RPRINTF("error during write: %s\n", strerror(errno));
+			return -1;
+		}
+		if (rc > 0)
+			cur += rc;
+
+		FD_ZERO(&wfds);
+		FD_SET(fd, &wfds);
+		if (!(rc = select(fd + 1, NULL, &wfds, NULL, &tv))) {
+			RPRINTF("time out during write\n");
+			return -1;
+		} else if (rc < 0) {
+			RPRINTF("error during select: %d\n", errno);
+			return -1;
+		}
+		rc = write(fd, buf + cur, len - cur);
+	}
+	/*
+	  RPRINTF("wrote %d bytes\n", cur + rc);
+	*/
+
+	return 0;
+	FD_ZERO(&wfds);
+	FD_SET(fd, &wfds);
+	select(fd + 1, NULL, &wfds, NULL, &tv);
+}
+
+
+static void inline close_stream_fd(struct tdremus_state *s)
+{
+	/* XXX: -2 is magic. replace with macro perhaps? */
+	tapdisk_server_unregister_event(s->stream_fd.id);
+	close(s->stream_fd.fd);
+	s->stream_fd.fd = -2;
+}
+
+/* primary functions */
+static void remus_client_event(event_id_t, char mode, void *private);
+static void remus_connect_event(event_id_t id, char mode, void *private);
+static void remus_retry_connect_event(event_id_t id, char mode, void *private);
+
+static int primary_do_connect(struct tdremus_state *state)
+{
+	event_id_t id;
+	int fd;
+	int rc;
+	int flags;
+
+	RPRINTF("client connecting to %s:%d...\n", inet_ntoa(state->sa.sin_addr), ntohs(state->sa.sin_port));
+
+	if ((fd = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
+		RPRINTF("could not create client socket: %d\n", errno);
+		return -1;
+	}
+
+	/* make socket nonblocking */
+	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
+		flags = 0;
+	if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1)
+		return -1;
+
+	/* once we have created the socket and populated the address, we can now start
+	 * our non-blocking connect. rather than duplicating code we trigger a timeout
+	 * on the socket fd, which calls out nonblocking connect code
+	 */
+	if((id = tapdisk_server_register_event(SCHEDULER_POLL_TIMEOUT, fd, 0, remus_retry_connect_event, state)) < 0) {
+		RPRINTF("error registering timeout client connection event handler: %s\n", strerror(id));
+		/* TODO: we leak a fd here */
+		return -1;
+	}
+	state->stream_fd.fd = fd;
+	state->stream_fd.id = id;
+	return 0;
+}
+
+static int primary_blocking_connect(struct tdremus_state *state)
+{
+	int fd;
+	int id;
+	int rc;
+	int flags;
+
+	RPRINTF("client connecting to %s:%d...\n", inet_ntoa(state->sa.sin_addr), ntohs(state->sa.sin_port));
+
+	if ((fd = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
+		RPRINTF("could not create client socket: %d\n", errno);
+		return -1;
+	}
+
+	do {
+		if ((rc = connect(fd, (struct sockaddr *)&state->sa,
+		    sizeof(state->sa))) < 0)
+		{
+			if (errno == ECONNREFUSED) {
+				RPRINTF("connection refused -- retrying in 1 second\n");
+				sleep(1);
+			} else {
+				RPRINTF("connection failed: %d\n", errno);
+				close(fd);
+				return -1;
+			}
+		}
+	} while (rc < 0);
+
+	RPRINTF("client connected\n");
+
+	/* make socket nonblocking */
+	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
+		flags = 0;
+	if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1)
+	{
+		RPRINTF("error making socket nonblocking\n");
+		close(fd);
+		return -1;
+	}
+
+	if((id = tapdisk_server_register_event(SCHEDULER_POLL_READ_FD, fd, 0, remus_client_event, state)) < 0) {
+		RPRINTF("error registering client event handler: %s\n", strerror(id));
+		close(fd);
+		return -1;
+	}
+
+	state->stream_fd.fd = fd;
+	state->stream_fd.id = id;
+	return 0;
+}
+
+/* on read, just pass request through */
+static void primary_queue_read(td_driver_t *driver, td_request_t treq)
+{
+	/* just pass read through */
+	td_forward_request(treq);
+}
+
+/* TODO:
+ * The primary uses mwrite() to write the contents of a write request to the
+ * backup. This effectively blocks until all data has been copied into a system
+ * buffer or a timeout has occured. We may wish to instead use tapdisk's
+ * nonblocking i/o interface, tapdisk_server_register_event(), to set timeouts
+ * and write data in an asynchronous fashion.
+ */
+static void primary_queue_write(td_driver_t *driver, td_request_t treq)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+
+	char header[sizeof(uint32_t) + sizeof(uint64_t)];
+	uint32_t *sectors = (uint32_t *)header;
+	uint64_t *sector = (uint64_t *)(header + sizeof(uint32_t));
+
+	// RPRINTF("write: stream_fd.fd: %d\n", s->stream_fd.fd);
+
+	/* -1 means we haven't connected yet, -2 means the connection was lost */
+	if(s->stream_fd.fd == -1) {
+		RPRINTF("connecting to backup...\n");
+		primary_blocking_connect(s);
+	}
+
+	*sectors = treq.secs;
+	*sector = treq.sec;
+
+	if (mwrite(s->stream_fd.fd, TDREMUS_WRITE, strlen(TDREMUS_WRITE)) < 0)
+		goto fail;
+	if (mwrite(s->stream_fd.fd, header, sizeof(header)) < 0)
+		goto fail;
+
+	if (mwrite(s->stream_fd.fd, treq.buf, treq.secs * driver->info.sector_size) < 0)
+		goto fail;
+
+	td_forward_request(treq);
+
+	return;
+
+ fail:
+	/* switch to unprotected mode and tell tapdisk to retry */
+	RPRINTF("write request replication failed, switching to unprotected mode");
+	switch_mode(s->tdremus_driver, mode_unprotected);
+	td_complete_request(treq, -EBUSY);
+}
+
+
+static int client_flush(td_driver_t *driver)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+
+	// RPRINTF("committing output\n");
+
+	if (s->stream_fd.fd == -1)
+		/* connection not yet established, nothing to flush */
+		return 0;
+
+	if (mwrite(s->stream_fd.fd, TDREMUS_COMMIT, strlen(TDREMUS_COMMIT)) < 0) {
+		RPRINTF("error flushing output");
+		close_stream_fd(s);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int server_flush(td_driver_t *driver)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+	/* 
+	 * Nothing to flush in beginning.
+	 */
+	if (!s->ramdisk.prev)
+		return 0;
+	/* Try to flush any remaining requests */
+	return ramdisk_flush(driver, s);	
+}
+
+static int primary_start(td_driver_t *driver)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+
+	RPRINTF("activating client mode\n");
+
+	tapdisk_remus.td_queue_read = primary_queue_read;
+	tapdisk_remus.td_queue_write = primary_queue_write;
+	s->queue_flush = client_flush;
+
+	s->stream_fd.fd = -1;
+	s->stream_fd.id = -1;
+
+	return 0;
+}
+
+/* timeout callback */
+static void remus_retry_connect_event(event_id_t id, char mode, void *private)
+{
+	struct tdremus_state *s = (struct tdremus_state *)private;
+
+	/* do a non-blocking connect */
+	if (connect(s->stream_fd.fd, (struct sockaddr *)&s->sa, sizeof(s->sa))
+	    && errno != EINPROGRESS)
+	{
+		if(errno == ECONNREFUSED || errno == ENETUNREACH || errno == EAGAIN || errno == ECONNABORTED)
+		{
+			/* try again in a second */
+			tapdisk_server_unregister_event(s->stream_fd.id);
+			if((id = tapdisk_server_register_event(SCHEDULER_POLL_TIMEOUT, s->stream_fd.fd, REMUS_CONNRETRY_TIMEOUT, remus_retry_connect_event, s)) < 0) {
+				RPRINTF("error registering timeout client connection event handler: %s\n", strerror(id));
+				return;
+			}
+			s->stream_fd.id = id;
+		}
+		else
+		{
+			/* not recoverable */
+			RPRINTF("error connection to server %s\n", strerror(errno));
+			return;
+		}
+	}
+	else
+	{
+		/* the connect returned EINPROGRESS (nonblocking connect) we must wait for the fd to be writeable to determine if the connect worked */
+
+		tapdisk_server_unregister_event(s->stream_fd.id);
+		if((id = tapdisk_server_register_event(SCHEDULER_POLL_WRITE_FD, s->stream_fd.fd, 0, remus_connect_event, s)) < 0) {
+			RPRINTF("error registering client connection event handler: %s\n", strerror(id));
+			return;
+		}
+		s->stream_fd.id = id;
+	}
+}
+
+/* callback when nonblocking connect() is finished */
+/* called only by primary in unprotected state */
+static void remus_connect_event(event_id_t id, char mode, void *private)
+{
+	int socket_errno;
+	socklen_t socket_errno_size;
+	struct tdremus_state *s = (struct tdremus_state *)private;
+
+	/* check to se if the connect succeeded */
+	socket_errno_size = sizeof(socket_errno);
+	if (getsockopt(s->stream_fd.fd, SOL_SOCKET, SO_ERROR, &socket_errno, &socket_errno_size)) {
+		RPRINTF("error getting socket errno\n");
+		return;
+	}
+
+	RPRINTF("socket connect returned %d\n", socket_errno);
+
+	if(socket_errno)
+	{
+		/* the connect did not succeed */
+
+		if(socket_errno == ECONNREFUSED || socket_errno == ENETUNREACH || socket_errno == ETIMEDOUT
+		   || socket_errno == ECONNABORTED || socket_errno == EAGAIN)
+		{
+			/* we can probably assume that the backup is down. just try again later */
+			tapdisk_server_unregister_event(s->stream_fd.id);
+			if((id = tapdisk_server_register_event(SCHEDULER_POLL_TIMEOUT, s->stream_fd.fd, REMUS_CONNRETRY_TIMEOUT, remus_retry_connect_event, s)) < 0) {
+				RPRINTF("error registering timeout client connection event handler: %s\n", strerror(id));
+				return;
+			}
+			s->stream_fd.id = id;
+		}
+		else
+		{
+			RPRINTF("socket connect returned %d, giving up\n", socket_errno);
+		}
+	}
+	else
+	{
+		/* the connect succeeded */
+
+		/* unregister this function and register a new event handler */
+		tapdisk_server_unregister_event(s->stream_fd.id);
+		if((id = tapdisk_server_register_event(SCHEDULER_POLL_READ_FD, s->stream_fd.fd, 0, remus_client_event, s)) < 0) {
+			RPRINTF("error registering client event handler: %s\n", strerror(id));
+			return;
+		}
+		s->stream_fd.id = id;
+
+		/* switch from unprotected to protected client */
+		switch_mode(s->tdremus_driver, mode_primary);
+	}
+}
+
+
+/* we install this event handler on the primary once we have connected to the backup */
+/* wait for "done" message to commit checkpoint */
+static void remus_client_event(event_id_t id, char mode, void *private)
+{
+	struct tdremus_state *s = (struct tdremus_state *)private;
+	char req[5];
+	int rc;
+
+	if (mread(s->stream_fd.fd, req, sizeof(req) - 1) < 0) {
+		/* replication stream closed or otherwise broken (timeout, reset, &c) */
+		RPRINTF("error reading from backup\n");
+		close_stream_fd(s);
+		return;
+	}
+
+	req[4] = '\0';
+
+	if (!strcmp(req, TDREMUS_DONE))
+		/* checkpoint committed, inform msg_fd */
+		ctl_respond(s, TDREMUS_DONE);
+	else {
+		RPRINTF("received unknown message: %s\n", req);
+		close_stream_fd(s);
+	}
+
+	return;
+}
+
+/* backup functions */
+static void remus_server_event(event_id_t id, char mode, void *private);
+
+/* returns the socket that receives write requests */
+static void remus_server_accept(event_id_t id, char mode, void* private)
+{
+	struct tdremus_state* s = (struct tdremus_state *) private;
+
+	int stream_fd;
+	event_id_t cid;
+
+	/* XXX: add address-based black/white list */
+	if ((stream_fd = accept(s->server_fd.fd, NULL, NULL)) < 0) {
+		RPRINTF("error accepting connection: %d\n", errno);
+		return;
+	}
+
+	/* TODO: check to see if we are already replicating. if so just close the
+	 * connection (or do something smarter) */
+	RPRINTF("server accepted connection\n");
+
+	/* add tapdisk event for replication stream */
+	cid = tapdisk_server_register_event(SCHEDULER_POLL_READ_FD, stream_fd, 0,
+					    remus_server_event, s);
+
+	if(cid < 0) {
+		RPRINTF("error registering connection event handler: %s\n", strerror(errno));
+		close(stream_fd);
+		return;
+	}
+
+	/* store replication file descriptor */
+	s->stream_fd.fd = stream_fd;
+	s->stream_fd.id = cid;
+}
+
+/* returns -2 if EADDRNOTAVAIL */
+static int remus_bind(struct tdremus_state* s)
+{
+//  struct sockaddr_in sa;
+	int opt;
+	int rc = -1;
+
+	if ((s->server_fd.fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+		RPRINTF("could not create server socket: %d\n", errno);
+		return rc;
+	}
+	opt = 1;
+	if (setsockopt(s->server_fd.fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0)
+		RPRINTF("Error setting REUSEADDR on %d: %d\n", s->server_fd.fd, errno);
+
+	if (bind(s->server_fd.fd, (struct sockaddr *)&s->sa, sizeof(s->sa)) < 0) {
+		RPRINTF("could not bind server socket %d to %s:%d: %d %s\n", s->server_fd.fd,
+			inet_ntoa(s->sa.sin_addr), ntohs(s->sa.sin_port), errno, strerror(errno));
+		if (errno != EADDRINUSE)
+			rc = -2;
+		goto err_sfd;
+	}
+	if (listen(s->server_fd.fd, 10)) {
+		RPRINTF("could not listen on socket: %d\n", errno);
+		goto err_sfd;
+	}
+
+	/* The socket s now bound to the address and listening so we may now register
+   * the fd with tapdisk */
+
+	if((s->server_fd.id = tapdisk_server_register_event(SCHEDULER_POLL_READ_FD,
+							    s->server_fd.fd, 0,
+							    remus_server_accept, s)) < 0) {
+		RPRINTF("error registering server connection event handler: %s",
+			strerror(s->server_fd.id));
+		goto err_sfd;
+	}
+
+	return 0;
+
+ err_sfd:
+	close(s->server_fd.fd);
+	s->server_fd.fd = -1;
+
+	return rc;
+}
+
+/* wait for latest checkpoint to be applied */
+static inline int server_writes_inflight(td_driver_t *driver)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+
+	if (!s->ramdisk.inflight && !s->ramdisk.prev)
+		return 0;
+
+	return 1;
+}
+
+/* Due to block device prefetching this code may be called on the server side
+ * during normal replication. In this case we must return EBUSY, otherwise the
+ * domain may be started with stale data.
+ */
+void backup_queue_read(td_driver_t *driver, td_request_t treq)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+	int i;
+	if(!remus_image)
+		remus_image = treq.image;
+	
+	/* check if this read is queued in any currently ongoing flush */
+	if (ramdisk_read(&s->ramdisk, treq.sec, treq.secs, treq.buf)) {
+		/* TODO: Add to pending read hash */
+		td_forward_request(treq);
+	} else {
+		/* complete the request */
+		td_complete_request(treq, 0);
+	}
+}
+
+/* see above */
+void backup_queue_write(td_driver_t *driver, td_request_t treq)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+
+	/* on a server write, we know the domain has failed over. we must change our
+	 * state to unprotected and then have the unprotected queue_write function
+	 * handle the write
+	 */
+
+	switch_mode(driver, mode_unprotected);
+	/* TODO: call the appropriate write function rather than return EBUSY */
+	td_complete_request(treq, -EBUSY);
+}
+
+static int backup_start(td_driver_t *driver)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+	int fd;
+
+	if (ramdisk_start(driver) < 0)
+		return -1;
+
+	tapdisk_remus.td_queue_read = backup_queue_read;
+	tapdisk_remus.td_queue_write = backup_queue_write;
+	s->queue_flush = server_flush;
+	/* TODO set flush function */
+	return 0;
+}
+
+static int server_do_wreq(td_driver_t *driver)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+	static tdremus_wire_t twreq;
+	char buf[4096];
+	int len, rc;
+
+	char header[sizeof(uint32_t) + sizeof(uint64_t)];
+	uint32_t *sectors = (uint32_t *) header;
+	uint64_t *sector =  (uint64_t *) &header[sizeof(uint32_t)];
+
+	// RPRINTF("received write request\n");
+
+	if (mread(s->stream_fd.fd, header, sizeof(header)) < 0)
+		goto err;
+
+	len = *sectors * driver->info.sector_size;
+
+	//RPRINTF("writing %d sectors (%d bytes) starting at %" PRIu64 "\n", *sectors, len,
+	// *sector);
+
+	if (len > sizeof(buf)) {
+		/* freak out! */
+		RPRINTF("write request too large: %d/%u\n", len, (unsigned)sizeof(buf));
+		return -1;
+	}
+
+	if (mread(s->stream_fd.fd, buf, len) < 0)
+		goto err;
+
+	if (ramdisk_write(&s->ramdisk, *sector, *sectors, buf) < 0)
+		goto err;
+
+	return 0;
+
+ err:
+	/* should start failover */
+	RPRINTF("backup write request error\n");
+	close_stream_fd(s);
+
+	return -1;
+}
+
+static int server_do_sreq(td_driver_t *driver)
+{
+	/*
+	  RPRINTF("submit request received\n");
+  */
+
+	return 0;
+}
+
+/* at this point, the server can start applying the most recent
+ * ramdisk. */
+static int server_do_creq(td_driver_t *driver)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+
+	// RPRINTF("committing buffer\n");
+
+	ramdisk_start_flush(driver);
+
+	/* XXX this message should not be sent until flush completes! */
+	if (write(s->stream_fd.fd, TDREMUS_DONE, strlen(TDREMUS_DONE)) != 4)
+		return -1;
+
+	return 0;
+}
+
+
+/* called when data is pending in s->rfd */
+static void remus_server_event(event_id_t id, char mode, void *private)
+{
+	struct tdremus_state *s = (struct tdremus_state *)private;
+	td_driver_t *driver = s->tdremus_driver;
+	char req[5];
+
+	// RPRINTF("replication data waiting\n");
+
+	/* TODO: add a get_connection_by_event_id() function.
+	 * for now we can assume that the fd is s->stream_fd */
+
+	if (mread(s->stream_fd.fd, req, sizeof(req) - 1) < 0) {
+		RPRINTF("error reading server event, activating backup\n");
+		switch_mode(driver, mode_unprotected);
+		return;
+	}
+
+	req[4] = '\0';
+
+	if (!strcmp(req, TDREMUS_WRITE))
+		server_do_wreq(driver);
+	else if (!strcmp(req, TDREMUS_SUBMIT))
+		server_do_sreq(driver);
+	else if (!strcmp(req, TDREMUS_COMMIT))
+		server_do_creq(driver);
+	else
+		RPRINTF("unknown request received: %s\n", req);
+
+	return;
+
+}
+
+/* unprotected */
+
+void unprotected_queue_read(td_driver_t *driver, td_request_t treq)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+
+	/* wait for previous ramdisk to flush  before servicing reads */
+	if (server_writes_inflight(driver)) {
+		/* for now lets just return EBUSY.
+		 * if there are any left-over requests in prev,
+		 * kick em again.
+		 */
+		if(!s->ramdisk.inflight) /* nothing in inprogress */
+			ramdisk_flush(driver, s);
+
+		td_complete_request(treq, -EBUSY);
+	}
+	else {
+		/* here we just pass reads through */
+		td_forward_request(treq);
+	}
+}
+
+/* For a recoverable remus solution we need to log unprotected writes here */
+void unprotected_queue_write(td_driver_t *driver, td_request_t treq)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+
+	/* wait for previous ramdisk to flush */
+	if (server_writes_inflight(driver)) {
+		RPRINTF("queue_write: waiting for queue to drain");
+		if(!s->ramdisk.inflight) /* nothing in inprogress. Kick prev */
+			ramdisk_flush(driver, s);
+		td_complete_request(treq, -EBUSY);
+	}
+	else {
+		// RPRINTF("servicing write request on backup\n");
+		/* NOTE: DRBD style bitmap tracking could go here */
+		td_forward_request(treq);
+	}
+}
+
+static int unprotected_start(td_driver_t *driver)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+
+	RPRINTF("failure detected, activating passthrough\n");
+
+	/* close the server socket */
+	close_stream_fd(s);
+
+	/* unregister the replication stream */
+	tapdisk_server_unregister_event(s->server_fd.id);
+
+	/* close the replication stream */
+	close(s->server_fd.fd);
+	s->server_fd.fd = -1;
+
+	/* install the unprotected read/write handlers */
+	tapdisk_remus.td_queue_read = unprotected_queue_read;
+	tapdisk_remus.td_queue_write = unprotected_queue_write;
+
+	return 0;
+}
+
+
+/* control */
+
+static inline int resolve_address(const char* addr, struct in_addr* ia)
+{
+	struct hostent* he;
+	uint32_t ip;
+
+	if (!(he = gethostbyname(addr))) {
+		RPRINTF("error resolving %s: %d\n", addr, h_errno);
+		return -1;
+	}
+
+	if (!he->h_addr_list[0]) {
+		RPRINTF("no address found for %s\n", addr);
+		return -1;
+	}
+
+	/* network byte order */
+	ip = *((uint32_t**)he->h_addr_list)[0];
+	ia->s_addr = ip;
+
+	return 0;
+}
+
+static int get_args(td_driver_t *driver, const char* name)
+{
+	struct tdremus_state *state = (struct tdremus_state *)driver->data;
+	char* host;
+	char* port;
+//  char* driver_str;
+//  char* parent;
+//  int type;
+//  char* path;
+//  unsigned long ulport;
+//  int i;
+//  struct sockaddr_in server_addr_in;
+
+	int gai_status;
+	int valid_addr;
+	struct addrinfo gai_hints;
+	struct addrinfo *servinfo, *servinfo_itr;
+
+	memset(&gai_hints, 0, sizeof gai_hints);
+	gai_hints.ai_family = AF_UNSPEC;
+	gai_hints.ai_socktype = SOCK_STREAM;
+
+	port = strchr(name, ':');
+	if (!port) {
+		RPRINTF("missing host in %s\n", name);
+		return -ENOENT;
+	}
+	if (!(host = strndup(name, port - name))) {
+		RPRINTF("unable to allocate host\n");
+		return -ENOMEM;
+	}
+	port++;
+
+	if ((gai_status = getaddrinfo(host, port, &gai_hints, &servinfo)) != 0) {
+		RPRINTF("getaddrinfo error: %s\n", gai_strerror(gai_status));
+		return -ENOENT;
+	}
+
+	/* TODO: do something smarter here */
+	valid_addr = 0;
+	for(servinfo_itr = servinfo; servinfo_itr != NULL; servinfo_itr = servinfo_itr->ai_next) {
+		void *addr;
+		char *ipver;
+
+		if (servinfo_itr->ai_family == AF_INET) {
+			valid_addr = 1;
+			memset(&state->sa, 0, sizeof(state->sa));
+			state->sa = *(struct sockaddr_in *)servinfo_itr->ai_addr;
+			break;
+		}
+	}
+	freeaddrinfo(servinfo);
+
+	if (!valid_addr)
+		return -ENOENT;
+
+	RPRINTF("host: %s, port: %d\n", inet_ntoa(state->sa.sin_addr), ntohs(state->sa.sin_port));
+
+	return 0;
+}
+
+static int switch_mode(td_driver_t *driver, enum tdremus_mode mode)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+	int rc;
+
+	if (mode == s->mode)
+		return 0;
+
+	if (s->queue_flush)
+		if ((rc = s->queue_flush(driver)) < 0) {
+			// fall back to unprotected mode on error
+			RPRINTF("switch_mode: error flushing queue (old: %d, new: %d)", s->mode, mode);
+			mode = mode_unprotected;
+		}
+
+	if (mode == mode_unprotected)
+		rc = unprotected_start(driver);
+	else if (mode == mode_primary)
+		rc = primary_start(driver);
+	else if (mode == mode_backup)
+		rc = backup_start(driver);
+	else {
+		RPRINTF("unknown mode requested: %d\n", mode);
+		rc = -1;
+	}
+
+	if (!rc)
+		s->mode = mode;
+
+	return rc;
+}
+
+static void ctl_request(event_id_t id, char mode, void *private)
+{
+	struct tdremus_state *s = (struct tdremus_state *)private;
+	td_driver_t *driver = s->tdremus_driver;
+	char msg[80];
+	int rc;
+
+	// RPRINTF("data waiting on control fifo\n");
+
+	if (!(rc = read(s->ctl_fd.fd, msg, sizeof(msg) - 1 /* append nul */))) {
+		RPRINTF("0-byte read received, reopening FIFO\n");
+		/*TODO: we may have to unregister/re-register with tapdisk_server */
+		close(s->ctl_fd.fd);
+		RPRINTF("FIFO closed\n");
+		if ((s->ctl_fd.fd = open(s->ctl_path, O_RDWR)) < 0) {
+			RPRINTF("error reopening FIFO: %d\n", errno);
+		}
+		return;
+	}
+
+	if (rc < 0) {
+		RPRINTF("error reading from FIFO: %d\n", errno);
+		return;
+	}
+
+	/* TODO: need to get driver somehow */
+	msg[rc] = '\0';
+	if (!strncmp(msg, "flush", 5)) {
+		if (s->queue_flush)
+			if ((rc = s->queue_flush(driver))) {
+				RPRINTF("error passing flush request to backup");
+				ctl_respond(s, TDREMUS_FAIL);
+			}
+	} else {
+		RPRINTF("unknown command: %s\n", msg);
+	}
+}
+
+static int ctl_respond(struct tdremus_state *s, const char *response)
+{
+	int rc;
+
+	if ((rc = write(s->msg_fd.fd, response, strlen(response))) < 0) {
+		RPRINTF("error writing notification: %d\n", errno);
+		close(s->msg_fd.fd);
+		if ((s->msg_fd.fd = open(s->msg_path, O_RDWR)) < 0)
+			RPRINTF("error reopening FIFO: %d\n", errno);
+	}
+
+	return rc;
+}
+
+/* must be called after the underlying driver has been initialized */
+static int ctl_open(td_driver_t *driver, const char* name)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+	int i, l;
+
+	/* first we must ensure that BLKTAP_CTRL_DIR exists */
+	if (mkdir(BLKTAP_CTRL_DIR, 0755) && errno != EEXIST)
+	{
+		DPRINTF("error creating directory %s: %d\n", BLKTAP_CTRL_DIR, errno);
+		return -1;
+	}
+
+	/* use the device name to create the control fifo path */
+	if (asprintf(&s->ctl_path, BLKTAP_CTRL_DIR "/remus_%s", name) < 0)
+		return -1;
+	/* scrub fifo pathname  */
+	for (i = strlen(BLKTAP_CTRL_DIR) + 1, l = strlen(s->ctl_path); i < l; i++) {
+		if (strchr(":/", s->ctl_path[i]))
+			s->ctl_path[i] = '_';
+	}
+	if (asprintf(&s->msg_path, "%s.msg", s->ctl_path) < 0)
+		goto err_ctlfifo;
+
+	if (mkfifo(s->ctl_path, S_IRWXU|S_IRWXG|S_IRWXO) && errno != EEXIST) {
+		RPRINTF("error creating control FIFO %s: %d\n", s->ctl_path, errno);
+		goto err_msgfifo;
+	}
+
+	if (mkfifo(s->msg_path, S_IRWXU|S_IRWXG|S_IRWXO) && errno != EEXIST) {
+		RPRINTF("error creating message FIFO %s: %d\n", s->msg_path, errno);
+		goto err_msgfifo;
+	}
+
+	/* RDWR so that fd doesn't block select when no writer is present */
+	if ((s->ctl_fd.fd = open(s->ctl_path, O_RDWR)) < 0) {
+		RPRINTF("error opening control FIFO %s: %d\n", s->ctl_path, errno);
+		goto err_msgfifo;
+	}
+
+	if ((s->msg_fd.fd = open(s->msg_path, O_RDWR)) < 0) {
+		RPRINTF("error opening message FIFO %s: %d\n", s->msg_path, errno);
+		goto err_openctlfifo;
+	}
+
+	RPRINTF("control FIFO %s\n", s->ctl_path);
+	RPRINTF("message FIFO %s\n", s->msg_path);
+
+	return 0;
+
+ err_openctlfifo:
+	close(s->ctl_fd.fd);
+ err_msgfifo:
+	free(s->msg_path);
+	s->msg_path = NULL;
+ err_ctlfifo:
+	free(s->ctl_path);
+	s->ctl_path = NULL;
+	return -1;
+}
+
+static void ctl_close(td_driver_t *driver)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+
+	/* TODO: close *all* connections */
+
+	if(s->ctl_fd.fd)
+		close(s->ctl_fd.fd);
+
+	if (s->ctl_path) {
+		unlink(s->ctl_path);
+		free(s->ctl_path);
+		s->ctl_path = NULL;
+	}
+	if (s->msg_path) {
+		unlink(s->msg_path);
+		free(s->msg_path);
+		s->msg_path = NULL;
+	}
+}
+
+static int ctl_register(struct tdremus_state *s)
+{
+	RPRINTF("registering ctl fifo\n");
+
+	/* register ctl fd */
+	s->ctl_fd.id = tapdisk_server_register_event(SCHEDULER_POLL_READ_FD, s->ctl_fd.fd, 0, ctl_request, s);
+
+	if (s->ctl_fd.id < 0) {
+		RPRINTF("error registering ctrl FIFO %s: %d\n", s->ctl_path, s->ctl_fd.id);
+		return -1;
+	}
+
+	return 0;
+}
+
+/* interface */
+
+static int tdremus_open(td_driver_t *driver, const char *name,
+			td_flag_t flags)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+	int rc;
+
+	RPRINTF("opening %s\n", name);
+
+	/* first we need to get the underlying vbd for this driver stack. To do so we
+	 * need to know the vbd's id. Fortunately, for tapdisk2 this is hard-coded as
+	 * 0 (see tapdisk2.c)
+	 */
+	device_vbd = tapdisk_server_get_vbd(0);
+
+	memset(s, 0, sizeof(*s));
+	s->server_fd.fd = -1;
+	s->stream_fd.fd = -1;
+	s->ctl_fd.fd = -1;
+	s->msg_fd.fd = -1;
+
+	/* TODO: this is only needed so that the server can send writes down
+	 * the driver stack from the stream_fd event handler */
+	s->tdremus_driver = driver;
+
+	/* parse name to get info etc */
+	if ((rc = get_args(driver, name)))
+		return rc;
+
+	if ((rc = ctl_open(driver, name))) {
+		RPRINTF("error setting up control channel\n");
+		free(s->driver_data);
+		return rc;
+	}
+
+	if ((rc = ctl_register(s))) {
+		RPRINTF("error registering control channel\n");
+		free(s->driver_data);
+		return rc;
+	}
+
+	if (!(rc = remus_bind(s)))
+		rc = switch_mode(driver, mode_backup);
+	else if (rc == -2)
+		rc = switch_mode(driver, mode_primary);
+
+	if (!rc)
+		return 0;
+
+	tdremus_close(driver);
+	return -EIO;
+}
+
+static int tdremus_close(td_driver_t *driver)
+{
+	struct tdremus_state *s = (struct tdremus_state *)driver->data;
+
+	RPRINTF("closing\n");
+	if (s->ramdisk.inprogress)
+		hashtable_destroy(s->ramdisk.inprogress, 0);
+	
+	if (s->driver_data) {
+		free(s->driver_data);
+		s->driver_data = NULL;
+	}
+	if (s->server_fd.fd >= 0) {
+		close(s->server_fd.fd);
+		s->server_fd.fd = -1;
+	}
+	if (s->stream_fd.fd >= 0)
+		close_stream_fd(s);
+
+	ctl_close(driver);
+
+	return 0;
+}
+
+static int tdremus_get_parent_id(td_driver_t *driver, td_disk_id_t *id)
+{
+	/* we shouldn't have a parent... for now */
+	return -EINVAL;
+}
+
+static int tdremus_validate_parent(td_driver_t *driver,
+				   td_driver_t *pdriver, td_flag_t flags)
+{
+	return 0;
+}
+
+struct tap_disk tapdisk_remus = {
+	.disk_type          = "tapdisk_remus",
+	.private_data_size  = sizeof(struct tdremus_state),
+	.td_open            = tdremus_open,
+	.td_queue_read      = unprotected_queue_read,
+	.td_queue_write     = unprotected_queue_write,
+	.td_close           = tdremus_close,
+	.td_get_parent_id   = tdremus_get_parent_id,
+	.td_validate_parent = tdremus_validate_parent,
+	.td_debug           = NULL,
+};
diff -Nur blktap2_oxt//drivers/block-vhd.c blktap2_xen//drivers/block-vhd.c
--- blktap2_oxt//drivers/block-vhd.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/block-vhd.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,8 +1,5 @@
-/*
- *
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* 
+ * Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -27,10 +24,6 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * block-vhd.c: asynchronous vhd implementation.
  *
  * A note on write transactions:
  * Writes that require updating the BAT or bitmaps cannot be signaled
@@ -57,20 +50,15 @@
 #include <unistd.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
-#include <uuid/uuid.h> /* For whatever reason, Linux packages this in */
-                       /* e2fsprogs-devel.                            */
 #include <string.h>    /* for memset.                                 */
 #include <libaio.h>
 #include <sys/mman.h>
-#include <sys/syscall.h>
 
 #include "libvhd.h"
 #include "tapdisk.h"
 #include "tapdisk-driver.h"
 #include "tapdisk-interface.h"
 #include "tapdisk-disktype.h"
-#include "tapdisk-storage.h"
-#include "block-crypto.h"
 
 unsigned int SPB;
 
@@ -96,7 +84,8 @@
 			__FILE__, __LINE__, #_p);			\
 		DBG(TLOG_WARN, "%s:%d: FAILED ASSERTION: '%s'\n",	\
 		    __FILE__, __LINE__, #_p);				\
-		td_panic();						\
+		tlog_flush();						\
+		*(int*)0 = 0;						\
 	}
 
 #if (DEBUGGING == 1)
@@ -132,7 +121,6 @@
 #define VHD_OP_BITMAP_READ           3
 #define VHD_OP_BITMAP_WRITE          4
 #define VHD_OP_ZERO_BM_WRITE         5
-#define VHD_OP_REDUNDANT_BM_WRITE    6
 
 #define VHD_BM_BAT_LOCKED            0
 #define VHD_BM_BAT_CLEAR             1
@@ -188,7 +176,6 @@
 	uint8_t                   op;
 	vhd_flag_t                flags;
 	td_request_t              treq;
-	char                     *orig_buf;
 	struct tiocb              tiocb;
 	struct vhd_state         *state;
 	struct vhd_request       *next;
@@ -235,7 +222,6 @@
 	vhd_context_t             vhd;
 	u32                       spp;         /* sectors per page */
         u32                       spb;         /* sectors per block */
-	u64                       first_db;    /* pointer to datablock 0 */
         u64                       next_db;     /* pointer to the next 
 						* (unallocated) datablock */
 
@@ -253,12 +239,6 @@
 	struct vhd_request       *vreq_free[VHD_REQS_DATA];
 	struct vhd_request        vreq_list[VHD_REQS_DATA];
 
-	/* for redundant bitmap writes */
-	int                       padbm_size;
-	char                     *padbm_buf;
-	long int                  debug_skipped_redundant_writes;
-	long int                  debug_done_redundant_writes;
-
 	td_driver_t              *driver;
 
 	uint64_t                  queued;
@@ -294,7 +274,7 @@
 		_vhd_zsize += VHD_BLOCK_SIZE;
 
 	_vhd_zeros = mmap(0, _vhd_zsize, PROT_READ,
-			  MAP_SHARED | MAP_ANONYMOUS, -1, 0);
+			  MAP_SHARED | MAP_ANON, -1, 0);
 	if (_vhd_zeros == MAP_FAILED) {
 		EPRINTF("vhd_initialize failed: %d\n", -errno);
 		_vhd_zeros = NULL;
@@ -353,7 +333,7 @@
 vhd_kill_footer(struct vhd_state *s)
 {
 	int err;
-	off64_t end;
+	off_t end;
 	char *zeros;
 
 	if (s->vhd.footer.type == HD_TYPE_FIXED)
@@ -366,10 +346,10 @@
 	err = 1;
 	memset(zeros, 0xc7c7c7c7, 512);
 
-	if ((end = lseek64(s->vhd.fd, 0, SEEK_END)) == -1)
+	if ((end = lseek(s->vhd.fd, 0, SEEK_END)) == -1)
 		goto fail;
 
-	if (lseek64(s->vhd.fd, (end - 512), SEEK_SET) == -1)
+	if (lseek(s->vhd.fd, (end - 512), SEEK_SET) == -1)
 		goto fail;
 
 	if (write(s->vhd.fd, zeros, 512) != 512)
@@ -384,61 +364,11 @@
 	return 0;
 }
 
-static int
-vhd_fix_batmap(struct vhd_state *s)
-{
-	int err;
-	uint32_t cksm;
-
-	err = vhd_read_batmap_header(&s->vhd, &s->vhd.batmap);
-	if (err) {
-		EPRINTF("%s: failed to read batmap header: %d\n",
-			s->vhd.file, err);
-		goto out;
-	}
-
-	err = vhd_read_batmap_map(&s->vhd, &s->vhd.batmap);
-	if (err) {
-		EPRINTF("%s: failed to read batmap map: %d\n",
-			s->vhd.file, err);
-		goto out;
-	}
-
-	cksm = vhd_checksum_batmap(&s->vhd, &s->vhd.batmap);
-	if (cksm == s->vhd.batmap.header.checksum) {
-		EPRINTF("%s: attempting to reset valid batmap\n", s->vhd.file);
-		err = -EINVAL;
-		goto out;
-	}
-
-	EPRINTF("%s: attempting to reset invalid batmap: "
-		"cksum 0x%x doesn't match header cksum 0x%x\n",
-		s->vhd.file, cksm, s->vhd.batmap.header.checksum);
-
-	/* temporarily disabled for diagnostic purposes */
-	EPRINTF("automatic batmap fixup disabled\n");
-	err = -ENOSYS;
-	goto out;
-
-	vhd_batmap_reset_map(&s->vhd, &s->vhd.batmap);
-
-	err = vhd_write_batmap(&s->vhd, &s->vhd.batmap);
-	if (err) {
-		EPRINTF("%s: failed to reset batmap: %d\n", s->vhd.file, err);
-		goto out;
-	}
-
-out:
-	free(s->vhd.batmap.map);
-	memset(&s->vhd.batmap, 0, sizeof(s->vhd.batmap));
-	return err;
-}
-
 static inline int
 find_next_free_block(struct vhd_state *s)
 {
 	int err;
-	off64_t eom;
+	off_t eom;
 	uint32_t i, entry;
 
 	err = vhd_end_of_headers(&s->vhd, &eom);
@@ -446,9 +376,6 @@
 		return err;
 
 	s->next_db = secs_round_up(eom);
-	s->first_db = s->next_db;
-	if ((s->first_db + s->bm_secs) % s->spp)
-		s->first_db += (s->spp - ((s->first_db + s->bm_secs) % s->spp));
 
 	for (i = 0; i < s->bat.bat.entries; i++) {
 		entry = bat_entry(s, i);
@@ -471,7 +398,7 @@
 static int
 vhd_initialize_bat(struct vhd_state *s)
 {
-	int err, psize, i;
+	int err, psize, batmap_required, i;
 
 	memset(&s->bat, 0, sizeof(struct vhd_bat));
 
@@ -483,48 +410,30 @@
 		return err;
 	}
 
-	if (!test_vhd_flag(s->flags, VHD_FLAG_OPEN_RDONLY)) {
+	batmap_required = 1;
+	if (test_vhd_flag(s->flags, VHD_FLAG_OPEN_RDONLY)) {
+		batmap_required = 0;
+	} else {
 		err = find_next_free_block(s);
 		if (err)
 			goto fail;
 	}
 
 	if (vhd_has_batmap(&s->vhd)) {
-		/*
-		 * if this vhd is read-only, its batmap could be temporarily
-		 * inconsistent due to a background coalesce task, so we retry
-		 * a few times if the initial read fails.
-		 */
 		for (i = 0; i < VHD_BATMAP_MAX_RETRIES; i++) {
 			err = vhd_read_batmap(&s->vhd, &s->bat.batmap);
-			if (!err)
-				break;
-
-			EPRINTF("%s: reading batmap: %d\n", s->vhd.file, err);
-
-			/*
-			 * EINVAL here probably means checksum mismatch.
-			 * if this is a writeable vhd and we have exclusive
-			 * access to it, we'll try to reset the batmap.
-			 */
-			if (err == -EINVAL &&
-			    /*
-			     * vhd_fix_batmap() is temporarily disabled, so
-			     * we'll fail early here to make the error obvious
-			     */
-			    /* test_vhd_flag(s->flags, VHD_FLAG_OPEN_STRICT) && */
-			    !test_vhd_flag(s->flags, VHD_FLAG_OPEN_RDONLY))
-				if (vhd_fix_batmap(s))
+			if (err) {
+				EPRINTF("%s: reading batmap: %d\n",
+						s->vhd.file, err);
+				if (batmap_required)
 					goto fail;
+			} else {
+				break;
+			}
 		}
-
-		/*
-		 * we couldn't read or fix the batmap, but we can still
-		 * carry on without it.
-		 */
 		if (err)
 			EPRINTF("%s: ignoring non-critical batmap error\n",
-				s->vhd.file);
+					s->vhd.file);
 	}
 
 	err = posix_memalign((void **)&s->bat.bat_buf,
@@ -599,7 +508,6 @@
 static int
 vhd_initialize_dynamic_disk(struct vhd_state *s)
 {
-	u32 bm_size;
 	int err;
 
 	err = vhd_get_header(&s->vhd);
@@ -619,19 +527,6 @@
 	s->spb     = s->vhd.header.block_size >> VHD_SECTOR_SHIFT;
 	s->bm_secs = secs_round_up_no_zero(s->spb >> 3);
 
-	s->padbm_size = (s->bm_secs / getpagesize()) * getpagesize();
-	if (s->bm_secs % getpagesize())
-		s->padbm_size += getpagesize();
-
-	err = posix_memalign((void **)&s->padbm_buf, 512, s->padbm_size);
-	if (err)
-		return -err;
-	bm_size = s->bm_secs << VHD_SECTOR_SHIFT;
-	memset(s->padbm_buf, 0, s->padbm_size - bm_size);
-	memset(s->padbm_buf + (s->padbm_size - bm_size), ~0, bm_size);
-	s->debug_skipped_redundant_writes = 0;
-	s->debug_done_redundant_writes = 0;
-
 	if (test_vhd_flag(s->flags, VHD_FLAG_OPEN_NO_CACHE))
 		return 0;
 
@@ -693,7 +588,7 @@
 			full++;
 	}
 
-	DPRINTF("%s version: %s 0x%08x, b: %u, a: %u, f: %u, n: %llu\n",
+	DPRINTF("%s version: %s 0x%08x, b: %u, a: %u, f: %u, n: %"PRIu64"\n",
 		s->vhd.file, buf, s->vhd.footer.crtr_ver, s->bat.bat.entries,
 		allocated, full, s->next_db);
 }
@@ -721,13 +616,6 @@
 	o_flags = ((test_vhd_flag(flags, VHD_FLAG_OPEN_RDONLY)) ? 
 		   VHD_OPEN_RDONLY : VHD_OPEN_RDWR);
 
-	if (test_vhd_flag(flags, VHD_FLAG_OPEN_STRICT))
-		set_vhd_flag(o_flags, VHD_OPEN_STRICT);
-
-#ifdef VHD_LOCKING
-	set_vhd_flag(o_flags, VHD_OPEN_LOCKED);
-#endif
-
 	err = vhd_open(&s->vhd, name, o_flags);
 	if (err) {
 		libvhd_set_log_level(1);
@@ -762,15 +650,10 @@
 	driver->info.sector_size = VHD_SECTOR_SIZE;
 	driver->info.info        = 0;
 
-        DBG(TLOG_INFO, "vhd_open: done (sz:%llu, sct:%lu, inf:%u)\n",
+        DBG(TLOG_INFO, "vhd_open: done (sz:%"PRIu64", sct:%"PRIu64
+            ", inf:%u)\n",
 	    driver->info.size, driver->info.sector_size, driver->info.info);
 
-	err = vhd_open_crypto(&s->vhd, name);
-	if (err) {
-		DPRINTF("failed to init crypto: %d\n", err);
-		goto fail;
-	}
-
 	if (test_vhd_flag(flags, VHD_FLAG_OPEN_STRICT) && 
 	    !test_vhd_flag(flags, VHD_FLAG_OPEN_RDONLY)) {
 		err = vhd_kill_footer(s);
@@ -809,8 +692,6 @@
 			      VHD_FLAG_OPEN_NO_CACHE);
 
 	/* pre-allocate for all but NFS and LVM storage */
-	driver->storage = tapdisk_storage_type(name);
-
 	if (driver->storage != TAPDISK_STORAGE_TYPE_NFS &&
 	    driver->storage != TAPDISK_STORAGE_TYPE_LVM)
 		vhd_flags |= VHD_FLAG_OPEN_PREALLOCATE;
@@ -836,7 +717,7 @@
 			full++;
 	}
 
-	DPRINTF("%s: b: %u, a: %u, f: %u, n: %llu\n",
+	DPRINTF("%s: b: %u, a: %u, f: %u, n: %"PRIu64"\n",
 		s->vhd.file, s->bat.bat.entries, allocated, full, s->next_db);
 }
 
@@ -850,10 +731,6 @@
 	DBG(TLOG_WARN, "vhd_close\n");
 	s = (struct vhd_state *)driver->data;
 
-	DPRINTF("gaps written/skipped: %ld/%ld\n", 
-			s->debug_done_redundant_writes,
-			s->debug_skipped_redundant_writes);
-
 	/* don't write footer if tapdisk is read-only */
 	if (test_vhd_flag(s->flags, VHD_FLAG_OPEN_RDONLY))
 		goto free;
@@ -895,6 +772,7 @@
 vhd_validate_parent(td_driver_t *child_driver,
 		    td_driver_t *parent_driver, td_flag_t flags)
 {
+	uint32_t status;
 	struct stat stats;
 	struct vhd_state *child  = (struct vhd_state *)child_driver->data;
 	struct vhd_state *parent;
@@ -929,7 +807,7 @@
 	}
 	*/
 
-	if (uuid_compare(child->vhd.header.prt_uuid, parent->vhd.footer.uuid)) {
+	if (vhd_uuid_compare(&child->vhd.header.prt_uuid, &parent->vhd.footer.uuid)) {
 		DPRINTF("ERROR: %s: %s, %s: parent uuid has changed since "
 			"snapshot.  Child image no longer valid.\n",
 			__func__, child->vhd.file, parent->vhd.file);
@@ -1465,56 +1343,6 @@
 	aio_write(s, req, offset);
 }
 
-/* This is a performance optimization. When writing sequentially into full 
- * blocks, skipping (up-to-date) bitmaps causes an approx. 25% reduction in 
- * throughput. To prevent skipping, we issue redundant writes into the (padded) 
- * bitmap area just to make all writes sequential. This will help VHDs on raw 
- * block devices, while the FS-based VHDs shouldn't suffer much.
- *
- * Note that it only makes sense to perform this reduntant bitmap write if the 
- * block is completely full (i.e. the batmap entry is set). If the block is not 
- * completely full then one of the following two things will be true:
- *  1. we'll either be allocating new sectors in this block and writing its
- *     bitmap transactionally, which will be slow anyways; or
- *  2. the IO will be skipping over the unallocated sectors again, so the
- *     pattern will not be sequential anyways
- * In either case a redundant bitmap write becomes pointless. This fact 
- * simplifies the implementation of redundant writes: since we know the bitmap 
- * cannot be updated by anyone else, we don't have to worry about transactions 
- * or potential write conflicts.
- * */
-static void
-schedule_redundant_bm_write(struct vhd_state *s, u32 blk)
-{
-	uint64_t offset;
-	struct vhd_bitmap *bm;
-	struct vhd_request *req;
-
-	ASSERT(s->vhd.footer.type != HD_TYPE_FIXED);
-	ASSERT(test_batmap(s, blk));
-
-	req = alloc_vhd_request(s);
-	if (!req) 
-		return;
-
-	req->treq.buf = s->padbm_buf;
-
-	offset = bat_entry(s, blk);
-	ASSERT(offset != DD_BLK_UNUSED);
-	offset <<= VHD_SECTOR_SHIFT;
-	offset -= s->padbm_size - (s->bm_secs << VHD_SECTOR_SHIFT);
-
-	req->op        = VHD_OP_REDUNDANT_BM_WRITE;
-	req->treq.sec  = blk * s->spb;
-	req->treq.secs = s->padbm_size >> VHD_SECTOR_SHIFT;
-	req->next      = NULL;
-
-	DBG(TLOG_DBG, "blk: %u, writing redundant bitmap at %" PRIu64 "\n",
-	    blk, offset);
-
-	aio_write(s, req, offset);
-}
-
 static int
 update_bat(struct vhd_state *s, uint32_t blk)
 {
@@ -1550,19 +1378,12 @@
 }
 
 static int
-vhd_fallocate(int fd, int mode, off_t offset, off_t length)
-{
-	return syscall(SYS_fallocate, fd, mode, offset, length);
-}
-
-static int
 allocate_block(struct vhd_state *s, uint32_t blk)
 {
 	char *zeros;
 	int err, gap;
 	uint64_t offset, size;
 	struct vhd_bitmap *bm;
-	ssize_t count;
 
 	ASSERT(bat_entry(s, blk) == DD_BLK_UNUSED);
 
@@ -1584,37 +1405,20 @@
 	}
 
 	s->bat.pbw_offset = s->next_db;
-	size = vhd_sectors_to_bytes(s->spb + s->bm_secs + gap);
 
 	DBG(TLOG_DBG, "blk: 0x%04x, pbwo: 0x%08"PRIx64"\n",
 	    blk, s->bat.pbw_offset);
 
-	err = vhd_fallocate(s->vhd.fd, 0, offset, size);
-	if (err) {
-		if (errno != ENOSYS) {
-			ERR(errno, "fallocate failed\n");
-			return -errno;
-		}
-
-		if (lseek(s->vhd.fd, offset, SEEK_SET) == (off_t)-1) {
-			ERR(errno, "lseek failed\n");
-			return -errno;
-		}
-
-		count = write(s->vhd.fd, vhd_zeros(size), size);
-		if (count != size) {
-			err = count < 0 ? -errno : -ENOSPC;
-			ERR(errno,
-			    "write failed (%zd, offset %"PRIu64")\n",
-			    count, offset);
-			return err;
-		}
+	if (lseek(s->vhd.fd, offset, SEEK_SET) == (off_t)-1) {
+		ERR(errno, "lseek failed\n");
+		return -errno;
 	}
 
-	err = fdatasync(s->vhd.fd);
-	if (err) {
-		err = -errno;
-		ERR(err, "sync failed");
+	size = vhd_sectors_to_bytes(s->spb + s->bm_secs + gap);
+	err  = write(s->vhd.fd, vhd_zeros(size), size);
+	if (err != size) {
+		err = (err == -1 ? -errno : -EIO);
+		ERR(err, "write failed");
 		return err;
 	}
 
@@ -1690,7 +1494,6 @@
 	u32 blk = 0, sec = 0;
 	struct vhd_bitmap  *bm = NULL;
 	struct vhd_request *req;
-	char *crypto_buf = NULL;
 
 	if (s->vhd.footer.type == HD_TYPE_FIXED) {
 		offset = vhd_sectors_to_bytes(treq.sec);
@@ -1717,30 +1520,15 @@
 	offset  = vhd_sectors_to_bytes(offset);
 
  make_request:
-	if (s->vhd.xts_tfm) {
-		err = posix_memalign((void **)&crypto_buf, VHD_SECTOR_SIZE,
-				     treq.secs * VHD_SECTOR_SIZE);
-		if (err)
-			return -EBUSY;
-	}
 	req = alloc_vhd_request(s);
-	if (!req) {
-		if (s->vhd.xts_tfm)
-			free(crypto_buf);
+	if (!req)
 		return -EBUSY;
-	}
 
 	req->treq  = treq;
 	req->flags = flags;
 	req->op    = VHD_OP_DATA_WRITE;
 	req->next  = NULL;
 
-	if (s->vhd.xts_tfm) {
-		req->orig_buf = req->treq.buf;
-		req->treq.buf = crypto_buf;
-		vhd_crypto_encrypt(&s->vhd, &req->treq, req->orig_buf);
-	}
-
 	if (test_vhd_flag(flags, VHD_FLAG_REQ_UPDATE_BITMAP)) {
 		bm = get_bitmap(s, blk);
 		ASSERT(bm && bitmap_valid(bm));
@@ -1751,11 +1539,7 @@
 			set_vhd_flag(req->flags, VHD_FLAG_REQ_QUEUED);
 		} else
 			add_to_transaction(&bm->tx, req);
-	} else if (sec == 0 && 	/* first sector inside data block */
-		   s->vhd.footer.type != HD_TYPE_FIXED && 
-		   bat_entry(s, blk) != s->first_db &&
-		   test_batmap(s, blk))
-		schedule_redundant_bm_write(s, blk);
+	}
 
 	aio_write(s, req, offset);
 
@@ -1983,6 +1767,7 @@
 
 		case VHD_BM_BAT_LOCKED:
 			err = -EBUSY;
+			clone.blocked = 1;
 			goto fail;
 
 		case VHD_BM_BAT_CLEAR:
@@ -2061,17 +1846,6 @@
 
 		err  = (error ? error : r->error);
 		next = r->next;
-		if (s->vhd.xts_tfm) {
-			switch (r->op) {
-			case VHD_OP_DATA_READ:
-				vhd_crypto_decrypt(&s->vhd, &r->treq);
-				break;
-			case VHD_OP_DATA_WRITE:
-				free(r->treq.buf);
-				r->treq.buf = r->orig_buf;
-				break;
-			}
-		}
 		td_complete_request(r->treq, err);
 		DBG(TLOG_DBG, "lsec: 0x%08"PRIx64", blk: 0x%04"PRIx64", "
 		    "err: %d\n", r->treq.sec, r->treq.sec / s->spb, err);
@@ -2284,26 +2058,6 @@
 		finish_data_transaction(s, bm);
 }
 
-static int
-finish_redundant_bm_write(struct vhd_request *req)
-{
-	/* u32 blk; */
-	struct vhd_state *s = (struct vhd_state *) req->state;
-
-	s->returned++;
-	TRACE(s);	
-	/* blk = req->treq.sec / s->spb;
-	   DBG(TLOG_DBG, "blk: %u\n", blk); */
-
-	if (req->error) {
-		ERR(req->error, "lsec: 0x%08"PRIx64, req->treq.sec);
-	}
-	free_vhd_request(s, req);
-	s->debug_done_redundant_writes++;
-	return 0;
-}
-
-
 static void
 finish_bitmap_read(struct vhd_request *req)
 {
@@ -2472,10 +2226,6 @@
 		finish_zero_bm_write(req);
 		break;
 
-	case VHD_OP_REDUNDANT_BM_WRITE:
-		finish_redundant_bm_write(req);
-		break;
-
 	case VHD_OP_BAT_WRITE:
 		finish_bat_write(req);
 		break;
diff -Nur blktap2_oxt//drivers/block-vindex.c blktap2_xen//drivers/block-vindex.c
--- blktap2_oxt//drivers/block-vindex.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/block-vindex.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,921 +0,0 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include "tapdisk.h"
-#include "tapdisk-utils.h"
-#include "tapdisk-driver.h"
-#include "tapdisk-server.h"
-#include "tapdisk-interface.h"
-
-#include "libvhd.h"
-#include "libvhd-index.h"
-
-#define DBG(_level, _f, _a...)       tlog_write(_level, _f, ##_a)
-#define ERR(_err, _f, _a...)         tlog_error(_err, _f, ##_a)
-#define WARN(_f, _a...)              tlog_write(TLOG_WARN, _f, ##_a)
-
-#define ASSERT(condition)					\
-	if (!(condition)) {					\
-		WARN("FAILED ASSERTION: '%s'\n", #condition);	\
-		td_panic();					\
-	}
-
-#define VHD_INDEX_FILE_POOL_SIZE     12
-#define VHD_INDEX_CACHE_SIZE         4
-#define VHD_INDEX_REQUESTS           (TAPDISK_DATA_REQUESTS + VHD_INDEX_CACHE_SIZE)
-
-#define VHD_INDEX_BLOCK_READ_PENDING 0x0001
-#define VHD_INDEX_BLOCK_VALID        0x0002
-
-#define VHD_INDEX_BAT_CLEAR          0
-#define VHD_INDEX_BIT_CLEAR          1
-#define VHD_INDEX_BIT_SET            2
-#define VHD_INDEX_CACHE_MISS         3
-#define VHD_INDEX_META_READ_PENDING  4
-
-typedef struct vhd_index             vhd_index_t;
-typedef struct vhd_index_block       vhd_index_block_t;
-typedef struct vhd_index_request     vhd_index_request_t;
-typedef struct vhd_index_file_ref    vhd_index_file_ref_t;
-
-struct vhd_index_request {
-	off64_t                      off;
-	td_request_t                 treq;
-	vhd_index_t                 *index;
-	struct tiocb                 tiocb;
-	struct list_head             next;
-	vhd_index_file_ref_t        *file;
-};
-
-struct vhd_index_block {
-	uint64_t                     blk;
-	uint32_t                     seqno;
-	td_flag_t                    state;
-	vhdi_block_t                 vhdi_block;
-	int                          table_size;
-	struct list_head             queue;
-	vhd_index_request_t          req;
-};
-
-struct vhd_index_file_ref {
-	int                          fd;
-	vhdi_file_id_t               fid;
-	uint32_t                     seqno;
-	uint32_t                     refcnt;
-};
-
-struct vhd_index {
-	char                        *name;
-
-	vhdi_bat_t                   bat;
-	vhdi_context_t               vhdi;
-	vhdi_file_table_t            files;
-
-	vhd_index_file_ref_t         fds[VHD_INDEX_FILE_POOL_SIZE];
-
-	vhd_index_block_t           *cache[VHD_INDEX_CACHE_SIZE];
-
-	int                          cache_free_cnt;
-	vhd_index_block_t           *cache_free_list[VHD_INDEX_CACHE_SIZE];
-	vhd_index_block_t            cache_list[VHD_INDEX_CACHE_SIZE];
-
-	int                          requests_free_cnt;
-	vhd_index_request_t         *requests_free_list[VHD_INDEX_REQUESTS];
-	vhd_index_request_t          requests_list[VHD_INDEX_REQUESTS];
-
-	td_driver_t                 *driver;
-};
-
-static void vhd_index_complete_meta_read(void *, struct tiocb *, int);
-static void vhd_index_complete_data_read(void *, struct tiocb *, int);
-
-#define vhd_index_block_for_each_request(_block, _req, _tmp)		\
-	list_for_each_entry_safe((_req), (_tmp), &(_block)->queue, next)
-
-static inline void
-vhd_index_initialize_request(vhd_index_request_t *req)
-{
-	memset(req, 0, sizeof(vhd_index_request_t));
-	INIT_LIST_HEAD(&req->next);
-}
-
-static inline void
-vhd_index_initialize_block(vhd_index_block_t *block)
-{
-	char *buf;
-
-	block->blk   = 0;
-	block->state = 0;
-	INIT_LIST_HEAD(&block->queue);
-	vhd_index_initialize_request(&block->req);
-	memset(block->vhdi_block.table, 0, block->table_size);
-}
-
-static void
-vhd_index_init(vhd_index_t *index)
-{
-	int i;
-
-	memset(index, 0, sizeof(vhd_index_t));
-
-	index->cache_free_cnt = VHD_INDEX_CACHE_SIZE;
-	for (i = 0; i < VHD_INDEX_CACHE_SIZE; i++) {
-		index->cache_free_list[i] = index->cache_list + i;
-		vhd_index_initialize_block(index->cache_free_list[i]);
-	}
-
-	index->requests_free_cnt = VHD_INDEX_REQUESTS;
-	for (i = 0; i < VHD_INDEX_REQUESTS; i++) {
-		index->requests_free_list[i] = index->requests_list + i;
-		vhd_index_initialize_request(index->requests_free_list[i]);
-	}
-
-	for (i = 0; i < VHD_INDEX_FILE_POOL_SIZE; i++)
-		index->fds[i].fd = -1;
-}
-
-static int
-vhd_index_allocate_cache(vhd_index_t *index)
-{
-	char *buf;
-	int i, err;
-	size_t size;
-
-	size = vhd_bytes_padded(index->vhdi.spb * sizeof(vhdi_entry_t));
-
-	for (i = 0; i < VHD_INDEX_CACHE_SIZE; i++) {
-		err = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, size);
-		if (err)
-			goto fail;
-
-		memset(buf, 0, size);
-		index->cache_list[i].vhdi_block.table   = (vhdi_entry_t *)buf;
-		index->cache_list[i].vhdi_block.entries = index->vhdi.spb;
-		index->cache_list[i].table_size         = size;
-	}
-
-	return 0;
-
-fail:
-	for (i = 0; i < VHD_INDEX_CACHE_SIZE; i++) {
-		free(index->cache_list[i].vhdi_block.table);
-		index->cache_list[i].vhdi_block.table = NULL;
-	}
-
-	return -ENOMEM;
-}
-
-static void
-vhd_index_free(vhd_index_t *index)
-{
-	int i;
-
-	for (i = 0; i < VHD_INDEX_CACHE_SIZE; i++)
-		free(index->cache_list[i].vhdi_block.table);
-
-	for (i = 0; i < VHD_INDEX_FILE_POOL_SIZE; i++)
-		if (index->fds[i].fd != -1)
-			close(index->fds[i].fd);
-
-	vhdi_file_table_free(&index->files);
-	free(index->bat.table);
-	free(index->name);
-}
-
-static int
-vhd_index_load(vhd_index_t *index)
-{
-	int err;
-
-	err = vhdi_bat_load(index->name, &index->bat);
-	if (err)
-		return err;
-
-	err = vhdi_open(&index->vhdi,
-			index->bat.index_path,
-			O_RDONLY | O_DIRECT | O_LARGEFILE);
-	if (err)
-		goto fail;
-
-	err = vhdi_file_table_load(index->bat.file_table_path, &index->files);
-	if (err) {
-		vhdi_close(&index->vhdi);
-		goto fail;
-	}
-
-	return 0;
-
-fail:
-	free(index->bat.table);
-	memset(&index->bat, 0, sizeof(vhdi_bat_t));
-	memset(&index->vhdi, 0, sizeof(vhdi_context_t));
-	memset(&index->files, 0, sizeof(vhdi_file_table_t));
-	return err;
-}
-
-static int
-vhd_index_open(td_driver_t *driver, const char *name, td_flag_t flags)
-{
-	int err;
-	vhd_index_t *index;
-
-	index = (vhd_index_t *)driver->data;
-
-	vhd_index_init(index);
-
-	index->name = strdup(name);
-	if (!index->name)
-		return -ENOMEM;
-
-	err = vhd_index_load(index);
-	if (err) {
-		free(index->name);
-		return err;
-	}
-
-	err = vhd_index_allocate_cache(index);
-	if (err) {
-		vhd_index_free(index);
-		return err;
-	}
-
-	driver->info.size = index->bat.vhd_blocks * index->bat.vhd_block_size;
-	driver->info.sector_size = VHD_SECTOR_SIZE;
-	driver->info.info = 0;
-
-	index->driver = driver;
-
-	DPRINTF("opened vhd index %s\n", name);
-
-	return 0;
-}
-
-static int
-vhd_index_close(td_driver_t *driver)
-{
-	vhd_index_t *index;
-
-	index = (vhd_index_t *)driver->data;
-	vhdi_close(&index->vhdi);
-
-	DPRINTF("closed vhd index %s\n", index->name);
-
-	vhd_index_free(index);
-
-	return 0;
-}
-
-static inline void
-vhd_index_touch_file_ref(vhd_index_t *index, vhd_index_file_ref_t *ref)
-{
-	int i;
-
-	if (++ref->seqno == 0xFFFFFFFF)
-		for (i = 0; i < VHD_INDEX_FILE_POOL_SIZE; i++)
-			index->fds[i].seqno >>= 1;
-}
-
-static inline void
-vhd_index_get_file_ref(vhd_index_file_ref_t *ref)
-{
-	++ref->refcnt;
-}
-
-static inline void
-vhd_index_put_file_ref(vhd_index_file_ref_t *ref)
-{
-	--ref->refcnt;
-}
-
-static inline vhd_index_file_ref_t *
-vhd_index_find_lru_file_ref(vhd_index_t *index)
-{
-	int i;
-	uint32_t min;
-	vhd_index_file_ref_t *lru;
-
-	lru = NULL;
-	min = (uint32_t)-1;
-
-	for (i = 1; i < VHD_INDEX_FILE_POOL_SIZE; i++) {
-		if (index->fds[i].refcnt)
-			continue;
-
-		if (!lru || index->fds[i].seqno < min) {
-			min = index->fds[i].seqno;
-			lru = index->fds + i;
-		}
-	}
-
-	return lru;
-}
-
-static inline int
-vhd_index_open_file(vhd_index_t *index,
-		    vhdi_file_id_t id, vhd_index_file_ref_t *ref)
-{
-	int i;
-	char *path;
-
-	path = NULL;
-
-	for (i = 0; i < index->files.entries; i++)
-		if (index->files.table[i].file_id == id) {
-			path = index->files.table[i].path;
-			break;
-		}
-
-	if (!path)
-		return -ENOENT;
-
-	ref->fd = open(path, O_RDONLY | O_DIRECT | O_LARGEFILE);
-	if (ref->fd == -1)
-		return -errno;
-
-	ref->fid    = id;
-	ref->refcnt = 0;
-
-	return 0;
-}
-
-static int
-vhd_index_get_file(vhd_index_t *index,
-		   vhdi_file_id_t id, vhd_index_file_ref_t **ref)
-{
-	int i, err;
-	vhd_index_file_ref_t *lru;
-
-	*ref = NULL;
-
-	for (i = 0; i < VHD_INDEX_FILE_POOL_SIZE; i++)
-		if (id == index->fds[i].fid) {
-			*ref = index->fds + i;
-			vhd_index_touch_file_ref(index, *ref);
-			vhd_index_get_file_ref(*ref);
-			return 0;
-		}
-
-	lru = vhd_index_find_lru_file_ref(index);
-	if (!lru)
-		return -EBUSY;
-
-	if (lru->fd != -1)
-		close(lru->fd);
-
-	err = vhd_index_open_file(index, id, lru);
-	if (err)
-		goto fail;
-
-	vhd_index_touch_file_ref(index, lru);
-	vhd_index_get_file_ref(lru);
-	*ref = lru;
-	return 0;
-
-fail:
-	lru->fd     = -1;
-	lru->fid    = 0;
-	lru->refcnt = 0;
-	return err;
-}
-
-static inline vhd_index_request_t *
-vhd_index_allocate_request(vhd_index_t *index)
-{
-	vhd_index_request_t *req;
-
-	if (index->requests_free_cnt <= 0)
-		return NULL;
-
-	req = index->requests_free_list[--index->requests_free_cnt];
-	ASSERT(!req->index);
-
-	return req;
-}
-
-static inline void
-vhd_index_free_request(vhd_index_t *index, vhd_index_request_t *req)
-{
-	list_del(&req->next);
-	vhd_index_initialize_request(req);
-	index->requests_free_list[index->requests_free_cnt++] = req;
-}
-
-static inline int
-vhd_index_block_valid(vhd_index_block_t *block)
-{
-	return (!td_flag_test(block->state, VHD_INDEX_BLOCK_READ_PENDING) &&
-		td_flag_test(block->state, VHD_INDEX_BLOCK_VALID));
-}
-
-static inline void
-vhd_index_touch_block(vhd_index_t *index, vhd_index_block_t *block)
-{
-	int i;
-
-	if (++block->seqno == 0xFFFFFFFF)
-		for (i = 0; i < VHD_INDEX_CACHE_SIZE; i++)
-			index->cache_list[i].seqno >>= 1;
-}
-
-static inline vhd_index_block_t *
-vhd_index_get_lru_block(vhd_index_t *index)
-{
-	int i, idx;
-	uint32_t min;
-	vhd_index_block_t *block, *lru;
-
-	lru = NULL;
-	min = (uint32_t)-1;
-	idx = 0;
-
-	for (i = 0; i < VHD_INDEX_CACHE_SIZE; i++) {
-		block = index->cache[i];
-
-		if (!block)
-			continue;
-
-		if (td_flag_test(block->state, VHD_INDEX_BLOCK_READ_PENDING))
-			continue;
-
-		if (!lru || block->seqno < min) {
-			lru = block;
-			min = block->seqno;
-			idx = i;
-		}
-	}
-
-	if (lru)
-		index->cache[idx] = NULL;
-
-	return lru;
-}
-
-static inline int
-vhd_index_allocate_block(vhd_index_t *index, vhd_index_block_t **block)
-{
-	vhd_index_block_t *b;
-
-	*block = NULL;
-
-	if (index->cache_free_cnt > 0)
-		b = index->cache_free_list[--index->cache_free_cnt];
-	else {
-		b = vhd_index_get_lru_block(index);
-		if (!b)
-			return -EBUSY;
-	}
-
-	vhd_index_initialize_block(b);
-	vhd_index_touch_block(index, b);
-	*block = b;
-
-	return 0;
-}
-
-static int
-vhd_index_install_block(vhd_index_t *index,
-			vhd_index_block_t **block, uint32_t blk)
-{
-	int i, err;
-	vhd_index_block_t *b;
-
-	*block = NULL;
-
-	err = vhd_index_allocate_block(index, &b);
-	if (err)
-		return err;
-
-	b->blk = blk;
-
-	for (i = 0; i < VHD_INDEX_CACHE_SIZE; i++)
-		if (!index->cache[i]) {
-			index->cache[i] = b;
-			break;
-		}
-
-	ASSERT(i < VHD_INDEX_CACHE_SIZE);
-	*block = b;
-
-	return 0;
-}
-
-static inline vhd_index_block_t *
-vhd_index_get_block(vhd_index_t *index, uint32_t blk)
-{
-	int i;
-	vhd_index_block_t *block;
-
-	for (i = 0; i < VHD_INDEX_CACHE_SIZE; i++) {
-		block = index->cache[i];
-		if (!block)
-			continue;
-
-		if (block->blk == blk)
-			return block;
-	}
-
-	return NULL;
-}
-
-static int
-vhd_index_read_cache(vhd_index_t *index, uint64_t sector)
-{
-	uint32_t blk, sec;
-	vhd_index_block_t *block;
-
-	blk = sector / index->vhdi.spb;
-
-	if (blk >= index->bat.vhd_blocks)
-		return -EINVAL;
-
-	if (index->bat.table[blk] == DD_BLK_UNUSED)
-		return VHD_INDEX_BAT_CLEAR;
-
-	block = vhd_index_get_block(index, blk);
-	if (!block)
-		return VHD_INDEX_CACHE_MISS;
-
-	vhd_index_touch_block(index, block);
-
-	if (td_flag_test(block->state, VHD_INDEX_BLOCK_READ_PENDING))
-		return VHD_INDEX_META_READ_PENDING;
-
-	sec = sector % index->vhdi.spb;
-	if (block->vhdi_block.table[sec].offset == DD_BLK_UNUSED)
-		return VHD_INDEX_BIT_CLEAR;
-
-	return VHD_INDEX_BIT_SET;
-}
-
-static int
-vhd_index_read_cache_span(vhd_index_t *index,
-			  uint64_t sector, int secs, int value)
-{
-	int i;
-	uint32_t blk, sec;
-	vhd_index_block_t *block;
-
-	blk = sector / index->vhdi.spb;
-	sec = sector % index->vhdi.spb;
-
-	ASSERT(blk < index->bat.vhd_blocks);
-
-	block = vhd_index_get_block(index, blk);
-	ASSERT(block && vhd_index_block_valid(block));
-
-	for (i = 0; i < secs && i + sec < index->vhdi.spb; i++)
-		if (value ^
-		    (block->vhdi_block.table[sec + i].offset != DD_BLK_UNUSED))
-			break;
-
-	return i;
-}
-
-static int
-vhd_index_schedule_meta_read(vhd_index_t *index, uint32_t blk)
-{
-	int err;
-	off64_t offset;
-	vhd_index_block_t *block;
-	vhd_index_request_t *req;
-
-	ASSERT(index->bat.table[blk] != DD_BLK_UNUSED);
-
-	block = vhd_index_get_block(index, blk);
-	if (!block) {
-		err = vhd_index_install_block(index, &block, blk);
-		if (err)
-			return err;
-	}
-
-	offset         = vhd_sectors_to_bytes(index->bat.table[blk]);
-
-	req            = &block->req;
-	req->index     = index;
-	req->treq.sec  = blk * index->vhdi.spb;
-	req->treq.secs = block->table_size >> VHD_SECTOR_SHIFT;
-
-	td_prep_read(&req->tiocb, index->vhdi.fd,
-		     (char *)block->vhdi_block.table, block->table_size,
-		     offset, vhd_index_complete_meta_read, req);
-	td_queue_tiocb(index->driver, &req->tiocb);
-
-	td_flag_set(block->state, VHD_INDEX_BLOCK_READ_PENDING);
-
-	return 0;
-}
-
-static int
-vhd_index_schedule_data_read(vhd_index_t *index, td_request_t treq)
-{
-	int i, err;
-	size_t size;
-	off64_t offset;
-	uint32_t blk, sec;
-	vhd_index_block_t *block;
-	vhd_index_request_t *req;
-	vhd_index_file_ref_t *file;
-
-	blk   = treq.sec / index->vhdi.spb;
-	sec   = treq.sec % index->vhdi.spb;
-	block = vhd_index_get_block(index, blk);
-
-	ASSERT(block && vhd_index_block_valid(block));
-	for (i = 0; i < treq.secs; i++) {
-		ASSERT(block->vhdi_block.table[sec + i].file_id != 0);
-		ASSERT(block->vhdi_block.table[sec + i].offset != DD_BLK_UNUSED);
-	}
-
-	req = vhd_index_allocate_request(index);
-	if (!req)
-		return -EBUSY;
-
-	err = vhd_index_get_file(index,
-				 block->vhdi_block.table[sec].file_id, &file);
-	if (err) {
-		vhd_index_free_request(index, req);
-		return err;
-	}
-
-	size       = vhd_sectors_to_bytes(treq.secs);
-	offset     = vhd_sectors_to_bytes(block->vhdi_block.table[sec].offset);
-
-	req->file  = file;
-	req->treq  = treq;
-	req->index = index;
-	req->off   = offset;
-
-	td_prep_read(&req->tiocb, file->fd, treq.buf, size, offset,
-		     vhd_index_complete_data_read, req);
-	td_queue_tiocb(index->driver, &req->tiocb);
-
-	return 0;
-}
-
-static int
-vhd_index_queue_request(vhd_index_t *index, td_request_t treq)
-{
-	vhd_index_block_t *block;
-	vhd_index_request_t *req;
-
-	req = vhd_index_allocate_request(index);
-	if (!req)
-		return -EBUSY;
-
-	req->treq = treq;
-
-	block = vhd_index_get_block(index, treq.sec / index->vhdi.spb);
-	ASSERT(block && td_flag_test(block->state, VHD_INDEX_BLOCK_READ_PENDING));
-
-	list_add_tail(&req->next, &block->queue);
-	return 0;
-}
-
-static void
-vhd_index_queue_read(td_driver_t *driver, td_request_t treq)
-{
-	vhd_index_t *index;
-
-	index = (vhd_index_t *)driver->data;
-
-	while (treq.secs) {
-		int err;
-		td_request_t clone;
-
-		err   = 0;
-		clone = treq;
-
-		switch (vhd_index_read_cache(index, clone.sec)) {
-		case -EINVAL:
-			err = -EINVAL;
-			goto fail;
-
-		case VHD_INDEX_BAT_CLEAR:
-			clone.secs = MIN(clone.secs, index->vhdi.spb - (clone.sec % index->vhdi.spb));
-			td_forward_request(clone);
-			break;
-
-		case VHD_INDEX_BIT_CLEAR:
-			clone.secs = vhd_index_read_cache_span(index, clone.sec, clone.secs, 0);
-			td_forward_request(clone);
-			break;
-
-		case VHD_INDEX_BIT_SET:
-			clone.secs = vhd_index_read_cache_span(index, clone.sec, clone.secs, 1);
-			err = vhd_index_schedule_data_read(index, clone);
-			if (err)
-				goto fail;
-			break;
-
-		case VHD_INDEX_CACHE_MISS:
-			err = vhd_index_schedule_meta_read(index, clone.sec / index->vhdi.spb);
-			if (err)
-				goto fail;
-
-			clone.secs = MIN(clone.secs, index->vhdi.spb - (clone.sec % index->vhdi.spb));
-			vhd_index_queue_request(index, clone);
-			break;
-
-		case VHD_INDEX_META_READ_PENDING:
-			clone.secs = MIN(clone.secs, index->vhdi.spb - (clone.sec % index->vhdi.spb));
-			err = vhd_index_queue_request(index, clone);
-			if (err)
-				goto fail;
-			break;
-		}
-
-		treq.sec  += clone.secs;
-		treq.secs -= clone.secs;
-		treq.buf  += vhd_sectors_to_bytes(clone.secs);
-		continue;
-
-	fail:
-		clone.secs = treq.secs;
-		td_complete_request(clone, err);
-		break;
-	}
-}
-
-static void
-vhd_index_queue_write(td_driver_t *driver, td_request_t treq)
-{
-	td_complete_request(treq, -EPERM);
-}
-
-static inline void
-vhd_index_signal_completion(vhd_index_t *index,
-			    vhd_index_request_t *req, int err)
-{
-	td_complete_request(req->treq, err);
-	vhd_index_put_file_ref(req->file);
-	vhd_index_free_request(index, req);
-}
-
-static void
-vhd_index_complete_meta_read(void *arg, struct tiocb *tiocb, int err)
-{
-	int i;
-	uint32_t blk;
-	td_request_t treq;
-	vhd_index_t *index;
-	vhd_index_block_t *block;
-	vhd_index_request_t *req, *r, *tmp;
-
-	req   = (vhd_index_request_t *)arg;
-	index = req->index;
-
-	blk   = req->treq.sec / index->vhdi.spb;
-	block = vhd_index_get_block(index, blk);
-	ASSERT(block && td_flag_test(block->state, VHD_INDEX_BLOCK_READ_PENDING));
-	td_flag_clear(block->state, VHD_INDEX_BLOCK_READ_PENDING);
-
-	if (err) {
-		memset(block->vhdi_block.table, 0, block->table_size);
-		vhd_index_block_for_each_request(block, r, tmp)
-			vhd_index_signal_completion(index, r, err);
-		return;
-	}
-
-	for (i = 0; i < block->vhdi_block.entries; i++)
-		vhdi_entry_in(block->vhdi_block.table + i);
-
-	td_flag_set(block->state, VHD_INDEX_BLOCK_VALID);
-
-	vhd_index_block_for_each_request(block, r, tmp) {
-		treq = r->treq;
-		vhd_index_free_request(index, r);
-		vhd_index_queue_read(index->driver, treq);
-	}
-}
-
-static void
-vhd_index_complete_data_read(void *arg, struct tiocb *tiocb, int err)
-{
-	vhd_index_t *index;
-	vhd_index_request_t *req;
-
-	req   = (vhd_index_request_t *)arg;
-	index = req->index;
-
-	vhd_index_signal_completion(index, req, err);
-}
-
-static int
-vhd_index_get_parent_id(td_driver_t *driver, td_disk_id_t *id)
-{
-	return -EINVAL;
-}
-
-static int
-vhd_index_validate_parent(td_driver_t *driver,
-			  td_driver_t *parent, td_flag_t flags)
-{
-	return -EINVAL;
-}
-
-static void
-vhd_index_debug(td_driver_t *driver)
-{
-	int i;
-	vhd_index_t *index;
-
-	index = (vhd_index_t *)driver->data;
-
-	WARN("VHD INDEX %s\n", index->name);
-	WARN("FILES:\n");
-	for (i = 0; i < index->files.entries; i++) {
-		int j, fd, refcnt;
-
-		fd     = -1;
-		refcnt = 0;
-
-		for (j = 0; j < VHD_INDEX_FILE_POOL_SIZE; j++)
-			if (index->fds[j].fid == index->files.table[i].file_id) {
-				fd     = index->fds[j].fd;
-				refcnt = index->fds[j].refcnt;
-			}
-
-		WARN("%s %u %d %d\n",
-		     index->files.table[i].path,
-		     index->files.table[i].file_id,
-		     fd, refcnt);
-	}
-
-	WARN("REQUESTS:\n");
-	for (i = 0; i < VHD_INDEX_REQUESTS; i++) {
-		vhd_index_request_t *req;
-
-		req = index->requests_list + i;
-
-		if (!req->index)
-			continue;
-
-		WARN("%d: buf: %p, sec: 0x%08"PRIx64", secs: 0x%04x, "
-		     "fid: %u, off: 0x%016"PRIx64"\n", i, req->treq.buf,
-		     req->treq.sec, req->treq.secs, req->file->fid, req->off);
-	}
-
-	WARN("BLOCKS:\n");
-	for (i = 0; i < VHD_INDEX_CACHE_SIZE; i++) {
-		int queued;
-		vhd_index_block_t *block;
-		vhd_index_request_t *req, *tmp;
-
-		queued = 0;
-		block  = index->cache[i];
-
-		if (!block)
-			continue;
-
-		vhd_index_block_for_each_request(block, req, tmp)
-			++queued;
-
-		WARN("%d: blk: 0x%08"PRIx64", state: 0x%08x, queued: %d\n",
-		     i, block->blk, block->state, queued);
-	}
-}
-
-struct tap_disk tapdisk_vhd_index = {
-	.disk_type                = "tapdisk_vhd_index",
-	.flags                    = 0,
-	.private_data_size        = sizeof(vhd_index_t),
-	.td_open                  = vhd_index_open,
-	.td_close                 = vhd_index_close,
-	.td_queue_read            = vhd_index_queue_read,
-	.td_queue_write           = vhd_index_queue_write,
-	.td_get_parent_id         = vhd_index_get_parent_id,
-	.td_validate_parent       = vhd_index_validate_parent,
-	.td_debug                 = vhd_index_debug,
-};
diff -Nur blktap2_oxt//drivers/bswap.h blktap2_xen//drivers/bswap.h
--- blktap2_oxt//drivers/bswap.h	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/bswap.h	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,179 @@
+#ifndef BSWAP_H
+#define BSWAP_H
+
+//#include "config-host.h"
+
+#include <inttypes.h>
+
+#if defined(__NetBSD__)
+#include <sys/endian.h>
+#include <sys/types.h>
+#elif defined(__OpenBSD__)
+#include <machine/endian.h>
+#define bswap_16(x) swap16(x)
+#define bswap_32(x) swap32(x)
+#define bswap_64(x) swap64(x)
+#elif defined(__linux__)
+
+#include <endian.h>
+#include <byteswap.h>
+
+static inline uint16_t bswap16(uint16_t x)
+{
+    return bswap_16(x);
+}
+
+static inline uint32_t bswap32(uint32_t x) 
+{
+    return bswap_32(x);
+}
+
+static inline uint64_t bswap64(uint64_t x) 
+{
+    return bswap_64(x);
+}
+
+static inline void bswap16s(uint16_t *s)
+{
+    *s = bswap16(*s);
+}
+
+static inline void bswap32s(uint32_t *s)
+{
+    *s = bswap32(*s);
+}
+
+static inline void bswap64s(uint64_t *s)
+{
+    *s = bswap64(*s);
+}
+
+#endif
+
+#if defined(WORDS_BIGENDIAN)
+#define be_bswap(v, size) (v)
+#define le_bswap(v, size) bswap ## size(v)
+#define be_bswaps(v, size)
+#define le_bswaps(p, size) *p = bswap ## size(*p);
+#else
+#define le_bswap(v, size) (v)
+#define be_bswap(v, size) bswap ## size(v)
+#define le_bswaps(v, size)
+#define be_bswaps(p, size) *p = bswap ## size(*p);
+#endif
+
+#define CPU_CONVERT(endian, size, type)\
+static inline type endian ## size ## _to_cpu(type v)\
+{\
+    return endian ## _bswap(v, size);\
+}\
+\
+static inline type cpu_to_ ## endian ## size(type v)\
+{\
+    return endian ## _bswap(v, size);\
+}\
+\
+static inline void endian ## size ## _to_cpus(type *p)\
+{\
+    endian ## _bswaps(p, size)\
+}\
+\
+static inline void cpu_to_ ## endian ## size ## s(type *p)\
+{\
+    endian ## _bswaps(p, size)\
+}\
+\
+static inline type endian ## size ## _to_cpup(const type *p)\
+{\
+    return endian ## size ## _to_cpu(*p);\
+}\
+\
+static inline void cpu_to_ ## endian ## size ## w(type *p, type v)\
+{\
+     *p = cpu_to_ ## endian ## size(v);\
+}
+
+CPU_CONVERT(be, 16, uint16_t)
+CPU_CONVERT(be, 32, uint32_t)
+CPU_CONVERT(be, 64, uint64_t)
+
+CPU_CONVERT(le, 16, uint16_t)
+CPU_CONVERT(le, 32, uint32_t)
+CPU_CONVERT(le, 64, uint64_t)
+
+/* unaligned versions (optimized for frequent unaligned accesses)*/
+
+#if defined(__i386__) || defined(__powerpc__)
+
+#define cpu_to_le16wu(p, v) cpu_to_le16w(p, v)
+#define cpu_to_le32wu(p, v) cpu_to_le32w(p, v)
+#define le16_to_cpupu(p) le16_to_cpup(p)
+#define le32_to_cpupu(p) le32_to_cpup(p)
+
+#define cpu_to_be16wu(p, v) cpu_to_be16w(p, v)
+#define cpu_to_be32wu(p, v) cpu_to_be32w(p, v)
+
+#else
+
+static inline void cpu_to_le16wu(uint16_t *p, uint16_t v)
+{
+    uint8_t *p1 = (uint8_t *)p;
+
+    p1[0] = v;
+    p1[1] = v >> 8;
+}
+
+static inline void cpu_to_le32wu(uint32_t *p, uint32_t v)
+{
+    uint8_t *p1 = (uint8_t *)p;
+
+    p1[0] = v;
+    p1[1] = v >> 8;
+    p1[2] = v >> 16;
+    p1[3] = v >> 24;
+}
+
+static inline uint16_t le16_to_cpupu(const uint16_t *p)
+{
+    const uint8_t *p1 = (const uint8_t *)p;
+    return p1[0] | (p1[1] << 8);
+}
+
+static inline uint32_t le32_to_cpupu(const uint32_t *p)
+{
+    const uint8_t *p1 = (const uint8_t *)p;
+    return p1[0] | (p1[1] << 8) | (p1[2] << 16) | (p1[3] << 24);
+}
+
+static inline void cpu_to_be16wu(uint16_t *p, uint16_t v)
+{
+    uint8_t *p1 = (uint8_t *)p;
+
+    p1[0] = v >> 8;
+    p1[1] = v;
+}
+
+static inline void cpu_to_be32wu(uint32_t *p, uint32_t v)
+{
+    uint8_t *p1 = (uint8_t *)p;
+
+    p1[0] = v >> 24;
+    p1[1] = v >> 16;
+    p1[2] = v >> 8;
+    p1[3] = v;
+}
+
+#endif
+
+#ifdef WORDS_BIGENDIAN
+#define cpu_to_32wu cpu_to_be32wu
+#else
+#define cpu_to_32wu cpu_to_le32wu
+#endif
+
+#undef le_bswap
+#undef be_bswap
+#undef le_bswaps
+#undef be_bswaps
+
+#endif /* BSWAP_H */
diff -Nur blktap2_oxt//drivers/check_gcrypt blktap2_xen//drivers/check_gcrypt
--- blktap2_oxt//drivers/check_gcrypt	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/check_gcrypt	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,18 @@
+#!/bin/sh
+
+cat > .gcrypt.c << EOF
+#include <gcrypt.h>
+int main(void) 
+{
+    gcry_md_hash_buffer(GCRY_MD_MD5, NULL, NULL, 0);
+    return 0; 
+}
+EOF
+
+if $1 -o .gcrypt .gcrypt.c -lgcrypt 2>/dev/null ; then
+  echo "yes"
+else
+  echo "no"
+fi
+
+rm -f .gcrypt*
diff -Nur blktap2_oxt//drivers/crypto/compat-crypto-openssl.h blktap2_xen//drivers/crypto/compat-crypto-openssl.h
--- blktap2_oxt//drivers/crypto/compat-crypto-openssl.h	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/crypto/compat-crypto-openssl.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,16 +0,0 @@
-/*
- * Copyright (c) 2014 Citrix Systems, Inc.
- */
-
-#ifndef COMPAT_CRYPTO_OPENSSL_H
-#define COMPAT_CRYPTO_OPENSSL_H
-
-#include <openssl/evp.h>
-
-struct crypto_blkcipher
-{
-	EVP_CIPHER_CTX de_ctx;
-	EVP_CIPHER_CTX en_ctx;
-};
-
-#endif
diff -Nur blktap2_oxt//drivers/crypto/Makefile blktap2_xen//drivers/crypto/Makefile
--- blktap2_oxt//drivers/crypto/Makefile	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/crypto/Makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,23 +0,0 @@
-#
-# Copyright (c) 2014 Citrix Systems, Inc.
-#
-
-# ASFLAGS += -g -I.
-# CFLAGS += -g -I.
-# LDFLAGS += -g
-RANLIB ?= ranlib
-
-LIBXTS-AES-OBJS := xts_aes.o
-
-libxts-aes.a: $(LIBXTS-AES-OBJS)
-	$(AR) r $@ $(LIBXTS-AES-OBJS)
-	$(RANLIB) $@
-
-test_decrypt: test_decrypt.o libxts-aes.a
-	$(CC) $(CFLAGS) -o $@ -lcrypto -L. -lxts-aes $+
-
-clean:
-	rm -f $(LIBXTS-AES-OBJS)
-	rm -f libxts-aes.a
-	rm -f test_decrypt test_decrypt.o
-
diff -Nur blktap2_oxt//drivers/crypto/test_decrypt.c blktap2_xen//drivers/crypto/test_decrypt.c
--- blktap2_oxt//drivers/crypto/test_decrypt.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/crypto/test_decrypt.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,109 +0,0 @@
-/*
- * Copyright (c) 2010, XenSource Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2014 Citrix Systems, Inc.
- */
-
-
-// #define PERF
-
-#include <err.h>
-#include <stdio.h>
-#include <stdint.h>
-#include "compat-crypto-openssl.h"
-#include "xts_aes.h"
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
- 
-#define BUFSIZE (512)
-uint8_t dst_buf[BUFSIZE];
-uint8_t src_buf[BUFSIZE];
-
-uint8_t key[32];
-
-int
-main(int argc, char **argv, char **envp)
-{
-    struct crypto_blkcipher *xts_tfm;
-    uint8_t *p_buf;
-    int fd, i, ret;
-    char *keyfile = "test.key";
-
-    fd = open(keyfile, O_RDONLY);
-    if (fd == -1)
-      err(1, "open");
-
-    ret = read(fd, key, sizeof(key));
-    if (ret != sizeof(key))
-      err(1, "read");
-
-    xts_tfm = xts_aes_setup();
-
-    xts_setkey(crypto_blkcipher_tfm(xts_tfm), key, sizeof(key));
-
-#ifdef PERF
-  for (i = 0; i < 1000000; i++) {
-#endif
-
-#ifndef PERF
-    printf("buffers: src %p dst %p\n", src_buf, dst_buf);
-#endif
-    ret = xts_aes_plain_encrypt(xts_tfm, 0, src_buf, src_buf, BUFSIZE);
-#ifndef PERF
-    printf("return %d\n", ret);
-#endif
-
-#ifndef PERF
-    p_buf = src_buf;
-    for (i = 0; i < BUFSIZE; i += 8)
-	printf("%03d/%p: %02x%02x%02x%02x%02x%02x%02x%02x\n", i, &p_buf[i],
-	       p_buf[i], p_buf[i+1], p_buf[i+2], p_buf[i+3],
-	       p_buf[i+4], p_buf[i+5], p_buf[i+6], p_buf[i+7]);
-#endif
-
-    ret = xts_aes_plain_decrypt(xts_tfm, 0, src_buf, src_buf, BUFSIZE);
-#ifndef PERF
-    printf("return %d\n", ret);
-#endif
-
-#ifndef PERF
-    p_buf = src_buf;
-    for (i = 0; i < BUFSIZE; i += 8)
-	printf("%03d/%p: %02x%02x%02x%02x%02x%02x%02x%02x\n", i, &p_buf[i],
-	       p_buf[i], p_buf[i+1], p_buf[i+2], p_buf[i+3],
-	       p_buf[i+4], p_buf[i+5], p_buf[i+6], p_buf[i+7]);
-#endif
-#ifdef PERF
-  }
-#endif
-
-    return 0;
-}
diff -Nur blktap2_oxt//drivers/crypto/xts_aes.c blktap2_xen//drivers/crypto/xts_aes.c
--- blktap2_oxt//drivers/crypto/xts_aes.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/crypto/xts_aes.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,82 +0,0 @@
-/*
- * Copyright (c) 2010, XenSource Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2014 Citrix Systems, Inc.
- */
-
-
-#include <err.h>
-#include <stdio.h>
-#include <stdint.h>
-#include <string.h>
-#include "compat-crypto-openssl.h"
-#include "xts_aes.h"
-
-struct crypto_blkcipher * xts_aes_setup(void)
-{
-	struct crypto_blkcipher *ret;
-
-	ret = calloc(1, sizeof(struct crypto_blkcipher));
-	if (!ret)
-		return NULL;
-	return ret;
-}
-
-int xts_aes_setkey(struct crypto_blkcipher *cipher, const uint8_t *key, unsigned int keysize)
-{
-	const EVP_CIPHER *type;
-
-	switch (keysize) {
-	case 64: type = EVP_aes_256_xts(); break;
-	case 32: type = EVP_aes_128_xts(); break;
-	default: return -21; break;
-	}
-
-	if (!type)
-		return -20;
-
-	EVP_CIPHER_CTX_init(&cipher->en_ctx);
-	EVP_CIPHER_CTX_init(&cipher->de_ctx);
-
-	/* TODO lazily initialize the encrypt context until doing an encryption,
-	 * since it's only needed for a writable node (top diff) */
-	if (!EVP_CipherInit_ex(&cipher->en_ctx, type, NULL, NULL, NULL, 1))
-		return -1;
-	if (!EVP_CipherInit_ex(&cipher->de_ctx, type, NULL, NULL, NULL, 0))
-		return -2;
-	if (!EVP_CIPHER_CTX_set_key_length(&cipher->en_ctx, keysize))
-		return -3;
-	if (!EVP_CipherInit_ex(&cipher->en_ctx, NULL, NULL, key, NULL, 1))
-		return -4;
-	if (!EVP_CIPHER_CTX_set_key_length(&cipher->de_ctx, keysize))
-		return -5;
-	if (!EVP_CipherInit_ex(&cipher->de_ctx, NULL, NULL, key, NULL, 0))
-		return -6;
-	return 0;
-}
diff -Nur blktap2_oxt//drivers/crypto/xts_aes.h blktap2_xen//drivers/crypto/xts_aes.h
--- blktap2_oxt//drivers/crypto/xts_aes.h	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/crypto/xts_aes.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,77 +0,0 @@
-/*
- * Copyright (c) 2010, XenSource Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2014 Citrix Systems, Inc.
- */
-
-
-extern struct crypto_blkcipher *xts_aes_setup(void);
-
-int xts_aes_setkey(struct crypto_blkcipher *cipher, const uint8_t *key, unsigned int keysize);
-
-typedef uint64_t sector_t;
-
-static inline void
-xts_aes_plain_iv_generate(uint8_t *iv, int iv_size, sector_t sector)
-{
-    memset(iv, 0, iv_size);
-    *(uint32_t *)iv = sector & 0xffffffff; /* LITTLE ENDIAN */
-}
-
-static inline int
-xts_aes_plain_encrypt(struct crypto_blkcipher *xts_tfm, sector_t sector,
-		      uint8_t *dst_buf, uint8_t *src_buf, unsigned int nbytes)
-{
-	uint8_t iv[16];
-	int dstlen;
-	xts_aes_plain_iv_generate(iv, 16, sector);
-
-	if (!EVP_CipherInit_ex(&xts_tfm->en_ctx, NULL, NULL, NULL, iv, -1))
-		return -1;
-	if (!EVP_CipherUpdate(&xts_tfm->en_ctx, dst_buf, &dstlen, src_buf, nbytes))
-		return -2;
-	/* no need to finalize with XTS when multiple of blocksize */
-	return 0;
-}
-
-static inline int
-xts_aes_plain_decrypt(struct crypto_blkcipher *xts_tfm, sector_t sector,
-		      uint8_t *dst_buf, uint8_t *src_buf, unsigned int nbytes)
-{
-	uint8_t iv[16];
-	int dstlen;
-	xts_aes_plain_iv_generate(iv, 16, sector);
-
-	if (!EVP_CipherInit_ex(&xts_tfm->de_ctx, NULL, NULL, NULL, iv, -1))
-		return -1;
-	if (!EVP_CipherUpdate(&xts_tfm->de_ctx, dst_buf, &dstlen, src_buf, nbytes))
-		return -2;
-	/* no need to finalize with XTS when multiple of blocksize */
-	return 0;
-}
diff -Nur blktap2_oxt//drivers/hashtable.c blktap2_xen//drivers/hashtable.c
--- blktap2_oxt//drivers/hashtable.c	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/hashtable.c	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,279 @@
+/* Copyright (C) 2004 Christopher Clark <firstname.lastname@cl.cam.ac.uk> */
+
+/*
+ * There are duplicates of this code in:
+ *  - tools/xenstore/hashtable.c
+ */
+
+#include "hashtable.h"
+#include "hashtable_private.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+
+/*
+Credit for primes table: Aaron Krowne
+ http://br.endernet.org/~akrowne/
+ http://planetmath.org/encyclopedia/GoodHashTablePrimes.html
+*/
+static const unsigned int primes[] = {
+	53, 97, 193, 389,
+	769, 1543, 3079, 6151,
+	12289, 24593, 49157, 98317,
+	196613, 393241, 786433, 1572869,
+	3145739, 6291469, 12582917, 25165843,
+	50331653, 100663319, 201326611, 402653189,
+	805306457, 1610612741
+};
+const unsigned int prime_table_length = sizeof(primes)/sizeof(primes[0]);
+const float max_load_factor = 0.65;
+
+/*****************************************************************************/
+struct hashtable *
+create_hashtable(unsigned int minsize,
+                 unsigned int (*hashf) (void*),
+                 int (*eqf) (void*,void*))
+{
+	struct hashtable *h;
+	unsigned int pindex, size = primes[0];
+	/* Check requested hashtable isn't too large */
+	if (minsize > (1u << 30)) return NULL;
+	/* Enforce size as prime */
+	for (pindex=0; pindex < prime_table_length; pindex++) {
+		if (primes[pindex] > minsize) { size = primes[pindex]; break; }
+	}
+	h = (struct hashtable *)malloc(sizeof(struct hashtable));
+	if (NULL == h) return NULL; /*oom*/
+	h->table = (struct entry **)malloc(sizeof(struct entry*) * size);
+	if (NULL == h->table) { free(h); return NULL; } /*oom*/
+	memset(h->table, 0, size * sizeof(struct entry *));
+	h->tablelength  = size;
+	h->primeindex   = pindex;
+	h->entrycount   = 0;
+	h->hashfn       = hashf;
+	h->eqfn         = eqf;
+	h->loadlimit    = (unsigned int) ceil(size * max_load_factor);
+	return h;
+}
+
+/*****************************************************************************/
+unsigned int
+hash(struct hashtable *h, void *k)
+{
+	/* Aim to protect against poor hash functions by adding logic here
+	 * - logic taken from java 1.4 hashtable source */
+	unsigned int i = h->hashfn(k);
+	i += ~(i << 9);
+	i ^=  ((i >> 14) | (i << 18)); /* >>> */
+	i +=  (i << 4);
+	i ^=  ((i >> 10) | (i << 22)); /* >>> */
+	return i;
+}
+
+/*****************************************************************************/
+static int
+hashtable_expand(struct hashtable *h)
+{
+	/* Double the size of the table to accomodate more entries */
+	struct entry **newtable;
+	struct entry *e;
+	struct entry **pE;
+	unsigned int newsize, i, index;
+	/* Check we're not hitting max capacity */
+	if (h->primeindex == (prime_table_length - 1)) return 0;
+	newsize = primes[++(h->primeindex)];
+
+	newtable = (struct entry **)malloc(sizeof(struct entry*) * newsize);
+	if (NULL != newtable)
+	{
+		memset(newtable, 0, newsize * sizeof(struct entry *));
+		/* This algorithm is not 'stable'. ie. it reverses the list
+		 * when it transfers entries between the tables */
+		for (i = 0; i < h->tablelength; i++) {
+			while (NULL != (e = h->table[i])) {
+				h->table[i] = e->next;
+				index = indexFor(newsize,e->h);
+				e->next = newtable[index];
+				newtable[index] = e;
+			}
+		}
+		free(h->table);
+		h->table = newtable;
+	}
+	/* Plan B: realloc instead */
+	else
+	{
+		newtable = (struct entry **)
+			realloc(h->table, newsize * sizeof(struct entry *));
+		if (NULL == newtable) { (h->primeindex)--; return 0; }
+		h->table = newtable;
+		memset(newtable[h->tablelength], 0, newsize - h->tablelength);
+		for (i = 0; i < h->tablelength; i++) {
+			for (pE = &(newtable[i]), e = *pE; e != NULL; e = *pE) {
+				index = indexFor(newsize,e->h);
+				if (index == i)
+				{
+					pE = &(e->next);
+				}
+				else
+				{
+					*pE = e->next;
+					e->next = newtable[index];
+					newtable[index] = e;
+				}
+			}
+		}
+	}
+	h->tablelength = newsize;
+	h->loadlimit   = (unsigned int) ceil(newsize * max_load_factor);
+	return -1;
+}
+
+/*****************************************************************************/
+unsigned int
+hashtable_count(struct hashtable *h)
+{
+	return h->entrycount;
+}
+
+/*****************************************************************************/
+int
+hashtable_insert(struct hashtable *h, void *k, void *v)
+{
+	/* This method allows duplicate keys - but they shouldn't be used */
+	unsigned int index;
+	struct entry *e;
+	if (++(h->entrycount) > h->loadlimit)
+	{
+		/* Ignore the return value. If expand fails, we should
+		 * still try cramming just this value into the existing table
+		 * -- we may not have memory for a larger table, but one more
+		 * element may be ok. Next time we insert, we'll try expanding again.*/
+		hashtable_expand(h);
+	}
+	e = (struct entry *)malloc(sizeof(struct entry));
+	if (NULL == e) { --(h->entrycount); return 0; } /*oom*/
+	e->h = hash(h,k);
+	index = indexFor(h->tablelength,e->h);
+	e->k = k;
+	e->v = v;
+	e->next = h->table[index];
+	h->table[index] = e;
+	return -1;
+}
+
+/*****************************************************************************/
+void * /* returns value associated with key */
+hashtable_search(struct hashtable *h, void *k)
+{
+	struct entry *e;
+	unsigned int hashvalue, index;
+	hashvalue = hash(h,k);
+	index = indexFor(h->tablelength,hashvalue);
+	e = h->table[index];
+	while (NULL != e)
+	{
+		/* Check hash value to short circuit heavier comparison */
+		if ((hashvalue == e->h) && (h->eqfn(k, e->k))) return e->v;
+		e = e->next;
+	}
+	return NULL;
+}
+
+/*****************************************************************************/
+void * /* returns value associated with key */
+hashtable_remove(struct hashtable *h, void *k)
+{
+	/* TODO: consider compacting the table when the load factor drops enough,
+	 *       or provide a 'compact' method. */
+
+	struct entry *e;
+	struct entry **pE;
+	void *v;
+	unsigned int hashvalue, index;
+
+	hashvalue = hash(h,k);
+	index = indexFor(h->tablelength,hash(h,k));
+	pE = &(h->table[index]);
+	e = *pE;
+	while (NULL != e)
+	{
+		/* Check hash value to short circuit heavier comparison */
+		if ((hashvalue == e->h) && (h->eqfn(k, e->k)))
+		{
+			*pE = e->next;
+			h->entrycount--;
+			v = e->v;
+			freekey(e->k);
+			free(e);
+			return v;
+		}
+		pE = &(e->next);
+		e = e->next;
+	}
+	return NULL;
+}
+
+/*****************************************************************************/
+/* destroy */
+void
+hashtable_destroy(struct hashtable *h, int free_values)
+{
+	unsigned int i;
+	struct entry *e, *f;
+	struct entry **table = h->table;
+	if (free_values)
+	{
+		for (i = 0; i < h->tablelength; i++)
+		{
+			e = table[i];
+			while (NULL != e)
+			{ f = e; e = e->next; freekey(f->k); free(f->v); free(f); }
+		}
+	}
+	else
+	{
+		for (i = 0; i < h->tablelength; i++)
+		{
+			e = table[i];
+			while (NULL != e)
+			{ f = e; e = e->next; freekey(f->k); free(f); }
+		}
+	}
+	free(h->table);
+	free(h);
+}
+
+/*
+ * Copyright (c) 2002, Christopher Clark
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of the original author; nor the names of any contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
diff -Nur blktap2_oxt//drivers/hashtable.h blktap2_xen//drivers/hashtable.h
--- blktap2_oxt//drivers/hashtable.h	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/hashtable.h	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,204 @@
+/* Copyright (C) 2002 Christopher Clark <firstname.lastname@cl.cam.ac.uk> */
+
+/*
+ * There are duplicates of this code in:
+ *  - tools/xenstore/hashtable.h
+ */
+
+#ifndef __HASHTABLE_CWC22_H__
+#define __HASHTABLE_CWC22_H__
+
+struct hashtable;
+
+/* Example of use:
+ *
+ *      struct hashtable  *h;
+ *      struct some_key   *k;
+ *      struct some_value *v;
+ *
+ *      static unsigned int         hash_from_key_fn( void *k );
+ *      static int                  keys_equal_fn ( void *key1, void *key2 );
+ *
+ *      h = create_hashtable(16, hash_from_key_fn, keys_equal_fn);
+ *      k = (struct some_key *)     malloc(sizeof(struct some_key));
+ *      v = (struct some_value *)   malloc(sizeof(struct some_value));
+ *
+ *      (initialise k and v to suitable values)
+ *
+ *      if (! hashtable_insert(h,k,v) )
+ *      {     exit(-1);               }
+ *
+ *      if (NULL == (found = hashtable_search(h,k) ))
+ *      {    printf("not found!");                  }
+ *
+ *      if (NULL == (found = hashtable_remove(h,k) ))
+ *      {    printf("Not found\n");                 }
+ *
+ */
+
+/* Macros may be used to define type-safe(r) hashtable access functions, with
+ * methods specialized to take known key and value types as parameters.
+ *
+ * Example:
+ *
+ * Insert this at the start of your file:
+ *
+ * DEFINE_HASHTABLE_INSERT(insert_some, struct some_key, struct some_value);
+ * DEFINE_HASHTABLE_SEARCH(search_some, struct some_key, struct some_value);
+ * DEFINE_HASHTABLE_REMOVE(remove_some, struct some_key, struct some_value);
+ *
+ * This defines the functions 'insert_some', 'search_some' and 'remove_some'.
+ * These operate just like hashtable_insert etc., with the same parameters,
+ * but their function signatures have 'struct some_key *' rather than
+ * 'void *', and hence can generate compile time errors if your program is
+ * supplying incorrect data as a key (and similarly for value).
+ *
+ * Note that the hash and key equality functions passed to create_hashtable
+ * still take 'void *' parameters instead of 'some key *'. This shouldn't be
+ * a difficult issue as they're only defined and passed once, and the other
+ * functions will ensure that only valid keys are supplied to them.
+ *
+ * The cost for this checking is increased code size and runtime overhead
+ * - if performance is important, it may be worth switching back to the
+ * unsafe methods once your program has been debugged with the safe methods.
+ * This just requires switching to some simple alternative defines - eg:
+ * #define insert_some hashtable_insert
+ *
+ */
+
+/*****************************************************************************
+ * create_hashtable
+
+ * @name                    create_hashtable
+ * @param   minsize         minimum initial size of hashtable
+ * @param   hashfunction    function for hashing keys
+ * @param   key_eq_fn       function for determining key equality
+ * @return                  newly created hashtable or NULL on failure
+ */
+
+struct hashtable *
+create_hashtable(unsigned int minsize,
+                 unsigned int (*hashfunction) (void*),
+                 int (*key_eq_fn) (void*,void*));
+
+/*****************************************************************************
+ * hashtable_insert
+
+ * @name        hashtable_insert
+ * @param   h   the hashtable to insert into
+ * @param   k   the key - hashtable claims ownership and will free on removal
+ * @param   v   the value - does not claim ownership
+ * @return      non-zero for successful insertion
+ *
+ * This function will cause the table to expand if the insertion would take
+ * the ratio of entries to table size over the maximum load factor.
+ *
+ * This function does not check for repeated insertions with a duplicate key.
+ * The value returned when using a duplicate key is undefined -- when
+ * the hashtable changes size, the order of retrieval of duplicate key
+ * entries is reversed.
+ * If in doubt, remove before insert.
+ */
+
+int
+hashtable_insert(struct hashtable *h, void *k, void *v);
+
+#define DEFINE_HASHTABLE_INSERT(fnname, keytype, valuetype) \
+int fnname (struct hashtable *h, keytype *k, valuetype *v) \
+{ \
+    return hashtable_insert(h,k,v); \
+}
+
+/*****************************************************************************
+ * hashtable_search
+
+ * @name        hashtable_search
+ * @param   h   the hashtable to search
+ * @param   k   the key to search for  - does not claim ownership
+ * @return      the value associated with the key, or NULL if none found
+ */
+
+void *
+hashtable_search(struct hashtable *h, void *k);
+
+#define DEFINE_HASHTABLE_SEARCH(fnname, keytype, valuetype) \
+valuetype * fnname (struct hashtable *h, keytype *k) \
+{ \
+    return (valuetype *) (hashtable_search(h,k)); \
+}
+
+/*****************************************************************************
+ * hashtable_remove
+
+ * @name        hashtable_remove
+ * @param   h   the hashtable to remove the item from
+ * @param   k   the key to search for  - does not claim ownership
+ * @return      the value associated with the key, or NULL if none found
+ */
+
+void * /* returns value */
+hashtable_remove(struct hashtable *h, void *k);
+
+#define DEFINE_HASHTABLE_REMOVE(fnname, keytype, valuetype) \
+valuetype * fnname (struct hashtable *h, keytype *k) \
+{ \
+    return (valuetype *) (hashtable_remove(h,k)); \
+}
+
+
+/*****************************************************************************
+ * hashtable_count
+
+ * @name        hashtable_count
+ * @param   h   the hashtable
+ * @return      the number of items stored in the hashtable
+ */
+unsigned int
+hashtable_count(struct hashtable *h);
+
+
+/*****************************************************************************
+ * hashtable_destroy
+
+ * @name        hashtable_destroy
+ * @param   h   the hashtable
+ * @param       free_values     whether to call 'free' on the remaining values
+ */
+
+void
+hashtable_destroy(struct hashtable *h, int free_values);
+
+#endif /* __HASHTABLE_CWC22_H__ */
+
+/*
+ * Copyright (c) 2002, Christopher Clark
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of the original author; nor the names of any contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
diff -Nur blktap2_oxt//drivers/hashtable_itr.c blktap2_xen//drivers/hashtable_itr.c
--- blktap2_oxt//drivers/hashtable_itr.c	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/hashtable_itr.c	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,195 @@
+/* Copyright (C) 2002, 2004 Christopher Clark  <firstname.lastname@cl.cam.ac.uk> */
+
+#include "hashtable.h"
+#include "hashtable_private.h"
+#include "hashtable_itr.h"
+#include <stdlib.h> /* defines NULL */
+
+struct hashtable_itr {
+	struct hashtable *h;
+	struct entry *e;
+	struct entry *parent;
+	unsigned int index;
+};
+
+/*****************************************************************************/
+/* hashtable_iterator    - iterator constructor */
+
+struct hashtable_itr *
+hashtable_iterator(struct hashtable *h)
+{
+	unsigned int i, tablelength;
+	struct hashtable_itr *itr = (struct hashtable_itr *)
+		malloc(sizeof(struct hashtable_itr));
+	if (NULL == itr) return NULL;
+	itr->h = h;
+	itr->e = NULL;
+	itr->parent = NULL;
+	tablelength = h->tablelength;
+	itr->index = tablelength;
+	if (0 == h->entrycount) return itr;
+
+	for (i = 0; i < tablelength; i++)
+	{
+		if (NULL != h->table[i])
+		{
+			itr->e = h->table[i];
+			itr->index = i;
+			break;
+		}
+	}
+	return itr;
+}
+
+/*****************************************************************************/
+/* key      - return the key of the (key,value) pair at the current position */
+/* value    - return the value of the (key,value) pair at the current position */
+
+void *
+hashtable_iterator_key(struct hashtable_itr *i)
+{ return i->e->k; }
+
+void *
+hashtable_iterator_value(struct hashtable_itr *i)
+{ return i->e->v; }
+
+/*****************************************************************************/
+/* advance - advance the iterator to the next element
+ *           returns zero if advanced to end of table */
+
+int
+hashtable_iterator_advance(struct hashtable_itr *itr)
+{
+	unsigned int j,tablelength;
+	struct entry **table;
+	struct entry *next;
+	if (NULL == itr->e) return 0; /* stupidity check */
+
+	next = itr->e->next;
+	if (NULL != next)
+	{
+		itr->parent = itr->e;
+		itr->e = next;
+		return -1;
+	}
+	tablelength = itr->h->tablelength;
+	itr->parent = NULL;
+	if (tablelength <= (j = ++(itr->index)))
+	{
+		itr->e = NULL;
+		return 0;
+	}
+	table = itr->h->table;
+	while (NULL == (next = table[j]))
+	{
+		if (++j >= tablelength)
+		{
+			itr->index = tablelength;
+			itr->e = NULL;
+			return 0;
+		}
+	}
+	itr->index = j;
+	itr->e = next;
+	return -1;
+}
+
+/*****************************************************************************/
+/* remove - remove the entry at the current iterator position
+ *          and advance the iterator, if there is a successive
+ *          element.
+ *          If you want the value, read it before you remove:
+ *          beware memory leaks if you don't.
+ *          Returns zero if end of iteration. */
+
+int
+hashtable_iterator_remove(struct hashtable_itr *itr)
+{
+	struct entry *remember_e, *remember_parent;
+	int ret;
+
+	/* Do the removal */
+	if (NULL == (itr->parent))
+	{
+		/* element is head of a chain */
+		itr->h->table[itr->index] = itr->e->next;
+	} else {
+		/* element is mid-chain */
+		itr->parent->next = itr->e->next;
+	}
+	/* itr->e is now outside the hashtable */
+	remember_e = itr->e;
+	itr->h->entrycount--;
+	freekey(remember_e->k);
+
+	/* Advance the iterator, correcting the parent */
+	remember_parent = itr->parent;
+	ret = hashtable_iterator_advance(itr);
+	if (itr->parent == remember_e) { itr->parent = remember_parent; }
+	free(remember_e);
+	return ret;
+}
+
+/*****************************************************************************/
+int /* returns zero if not found */
+hashtable_iterator_search(struct hashtable_itr *itr,
+                          struct hashtable *h, void *k)
+{
+	struct entry *e, *parent;
+	unsigned int hashvalue, index;
+
+	hashvalue = hash(h,k);
+	index = indexFor(h->tablelength,hashvalue);
+
+	e = h->table[index];
+	parent = NULL;
+	while (NULL != e)
+	{
+		/* Check hash value to short circuit heavier comparison */
+		if ((hashvalue == e->h) && (h->eqfn(k, e->k)))
+		{
+			itr->index = index;
+			itr->e = e;
+			itr->parent = parent;
+			itr->h = h;
+			return -1;
+		}
+		parent = e;
+		e = e->next;
+	}
+	return 0;
+}
+
+
+/*
+ * Copyright (c) 2002, 2004, Christopher Clark
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of the original author; nor the names of any contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
diff -Nur blktap2_oxt//drivers/hashtable_itr.h blktap2_xen//drivers/hashtable_itr.h
--- blktap2_oxt//drivers/hashtable_itr.h	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/hashtable_itr.h	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,96 @@
+/* Copyright (C) 2002, 2004 Christopher Clark <firstname.lastname@cl.cam.ac.uk> */
+
+#ifndef __HASHTABLE_ITR_CWC22__
+#define __HASHTABLE_ITR_CWC22__
+#include "hashtable.h"
+#include "hashtable_private.h" /* needed to enable inlining */
+
+struct hashtable_itr;
+
+/*****************************************************************************/
+/* hashtable_iterator
+ */
+
+struct hashtable_itr *
+hashtable_iterator(struct hashtable *h);
+
+/*****************************************************************************/
+/* hashtable_iterator_key
+ * - return the value of the (key,value) pair at the current position */
+
+void *
+hashtable_iterator_key(struct hashtable_itr *i);
+
+/*****************************************************************************/
+/* value - return the value of the (key,value) pair at the current position */
+
+void *
+hashtable_iterator_value(struct hashtable_itr *i);
+
+/*****************************************************************************/
+/* advance - advance the iterator to the next element
+ *           returns zero if advanced to end of table */
+
+int
+hashtable_iterator_advance(struct hashtable_itr *itr);
+
+/*****************************************************************************/
+/* remove - remove current element and advance the iterator to the next element
+ *          NB: if you need the value to free it, read it before
+ *          removing. ie: beware memory leaks!
+ *          returns zero if advanced to end of table */
+
+int
+hashtable_iterator_remove(struct hashtable_itr *itr);
+
+/*****************************************************************************/
+/* search - overwrite the supplied iterator, to point to the entry
+ *          matching the supplied key.
+            h points to the hashtable to be searched.
+ *          returns zero if not found. */
+int
+hashtable_iterator_search(struct hashtable_itr *itr,
+                          struct hashtable *h, void *k);
+
+#define DEFINE_HASHTABLE_ITERATOR_SEARCH(fnname, keytype) \
+int fnname (struct hashtable_itr *i, struct hashtable *h, keytype *k) \
+{ \
+    return (hashtable_iterator_search(i,h,k)); \
+}
+
+
+
+#endif /* __HASHTABLE_ITR_CWC22__*/
+
+/*
+ * Copyright (c) 2002, 2004, Christopher Clark
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of the original author; nor the names of any contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
diff -Nur blktap2_oxt//drivers/hashtable_private.h blktap2_xen//drivers/hashtable_private.h
--- blktap2_oxt//drivers/hashtable_private.h	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/hashtable_private.h	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,90 @@
+/* Copyright (C) 2002, 2004 Christopher Clark <firstname.lastname@cl.cam.ac.uk> */
+
+/*
+ * There are duplicates of this code in:
+ *  - tools/xenstore/hashtable_private.h
+ */
+
+#ifndef __HASHTABLE_PRIVATE_CWC22_H__
+#define __HASHTABLE_PRIVATE_CWC22_H__
+
+#include "hashtable.h"
+
+/*****************************************************************************/
+struct entry
+{
+    void *k, *v;
+    unsigned int h;
+    struct entry *next;
+};
+
+struct hashtable {
+    unsigned int tablelength;
+    struct entry **table;
+    unsigned int entrycount;
+    unsigned int loadlimit;
+    unsigned int primeindex;
+    unsigned int (*hashfn) (void *k);
+    int (*eqfn) (void *k1, void *k2);
+};
+
+/*****************************************************************************/
+unsigned int
+hash(struct hashtable *h, void *k);
+
+/*****************************************************************************/
+/* indexFor */
+static inline unsigned int
+indexFor(unsigned int tablelength, unsigned int hashvalue) {
+    return (hashvalue % tablelength);
+};
+
+/* Only works if tablelength == 2^N */
+/*static inline unsigned int
+indexFor(unsigned int tablelength, unsigned int hashvalue)
+{
+    return (hashvalue & (tablelength - 1u));
+}
+*/
+
+/*****************************************************************************/
+#define freekey(X) free(X)
+/*define freekey(X) ; */
+
+
+/*****************************************************************************/
+
+#endif /* __HASHTABLE_PRIVATE_CWC22_H__*/
+
+/*
+ * Copyright (c) 2002, Christopher Clark
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of the original author; nor the names of any contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
diff -Nur blktap2_oxt//drivers/hashtable_utility.c blktap2_xen//drivers/hashtable_utility.c
--- blktap2_oxt//drivers/hashtable_utility.c	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/hashtable_utility.c	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,71 @@
+/* Copyright (C) 2002 Christopher Clark <firstname.lastname@cl.cam.ac.uk> */
+
+#include "hashtable.h"
+#include "hashtable_private.h"
+#include "hashtable_utility.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+/*****************************************************************************/
+/* hashtable_change
+ *
+ * function to change the value associated with a key, where there already
+ * exists a value bound to the key in the hashtable.
+ * Source due to Holger Schemel.
+ *
+ *  */
+int
+hashtable_change(struct hashtable *h, void *k, void *v)
+{
+	struct entry *e;
+	unsigned int hashvalue, index;
+	hashvalue = hash(h,k);
+	index = indexFor(h->tablelength,hashvalue);
+	e = h->table[index];
+	while (NULL != e)
+	{
+		/* Check hash value to short circuit heavier comparison */
+		if ((hashvalue == e->h) && (h->eqfn(k, e->k)))
+		{
+			free(e->v);
+			e->v = v;
+			return -1;
+		}
+		e = e->next;
+	}
+	return 0;
+}
+
+/*
+ * Copyright (c) 2002, Christopher Clark
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of the original author; nor the names of any contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
diff -Nur blktap2_oxt//drivers/hashtable_utility.h blktap2_xen//drivers/hashtable_utility.h
--- blktap2_oxt//drivers/hashtable_utility.h	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/hashtable_utility.h	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,55 @@
+/* Copyright (C) 2002 Christopher Clark <firstname.lastname@cl.cam.ac.uk> */
+
+#ifndef __HASHTABLE_CWC22_UTILITY_H__
+#define __HASHTABLE_CWC22_UTILITY_H__
+
+/*****************************************************************************
+ * hashtable_change
+ *
+ * function to change the value associated with a key, where there already
+ * exists a value bound to the key in the hashtable.
+ * Source due to Holger Schemel.
+ *
+ * @name        hashtable_change
+ * @param   h   the hashtable
+ * @param       key
+ * @param       value
+ *
+ */
+int
+hashtable_change(struct hashtable *h, void *k, void *v);
+
+#endif /* __HASHTABLE_CWC22_H__ */
+
+/*
+ * Copyright (c) 2002, Christopher Clark
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of the original author; nor the names of any contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
diff -Nur blktap2_oxt//drivers/img2qcow.c blktap2_xen//drivers/img2qcow.c
--- blktap2_oxt//drivers/img2qcow.c	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/img2qcow.c	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,316 @@
+/* img2qcow.c
+ *
+ * Generates a qcow format disk and fills it from an existing image.
+ *
+ * (c) 2006 Julian Chesterfield and Andrew Warfield
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation; or, when distributed
+ * separately from the Linux kernel or incorporated into other
+ * software packages, subject to the following license:
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this source file (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/statvfs.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <string.h>
+#include <zlib.h>
+#include <inttypes.h>
+#include <libaio.h>
+
+#include "bswap.h"
+#include "aes.h"
+#include "tapdisk.h"
+#include "tapdisk-server.h"
+#include "tapdisk-driver.h"
+#include "tapdisk-interface.h"
+#include "tapdisk-disktype.h"
+#include "qcow.h"
+#include "blk.h"
+
+
+#if 1
+#define DFPRINTF(_f, _a...) fprintf ( stderr, _f , ## _a )
+#else
+#define DFPRINTF(_f, _a...) ((void)0)
+#endif
+
+/* *BSD has no O_LARGEFILE */
+#ifndef O_LARGEFILE
+#define O_LARGEFILE	0
+#endif
+
+#define BLOCK_PROCESSSZ 4096
+#define QCOW_VBD 0
+#define PROGRESS_QUANT 2
+
+static int running = 1, complete = 0;
+static int returned_events = 0, submit_events = 0;
+static uint32_t read_idx = 0;
+td_driver_t *ddqcow;
+td_vbd_t* qcow_vbd;
+static uint64_t prev = 0, written = 0;
+static char output[(100/PROGRESS_QUANT) + 5];
+
+extern tapdisk_server_t server;
+
+
+static void print_bytes(void *ptr, int length)
+{
+  int i,k;
+  unsigned char *p = ptr;
+
+    DFPRINTF("Buf dump, length %d:\n",length);
+    for (k = 0; k < length; k++) {
+        DFPRINTF("%x",*p);
+        *p++;
+	if(k % 16 == 0) DFPRINTF("\n");
+        else if(k % 2 == 0) DFPRINTF(" ");	
+    }
+    DFPRINTF("\n");
+    return;
+}
+
+static void debug_output(uint64_t progress, uint64_t size)
+{
+  //Output progress every PROGRESS_QUANT                                  
+  uint64_t blocks = size/(100/PROGRESS_QUANT);
+
+  if (progress/blocks > prev) {
+    memcpy(output+prev+1,"=>",2);
+    prev++;
+    DFPRINTF("\r%s     %"PRIi64"%%",
+             output, (int64_t)((prev-1)*PROGRESS_QUANT));
+  }
+  return;
+}
+
+static int get_image_info(td_disk_info_t *driver, int fd)
+{
+	int ret;
+	long size;
+	unsigned long total_size;
+	struct statvfs statBuf;
+	struct stat stat;
+	uint64_t sector_size=DEFAULT_SECTOR_SIZE;
+
+	ret = fstat(fd, &stat);
+	if (ret != 0) {
+		DFPRINTF("ERROR: fstat failed, Couldn't stat image");
+		return -EINVAL;
+	}
+
+	if (S_ISBLK(stat.st_mode)) {
+		/*Accessing block device directly*/
+		if (blk_getimagesize(fd, &driver->size) != 0)
+			return -EINVAL;
+
+		DFPRINTF("Image size: \n\tpre sector_shift  [%"PRIu64"]\n\tpost "
+			"sector_shift [%"PRIu64"]\n",
+			(uint64_t)(driver->size << SECTOR_SHIFT),
+			(uint64_t)driver->size);
+
+		/*Get the sector size*/
+		if (!blk_getsectorsize(fd, &sector_size))
+		  driver->sector_size = sector_size;
+
+	} else {
+		/*Local file? try fstat instead*/
+		driver->size = (stat.st_size >> SECTOR_SHIFT);
+		driver->sector_size = DEFAULT_SECTOR_SIZE;
+		DFPRINTF("Image size: [%"PRIu64"]\n",
+			(uint64_t)driver->size);
+	}
+
+	return 0;
+}
+
+void send_responses(td_request_t treq, int err)
+{
+  if (err < 0) {
+    DFPRINTF("AIO FAILURE: res [%d]!\n",err);
+    return;
+  }
+
+  returned_events++;
+
+  free(treq.buf);
+} 
+
+int main(int argc, const char *argv[])
+{
+        int ret = -1, fd, len, err;
+	struct timeval timeout;
+	uint64_t i;
+	char *buf;
+	td_request_t treq;
+        td_disk_info_t info;
+        td_vbd_request_t* vreq;
+
+	if (argc != 3) {
+		fprintf(stderr, "Qcow-utils: v1.0.0\n");
+		fprintf(stderr, "usage: %s <QCOW FILENAME> <SRC IMAGE>\n", 
+			argv[0]);
+		exit(-1);
+	}
+
+
+	/*Open image*/
+	fd = open(argv[2], O_RDONLY | O_LARGEFILE);
+	
+        if (fd == -1) {
+                DFPRINTF("Unable to open [%s], (err %d)!\n",argv[2],0 - errno);
+                exit(-1);
+        }
+	
+	get_image_info(&info, fd);
+
+	/*Create qcow file*/
+	ret = qcow_create(argv[1],info.size<<SECTOR_SHIFT,NULL,0);
+	
+	if (ret < 0) {
+		DFPRINTF("Unable to create QCOW file\n");
+		exit(-1);
+	} else DFPRINTF("Qcow file created: size %"PRIu64" sectors\n",
+			(uint64_t)info.size);
+	
+        /* Open Qcow image*/
+        err = tapdisk_server_initialize();
+        if( err ) {
+          DPRINTF("qcow2raw Couldn't initialize server instance.\n");
+          return err;
+        }
+
+        err=tapdisk_vbd_initialize(QCOW_VBD);
+        if( err ) {
+          DPRINTF("qcow2raw Couldn't initialize qcow vbd.\n");
+          return err;
+        }
+
+        qcow_vbd = tapdisk_server_get_vbd(QCOW_VBD);
+        if (!qcow_vbd) {
+          err = -ENODEV;
+          DPRINTF("qcow2raw Couldn't create qcow vbd.\n");
+          return err;
+        }
+
+        err = tapdisk_vbd_open_vdi(qcow_vbd, argv[1], DISK_TYPE_QCOW,
+                                   TAPDISK_STORAGE_TYPE_DEFAULT,
+                                   0);
+        if( err ) {
+          DPRINTF("qcow2raw Couldn't open qcow file.\n");
+          return err;
+        }
+
+        ddqcow=(tapdisk_vbd_first_image(qcow_vbd))->driver;
+
+        /*Initialise the output string*/
+        memset(output,0x20,(100/PROGRESS_QUANT)+5);
+        output[0] = '[';
+        output[(100/PROGRESS_QUANT)+2] = ']';
+        output[(100/PROGRESS_QUANT)+3] = '\0';
+        DFPRINTF("%s",output);
+
+	i = 0;
+	while (running) {
+		
+		if (!complete) {
+			/*Read sector from image*/
+			if (lseek(fd, i*512, SEEK_SET) == (off_t)-1) {
+				DFPRINTF("Unable to access file offset %"PRIu64"\n",
+				       (uint64_t)i*512);
+				exit(-1);
+			}
+			
+			if( (ret = posix_memalign((void **)&buf, 
+						  BLOCK_PROCESSSZ, 
+						  BLOCK_PROCESSSZ)) != 0) {
+				DFPRINTF("Unable to read memalign buf (%d)\n",ret);
+				exit(-1);				
+			}
+		
+			/*We attempt to read 4k sized blocks*/
+			len = read(fd, buf, BLOCK_PROCESSSZ);
+			if (len < 512) {
+				DFPRINTF("Unable to read sector %"PRIu64"\n",
+					 (uint64_t) (i));
+				complete = 1;
+				continue;
+			}
+			
+			len = (len >> 9);
+
+			treq.op = TD_OP_WRITE;
+			treq.buf = buf;
+			treq.sec = i;
+			treq.secs = len;
+			treq.image = 0;
+			treq.cb = send_responses;
+			treq.cb_data = buf;
+			treq.id = 0;
+			treq.sidx = 0;
+                        vreq = calloc(1, sizeof(td_vbd_request_t));
+			treq.private = vreq; 
+                        
+			vreq->submitting = 1;
+                        INIT_LIST_HEAD(&vreq->next);
+                        tapdisk_vbd_move_request(treq.private,
+                                                 &qcow_vbd->pending_requests);
+
+                        ddqcow->ops->td_queue_write(ddqcow,treq);
+                        --vreq->submitting;
+
+			submit_events++;
+
+			i += len;
+
+			if (i == info.size) 
+			  complete = 1;
+
+                        tapdisk_submit_all_tiocbs(&server.aio_queue);
+			debug_output(i,info.size);
+                }
+		
+		while(returned_events != submit_events) {
+		    ret = scheduler_wait_for_events(&server.scheduler);
+		    if (ret < 0) {
+		      DFPRINTF("server wait returned %d\n", ret);
+		      sleep(2);
+		    }
+		}
+
+		if (complete && (returned_events == submit_events)) 
+			running = 0;
+	}
+	memcpy(output+prev+1,"=",1);
+	DFPRINTF("\r%s     100%%\nTRANSFER COMPLETE\n\n", output);
+
+        ddqcow->ops->td_close(ddqcow);
+        free(ddqcow->data);
+
+	return 0;
+}
diff -Nur blktap2_oxt//drivers/io-optimize.c blktap2_xen//drivers/io-optimize.c
--- blktap2_oxt//drivers/io-optimize.c	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/io-optimize.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,5 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* 
+ * Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,7 +24,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
+*/
 
 #include <time.h>
 #include <stdio.h>
diff -Nur blktap2_oxt//drivers/io-optimize.h blktap2_xen//drivers/io-optimize.h
--- blktap2_oxt//drivers/io-optimize.h	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/io-optimize.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,11 +1,30 @@
-/* Copyright (c) 2007, XenSource Inc.
+/* 
+ * Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
- */
-
-/*
- * Copyright (c) 2008 Citrix Systems, Inc.
- */
-
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of XenSource Inc. nor the names of its contributors
+ *       may be used to endorse or promote products derived from this software
+ *       without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
 
 #ifndef __IO_OPTIMIZE_H__
 #define __IO_OPTIMIZE_H__
diff -Nur blktap2_oxt//drivers/libaio-compat.h blktap2_xen//drivers/libaio-compat.h
--- blktap2_oxt//drivers/libaio-compat.h	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/libaio-compat.h	2015-03-19 11:08:36.000000000 -0400
@@ -19,11 +19,6 @@
  */
 
 /*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
-/*
  * kernel 2.6.21 added eventfd(2) support, kernel 2.6.22 eventfds for
  * aio. libaio 0.3.107 updated the header file, but few systems have
  * it. define a custom iocb_common struct instead, and work around a
@@ -34,6 +29,7 @@
 #ifndef __LIBAIO_COMPAT
 #define __LIBAIO_COMPAT
 
+#include "../../config.h"
 #include <libaio.h>
 #include <unistd.h>
 #include <sys/syscall.h>
@@ -55,6 +51,16 @@
 	c->resfd = eventfd;
 }
 
+#ifdef HAVE_SYS_EVENTFD_H
+
+#include <sys/eventfd.h>
+
+static inline int tapdisk_sys_eventfd(int initval)
+{
+	return eventfd(initval, 0);
+}
+
+#else /* Fallback */
 #ifndef SYS_eventfd
 #ifndef __NR_eventfd
 # if defined(__alpha__)
@@ -93,5 +99,6 @@
 {
 	return syscall(SYS_eventfd, initval, 0);
 }
+#endif
 
 #endif /* __LIBAIO_COMPAT */
diff -Nur blktap2_oxt//drivers/lock.c blktap2_xen//drivers/lock.c
--- blktap2_oxt//drivers/lock.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/lock.c	2015-03-19 11:08:36.000000000 -0400
@@ -27,11 +27,6 @@
  */
 
 /*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
-/*
  * This module implements a "dot locking" style advisory file locking algorithm.
  */
 
@@ -255,7 +250,7 @@
                         }
                 }
                 dptr = readdir(pd);
-                if (!dptr && !errno) {
+                if (!dptr && errno) {
                     *ioerror = EIO;
                 }
         }
diff -Nur blktap2_oxt//drivers/lock.h blktap2_xen//drivers/lock.h
--- blktap2_oxt//drivers/lock.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/lock.h	2015-03-19 11:08:36.000000000 -0400
@@ -26,11 +26,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2008 Citrix Systems, Inc.
- */
-
-
 #define DEFAULT_LEASE_TIME_SECS 30
 
 int lock(char *fn_to_lock, char *uuid, int force, int readonly, int *lease_time, int *retstat);
diff -Nur blktap2_oxt//drivers/log.h blktap2_xen//drivers/log.h
--- blktap2_oxt//drivers/log.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/log.h	2015-03-19 11:08:36.000000000 -0400
@@ -26,11 +26,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2008 Citrix Systems, Inc.
- */
-
-
 /* log.h: API for writelog communication */
 
 #ifndef __LOG_H__
@@ -38,9 +33,9 @@
 
 #include <inttypes.h>
 
+#include <xen/io/ring.h>
 /* for wmb et al */
 #include <xenctrl.h>
-#include <xen/io/ring.h>
 
 #define LOGCMD_SHMP  "shmp"
 #define LOGCMD_PEEK  "peek"
diff -Nur blktap2_oxt//drivers/Makefile blktap2_xen//drivers/Makefile
--- blktap2_oxt//drivers/Makefile	2016-03-14 14:24:58.156021126 -0400
+++ blktap2_xen//drivers/Makefile	2015-03-19 11:08:36.000000000 -0400
@@ -1,108 +1,116 @@
-#
-# Copyright (c) 2014 Citrix Systems, Inc.
-#
-
+XEN_ROOT=$(CURDIR)/../../..
 BLKTAP_ROOT= ..
-include $(BLKTAP_ROOT)/Rules.mk
+include $(XEN_ROOT)/tools/Rules.mk
 
 LIBVHDDIR  = $(BLKTAP_ROOT)/vhd/lib
 
-IBIN       = tapdisk2 td-util tapdisk-stream tapdisk-diff
+IBIN       = tapdisk2 td-util tapdisk-client tapdisk-stream tapdisk-diff
+QCOW_UTIL  = img2qcow qcow-create qcow2raw
 LOCK_UTIL  = lock-util
-INST_DIR   = /usr/sbin
+INST_DIR   = $(SBINDIR)
 
-CFLAGS    += -Wall
-CFLAGS    += -g
+CFLAGS    += -Werror -g
 CFLAGS    += -Wno-unused
 CFLAGS    += -fno-strict-aliasing
-CFLAGS    += -I../include
+CFLAGS    += -I$(BLKTAP_ROOT)/include -I$(BLKTAP_ROOT)/drivers
+CFLAGS    += $(CFLAGS_libxenctrl)
 CFLAGS    += -D_GNU_SOURCE
 CFLAGS    += -DUSE_NFS_LOCKS
-CFLAGS    += -DTAPDISK
 
-LIBS      += -lrt
+ifeq ($(CONFIG_X86_64),y)
+CFLAGS            += -fPIC
+endif
 
-# Get gcc to generate the dependencies for us.
-CFLAGS    += -Wp,-MD,.$(@F).d
-DEPS       = .*.d
+VHDLIBS    := -L$(LIBVHDDIR) -lvhd
 
-tapdisk2 td-util tapdisk-stream tapdisk-diff: LIBS += -L$(LIBVHDDIR) -lvhd -luuid -licbinn_resolved -lpthread -ldl
+REMUS-OBJS  := block-remus.o
+REMUS-OBJS  += hashtable.o
+REMUS-OBJS  += hashtable_itr.o
+REMUS-OBJS  += hashtable_utility.o
 
-ifneq ($(USE_SYSTEM_LIBRARIES),y)
+ifneq ($(CONFIG_SYSTEM_LIBAIO),y)
+CFLAGS    += -I $(LIBAIO_DIR)
 LIBAIO_DIR = $(XEN_ROOT)/tools/libaio/src
-tapdisk2 tapdisk-stream tapdisk-diff: AIOLIBS := $(LIBAIO_DIR)/libaio.a
-tapdisk2 tapdisk-stream tapdisk-diff: CFLAGS  += -I$(LIBAIO_DIR) -I$(XEN_LIBXC)
-tapdisk2 tapdisk-client tapdisk-stream tapdisk-diff block-log: CFLAGS += -I$(XEN_ROOT)/tools/include
+tapdisk2 tapdisk-stream tapdisk-diff $(QCOW_UTIL): AIOLIBS := $(LIBAIO_DIR)/libaio.a 
+tapdisk-client tapdisk-stream tapdisk-diff $(QCOW_UTIL): CFLAGS  += -I$(LIBAIO_DIR)
 else
-tapdisk2 tapdisk-stream tapdisk-diff: AIOLIBS := -laio
+tapdisk2 tapdisk-stream tapdisk-diff $(QCOW_UTIL): AIOLIBS := -laio
+endif
+
+MEMSHRLIBS :=
+ifeq ($(CONFIG_Linux), __fixme__)
+MEMSHR_DIR = $(XEN_ROOT)/tools/memshr
+CFLAGS += -DMEMSHR
+CFLAGS += -I $(MEMSHR_DIR)
+MEMSHRLIBS += -L$(XEN_ROOT)/tools/libxc -lxenctrl $(MEMSHR_DIR)/libmemshr.a
 endif
 
 ifeq ($(VHD_STATIC),y)
 td-util: CFLAGS += -static
 endif
 
-tapdisk tapdisk2 tapdisk-stream tapdisk-diff: LIBS += -lcrypto -Lcrypto -lxts-aes
-tapdisk tapdisk2 tapdisk-stream tapdisk-diff: crypto/libxts-aes.a
-
-crypto/libxts-aes.a: crypto/*.c crypto/*.h
-	$(MAKE) -C crypto libxts-aes.a
+PORTABLE-OBJS-y :=
+PORTABLE-OBJS-$(CONFIG_Linux)  += blk_linux.o
+PORTABLE-OBJS-$(CONFIG_NetBSD) += blk_netbsd.o
+
+TAP-OBJS-y  := scheduler.o
+TAP-OBJS-y  += tapdisk-vbd.o
+TAP-OBJS-y  += tapdisk-control.o
+TAP-OBJS-y  += tapdisk-image.o
+TAP-OBJS-y  += tapdisk-driver.o
+TAP-OBJS-y  += tapdisk-disktype.o
+TAP-OBJS-y  += tapdisk-interface.o
+TAP-OBJS-y  += tapdisk-server.o
+TAP-OBJS-y  += tapdisk-queue.o
+TAP-OBJS-y  += tapdisk-filter.o
+TAP-OBJS-y  += tapdisk-log.o
+TAP-OBJS-y  += tapdisk-utils.o
+TAP-OBJS-y  += io-optimize.o
+TAP-OBJS-y  += lock.o
+TAP-OBJS-y  += $(PORTABLE-OBJS-y)
+
+MISC-OBJS-y := atomicio.o
+
+BLK-OBJS-y  := block-aio.o
+BLK-OBJS-y  += block-ram.o
+BLK-OBJS-y  += block-cache.o
+BLK-OBJS-y  += block-vhd.o
+BLK-OBJS-y  += block-log.o
+BLK-OBJS-y  += block-qcow.o
+BLK-OBJS-y  += aes.o
+BLK-OBJS-y  += md5.o
+BLK-OBJS-y  += $(PORTABLE-OBJS-y)
+BLK-OBJS-y  += $(REMUS-OBJS)
 
-TAP-OBJS  := scheduler.o
-TAP-OBJS  += tapdisk-control.o
-TAP-OBJS  += tapdisk-vbd.o
-TAP-OBJS  += tapdisk-image.o
-TAP-OBJS  += tapdisk-driver.o
-TAP-OBJS  += tapdisk-disktype.o
-TAP-OBJS  += tapdisk-interface.o
-TAP-OBJS  += tapdisk-server.o
-TAP-OBJS  += tapdisk-queue.o
-TAP-OBJS  += tapdisk-filter.o
-TAP-OBJS  += tapdisk-logfile.o
-TAP-OBJS  += tapdisk-log.o
-TAP-OBJS  += tapdisk-utils.o
-TAP-OBJS  += tapdisk-syslog.o
-TAP-OBJS  += tapdisk-stats.o
-TAP-OBJS  += tapdisk-storage.o
-TAP-OBJS  += io-optimize.o
-TAP-OBJS  += lock.o
-
-MISC-OBJS := atomicio.o
-
-BLK-OBJS  := block-aio.o
-BLK-OBJS  += block-ram.o
-BLK-OBJS  += block-cache.o
-BLK-OBJS  += block-vhd.o
-BLK-OBJS  += block-vindex.o
-BLK-OBJS  += block-lcache.o
-BLK-OBJS  += block-crypto.o
+all: $(IBIN) lock-util qcow-util
 
-all: $(IBIN) lock-util
 
-TAPDISK-OBJS := $(TAP-OBJS) $(BLK-OBJS)
-
-tapdisk2: tapdisk2.c $(TAPDISK-OBJS) $(MISC-OBJS)
-	$(CC) $(CFLAGS) -o $@ $(TAPDISK-OBJS) $(MISC-OBJS) $< $(LIBS) $(AIOLIBS)
+tapdisk2: $(TAP-OBJS-y) $(BLK-OBJS-y) $(MISC-OBJS-y) tapdisk2.o
+	$(CC) -o $@ $^ $(LDFLAGS) -lrt -lz $(VHDLIBS) $(AIOLIBS) $(MEMSHRLIBS) -lm 
 
 tapdisk-client: tapdisk-client.o
-	$(CC) $(CFLAGS) -o $@ $^ $(LIBS)
+	$(CC) -o $@ $^ $(LDFLAGS) -lrt
 
-tapdisk-stream tapdisk-diff: %: %.o $(TAPDISK-OBJS)
-	$(CC) $(CFLAGS) -o $@ $< $(TAPDISK-OBJS) $(LIBS) $(AIOLIBS)
+tapdisk-stream tapdisk-diff: %: %.o $(TAP-OBJS-y) $(BLK-OBJS-y)
+	$(CC) -o $@ $^ $(LDFLAGS) -lrt -lz $(VHDLIBS) $(AIOLIBS) $(MEMSHRLIBS) -lm
 
-td-util: td.o tapdisk-utils.o
-	$(CC) $(CFLAGS) -o $@ $^ $(LIBS)
+td-util: td.o tapdisk-utils.o tapdisk-log.o $(PORTABLE-OBJS-y)
+	$(CC) -o $@ $^ $(LDFLAGS) $(VHDLIBS)
 
 lock-util: lock.c
-	$(CC) $(CFLAGS) -DUTIL -o lock-util lock.c $(LIBS)
+	$(CC) $(CFLAGS) -DUTIL -o lock-util lock.c $(LDFLAGS)
+
+.PHONY: qcow-util
+qcow-util: img2qcow qcow2raw qcow-create
+
+img2qcow qcow2raw qcow-create: %: %.o $(TAP-OBJS-y) $(BLK-OBJS-y)
+	$(CC) -o $@ $^ $(LDFLAGS) -lrt -lz $(VHDLIBS) $(AIOLIBS) $(MEMSHRLIBS) -lm
 
 install: all
 	$(INSTALL_DIR) -p $(DESTDIR)$(INST_DIR)
-	$(INSTALL_PROG) $(IBIN) $(LOCK_UTIL) $(DESTDIR)$(INST_DIR)
+	$(INSTALL_PROG) $(IBIN) $(LOCK_UTIL) $(QCOW_UTIL) $(DESTDIR)$(INST_DIR)
 
 clean:
-	rm -rf *.o *~ $(DEPS) xen TAGS $(IBIN) $(LIB) $(LOCK_UTIL)
-	$(MAKE) -C crypto clean
+	rm -rf .*.d *.o *~ xen TAGS $(IBIN) $(LIB) $(LOCK_UTIL) $(QCOW_UTIL)
 
 .PHONY: clean install
-
--include $(DEPS)
diff -Nur blktap2_oxt//drivers/md5.c blktap2_xen//drivers/md5.c
--- blktap2_oxt//drivers/md5.c	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/md5.c	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,278 @@
+/* start - public domain MD5 implementation */
+/*
+ * This code implements the MD5 message-digest algorithm.
+ * The algorithm is due to Ron Rivest.  This code was
+ * written by Colin Plumb in 1993, no copyright is claimed.
+ * This code is in the public domain; do with it what you wish.
+ *
+ * Equivalent code is available from RSA Data Security, Inc.
+ * This code has been tested against that, and is equivalent,
+ * except that you don't need to include two pages of legalese
+ * with every copy.
+ *
+ * To compute the message digest of a chunk of bytes, declare an
+ * MD5Context structure, pass it to MD5Init, call MD5Update as
+ * needed on buffers full of bytes, and then call MD5Final, which
+ * will fill a supplied 16-byte array with the digest.
+ */
+
+#include <string.h>
+#include <stdint.h>
+
+struct MD5Context {
+        uint32_t buf[4];
+        uint32_t bits[2];
+        uint8_t in[64];
+};
+
+static void MD5Init(struct MD5Context *context);
+static void MD5Update(struct MD5Context *context, unsigned char const *buf,
+                          unsigned len);
+static void MD5Final(unsigned char digest[16], struct MD5Context *context);
+static void MD5Transform(uint32_t buf[4], uint32_t const in[16]);
+
+
+typedef struct MD5Context MD5_CTX;
+
+
+/**
+ * md5_sum - MD5 hash for a data block
+ * @addr: Pointers to the data area
+ * @len: Lengths of the data block
+ * @mac: Buffer for the hash
+ */
+void md5_sum(const uint8_t *addr, const size_t len, uint8_t *mac)
+{
+        MD5_CTX ctx;
+
+        MD5Init(&ctx);
+       MD5Update(&ctx, addr, len);
+        MD5Final(mac, &ctx);
+}
+
+
+#ifndef WORDS_BIGENDIAN
+#define byteReverse(buf, len)   /* Nothing */
+#else
+/*
+ * Note: this code is harmless on little-endian machines.
+ */
+static void byteReverse(unsigned char *buf, unsigned longs)
+{
+    uint32_t t;
+    do {
+        t = (uint32_t) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
+            ((unsigned) buf[1] << 8 | buf[0]);
+        *(uint32_t *) buf = t;
+        buf += 4;
+    } while (--longs);
+}
+#endif
+
+/*
+ * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
+ * initialization constants.
+ */
+void MD5Init(struct MD5Context *ctx)
+{
+    ctx->buf[0] = 0x67452301;
+    ctx->buf[1] = 0xefcdab89;
+    ctx->buf[2] = 0x98badcfe;
+    ctx->buf[3] = 0x10325476;
+
+    ctx->bits[0] = 0;
+    ctx->bits[1] = 0;
+}
+
+/*
+ * Update context to reflect the concatenation of another buffer full
+ * of bytes.
+ */
+void MD5Update(struct MD5Context *ctx, unsigned char const *buf, unsigned len)
+{
+    uint32_t t;
+
+    /* Update bitcount */
+
+    t = ctx->bits[0];
+    if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t)
+        ctx->bits[1]++;         /* Carry from low to high */
+    ctx->bits[1] += len >> 29;
+
+    t = (t >> 3) & 0x3f;        /* Bytes already in shsInfo->data */
+
+    /* Handle any leading odd-sized chunks */
+
+    if (t) {
+        unsigned char *p = (unsigned char *) ctx->in + t;
+
+        t = 64 - t;
+        if (len < t) {
+            memcpy(p, buf, len);
+            return;
+        }
+        memcpy(p, buf, t);
+        byteReverse(ctx->in, 16);
+        MD5Transform(ctx->buf, (uint32_t *) ctx->in);
+        buf += t;
+        len -= t;
+    }
+    /* Process data in 64-byte chunks */
+
+    while (len >= 64) {
+        memcpy(ctx->in, buf, 64);
+        byteReverse(ctx->in, 16);
+        MD5Transform(ctx->buf, (uint32_t *) ctx->in);
+        buf += 64;
+        len -= 64;
+    }
+
+    /* Handle any remaining bytes of data. */
+
+    memcpy(ctx->in, buf, len);
+}
+
+/*
+ * Final wrapup - pad to 64-byte boundary with the bit pattern
+ * 1 0* (64-bit count of bits processed, MSB-first)
+ */
+void MD5Final(unsigned char digest[16], struct MD5Context *ctx)
+{
+    unsigned count;
+    unsigned char *p;
+
+    /* Compute number of bytes mod 64 */
+    count = (ctx->bits[0] >> 3) & 0x3F;
+
+    /* Set the first char of padding to 0x80.  This is safe since there is
+       always at least one byte free */
+    p = ctx->in + count;
+    *p++ = 0x80;
+
+    /* Bytes of padding needed to make 64 bytes */
+    count = 64 - 1 - count;
+
+    /* Pad out to 56 mod 64 */
+    if (count < 8) {
+        /* Two lots of padding:  Pad the first block to 64 bytes */
+        memset(p, 0, count);
+        byteReverse(ctx->in, 16);
+        MD5Transform(ctx->buf, (uint32_t *) ctx->in);
+
+        /* Now fill the next block with 56 bytes */
+        memset(ctx->in, 0, 56);
+    } else {
+        /* Pad block to 56 bytes */
+        memset(p, 0, count - 8);
+    }
+    byteReverse(ctx->in, 14);
+
+    /* Append length in bits and transform */
+    ((uint32_t *) ctx->in)[14] = ctx->bits[0];
+    ((uint32_t *) ctx->in)[15] = ctx->bits[1];
+
+    MD5Transform(ctx->buf, (uint32_t *) ctx->in);
+    byteReverse((unsigned char *) ctx->buf, 4);
+    memcpy(digest, ctx->buf, 16);
+    memset(ctx, 0, sizeof(*ctx));     /* In case it's sensitive */
+}
+
+/* The four core functions - F1 is optimized somewhat */
+
+/* #define F1(x, y, z) (x & y | ~x & z) */
+#define F1(x, y, z) (z ^ (x & (y ^ z)))
+#define F2(x, y, z) F1(z, x, y)
+#define F3(x, y, z) (x ^ y ^ z)
+#define F4(x, y, z) (y ^ (x | ~z))
+
+/* This is the central step in the MD5 algorithm. */
+#define MD5STEP(f, w, x, y, z, data, s) \
+        ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
+
+/*
+ * The core of the MD5 algorithm, this alters an existing MD5 hash to
+ * reflect the addition of 16 longwords of new data.  MD5Update blocks
+ * the data and converts bytes into longwords for this routine.
+ */
+static void MD5Transform(uint32_t buf[4], uint32_t const in[16])
+{
+    register uint32_t a, b, c, d;
+
+    a = buf[0];
+    b = buf[1];
+    c = buf[2];
+    d = buf[3];
+
+    MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
+    MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
+    MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
+    MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
+    MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
+    MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
+    MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
+    MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
+    MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
+    MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
+    MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
+    MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
+    MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
+    MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
+    MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
+    MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);
+
+    MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
+    MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
+    MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
+    MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
+    MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
+    MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
+    MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
+    MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
+    MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
+    MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
+    MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
+    MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
+    MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
+    MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
+    MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
+    MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
+
+    MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
+    MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
+    MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
+    MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
+    MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
+    MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
+    MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
+    MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
+    MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
+    MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
+    MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
+    MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
+    MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
+    MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
+    MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
+    MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);
+
+    MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
+    MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
+    MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
+    MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
+    MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
+    MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
+    MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
+    MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
+    MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
+    MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
+    MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
+    MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
+    MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
+    MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
+    MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
+    MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
+
+    buf[0] += a;
+    buf[1] += b;
+    buf[2] += c;
+    buf[3] += d;
+}
diff -Nur blktap2_oxt//drivers/md5.h blktap2_xen//drivers/md5.h
--- blktap2_oxt//drivers/md5.h	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/md5.h	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,15 @@
+#ifndef MD5_H
+#define MD5_H
+
+#include <stdint.h>
+#include <stddef.h>
+
+/**
+ * md5_sum - MD5 hash for a data block
+ * @addr: Pointers to the data area
+ * @len: Lengths of the data block
+ * @mac: Buffer for the hash
+ */
+void md5_sum(const uint8_t *addr, const size_t len, uint8_t *mac);
+
+#endif
diff -Nur blktap2_oxt//drivers/profile.h blktap2_xen//drivers/profile.h
--- blktap2_oxt//drivers/profile.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/profile.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,11 +1,30 @@
-/* Copyright (c) 2007, XenSource Inc.
+/* 
+ * Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
- */
-
-/*
- * Copyright (c) 2008 Citrix Systems, Inc.
- */
-
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of XenSource Inc. nor the names of its contributors
+ *       may be used to endorse or promote products derived from this software
+ *       without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
 
 #ifndef __TAP_PROFILE_H__
 #define __TAP_PROFILE_H__
diff -Nur blktap2_oxt//drivers/qcow2raw.c blktap2_xen//drivers/qcow2raw.c
--- blktap2_oxt//drivers/qcow2raw.c	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/qcow2raw.c	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,443 @@
+/* qcow2raw.c
+ *
+ * Generates raw image data from an existing qcow image
+ *
+ * (c) 2006 Julian Chesterfield and Andrew Warfield
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation; or, when distributed
+ * separately from the Linux kernel or incorporated into other
+ * software packages, subject to the following license:
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this source file (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <inttypes.h>
+#include <unistd.h>
+#include <sys/statvfs.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <string.h>
+
+#include "bswap.h"
+#include "aes.h"
+#include "blk.h"
+#include "tapdisk.h"
+#include "tapdisk-server.h"
+#include "tapdisk-driver.h"
+#include "tapdisk-interface.h"
+#include "tapdisk-disktype.h"
+#include "qcow.h"
+
+#if 1
+#define DFPRINTF(_f, _a...) fprintf ( stderr, _f , ## _a )
+#else
+#define DFPRINTF(_f, _a...) ((void)0)
+#endif
+
+
+/* *BSD has no O_LARGEFILE */
+#ifndef O_LARGEFILE
+#define O_LARGEFILE 0
+#endif
+
+#define BLOCK_PROCESSSZ 4096
+#define QCOW_VBD 0
+#define AIO_VBD 1
+#define WINDOW 32
+#define PROGRESS_QUANT 2
+
+static int running = 1, complete = 0; 
+static int returned_read_events = 0, returned_write_events = 0;
+static int submit_events = 0;
+static uint32_t read_idx = 0;
+td_driver_t *ddqcow, *ddaio;
+td_vbd_t* qcow_vbd, *aio_vbd;
+static uint64_t prev = 0, written = 0;
+static char output[(100/PROGRESS_QUANT) + 5];
+
+extern tapdisk_server_t server;
+
+struct request_info {
+  void* buf;
+  uint64_t logical_sec;
+  int pending;
+};
+
+static void print_bytes(void *ptr, int length)
+{
+  int i,k;
+  unsigned char *p = ptr;
+
+    DFPRINTF("Buf dump, length %d:\n",length);
+    for (k = 0; k < length; k++) {
+        DFPRINTF("%x",*p);
+        *p++;
+	if (k % 16 == 0) DFPRINTF("\n");
+        else if (k % 2 == 0) DFPRINTF(" ");	
+    }
+    DFPRINTF("\n");
+    return;
+}
+
+static void debug_output(uint64_t progress, uint64_t size)
+{
+        //Output progress every PROGRESS_QUANT 
+        uint64_t blocks = size/(100/PROGRESS_QUANT);
+
+	if (progress/blocks > prev) {
+		memcpy(output+prev+1,"=>",2);
+		prev++;
+		DFPRINTF("\r%s     %"PRIu64"%%", 
+			output, (uint64_t)((prev-1)*PROGRESS_QUANT));
+	}
+	return;
+}
+
+static void send_write_responses(td_request_t treq, int err)
+{
+        struct request_info* req;
+
+	if (err < 0) {
+		DFPRINTF("AIO FAILURE: res [%d]!\n",err);
+		return;
+	}
+	returned_write_events+=treq.secs;
+        written += treq.secs;
+
+        req= (struct request_info*)treq.cb_data;
+
+        //Wait for whole request to complete.
+        req->pending-=treq.secs;
+        if(req->pending)
+          return;
+
+        //Whole request has completed, we can free buffers. 
+        free(req->buf);
+        free(req);
+
+	debug_output(written, ddaio->info.size);
+	
+	return;
+}
+
+static void send_read_responses(td_request_t treq, int err)
+{
+	int ret;
+        struct request_info* req;
+        td_vbd_request_t* vreq;
+
+	if (err < 0)  {
+	  DFPRINTF("AIO FAILURE: res [%d]!\n",err); 
+	  return;
+	}
+	returned_read_events+=treq.secs;
+
+        req= (struct request_info*)treq.cb_data;
+
+        //do nothing until all fragments complete.
+        req->pending-=treq.secs;
+
+        if(req->pending)
+          return;
+
+        //This read is done.
+        tapdisk_vbd_complete_vbd_request(qcow_vbd, treq.private);
+
+
+        treq.op      = TD_OP_WRITE;
+        treq.buf     = req->buf;
+        treq.sec     = req->logical_sec;
+        treq.secs    = BLOCK_PROCESSSZ>>9;
+        treq.image   = tapdisk_vbd_first_image(aio_vbd);
+        treq.cb      = send_write_responses;
+        treq.id      = 0;
+        treq.sidx    = 0;
+
+        req->pending = BLOCK_PROCESSSZ>>9;
+        treq.cb_data = req;
+
+        vreq         = calloc(1, sizeof(td_vbd_request_t));
+        treq.private = vreq;
+
+        //Put it in the VBD's queue, so we don't lose
+        //track of it.
+        vreq->submitting = 1;
+        INIT_LIST_HEAD(&vreq->next);
+        tapdisk_vbd_move_request(treq.private, 
+                                 &aio_vbd->pending_requests);
+
+        ddaio->ops->td_queue_write(ddaio,treq);
+        --vreq->submitting;
+
+        tapdisk_submit_all_tiocbs(&server.aio_queue);
+
+	return;
+}
+
+int main(int argc, const char *argv[])
+{
+	int ret = -1, fd, len,input;
+	uint64_t size;
+	struct timeval timeout;
+	uint64_t i;
+	char *buf;
+	struct stat finfo;
+	td_request_t treq;
+	td_vbd_request_t* vreq;
+        struct request_info* req;
+        int err;
+
+	if (argc != 3) {
+		fprintf(stderr, "Qcow-utils: v1.0.0\n");
+		fprintf(stderr, "usage: %s <Dest File descriptor> "
+			"<Qcow SRC IMAGE>\n", 
+		       argv[0]);
+		exit(-1);
+	}
+
+        err = tapdisk_server_initialize();
+        if( err ) {
+          DPRINTF("qcow2raw Couldn't initialize server instance.\n");
+          return err;
+        }
+
+        err=tapdisk_vbd_initialize(QCOW_VBD);
+        if( err ) {
+          DPRINTF("qcow2raw Couldn't initialize qcow vbd.\n");
+          return err;
+        }
+
+        qcow_vbd = tapdisk_server_get_vbd(QCOW_VBD);
+        if (!qcow_vbd) {
+          err = -ENODEV;
+          DPRINTF("qcow2raw Couldn't create qcow vbd.\n");
+          return err;
+        }
+
+        err = tapdisk_vbd_open_vdi(qcow_vbd, argv[2], DISK_TYPE_QCOW,
+                                   TAPDISK_STORAGE_TYPE_DEFAULT,
+                                   TD_OPEN_RDONLY);
+        if( err ) {
+          DPRINTF("qcow2raw Couldn't open qcow file.\n");
+          return err;
+        }
+
+        ddqcow=(tapdisk_vbd_first_image(qcow_vbd))->driver;
+
+        /*Setup aio destination file*/
+	ret = stat(argv[1],&finfo);
+	if (ret == -1) {
+		/*Check errno*/
+		switch(errno) {
+		case ENOENT:
+			/*File doesn't exist, create*/
+			fd = open(argv[1], 
+				  O_RDWR | O_LARGEFILE | O_CREAT, 0644);
+			if (fd < 0) {
+				DFPRINTF("ERROR creating file [%s] "
+					 "(errno %d)\n",
+				       argv[1], 0 - errno);
+				exit(-1);
+			}
+			if (ftruncate(fd, (off_t)ddqcow->info.size<<9) < 0) {
+				DFPRINTF("Unable to create file "
+					"[%s] of size %"PRIu64" (errno %d). "
+					 "Exiting...\n",
+					argv[1], 
+					(uint64_t)ddqcow->info.size<<9, 
+					0 - errno);
+				close(fd);
+				exit(-1);
+			}
+			close(fd);
+			break;
+		case  ENXIO:
+			DFPRINTF("ERROR Device [%s] does not exist\n",argv[1]);
+			exit(-1);
+		default: 
+			DFPRINTF("An error occurred opening Device [%s] "
+				 "(errno %d)\n",
+			       argv[1], 0 - errno);
+			exit(-1);
+		}
+	} else {		
+		fprintf(stderr, "WARNING: All existing data in "
+			"%s will be overwritten.\nDo you wish to continue? "
+			"(y or n)  ",
+			argv[1]);
+		if (getchar() != 'y') {
+			DFPRINTF("Exiting...\n");
+			exit(-1);
+		}
+		
+		/*TODO - Test the existing file or device for adequate space*/
+		fd = open(argv[1], O_RDWR | O_LARGEFILE);
+		if (fd < 0) {
+			DFPRINTF("ERROR: opening file [%s] (errno %d)\n",
+			       argv[1], 0 - errno);
+			exit(-1);
+		}
+
+		if (S_ISBLK(finfo.st_mode)) {
+			if (blk_getimagesize(fd, &size) != 0) {
+				close(fd);
+				return -1;
+			}
+
+			if (size < ddqcow->info.size<<9) {
+				DFPRINTF("ERROR: Not enough space on device "
+					"%s (%"PRIu64" bytes available, "
+					"%"PRIu64" bytes required\n",
+					argv[1], size, 
+					(uint64_t)ddqcow->info.size<<9);
+				close(fd);
+				exit(-1);				
+			}
+		} else {
+			if (ftruncate(fd, (off_t)ddqcow->info.size<<9) < 0) {
+				DFPRINTF("Unable to create file "
+					"[%s] of size %"PRIu64" (errno %d). "
+					 "Exiting...\n",
+					argv[1], 
+					(uint64_t)ddqcow->info.size<<9, 
+					 0 - errno);
+				close(fd);
+				exit(-1);
+			} else DFPRINTF("File [%s] truncated to length %"PRIu64" "
+					"(%"PRIu64")\n", 
+				       argv[1], 
+				       (uint64_t)ddqcow->info.size<<9, 
+				       (uint64_t)ddqcow->info.size);
+		}
+		close(fd);
+	}
+
+        //Now the output file should be there, reopen it as an aio VBD
+        err=tapdisk_vbd_initialize(AIO_VBD);
+        if( err ) {
+          DPRINTF("qcow2raw Couldn't initialize aio vbd.\n");
+          return err;
+        }
+
+        aio_vbd = tapdisk_server_get_vbd(AIO_VBD);
+        if (!aio_vbd) {
+          err = -ENODEV;
+          DPRINTF("qcow2raw Couldn't create aio vbd.\n");
+          return err;
+        }
+
+        err = tapdisk_vbd_open_vdi(aio_vbd, argv[1], DISK_TYPE_AIO,
+                                   TAPDISK_STORAGE_TYPE_DEFAULT,
+                                   0);
+        if( err ) {
+          DPRINTF("qcow2raw Couldn't open aio file.\n");
+          return err;
+        }
+
+        ddaio=(tapdisk_vbd_first_image(aio_vbd))->driver;
+
+	/*Initialise the output string*/
+	memset(output,0x20,(100/PROGRESS_QUANT)+5);
+	output[0] = '[';
+        output[(100/PROGRESS_QUANT)+2] = ']';
+        output[(100/PROGRESS_QUANT)+3] = '\0';
+	DFPRINTF("%s",output);
+
+	i = 0;
+	while (running) {
+		timeout.tv_sec = 0;
+		
+		if (!complete) {
+			/*Read Pages from qcow image*/
+			if ( (ret = posix_memalign((void **)&buf, 
+						   BLOCK_PROCESSSZ, 
+						   BLOCK_PROCESSSZ))
+			     != 0) {
+				DFPRINTF("Unable to alloc memory (%d)\n",ret);
+				exit(-1);				
+			}
+		
+			/*Attempt to read 4k sized blocks*/
+			submit_events+=BLOCK_PROCESSSZ>>9;
+
+			//Set up the read request
+			treq.op      = TD_OP_READ;
+			treq.buf     = buf;
+			treq.sec     = i;
+			treq.secs    = BLOCK_PROCESSSZ>>9;
+			treq.image   = tapdisk_vbd_first_image(qcow_vbd);
+			treq.cb      = send_read_responses;
+			treq.id      = 0;
+			treq.sidx    = 0;
+
+                        req = calloc(1, sizeof(struct request_info));
+                        req->buf = buf;
+                        req->logical_sec = i;
+                        req->pending = BLOCK_PROCESSSZ>>9;
+			treq.cb_data = req;
+
+                        vreq         = calloc(1, sizeof(td_vbd_request_t));
+                        treq.private = vreq;
+
+                        //Put it in the VBD's queue, so we don't lose
+                        //track of it.
+                        vreq->submitting = 1;
+                        INIT_LIST_HEAD(&vreq->next);
+                        tapdisk_vbd_move_request(treq.private, 
+                                                 &qcow_vbd->pending_requests);
+
+			ddqcow->ops->td_queue_read(ddqcow, treq);
+                        --vreq->submitting;
+
+			i += BLOCK_PROCESSSZ>>9;
+
+			if (i >= ddqcow->info.size)
+			  complete = 1;
+
+			
+			tapdisk_submit_all_tiocbs(&server.aio_queue);
+		}
+		
+
+		while(returned_write_events != submit_events) {
+		  ret = scheduler_wait_for_events(&server.scheduler);
+		  if (ret < 0) {
+		    DFPRINTF("server wait returned %d\n", ret);
+		    sleep(2);
+		  }
+		}
+		if (complete && (returned_write_events == submit_events)) 
+			running = 0;
+	}
+	memcpy(output+prev+1,"=",1);
+	DFPRINTF("\r%s     100%%\nTRANSFER COMPLETE\n\n", output);
+
+	ddqcow->ops->td_close(ddqcow);
+	ddaio->ops->td_close(ddaio);
+	free(ddqcow->data);
+	free(ddaio->data);
+		
+	return 0;
+}
diff -Nur blktap2_oxt//drivers/qcow-create.c blktap2_xen//drivers/qcow-create.c
--- blktap2_oxt//drivers/qcow-create.c	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/qcow-create.c	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,121 @@
+/* qcow-create.c
+ *
+ * Generates a qcow format disk.
+ *
+ * (c) 2006 Andrew Warfield and Julian Chesterfield
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation; or, when distributed
+ * separately from the Linux kernel or incorporated into other
+ * software packages, subject to the following license:
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this source file (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/statvfs.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <string.h>
+#include "tapdisk.h"
+#include "qcow.h"
+
+#if 1
+#define DFPRINTF(_f, _a...) fprintf ( stderr, _f , ## _a )
+#else
+#define DFPRINTF(_f, _a...) ((void)0)
+#endif
+
+#define MAX_NAME_LEN 1000
+
+void help(void)
+{
+	fprintf(stderr, "Qcow-utils: v1.0.0\n");
+	fprintf(stderr, 
+		"usage: qcow-create [-h help] [-r reserve] <SIZE(MB)> <FILENAME> "
+		"[<BACKING_FILENAME>]\n"); 
+	exit(-1);
+}
+
+int main(int argc, char *argv[])
+{
+	int ret = -1, c, backed = 0;
+	int sparse =  1;
+	uint64_t size;
+	char filename[MAX_NAME_LEN], bfilename[MAX_NAME_LEN];
+
+        for(;;) {
+                c = getopt(argc, argv, "hr");
+                if (c == -1)
+                        break;
+                switch(c) {
+                case 'h':
+                        help();
+                        exit(0);
+                        break;
+                case 'r':
+			sparse = 0;
+			break;
+		default:
+			fprintf(stderr, "Unknown option\n");
+			help();
+		}
+	}
+
+	printf("Optind %d, argc %d\n", optind, argc);
+	if ( !(optind == (argc - 2) || optind == (argc - 3)) )
+		help();
+
+	size = atoi(argv[optind++]);
+	size = size << 20;
+
+	if (snprintf(filename, MAX_NAME_LEN, "%s",argv[optind++]) >=
+		MAX_NAME_LEN) {
+		fprintf(stderr,"Device name too long\n");
+		exit(-1);
+	}
+
+	if (optind != argc) {
+		/*Backing file argument*/
+		backed = 1;
+		if (snprintf(bfilename, MAX_NAME_LEN, "%s",argv[optind++]) >=
+			MAX_NAME_LEN) {
+			fprintf(stderr,"Device name too long\n");
+			exit(-1);
+		}
+	}
+
+	DFPRINTF("Creating file size %"PRIu64", name %s\n",(uint64_t)size, filename);
+	if (!backed)
+		ret = qcow_create(filename,size,NULL,sparse);
+	else
+		ret = qcow_create(filename,size,bfilename,sparse);
+
+	if (ret < 0)
+		DPRINTF("Unable to create QCOW file\n");
+	else
+		DPRINTF("QCOW file successfully created\n");
+
+	return 0;
+}
diff -Nur blktap2_oxt//drivers/qcow.h blktap2_xen//drivers/qcow.h
--- blktap2_oxt//drivers/qcow.h	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/qcow.h	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,131 @@
+/* 
+ * Copyright (c) 2008, XenSource Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of XenSource Inc. nor the names of its contributors
+ *       may be used to endorse or promote products derived from this software
+ *       without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _QCOW_H_
+#define _QCOW_H_
+
+#include "aes.h"
+/**************************************************************/
+/* QEMU COW block driver with compression and encryption support */
+
+#define QCOW_MAGIC (('Q' << 24) | ('F' << 16) | ('I' << 8) | 0xfb)
+#define XEN_MAGIC  (('X' << 24) | ('E' << 16) | ('N' << 8) | 0xfb)
+#define QCOW_VERSION 1
+
+#define QCOW_CRYPT_NONE 0x00
+#define QCOW_CRYPT_AES  0x01
+
+#define QCOW_OFLAG_COMPRESSED (1LL << 63)
+#define SPARSE_FILE 0x01
+#define EXTHDR_L1_BIG_ENDIAN 0x02
+
+#ifndef O_BINARY
+#define O_BINARY 0
+#endif
+
+#define ROUNDUP(l, s) \
+({ \
+    (uint64_t)( \
+        (l + (s - 1)) - ((l + (s - 1)) % s)); \
+})
+
+typedef struct QCowHeader {
+	uint32_t magic;
+	uint32_t version;
+	uint64_t backing_file_offset;
+	uint32_t backing_file_size;
+	uint32_t mtime;
+	uint64_t size; /* in bytes */
+	uint8_t cluster_bits;
+	uint8_t l2_bits;
+	uint32_t crypt_method;
+	uint64_t l1_table_offset;
+} QCowHeader;
+
+/*Extended header for Xen enhancements*/
+typedef struct QCowHeader_ext {
+        uint32_t xmagic;
+        uint32_t cksum;
+        uint32_t min_cluster_alloc;
+        uint32_t flags;
+} QCowHeader_ext;
+
+uint32_t gen_cksum(char *ptr, int len);
+int get_filesize(char *filename, uint64_t *size, struct stat *st);
+int qtruncate(int fd, off_t length, int sparse);
+
+#define L2_CACHE_SIZE 16  /*Fixed allocation in Qemu*/
+
+struct tdqcow_state {
+        int fd;                        /*Main Qcow file descriptor */
+	uint64_t fd_end;               /*Store a local record of file length */
+	char *name;                    /*Record of the filename*/
+	uint32_t backing_file_size;
+	uint64_t backing_file_offset;
+	uint8_t extended;              /*File contains extended header*/
+	int encrypted;                 /*File contents are encrypted or plain*/
+	int cluster_bits;              /*Determines length of cluster as 
+					*indicated by file hdr*/
+	int cluster_size;              /*Length of cluster*/
+	int cluster_sectors;           /*Number of sectors per cluster*/
+	int cluster_alloc;             /*Blktap fix for allocating full 
+					*extents*/
+	int min_cluster_alloc;         /*Blktap historical extent alloc*/
+	int sparse;                    /*Indicates whether to preserve sparseness*/
+	int l2_bits;                   /*Size of L2 table entry*/
+	int l2_size;                   /*Full table size*/
+	int l1_size;                   /*L1 table size*/
+	uint64_t cluster_offset_mask;    
+	uint64_t l1_table_offset;      /*L1 table offset from beginning of 
+					*file*/
+	uint64_t *l1_table;            /*L1 table entries*/
+	uint64_t *l2_cache;            /*We maintain a cache of size 
+					*L2_CACHE_SIZE of most read entries*/
+	uint64_t l2_cache_offsets[L2_CACHE_SIZE];     /*L2 cache entries*/
+	uint32_t l2_cache_counts[L2_CACHE_SIZE];      /*Cache access record*/
+	uint8_t *cluster_cache;          
+	uint8_t *cluster_data;
+	uint64_t cluster_cache_offset; /**/
+	uint32_t crypt_method;         /*current crypt method, 0 if no 
+					*key yet */
+	uint32_t crypt_method_header;  /**/
+	AES_KEY aes_encrypt_key;       /*AES key*/
+	AES_KEY aes_decrypt_key;       /*AES key*/
+
+        /* libaio state */
+	int                  aio_free_count;	
+	int                  max_aio_reqs;
+	struct qcow_request   *aio_requests;
+	struct qcow_request  **aio_free_list;
+
+};
+
+int qcow_create(const char *filename, uint64_t total_size,
+		const char *backing_file, int sparse);
+
+#endif //_QCOW_H_
diff -Nur blktap2_oxt//drivers/scheduler.c blktap2_xen//drivers/scheduler.c
--- blktap2_oxt//drivers/scheduler.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/scheduler.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,23 +25,16 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <errno.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
 #include <sys/time.h>
 
-#include "tapdisk.h"
 #include "scheduler.h"
 #include "tapdisk-log.h"
 
 #define DBG(_f, _a...)               tlog_write(TLOG_DBG, _f, ##_a)
-#define BUG_ON(_cond)                if (_cond) td_panic()
 
 #define SCHEDULER_MAX_TIMEOUT        600
 #define SCHEDULER_POLL_FD           (SCHEDULER_POLL_READ_FD |	\
@@ -51,17 +44,11 @@
 #define MIN(a, b)                   ((a) <= (b) ? (a) : (b))
 #define MAX(a, b)                   ((a) >= (b) ? (a) : (b))
 
-#define scheduler_for_each_event(s, event)	\
-	list_for_each_entry(event, &(s)->events, next)
-#define scheduler_for_each_event_safe(s, event, tmp)	\
+#define scheduler_for_each_event(s, event, tmp)	\
 	list_for_each_entry_safe(event, tmp, &(s)->events, next)
 
 typedef struct event {
 	char                         mode;
-	char                         dead;
-	char                         pending;
-	char                         masked;
-
 	event_id_t                   id;
 
 	int                          fd;
@@ -79,21 +66,18 @@
 {
 	int diff;
 	struct timeval now;
-	event_t *event;
+	event_t *event, *tmp;
 
 	FD_ZERO(&s->read_fds);
 	FD_ZERO(&s->write_fds);
 	FD_ZERO(&s->except_fds);
 
-	s->max_fd  = -1;
+	s->max_fd  = 0;
 	s->timeout = SCHEDULER_MAX_TIMEOUT;
 
 	gettimeofday(&now, NULL);
 
-	scheduler_for_each_event(s, event) {
-		if (event->masked || event->dead)
-			continue;
-
+	scheduler_for_each_event(s, event, tmp) {
 		if (event->mode & SCHEDULER_POLL_READ_FD) {
 			FD_SET(event->fd, &s->read_fds);
 			s->max_fd = MAX(event->fd, s->max_fd);
@@ -121,89 +105,59 @@
 	s->timeout = MIN(s->timeout, s->max_timeout);
 }
 
-static int
-scheduler_check_events(scheduler_t *s, int nfds)
+static void
+scheduler_event_callback(event_t *event, char mode)
 {
-	event_t *event;
-	struct timeval now;
+	if (event->mode & SCHEDULER_POLL_TIMEOUT) {
+		struct timeval now;
+		gettimeofday(&now, NULL);
+		event->deadline = now.tv_sec + event->timeout;
+	}
 
-	if (nfds <= 0)
-		return nfds;
+	event->cb(event->id, mode, event->private);
+}
+
+static void
+scheduler_run_events(scheduler_t *s)
+{
+	struct timeval now;
+	event_t *event, *tmp;
 
 	gettimeofday(&now, NULL);
 
-	scheduler_for_each_event(s, event) {
-		if (event->dead)
-			continue;
+ again:
+	s->restart = 0;
 
+	scheduler_for_each_event(s, event, tmp) {
 		if ((event->mode & SCHEDULER_POLL_READ_FD) &&
 		    FD_ISSET(event->fd, &s->read_fds)) {
 			FD_CLR(event->fd, &s->read_fds);
-			event->pending |= SCHEDULER_POLL_READ_FD;
-			--nfds;
+			scheduler_event_callback(event, SCHEDULER_POLL_READ_FD);
+			goto next;
 		}
 
 		if ((event->mode & SCHEDULER_POLL_WRITE_FD) &&
 		    FD_ISSET(event->fd, &s->write_fds)) {
 			FD_CLR(event->fd, &s->write_fds);
-			event->pending |= SCHEDULER_POLL_WRITE_FD;
-			--nfds;
+			scheduler_event_callback(event, SCHEDULER_POLL_WRITE_FD);
+			goto next;
 		}
 
 		if ((event->mode & SCHEDULER_POLL_EXCEPT_FD) &&
 		    FD_ISSET(event->fd, &s->except_fds)) {
 			FD_CLR(event->fd, &s->except_fds);
-			event->pending |= SCHEDULER_POLL_EXCEPT_FD;
-			--nfds;
-		}
-
-		if (event->pending) {
-			BUG_ON(event->masked);
-			continue;
+			scheduler_event_callback(event, SCHEDULER_POLL_EXCEPT_FD);
+			goto next;
 		}
 
 		if ((event->mode & SCHEDULER_POLL_TIMEOUT) &&
 		    (event->deadline <= now.tv_sec))
-			event->pending = SCHEDULER_POLL_TIMEOUT;
-	}
+		    scheduler_event_callback(event, SCHEDULER_POLL_TIMEOUT);
 
-	return nfds;
-}
-
-static void
-scheduler_event_callback(event_t *event, char mode)
-{
-	if (event->mode & SCHEDULER_POLL_TIMEOUT) {
-		struct timeval now;
-		gettimeofday(&now, NULL);
-		event->deadline = now.tv_sec + event->timeout;
+	next:
+		if (s->restart)
+			goto again;
 	}
-
-	event->cb(event->id, mode, event->private);
-}
-
-static int
-scheduler_run_events(scheduler_t *s)
-{
-	event_t *event;
-	int n_dispatched = 0;
-
-	scheduler_for_each_event(s, event) {
-		char pending;
-
-		if (event->dead)
-			continue;
-
-		pending = event->pending;
-		if (pending) {
-			event->pending = 0;
-			/* NB. must clear before cb */
-			scheduler_event_callback(event, pending);
-			n_dispatched++;
-		}
-	}
-
-	return n_dispatched;
 }
 
 int
@@ -234,7 +188,6 @@
 	event->cb       = cb;
 	event->private  = private;
 	event->id       = s->uuid++;
-	event->masked   = 0;
 
 	if (!s->uuid)
 		s->uuid++;
@@ -247,42 +200,17 @@
 void
 scheduler_unregister_event(scheduler_t *s, event_id_t id)
 {
-	event_t *event;
-
-	if (!id)
-		return;
-
-	scheduler_for_each_event(s, event)
-		if (event->id == id) {
-			event->dead = 1;
-			break;
-		}
-}
-
-void
-scheduler_mask_event(scheduler_t *s, event_id_t id, int masked)
-{
-	event_t *event;
+	event_t *event, *tmp;
 
 	if (!id)
 		return;
 
-	scheduler_for_each_event(s, event)
+	scheduler_for_each_event(s, event, tmp)
 		if (event->id == id) {
-			event->masked = !!masked;
-			break;
-		}
-}
-
-static void
-scheduler_gc_events(scheduler_t *s)
-{
-	event_t *event, *next;
-
-	scheduler_for_each_event_safe(s, event, next)
-		if (event->dead) {
 			list_del(&event->next);
 			free(event);
+			s->restart = 1;
+			break;
 		}
 }
 
@@ -299,15 +227,6 @@
 	int ret;
 	struct timeval tv;
 
-	s->depth++;
-	ret = 0;
-
-	if (s->depth > 1 && scheduler_run_events(s))
-		/* NB. recursive invocations continue with the pending
-		 * event set. We return as soon as we made some
-		 * progress. */
-		goto out;
-
 	scheduler_prepare_events(s);
 
 	tv.tv_sec  = s->timeout;
@@ -319,22 +238,14 @@
 	ret = select(s->max_fd + 1, &s->read_fds,
 		     &s->write_fds, &s->except_fds, &tv);
 
-	if (ret < 0)
-		goto out;
-
-	ret = scheduler_check_events(s, ret);
-	BUG_ON(ret);
-
+	s->restart     = 0;
 	s->timeout     = SCHEDULER_MAX_TIMEOUT;
 	s->max_timeout = SCHEDULER_MAX_TIMEOUT;
 
-	scheduler_run_events(s);
-
-	if (s->depth == 1)
-		scheduler_gc_events(s);
+	if (ret < 0)
+		return ret;
 
-out:
-	s->depth--;
+	scheduler_run_events(s);
 
 	return ret;
 }
@@ -344,8 +255,7 @@
 {
 	memset(s, 0, sizeof(scheduler_t));
 
-	s->uuid  = 1;
-	s->depth = 0;
+	s->uuid = 1;
 
 	FD_ZERO(&s->read_fds);
 	FD_ZERO(&s->write_fds);
diff -Nur blktap2_oxt//drivers/scheduler.h blktap2_xen//drivers/scheduler.h
--- blktap2_oxt//drivers/scheduler.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/scheduler.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #ifndef _SCHEDULER_H_
 #define _SCHEDULER_H_
 
@@ -55,8 +50,8 @@
 	int                          uuid;
 	int                          max_fd;
 	int                          timeout;
+	int                          restart;
 	int                          max_timeout;
-	int                          depth;
 } scheduler_t;
 
 void scheduler_initialize(scheduler_t *);
@@ -64,7 +59,6 @@
 				    int fd, int timeout,
 				    event_cb_t cb, void *private);
 void scheduler_unregister_event(scheduler_t *,  event_id_t);
-void scheduler_mask_event(scheduler_t *, event_id_t, int masked);
 void scheduler_set_max_timeout(scheduler_t *, int);
 int scheduler_wait_for_events(scheduler_t *);
 
diff -Nur blktap2_oxt//drivers/tapdisk2.c blktap2_xen//drivers/tapdisk2.c
--- blktap2_oxt//drivers/tapdisk2.c	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk2.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,16 +25,14 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <stdlib.h>
 #include <unistd.h>
+#ifdef MEMSHR
+#include <memshr.h>
+#endif
 
 #include "tapdisk.h"
 #include "tapdisk-utils.h"
@@ -44,80 +42,20 @@
 static void
 usage(const char *app, int err)
 {
-	fprintf(stderr, "usage: %s [-D don't daemonize] [-h help]\n", app);
+	fprintf(stderr, "usage: %s [-D] <-u uuid> <-c control socket>\n", app);
 	exit(err);
 }
 
-static FILE *
-fdup(FILE *stream, const char *mode)
-{
-	int fd, err;
-	FILE *f;
-
-	fd = dup(STDOUT_FILENO);
-	if (fd < 0)
-		goto fail;
-
-	f = fdopen(fd, mode);
-	if (!f)
-		goto fail;
-
-	return f;
-
-fail:
-	err = -errno;
-	if (fd >= 0)
-		close(fd);
-	errno = -err;
-
-	return NULL;
-}
-
-/*
- * put tapdisk pids in non-volatile directory for debugging purposes
- */
-#define TAPDISK2_PID_DIRECTORY "/var/log/tapdisk-pids"
-static char tapdisk2_pid_file[512] = { 0 };
-
-static int
-tapdisk2_create_pid_file(void)
-{
-	int fd;
-
-	if (access(TAPDISK2_PID_DIRECTORY, X_OK))
-		return (errno == ENOENT ? 0 : -errno);
-
-	snprintf(tapdisk2_pid_file, sizeof(tapdisk2_pid_file),
-		 "%s/%u", TAPDISK2_PID_DIRECTORY, getpid());
-
-	fd = open(tapdisk2_pid_file, O_CREAT | O_EXCL, 0644);
-	if (fd == -1)
-		return -errno;
-
-	close(fd);
-	return 0;
-}
-
-static int
-tapdisk2_remove_pid_file(void)
-{
-	if (!tapdisk2_pid_file[0])
-		return -EINVAL;
-
-	return (unlink(tapdisk2_pid_file) == -1 ? -errno : 0);
-}
-
 int
 main(int argc, char *argv[])
 {
 	char *control;
-	int c, err, nodaemon, fd;
-	FILE *out;
+	int c, err, nodaemon;
 
 	control  = NULL;
 	nodaemon = 0;
 
-	while ((c = getopt(argc, argv, "Dh")) != -1) {
+	while ((c = getopt(argc, argv, "s:Dh")) != -1) {
 		switch (c) {
 		case 'D':
 			nodaemon = 1;
@@ -125,6 +63,14 @@
 		case 'h':
 			usage(argv[0], 0);
 			break;
+		case 's':
+#ifdef MEMSHR
+			memshr_set_domid(atoi(optarg));
+#else
+			fprintf(stderr, "MEMSHR support not compiled in.\n");
+			exit(EXIT_FAILURE);
+#endif
+			break;
 		default:
 			usage(argv[0], EINVAL);
 		}
@@ -133,56 +79,60 @@
 	if (optind != argc)
 		usage(argv[0], EINVAL);
 
-	err = tapdisk_server_init();
-	if (err) {
-		DPRINTF("failed to initialize server: %d\n", err);
+	if (chdir("/")) {
+		DPRINTF("failed to chdir(/): %d\n", errno);
+		err = 1;
 		goto out;
 	}
 
-	out = fdup(stdout, "w");
-	if (!out) {
-		err = -errno;
-		DPRINTF("failed to dup stdout: %d\n", err);
+	tapdisk_start_logging("tapdisk2");
+
+	err = tapdisk_server_init();
+	if (err) {
+		DPRINTF("failed to initialize server: %d\n", err);
 		goto out;
 	}
 
 	if (!nodaemon) {
-		err = daemon(0, 0);
+		err = daemon(0, 1);
 		if (err) {
 			DPRINTF("failed to daemonize: %d\n", errno);
 			goto out;
 		}
 	}
 
-	tapdisk_start_logging("tapdisk", NULL);
-
 	err = tapdisk_control_open(&control);
 	if (err) {
 		DPRINTF("failed to open control socket: %d\n", err);
 		goto out;
 	}
 
-	err = tapdisk_server_complete();
-	if (err) {
-		DPRINTF("failed to complete server: %d\n", err);
-		goto out;
-	}
+	fprintf(stdout, "%s\n", control);
+	fflush(stdout);
+
+	if (!nodaemon) {
+		int fd;
 
-	fprintf(out, "%s\n", control);
-	fclose(out);
+		fd = open("/dev/null", O_RDWR);
+		if (fd != -1) {
+			dup2(fd, STDIN_FILENO);
+			dup2(fd, STDOUT_FILENO);
+			dup2(fd, STDERR_FILENO);
+			if (fd > 2)
+				close(fd);
+		}
+	}
 
-	err = tapdisk2_create_pid_file();
+	err = tapdisk_server_complete();
 	if (err) {
-		DPRINTF("failed to create pid file: %d\n", err);
+		DPRINTF("failed to complete server: %d\n", err);
 		goto out;
 	}
 
 	err = tapdisk_server_run();
-	if (!err)
-		tapdisk2_remove_pid_file();
 
 out:
 	tapdisk_control_close();
 	tapdisk_stop_logging();
-	return -err;
+	return err;
 }
diff -Nur blktap2_oxt//drivers/tapdisk2.h blktap2_xen//drivers/tapdisk2.h
--- blktap2_oxt//drivers/tapdisk2.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk2.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,11 +0,0 @@
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-#ifndef __TAPDISK2_H__
-#define __TAPDISK2_H__
-
-int tapdisk2_create_device();
-int tapdisk2_attach_device(int, const char *);
-
-#endif
diff -Nur blktap2_oxt//drivers/tapdisk-client.c blktap2_xen//drivers/tapdisk-client.c
--- blktap2_oxt//drivers/tapdisk-client.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-client.c	2015-03-19 11:08:36.000000000 -0400
@@ -26,11 +26,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2008 Citrix Systems, Inc.
- */
-
-
 /* client harness for tapdisk log */
 
 #include <errno.h>
@@ -114,7 +109,7 @@
   saddr.sun_family = AF_UNIX;
   memcpy(saddr.sun_path, sockpath, strlen(sockpath));
 
-  if (connect(fd, &saddr, sizeof(saddr)) < 0) {
+  if (connect(fd, (struct sockaddr *)&saddr, sizeof(saddr)) < 0) {
     BWPRINTF("error connecting to socket %s: %s", sockpath, strerror(errno));
     close(fd);
     return -1;
@@ -397,7 +392,7 @@
     BWPRINTF("EOF on control socket");
     return -1;
   } else if (rc < sizeof(msg)) {
-    BWPRINTF("short reply (%d/%d bytes)", rc, sizeof(msg));
+	  BWPRINTF("short reply (%d/%d bytes)", rc, (int) sizeof(msg));
     return -1;
   }
 
diff -Nur blktap2_oxt//drivers/tapdisk-control.c blktap2_xen//drivers/tapdisk-control.c
--- blktap2_oxt//drivers/tapdisk-control.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-control.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -42,7 +37,6 @@
 #include <sys/types.h>
 #include <sys/ioctl.h>
 #include <sys/socket.h>
-#include <sys/mman.h>
 
 #include "list.h"
 #include "tapdisk.h"
@@ -53,348 +47,32 @@
 #include "tapdisk-server.h"
 #include "tapdisk-message.h"
 #include "tapdisk-disktype.h"
-#include "tapdisk-stats.h"
-#include "tapdisk-control.h"
-
-#define TD_CTL_MAX_CONNECTIONS  10
-#define TD_CTL_SOCK_BACKLOG     32
-#define TD_CTL_RECV_TIMEOUT     10
-#define TD_CTL_SEND_TIMEOUT     10
-#define TD_CTL_SEND_BUFSZ       4096
-
-#define DBG(_f, _a...)             tlog_syslog(LOG_DEBUG, _f, ##_a)
-#define ERR(err, _f, _a...)        tlog_error(err, _f, ##_a)
-
-#define ASSERT(_p)							\
-	if (!(_p)) {							\
-		EPRINTF("%s:%d: FAILED ASSERTION: '%s'\n",		\
-			__FILE__, __LINE__, #_p);			\
-		td_panic();						\
-	}
-
-#define WARN_ON(_p)							\
-	if (_p) {							\
-		EPRINTF("%s:%d: WARNING: '%s'\n",			\
-			__FILE__, __LINE__, #_p);			\
-	}
-
-struct tapdisk_ctl_conn {
-	int             fd;
-
-	struct {
-		void           *buf;
-		size_t          bufsz;
-		int             event_id;
-		int             done;
-
-		void           *prod;
-		void           *cons;
-	} out;
-
-	struct {
-		int             event_id;
-		int             busy;
-	} in;
-
-	struct tapdisk_control_info *info;
-};
-
-#define TAPDISK_MSG_REENTER    (1<<0) /* non-blocking, idempotent */
-#define TAPDISK_MSG_VERBOSE    (1<<1) /* tell syslog about it */
-
-struct tapdisk_control_info {
-	void (*handler)(struct tapdisk_ctl_conn *, tapdisk_message_t *);
-	int flags;
-};
 
 struct tapdisk_control {
 	char              *path;
-	int                uuid;
 	int                socket;
 	int                event_id;
-	int                busy;
+};
 
-	int                n_conn;
-	struct tapdisk_ctl_conn __conn[TD_CTL_MAX_CONNECTIONS];
-	struct tapdisk_ctl_conn *conn[TD_CTL_MAX_CONNECTIONS];
+struct tapdisk_control_connection {
+	int                socket;
+	event_id_t         event_id;
 };
 
 static struct tapdisk_control td_control;
 
-static inline size_t
-page_align(size_t size)
-{
-	size_t page_size = sysconf(_SC_PAGE_SIZE);
-	return (size + page_size - 1) & ~(page_size - 1);
-}
-
-static void
-tapdisk_ctl_conn_uninit(struct tapdisk_ctl_conn *conn)
-{
-	if (conn->out.buf) {
-		munmap(conn->out.buf, conn->out.bufsz);
-		conn->out.buf = NULL;
-	}
-}
-
-static int
-tapdisk_ctl_conn_init(struct tapdisk_ctl_conn *conn, size_t bufsz)
-{
-	int prot, flags, err;
-
-	memset(conn, 0, sizeof(*conn));
-	conn->out.event_id = -1;
-	conn->in.event_id  = -1;
-
-	prot  = PROT_READ|PROT_WRITE;
-	flags = MAP_ANONYMOUS|MAP_PRIVATE;
-
-	conn->out.buf = mmap(NULL, bufsz, prot, flags, -1, 0);
-	if (conn->out.buf == MAP_FAILED) {
-		conn->out.buf = NULL;
-		err = -ENOMEM;
-		goto fail;
-	}
-	conn->out.bufsz = page_align(bufsz);
-
-	return 0;
-
-fail:
-	tapdisk_ctl_conn_uninit(conn);
-	return err;
-}
-
-static int
-tapdisk_ctl_conn_connected(struct tapdisk_ctl_conn *conn)
-{
-	return conn->fd >= 1;
-}
-
-static void
-tapdisk_ctl_conn_free(struct tapdisk_ctl_conn *conn)
-{
-	struct tapdisk_ctl_conn *prev, *next;
-	int i;
-
-	i = --td_control.n_conn;
-	/* NB. bubble the freed connection off the active list. */
-	prev = conn;
-	do {
-		ASSERT(i >= 0);
-		next = td_control.conn[i];
-		td_control.conn[i] = prev;
-		prev = next;
-		i--;
-	} while (next != conn);
-}
-
-static void
-tapdisk_ctl_conn_close(struct tapdisk_ctl_conn *conn)
-{
-	if (conn->out.event_id >= 0) {
-		tapdisk_server_unregister_event(conn->out.event_id);
-		conn->out.event_id = -1;
-	}
-
-	if (conn->fd >= 0) {
-		close(conn->fd);
-		conn->fd = -1;
-
-		tapdisk_ctl_conn_free(conn);
-		tapdisk_server_mask_event(td_control.event_id, 0);
-	}
-}
-
-static void
-tapdisk_ctl_conn_mask_out(struct tapdisk_ctl_conn *conn)
-{
-	tapdisk_server_mask_event(conn->out.event_id, 1);
-}
-
-static void
-tapdisk_ctl_conn_unmask_out(struct tapdisk_ctl_conn *conn)
-{
-	tapdisk_server_mask_event(conn->out.event_id, 0);
-}
-
-static ssize_t
-tapdisk_ctl_conn_send_buf(struct tapdisk_ctl_conn *conn)
-{
-	ssize_t size;
-
-	size = conn->out.prod - conn->out.cons;
-	if (!size)
-		return 0;
-
-	size = send(conn->fd, conn->out.cons, size, MSG_DONTWAIT);
-	if (size < 0)
-		return -errno;
-
-	conn->out.cons += size;
-
-	return size;
-}
-
-static void
-tapdisk_ctl_conn_send_event(event_id_t id, char mode, void *private)
-{
-	struct tapdisk_ctl_conn *conn = private;
-	ssize_t rv;
-
-	do {
-		rv = tapdisk_ctl_conn_send_buf(conn);
-	} while (rv > 0);
-
-	if (rv == -EAGAIN)
-		return;
-
-	if (rv < 0)
-		ERR(rv, "failure sending message at offset %d/%d\n",
-		    conn->out.cons - conn->out.buf,
-		    conn->out.prod - conn->out.buf);
-
-	if (rv || conn->out.done || mode & SCHEDULER_POLL_TIMEOUT)
-		tapdisk_ctl_conn_close(conn);
-	else
-		tapdisk_ctl_conn_mask_out(conn);
-}
-
-/*
- * NB. the control interface is still not properly integrated into the
- * server, therefore neither the scheduler. After the last close, the
- * server will exit but we still have a pending close response in the
- * output buffer.
- */
-static void
-tapdisk_ctl_conn_drain(struct tapdisk_ctl_conn *conn)
-{
-	struct timeval tv = { .tv_sec = TD_CTL_SEND_TIMEOUT,
-			      .tv_usec = 0 };
-	fd_set wfds;
-	int n, mode;
-
-	ASSERT(conn->out.done);
-	ASSERT(conn->fd >= 0);
-
-	while (tapdisk_ctl_conn_connected(conn)) {
-		FD_ZERO(&wfds);
-		FD_SET(conn->fd, &wfds);
-
-		n = select(conn->fd + 1, NULL, &wfds, NULL, &tv);
-		if (n < 0)
-			break;
-
-		if (n)
-			mode = SCHEDULER_POLL_WRITE_FD;
-		else
-			mode = SCHEDULER_POLL_TIMEOUT;
-
-		tapdisk_ctl_conn_send_event(conn->out.event_id, mode, conn);
-	}
-}
-
-
-struct tapdisk_ctl_conn *
-tapdisk_ctl_conn_open(int fd)
-{
-	struct tapdisk_ctl_conn *conn;
-
-	if (td_control.n_conn >= TD_CTL_MAX_CONNECTIONS)
-		return NULL;
-
-	conn = td_control.conn[td_control.n_conn++];
-
-	conn->out.event_id =
-		tapdisk_server_register_event(SCHEDULER_POLL_WRITE_FD,
-					      fd, TD_CTL_SEND_TIMEOUT,
-					      tapdisk_ctl_conn_send_event,
-					      conn);
-	if (conn->out.event_id < 0)
-		return NULL;
-
-	conn->fd       = fd;
-	conn->out.prod = conn->out.buf;
-	conn->out.cons = conn->out.buf;
-
-	tapdisk_ctl_conn_mask_out(conn);
-
-	if (td_control.n_conn >= TD_CTL_MAX_CONNECTIONS)
-		tapdisk_server_mask_event(td_control.event_id, 1);
-
-	return conn;
-}
-
-static size_t
-tapdisk_ctl_conn_write(struct tapdisk_ctl_conn *conn, void *buf, size_t size)
-{
-	size_t rest;
-
-	rest = conn->out.buf + conn->out.bufsz - conn->out.prod;
-	if (rest < size)
-		size = rest;
-	if (!size)
-		return 0;
-
-	memcpy(conn->out.prod, buf, size);
-	conn->out.prod += size;
-	tapdisk_ctl_conn_unmask_out(conn);
-
-	return size;
-}
-
-static void
-tapdisk_ctl_conn_release(struct tapdisk_ctl_conn *conn)
-{
-	conn->out.done = 1;
-
-	if (conn->out.prod == conn->out.cons)
-		tapdisk_ctl_conn_close(conn);
-}
-
 static void
 tapdisk_control_initialize(void)
 {
-	struct tapdisk_ctl_conn *conn;
-	int i;
-
 	td_control.socket   = -1;
 	td_control.event_id = -1;
 
 	signal(SIGPIPE, SIG_IGN);
-
-	for (i = 0; i < TD_CTL_MAX_CONNECTIONS; i++) {
-		conn = &td_control.__conn[i];
-		tapdisk_ctl_conn_init(conn, TD_CTL_SEND_BUFSZ);
-		td_control.conn[i] = conn;
-	}
-
-	td_control.n_conn = 0;
-
-	DPRINTF("tapdisk-control: init, %d x %zuk buffers\n",
-		TD_CTL_MAX_CONNECTIONS, TD_CTL_SEND_BUFSZ >> 10);
 }
 
 void
 tapdisk_control_close(void)
 {
-	struct tapdisk_ctl_conn *conn;
-	int i;
-
-	DPRINTF("tapdisk-control: draining %d connections\n",
-		td_control.n_conn);
-
-	while (td_control.n_conn) {
-		conn = td_control.conn[td_control.n_conn-1];
-		tapdisk_ctl_conn_drain(conn);
-	}
-
-	for (i = 0; i < TD_CTL_MAX_CONNECTIONS; i++) {
-		conn = &td_control.__conn[i];
-		tapdisk_ctl_conn_uninit(conn);
-	}
-
-	DPRINTF("tapdisk-control: done\n");
-
 	if (td_control.path) {
 		unlink(td_control.path);
 		free(td_control.path);
@@ -407,40 +85,40 @@
 	}
 }
 
-static void
-tapdisk_control_release_connection(struct tapdisk_ctl_conn *conn)
+static struct tapdisk_control_connection *
+tapdisk_control_allocate_connection(int fd)
 {
-	if (conn->in.event_id) {
-		tapdisk_server_unregister_event(conn->in.event_id);
-		conn->in.event_id = -1;
+	struct tapdisk_control_connection *connection;
+	size_t sz;
+
+	connection = calloc(1, sizeof(*connection));
+	if (!connection) {
+		EPRINTF("calloc");
+		return NULL;
 	}
 
-	tapdisk_ctl_conn_release(conn);
+	connection->socket = fd;
+	return connection;
 }
 
 static void
-tapdisk_control_close_connection(struct tapdisk_ctl_conn *conn)
+tapdisk_control_close_connection(struct tapdisk_control_connection *connection)
 {
-	tapdisk_control_release_connection(conn);
-
-	if (tapdisk_ctl_conn_connected(conn))
-		/* NB. best effort for write/close sequences. */
-		tapdisk_ctl_conn_send_buf(conn);
-
-	tapdisk_ctl_conn_close(conn);
+	tapdisk_server_unregister_event(connection->event_id);
+	close(connection->socket);
+	free(connection);
 }
 
-
 static int
 tapdisk_control_read_message(int fd, tapdisk_message_t *message, int timeout)
 {
-	const int len = sizeof(tapdisk_message_t);
 	fd_set readfds;
-	int ret, offset, err = 0;
+	int ret, len, offset;
 	struct timeval tv, *t;
 
 	t      = NULL;
 	offset = 0;
+	len    = sizeof(tapdisk_message_t);
 
 	if (timeout) {
 		tv.tv_sec  = timeout;
@@ -466,30 +144,63 @@
 			break;
 	}
 
-	if (ret < 0)
-		err = -errno;
-	else if (offset != len)
-		err = -EIO;
-	if (err)
-		ERR(err, "failure reading message at offset %d/%d\n",
-		    offset, len);
+	if (offset != len) {
+		EPRINTF("failure reading message (wanted %d but got %d)\n",
+			len, offset);
+		return -EIO;
+	}
 
+	DPRINTF("received '%s' message (uuid = %u)\n",
+		tapdisk_message_name(message->type), message->cookie);
 
-	return err;
+	return 0;
 }
 
-static void
-tapdisk_control_write_message(struct tapdisk_ctl_conn *conn,
-			      tapdisk_message_t *message)
+static int
+tapdisk_control_write_message(int fd, tapdisk_message_t *message, int timeout)
 {
-	size_t size = sizeof(*message), count;
+	fd_set writefds;
+	int ret, len, offset;
+	struct timeval tv, *t;
 
-	if (conn->info->flags & TAPDISK_MSG_VERBOSE)
-		DBG("sending '%s' message (uuid = %u)\n",
-		    tapdisk_message_name(message->type), message->cookie);
+	t      = NULL;
+	offset = 0;
+	len    = sizeof(tapdisk_message_t);
+
+	if (timeout) {
+		tv.tv_sec  = timeout;
+		tv.tv_usec = 0;
+		t = &tv;
+	}
 
-	count = tapdisk_ctl_conn_write(conn, message, size);
-	WARN_ON(count != size);
+	DPRINTF("sending '%s' message (uuid = %u)\n",
+		tapdisk_message_name(message->type), message->cookie);
+
+	while (offset < len) {
+		FD_ZERO(&writefds);
+		FD_SET(fd, &writefds);
+
+		/* we don't bother reinitializing tv. at worst, it will wait a
+		 * bit more time than expected. */
+
+		ret = select(fd + 1, NULL, &writefds, NULL, t);
+		if (ret == -1)
+			break;
+		else if (FD_ISSET(fd, &writefds)) {
+			ret = write(fd, message + offset, len - offset);
+			if (ret <= 0)
+				break;
+			offset += ret;
+		} else
+			break;
+	}
+
+	if (offset != len) {
+		EPRINTF("failure writing message\n");
+		return -EIO;
+	}
+
+	return 0;
 }
 
 static int
@@ -504,7 +215,7 @@
 }
 
 static void
-tapdisk_control_list_minors(struct tapdisk_ctl_conn *conn,
+tapdisk_control_list_minors(struct tapdisk_control_connection *connection,
 			    tapdisk_message_t *request)
 {
 	int i;
@@ -530,11 +241,13 @@
 	}
 
 	response.u.minors.count = i;
-	tapdisk_ctl_conn_write(conn, &response, 2);
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 }
 
 static void
-tapdisk_control_list(struct tapdisk_ctl_conn *conn, tapdisk_message_t *request)
+tapdisk_control_list(struct tapdisk_control_connection *connection,
+		     tapdisk_message_t *request)
 {
 	td_vbd_t *vbd;
 	struct list_head *head;
@@ -557,25 +270,29 @@
 		response.u.list.state   = vbd->state;
 		response.u.list.path[0] = 0;
 
-		if (vbd->name)
+		if (!list_empty(&vbd->images)) {
+			td_image_t *image = list_entry(vbd->images.next,
+						       td_image_t, next);
 			snprintf(response.u.list.path,
 				 sizeof(response.u.list.path),
 				 "%s:%s",
-				 tapdisk_disk_types[vbd->type]->name,
-				 vbd->name);
+				 tapdisk_disk_types[image->type]->name,
+				 image->name);
+		}
 
-		tapdisk_control_write_message(conn, &response);
+		tapdisk_control_write_message(connection->socket, &response, 2);
 	}
 
 	response.u.list.count   = count;
 	response.u.list.minor   = -1;
 	response.u.list.path[0] = 0;
 
-	tapdisk_control_write_message(conn, &response);
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 }
 
 static void
-tapdisk_control_get_pid(struct tapdisk_ctl_conn *conn,
+tapdisk_control_get_pid(struct tapdisk_control_connection *connection,
 			tapdisk_message_t *request)
 {
 	tapdisk_message_t response;
@@ -585,11 +302,12 @@
 	response.cookie = request->cookie;
 	response.u.tapdisk_pid = getpid();
 
-	tapdisk_control_write_message(conn, &response);
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 }
 
 static void
-tapdisk_control_attach_vbd(struct tapdisk_ctl_conn *conn,
+tapdisk_control_attach_vbd(struct tapdisk_control_connection *connection,
 			   tapdisk_message_t *request)
 {
 	tapdisk_message_t response;
@@ -640,7 +358,8 @@
 	response.cookie = request->cookie;
 	response.u.response.error = -err;
 
-	tapdisk_control_write_message(conn, &response);
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 
 	return;
 
@@ -652,7 +371,7 @@
 
 
 static void
-tapdisk_control_detach_vbd(struct tapdisk_ctl_conn *conn,
+tapdisk_control_detach_vbd(struct tapdisk_control_connection *connection,
 			   tapdisk_message_t *request)
 {
 	tapdisk_message_t response;
@@ -665,11 +384,6 @@
 		goto out;
 	}
 
-	if (vbd->name) {
-		err = -EBUSY;
-		goto out;
-	}
-
 	tapdisk_vbd_detach(vbd);
 
 	if (list_empty(&vbd->images)) {
@@ -684,20 +398,20 @@
 	response.cookie = request->cookie;
 	response.u.response.error = -err;
 
-	tapdisk_control_write_message(conn, &response);
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 }
 
 static void
-tapdisk_control_open_image(struct tapdisk_ctl_conn *conn,
+tapdisk_control_open_image(struct tapdisk_control_connection *connection,
 			   tapdisk_message_t *request)
 {
-	int err, type, secondary_type;
+	int err;
 	image_t image;
 	td_vbd_t *vbd;
 	td_flag_t flags;
 	tapdisk_message_t response;
 	struct blktap2_params params;
-	const char *path, *secondary_path;
 
 	vbd = tapdisk_server_get_vbd(request->cookie);
 	if (!vbd) {
@@ -716,8 +430,6 @@
 	}
 
 	flags = 0;
-	secondary_type = 0;
-	secondary_path = NULL;
 	if (request->u.params.flags & TAPDISK_MESSAGE_FLAG_RDONLY)
 		flags |= TD_OPEN_RDONLY;
 	if (request->u.params.flags & TAPDISK_MESSAGE_FLAG_SHARED)
@@ -728,32 +440,19 @@
 		flags |= TD_OPEN_VHD_INDEX;
 	if (request->u.params.flags & TAPDISK_MESSAGE_FLAG_LOG_DIRTY)
 		flags |= TD_OPEN_LOG_DIRTY;
-	if (request->u.params.flags & TAPDISK_MESSAGE_FLAG_ADD_LCACHE)
-		flags |= TD_OPEN_LOCAL_CACHE;
-	if (request->u.params.flags & TAPDISK_MESSAGE_FLAG_REUSE_PRT)
-		flags |= TD_OPEN_REUSE_PARENT;
-	if (request->u.params.flags & TAPDISK_MESSAGE_FLAG_STANDBY)
-		flags |= TD_OPEN_STANDBY;
-	if (request->u.params.flags & TAPDISK_MESSAGE_FLAG_SECONDARY) {
-		flags |= TD_OPEN_SECONDARY;
-		secondary_type = tapdisk_disktype_parse_params(
-				request->u.params.secondary, &secondary_path);
-		if (secondary_type < 0) {
-			err = secondary_type;
-			goto out;
-		}
-	}
 
-	type = tapdisk_disktype_parse_params(request->u.params.path, &path);
-	if (type < 0) {
-		err = type;
+	vbd->name = strndup(request->u.params.path,
+			    sizeof(request->u.params.path));
+	if (!vbd->name) {
+		err = -ENOMEM;
 		goto out;
 	}
 
-	err = tapdisk_vbd_open_vdi(vbd,
-				   type, path,
-				   flags, request->u.params.prt_devnum,
-				   secondary_type, secondary_path);
+	err = tapdisk_vbd_parse_stack(vbd, request->u.params.path);
+	if (err)
+		goto out;
+
+	err = tapdisk_vbd_open_stack(vbd, request->u.params.storage, flags);
 	if (err)
 		goto out;
 
@@ -763,8 +462,7 @@
 
 	params.capacity = image.size;
 	params.sector_size = image.secsize;
-	snprintf(params.name, sizeof(params.name) - 1,
-		 "%s", request->u.params.path);
+	strncpy(params.name, vbd->name, BLKTAP2_MAX_MESSAGE_LEN);
 
 	err = ioctl(vbd->ring.fd, BLKTAP2_IOCTL_CREATE_DEVICE, &params);
 	if (err && errno != EEXIST) {
@@ -789,18 +487,20 @@
 		response.type                = TAPDISK_MESSAGE_OPEN_RSP;
 	}
 
-	tapdisk_control_write_message(conn, &response);
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 
 	return;
 
 fail_close:
 	tapdisk_vbd_close_vdi(vbd);
-	free(vbd);
+	free(vbd->name);
+	vbd->name = NULL;
 	goto out;
 }
 
 static void
-tapdisk_control_close_image(struct tapdisk_ctl_conn *conn,
+tapdisk_control_close_image(struct tapdisk_control_connection *connection,
 			    tapdisk_message_t *request)
 {
 	tapdisk_message_t response;
@@ -809,35 +509,14 @@
 
 	vbd = tapdisk_server_get_vbd(request->cookie);
 	if (!vbd) {
-		err = -ENODEV;
+		err = -EINVAL;
 		goto out;
 	}
 
-	do {
-		err = ioctl(vbd->ring.fd, BLKTAP2_IOCTL_REMOVE_DEVICE);
-
-		if (!err || errno != EBUSY)
-			break;
-
-		tapdisk_server_iterate();
-
-	} while (conn->fd >= 0);
-
-	if (err) {
-		err = -errno;
-		ERR(err, "failure closing image\n");
-	}
-
-	if (err == -ENOTTY) {
-
-		while (!list_empty(&vbd->pending_requests))
-			tapdisk_server_iterate();
-
-		err = 0;
-	}
-
-	if (err)
+	if (!list_empty(&vbd->pending_requests)) {
+		err = -EAGAIN;
 		goto out;
+	}
 
 	tapdisk_vbd_close_vdi(vbd);
 
@@ -849,20 +528,22 @@
 
 	if (vbd->minor == -1) {
 		tapdisk_server_remove_vbd(vbd);
-		free(vbd);
+		tapdisk_vbd_free(vbd);
 	}
 
+	err = 0;
 out:
 	memset(&response, 0, sizeof(response));
 	response.type = TAPDISK_MESSAGE_CLOSE_RSP;
 	response.cookie = request->cookie;
 	response.u.response.error = -err;
 
-	tapdisk_control_write_message(conn, &response);
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 }
 
 static void
-tapdisk_control_pause_vbd(struct tapdisk_ctl_conn *conn,
+tapdisk_control_pause_vbd(struct tapdisk_control_connection *connection,
 			  tapdisk_message_t *request)
 {
 	int err;
@@ -886,25 +567,22 @@
 			break;
 
 		tapdisk_server_iterate();
-
-	} while (conn->fd >= 0);
+	} while (1);
 
 out:
 	response.cookie = request->cookie;
 	response.u.response.error = -err;
-	tapdisk_control_write_message(conn, &response);
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 }
 
 static void
-tapdisk_control_resume_vbd(struct tapdisk_ctl_conn *conn,
+tapdisk_control_resume_vbd(struct tapdisk_control_connection *connection,
 			   tapdisk_message_t *request)
 {
 	int err;
 	td_vbd_t *vbd;
 	tapdisk_message_t response;
-	const char *path = NULL;
-	int type = -1;
-	size_t len;
 
 	memset(&response, 0, sizeof(response));
 
@@ -916,212 +594,124 @@
 		goto out;
 	}
 
-	len = strnlen(request->u.params.path, sizeof(request->u.params.path));
-	if (len) {
-		type = tapdisk_disktype_parse_params(request->u.params.path, &path);
-		if (type < 0) {
-			err = type;
-			goto out;
-		}
+	if (!td_flag_test(vbd->state, TD_VBD_PAUSED)) {
+		err = -EINVAL;
+		goto out;
 	}
 
-	err = tapdisk_vbd_resume(vbd, type, path);
-
-out:
-	response.cookie = request->cookie;
-	response.u.response.error = -err;
-	tapdisk_control_write_message(conn, &response);
-}
-
-static void
-tapdisk_control_stats(struct tapdisk_ctl_conn *conn,
-		      tapdisk_message_t *request)
-{
-	tapdisk_message_t response;
-	td_stats_t _st, *st = &_st;
-	td_vbd_t *vbd;
-	size_t rv;
-
-	tapdisk_stats_init(st,
-			   conn->out.buf + sizeof(response),
-			   conn->out.bufsz - sizeof(response));
-
-	if (request->cookie != (uint16_t)-1) {
-
-		vbd = tapdisk_server_get_vbd(request->cookie);
-		if (!vbd) {
-			rv = -ENODEV;
+	if (request->u.params.path[0]) {
+		free(vbd->name);
+		vbd->name = strndup(request->u.params.path,
+				    sizeof(request->u.params.path));
+		if (!vbd->name) {
+			err = -ENOMEM;
 			goto out;
 		}
+	} else if (!vbd->name) {
+		err = -EINVAL;
+		goto out;
+	}
 
-		tapdisk_vbd_stats(vbd, st);
-
-	} else {
-		struct list_head *list = tapdisk_server_get_all_vbds();
-
-		tapdisk_stats_enter(st, '[');
-
-		list_for_each_entry(vbd, list, next)
-			tapdisk_vbd_stats(vbd, st);
+	err = tapdisk_vbd_parse_stack(vbd, vbd->name);
+	if (err)
+		goto out;
 
-		tapdisk_stats_leave(st, ']');
-	}
+	err = tapdisk_vbd_resume(vbd, NULL, -1);
+	if (err)
+		goto out;
 
-	rv = tapdisk_stats_length(st);
 out:
-	memset(&response, 0, sizeof(response));
-	response.type = TAPDISK_MESSAGE_STATS_RSP;
 	response.cookie = request->cookie;
-	response.u.info.length = rv;
-
-	tapdisk_control_write_message(conn, &response);
-	if (rv > 0)
-		conn->out.prod += rv;
+	response.u.response.error = -err;
+	tapdisk_control_write_message(connection->socket, &response, 2);
+	tapdisk_control_close_connection(connection);
 }
 
-struct tapdisk_control_info message_infos[] = {
-	[TAPDISK_MESSAGE_PID] = {
-		.handler = tapdisk_control_get_pid,
-		.flags   = TAPDISK_MSG_REENTER,
-	},
-	[TAPDISK_MESSAGE_LIST] = {
-		.handler = tapdisk_control_list,
-		.flags   = TAPDISK_MSG_REENTER,
-	},
-	[TAPDISK_MESSAGE_ATTACH] = {
-		.handler = tapdisk_control_attach_vbd,
-		.flags   = TAPDISK_MSG_VERBOSE,
-	},
-	[TAPDISK_MESSAGE_DETACH] = {
-		.handler = tapdisk_control_detach_vbd,
-		.flags   = TAPDISK_MSG_VERBOSE,
-	},
-	[TAPDISK_MESSAGE_OPEN] = {
-		.handler = tapdisk_control_open_image,
-		.flags   = TAPDISK_MSG_VERBOSE,
-	},
-	[TAPDISK_MESSAGE_PAUSE] = {
-		.handler = tapdisk_control_pause_vbd,
-		.flags   = TAPDISK_MSG_VERBOSE,
-	},
-	[TAPDISK_MESSAGE_RESUME] = {
-		.handler = tapdisk_control_resume_vbd,
-		.flags   = TAPDISK_MSG_VERBOSE,
-	},
-	[TAPDISK_MESSAGE_CLOSE] = {
-		.handler = tapdisk_control_close_image,
-		.flags   = TAPDISK_MSG_VERBOSE,
-	},
-	[TAPDISK_MESSAGE_STATS] = {
-		.handler = tapdisk_control_stats,
-		.flags   = TAPDISK_MSG_REENTER,
-	},
-};
-
-
 static void
 tapdisk_control_handle_request(event_id_t id, char mode, void *private)
 {
-	int err, len, excl;
-	tapdisk_message_t message, response;
-	struct tapdisk_ctl_conn *conn = private;
-	struct tapdisk_control_info *info;
-
-	err = tapdisk_control_read_message(conn->fd, &message, 2);
-	if (err)
-		goto close;
-
-	if (conn->in.busy)
-		goto busy;
+	int err;
+	tapdisk_message_t message;
+	struct tapdisk_control_connection *connection =
+		(struct tapdisk_control_connection *)private;
+
+	if (tapdisk_control_read_message(connection->socket, &message, 2)) {
+		EPRINTF("failed to read message from %d\n", connection->socket);
+		tapdisk_control_close_connection(connection);
+		return;
+	}
 
 	err = tapdisk_control_validate_request(&message);
 	if (err)
-		goto invalid;
-
-	if (message.type > TAPDISK_MESSAGE_EXIT)
-		goto invalid;
-
-	info = &message_infos[message.type];
-
-	if (!info->handler)
-		goto invalid;
-
-	if (info->flags & TAPDISK_MSG_VERBOSE)
-		DBG("received '%s' message (uuid = %u)\n",
-		    tapdisk_message_name(message.type), message.cookie);
+		goto fail;
 
-	excl = !(info->flags & TAPDISK_MSG_REENTER);
-	if (excl) {
-		if (td_control.busy)
-			goto busy;
+	switch (message.type) {
+	case TAPDISK_MESSAGE_PID:
+		return tapdisk_control_get_pid(connection, &message);
+	case TAPDISK_MESSAGE_LIST_MINORS:
+		return tapdisk_control_list_minors(connection, &message);
+	case TAPDISK_MESSAGE_LIST:
+		return tapdisk_control_list(connection, &message);
+	case TAPDISK_MESSAGE_ATTACH:
+		return tapdisk_control_attach_vbd(connection, &message);
+	case TAPDISK_MESSAGE_DETACH:
+		return tapdisk_control_detach_vbd(connection, &message);
+	case TAPDISK_MESSAGE_OPEN:
+		return tapdisk_control_open_image(connection, &message);
+	case TAPDISK_MESSAGE_PAUSE:
+		return tapdisk_control_pause_vbd(connection, &message);
+	case TAPDISK_MESSAGE_RESUME:
+		return tapdisk_control_resume_vbd(connection, &message);
+	case TAPDISK_MESSAGE_CLOSE:
+		return tapdisk_control_close_image(connection, &message);
+	default: {
+		tapdisk_message_t response;
+	fail:
+
+		EPRINTF("received unsupported message '%s'\n",
+			tapdisk_message_name(message.type));
+
+		memset(&response, 0, sizeof(response));
+
+		response.type = TAPDISK_MESSAGE_ERROR;
+		response.u.response.error = (err ? -err : EINVAL);
+		tapdisk_control_write_message(connection->socket, &response, 2);
 
-		td_control.busy = 1;
+		tapdisk_control_close_connection(connection);
+		break;
+	}
 	}
-	conn->in.busy = 1;
-	conn->info    = info;
-
-	info->handler(conn, &message);
-
-	conn->in.busy = 0;
-	if (excl)
-		td_control.busy = 0;
-
-	tapdisk_control_release_connection(conn);
-	return;
-
-error:
-	memset(&response, 0, sizeof(response));
-	response.type = TAPDISK_MESSAGE_ERROR;
-	response.u.response.error = (err ? -err : EINVAL);
-	tapdisk_control_write_message(conn, &response);
-
-close:
-	tapdisk_control_close_connection(conn);
-	return;
-
-busy:
-	err = -EBUSY;
-	ERR(err, "rejecting message '%s' while busy\n",
-	    tapdisk_message_name(message.type));
-	goto error;
-
-invalid:
-	err = -EINVAL;
-	ERR(err, "rejecting unsupported message '%s'\n",
-	    tapdisk_message_name(message.type));
-	goto error;
 }
 
 static void
 tapdisk_control_accept(event_id_t id, char mode, void *private)
 {
 	int err, fd;
-	struct tapdisk_ctl_conn *conn;
+	struct tapdisk_control_connection *connection;
 
 	fd = accept(td_control.socket, NULL, NULL);
 	if (fd == -1) {
-		ERR(-errno, "failed to accept new control connection: %d\n", errno);
+		EPRINTF("failed to accept new control connection: %d\n", errno);
 		return;
 	}
 
-	conn = tapdisk_ctl_conn_open(fd);
-	if (!conn) {
+	connection = tapdisk_control_allocate_connection(fd);
+	if (!connection) {
 		close(fd);
-		ERR(-ENOMEM, "failed to allocate new control connection\n");
-		return;
+		EPRINTF("failed to allocate new control connection\n");
 	}
 
 	err = tapdisk_server_register_event(SCHEDULER_POLL_READ_FD,
-					    conn->fd, TD_CTL_RECV_TIMEOUT,
+					    connection->socket, 0,
 					    tapdisk_control_handle_request,
-					    conn);
+					    connection);
 	if (err == -1) {
-		tapdisk_control_close_connection(conn);
-		ERR(err, "failed to register new control event\n");
-		return;
+		close(fd);
+		free(connection);
+		EPRINTF("failed to register new control event: %d\n", err);
 	}
 
-	conn->in.event_id = err;
+	connection->event_id = err;
 }
 
 static int
@@ -1211,7 +801,7 @@
 		goto fail;
 	}
 
-	err = listen(td_control.socket, TD_CTL_SOCK_BACKLOG);
+	err = listen(td_control.socket, 10);
 	if (err == -1) {
 		err = errno;
 		EPRINTF("failed to listen: %d\n", err);
diff -Nur blktap2_oxt//drivers/tapdisk-control.h blktap2_xen//drivers/tapdisk-control.h
--- blktap2_oxt//drivers/tapdisk-control.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-control.h	2015-03-19 11:08:36.000000000 -0400
@@ -26,11 +26,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
 #ifndef __TAPDISK_CONTROL_H__
 #define __TAPDISK_CONTROL_H__
 
diff -Nur blktap2_oxt//drivers/tapdisk-diff.c blktap2_xen//drivers/tapdisk-diff.c
--- blktap2_oxt//drivers/tapdisk-diff.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-diff.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,6 +1,5 @@
-/*
- * Copyright (c) 2009, Citrix Systems, Inc.
- *
+/* 
+ * Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -25,14 +24,14 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
+#include <libgen.h>	/* for basename(3) */
 #include <unistd.h>
 
 #include "list.h"
@@ -40,6 +39,7 @@
 #include "tapdisk-vbd.h"
 #include "tapdisk-server.h"
 #include "tapdisk-disktype.h"
+#include "tapdisk-utils.h"
 #include "libvhd.h"
 
 #define POLL_READ                        0
@@ -47,21 +47,6 @@
 
 #define SPB_SHIFT (VHD_BLOCK_SHIFT - SECTOR_SHIFT)
 
-/* 
- * we have to use half the max number of requests because we're using the same 
- * tapdisk server for both streams and all the parents will be shared. If we 
- * issue more than MAX_REQUESTS/2 requests, the vhd_state will run out of 
- * vhd_request's and return EBUSY, which we don't handle here. However, even 
- * with MAX_REQUESTS/2 we can still run out of vhd_request's because of 
- * splitting: if some sectors spanned by a segment are in a parent, a segment 
- * could be split into at most N/2 vhd_request's, where N is the number of 
- * sectors per segment. Therefore, if we use 11 segments, we need to divide 
- * MAX_REQUESTS by 11/2=6 on top of that. If we don't, we'd have to handle 
- * EBUSY by retrying here.
- */
-#define MAX_SEGMENTS 8
-#define MAX_STREAM_REQUESTS (MAX_REQUESTS / 2 / (MAX_SEGMENTS / 2))
-
 struct tapdisk_stream_poll {
 	int                              pipe[2];
 	int                              set;
@@ -96,7 +81,7 @@
 	struct list_head                 pending_list;
 	struct list_head                 completed_list;
 
-	struct tapdisk_stream_request    requests[MAX_STREAM_REQUESTS];
+	struct tapdisk_stream_request    requests[MAX_REQUESTS];
 };
 
 static unsigned int tapdisk_stream_count;
@@ -184,9 +169,9 @@
 static inline void
 tapdisk_stream_poll_clear(struct tapdisk_stream_poll *p)
 {
-	int gcc, dummy;
+	int dummy;
 
-	gcc = read(p->pipe[POLL_READ], &dummy, sizeof(dummy));
+	read_exact(p->pipe[POLL_READ], &dummy, sizeof(dummy));
 	p->set = 0;
 }
 
@@ -196,7 +181,7 @@
 	int dummy = 0;
 
 	if (!p->set) {
-		int gcc = write(p->pipe[POLL_WRITE], &dummy, sizeof(dummy));
+		write_exact(p->pipe[POLL_WRITE], &dummy, sizeof(dummy));
 		p->set = 1;
 	}
 }
@@ -341,12 +326,11 @@
 	else {
 		s->err = EIO;
 		list_add_tail(&sreq->next, &s->free_list);
-		fprintf(stderr, "error reading sector %llu (stream %d)\n",
-				sreq->sec, (s == &stream2) + 1);
+		fprintf(stderr, "error reading sector 0x%"PRIx64"\n", sreq->sec);
 	}
 
 	if (tapdisk_stream_process_data()) {
-		fprintf(stderr, "mismatch at sector %llu\n",
+		fprintf(stderr, "mismatch at sector 0x%"PRIx64"\n",
 				sreq->sec);
 		stream1.err = EINVAL;
 		stream2.err = EINVAL;
@@ -395,7 +379,6 @@
 	assert(vreq->secs_pending == 0);
 
 	memcpy(&vreq->req, breq, sizeof(*breq));
-	s->started++;
 	vbd->received++;
 	vreq->vbd = vbd;
 
@@ -447,7 +430,7 @@
 		breq->sector_number = sreq->sec;
 		breq->operation     = BLKIF_OP_READ;
 
-		for (i = 0; i < MAX_SEGMENTS; i++) {
+		for (i = 0; i < BLKIF_MAX_SEGMENTS_PER_REQUEST; i++) {
 			uint32_t secs;
 			struct blkif_request_segment *seg = breq->seg + i;
 
@@ -559,7 +542,7 @@
 
 	s->id = tapdisk_stream_count++;
 
-	err = tapdisk_vbd_initialize(-1, -1, s->id);
+	err = tapdisk_vbd_initialize(s->id);
 	if (err)
 		goto out;
 
@@ -571,11 +554,14 @@
 
 	tapdisk_vbd_set_callback(s->vbd, tapdisk_stream_dequeue, s);
 
-	err = tapdisk_vbd_open_vdi(s->vbd, type, path,
-				   TD_OPEN_RDONLY, -1, -1, NULL);
+	err = tapdisk_vbd_open_vdi(s->vbd, path, type,
+				   TAPDISK_STORAGE_TYPE_DEFAULT,
+				   TD_OPEN_RDONLY);
 	if (err)
 		goto out;
 
+	s->vbd->reopened = 1;
+
 	err = tapdisk_vbd_get_image_info(s->vbd, &image);
 	if (err) {
 		fprintf(stderr, "failed getting image size: %d\n", err);
@@ -629,7 +615,7 @@
 		return err;
 	}
 
-	for (i = 0; i < MAX_STREAM_REQUESTS; i++) {
+	for (i = 0; i < MAX_REQUESTS; i++) {
 		struct tapdisk_stream_request *req = s->requests + i;
 		tapdisk_stream_initialize_request(req);
 		list_add_tail(&req->next, &s->free_list);
@@ -771,9 +757,9 @@
 	if (err)
 		return err;
 
-	tapdisk_start_logging("tapdisk-diff", "daemon");
+	tapdisk_start_logging("tapdisk-diff");
 
-	err = tapdisk_server_initialize(NULL, NULL);
+	err = tapdisk_server_initialize();
 	if (err)
 		goto out;
 
diff -Nur blktap2_oxt//drivers/tapdisk-disktype.c blktap2_xen//drivers/tapdisk-disktype.c
--- blktap2_oxt//drivers/tapdisk-disktype.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-disktype.c	2015-03-19 11:08:36.000000000 -0400
@@ -26,16 +26,12 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
 #include <stddef.h>
 #include <string.h>
 #include <errno.h>
 
 #include "tapdisk-disktype.h"
+#include "tapdisk-message.h"
 
 static const disk_info_t aio_disk = {
        "aio",
@@ -98,13 +94,12 @@
 	0,
 };
 
-static const disk_info_t local_cache_disk = {
-       "lc",
-       "local cache image (lc)",
+static const disk_info_t remus_disk = {
+       "remus",
+       "remus disk replicator (remus)",
        0,
 };
 
-
 const disk_info_t *tapdisk_disk_types[] = {
 	[DISK_TYPE_AIO]	= &aio_disk,
 	[DISK_TYPE_SYNC]	= &sync_disk,
@@ -114,48 +109,37 @@
 	[DISK_TYPE_RAM]	= &ram_disk,
 	[DISK_TYPE_QCOW]	= &qcow_disk,
 	[DISK_TYPE_BLOCK_CACHE] = &block_cache_disk,
-	[DISK_TYPE_VINDEX]	= &vhd_index_disk,
 	[DISK_TYPE_LOG]	= &log_disk,
-	[DISK_TYPE_LOCAL_CACHE] = &local_cache_disk,
+	[DISK_TYPE_VINDEX]	= &vhd_index_disk,
+	[DISK_TYPE_REMUS]	= &remus_disk,
 	0,
 };
 
 extern struct tap_disk tapdisk_aio;
-#if 0
 extern struct tap_disk tapdisk_sync;
 extern struct tap_disk tapdisk_vmdk;
 extern struct tap_disk tapdisk_vhdsync;
-#endif
 extern struct tap_disk tapdisk_vhd;
 extern struct tap_disk tapdisk_ram;
-#if 0
 extern struct tap_disk tapdisk_qcow;
-#endif
 extern struct tap_disk tapdisk_block_cache;
 extern struct tap_disk tapdisk_vhd_index;
-#if 0
 extern struct tap_disk tapdisk_log;
-#endif
-extern struct tap_disk tapdisk_local_cache;
+extern struct tap_disk tapdisk_remus;
 
 const struct tap_disk *tapdisk_disk_drivers[] = {
 	[DISK_TYPE_AIO]         = &tapdisk_aio,
 #if 0
 	[DISK_TYPE_SYNC]        = &tapdisk_sync,
 	[DISK_TYPE_VMDK]        = &tapdisk_vmdk,
-	[DISK_TYPE_VHDSYNC]     = &tapdisk_vhdsync_disk
 #endif
 	[DISK_TYPE_VHD]         = &tapdisk_vhd,
 	[DISK_TYPE_RAM]         = &tapdisk_ram,
-#if 0
 	[DISK_TYPE_QCOW]        = &tapdisk_qcow,
-#endif
 	[DISK_TYPE_BLOCK_CACHE] = &tapdisk_block_cache,
 	[DISK_TYPE_VINDEX]      = &tapdisk_vhd_index,
-#if 0
 	[DISK_TYPE_LOG]         = &tapdisk_log,
-#endif
-	[DISK_TYPE_LOCAL_CACHE] = &tapdisk_local_cache,
+	[DISK_TYPE_REMUS]       = &tapdisk_remus,
 	0,
 };
 
@@ -204,3 +188,17 @@
 
 	return type;
 }
+
+int
+tapdisk_parse_disk_type(const char *params, const char **_path, int *_type)
+{
+	int type;
+
+	type = tapdisk_disktype_parse_params(params, _path);
+	if (type < 0)
+		return type;
+
+	*_type = type;
+
+	return 0;
+}
diff -Nur blktap2_oxt//drivers/tapdisk-disktype.h blktap2_xen//drivers/tapdisk-disktype.h
--- blktap2_oxt//drivers/tapdisk-disktype.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-disktype.h	2015-03-19 11:08:36.000000000 -0400
@@ -26,11 +26,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
 #ifndef __DISKTYPES_H__
 #define __DISKTYPES_H__
 
@@ -42,10 +37,9 @@
 #define DISK_TYPE_RAM         5
 #define DISK_TYPE_QCOW        6
 #define DISK_TYPE_BLOCK_CACHE 7
-#define DISK_TYPE_VINDEX      8
-#define DISK_TYPE_LOG         9
-#define DISK_TYPE_REMUS       10
-#define DISK_TYPE_LOCAL_CACHE 11
+#define DISK_TYPE_LOG         8
+#define DISK_TYPE_REMUS       9
+#define DISK_TYPE_VINDEX      10
 
 #define DISK_TYPE_NAME_MAX    32
 
@@ -63,5 +57,6 @@
 
 int tapdisk_disktype_find(const char *name);
 int tapdisk_disktype_parse_params(const char *params, const char **_path);
+int tapdisk_parse_disk_type(const char *, const char **, int *);
 
 #endif
diff -Nur blktap2_oxt//drivers/tapdisk-driver.c blktap2_xen//drivers/tapdisk-driver.c
--- blktap2_oxt//drivers/tapdisk-driver.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-driver.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,22 +25,14 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
 #include <stdlib.h>
-#include <stdio.h>
 
 #include "tapdisk-driver.h"
 #include "tapdisk-server.h"
 #include "tapdisk-disktype.h"
-#include "tapdisk-stats.h"
 
 td_driver_t *
-tapdisk_driver_allocate(int type, char *name, td_flag_t flags)
+tapdisk_driver_allocate(int type, char *name, td_flag_t flags, int storage)
 {
 	int err;
 	td_driver_t *driver;
@@ -60,7 +52,7 @@
 
 	driver->ops     = ops;
 	driver->type    = type;
-	driver->storage = -1;
+	driver->storage = storage;
 	driver->data    = calloc(1, ops->private_data_size);
 	if (!driver->data)
 		goto fail;
@@ -107,22 +99,3 @@
 	if (driver->ops->td_debug)
 		driver->ops->td_debug(driver);
 }
-
-void
-tapdisk_driver_stats(td_driver_t *driver, td_stats_t *st)
-{
-	const disk_info_t *info;
-
-	tapdisk_stats_field(st, "type", "d", driver->type);
-
-	info = tapdisk_disk_types[driver->type];
-	tapdisk_stats_field(st, "name", "s", info->name);
-
-	if (driver->ops->td_stats) {
-		tapdisk_stats_field(st, "status", "{");
-		driver->ops->td_stats(driver, st);
-		tapdisk_stats_leave(st, '}');
-	} else
-		tapdisk_stats_field(st, "status", NULL);
-
-}
diff -Nur blktap2_oxt//drivers/tapdisk-driver.h blktap2_xen//drivers/tapdisk-driver.h
--- blktap2_oxt//drivers/tapdisk-driver.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-driver.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #ifndef _TAPDISK_DRIVER_H_
 #define _TAPDISK_DRIVER_H_
 
@@ -57,13 +52,11 @@
 	struct list_head             next;
 };
 
-td_driver_t *tapdisk_driver_allocate(int, char *, td_flag_t);
+td_driver_t *tapdisk_driver_allocate(int, char *, td_flag_t, int);
 void tapdisk_driver_free(td_driver_t *);
 
 void tapdisk_driver_queue_tiocb(td_driver_t *, struct tiocb *);
 
 void tapdisk_driver_debug(td_driver_t *);
 
-void tapdisk_driver_stats(td_driver_t *, td_stats_t *);
-
 #endif
diff -Nur blktap2_oxt//drivers/tapdisk-filter.c blktap2_xen//drivers/tapdisk-filter.c
--- blktap2_oxt//drivers/tapdisk-filter.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-filter.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,5 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* 
+ * Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,7 +24,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
+*/
 
 #include <stdlib.h>
 #include <unistd.h>
@@ -115,10 +113,11 @@
 	if (hash->hash != chksum(buf)) {
 		struct timeval now;
 		gettimeofday(&now, NULL);
-		DBG("%s: hash table: 0x%020" PRIx64 " at %012lu.%06lu, "
-		    "from disk: 0x%020" PRIx64 " at %012lu.%06lu\n",
+		DBG("%s: hash table: 0x%020" PRIx64 " at %012lu.%06llu, "
+		    "from disk: 0x%020" PRIx64 " at %012lu.%06llu\n",
 		    type, hash->hash, hash->time.tv_sec,
-		    hash->time.tv_usec, sum, now.tv_sec, now.tv_usec);
+		    (unsigned long long)hash->time.tv_usec, sum,
+		    now.tv_sec, (unsigned long long)now.tv_usec);
 	}
 }
 
diff -Nur blktap2_oxt//drivers/tapdisk-filter.h blktap2_xen//drivers/tapdisk-filter.h
--- blktap2_oxt//drivers/tapdisk-filter.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-filter.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,12 +1,30 @@
-/* Copyright (c) 2007, XenSource Inc.
+/* 
+ * Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
- */
-
-/*
- * Copyright (c) 2008 Citrix Systems, Inc.
- */
-
-
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of XenSource Inc. nor the names of its contributors
+ *       may be used to endorse or promote products derived from this software
+ *       without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
 #ifndef TAPDISK_FILTER_H
 #define TAPDISK_FILTER_H
 
diff -Nur blktap2_oxt//drivers/tapdisk.h blktap2_xen//drivers/tapdisk.h
--- blktap2_oxt//drivers/tapdisk.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk.h	2015-03-19 11:08:36.000000000 -0400
@@ -53,11 +53,6 @@
  *     -errno on error
  */
 
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
 #ifndef _TAPDISK_H_
 #define _TAPDISK_H_
 
@@ -65,11 +60,17 @@
 #include <stdint.h>
 
 #include "list.h"
-#include "blktap-int.h"
 #include "blktaplib.h"
 #include "tapdisk-log.h"
 #include "tapdisk-utils.h"
-#include "tapdisk-stats.h"
+
+#ifdef MEMSHR
+#include "memshr.h"
+#endif
+
+#define DPRINTF(_f, _a...)           syslog(LOG_INFO, _f, ##_a)
+#define EPRINTF(_f, _a...)           syslog(LOG_ERR, "tap-err:%s: " _f, __func__, ##_a)
+#define PERROR(_f, _a...)            EPRINTF(_f ": %s", ##_a, strerror(errno))
 
 #define MAX_SEGMENTS_PER_REQ         11
 #define SECTOR_SHIFT                 9
@@ -93,11 +94,6 @@
 #define TD_OPEN_ADD_CACHE            0x00020
 #define TD_OPEN_VHD_INDEX            0x00040
 #define TD_OPEN_LOG_DIRTY            0x00080
-#define TD_OPEN_LOCAL_CACHE          0x00100
-#define TD_OPEN_REUSE_PARENT         0x00200
-#define TD_OPEN_SECONDARY            0x00400
-#define TD_OPEN_STANDBY              0x00800
-#define TD_IGNORE_ENOSPC             0x01000
 
 #define TD_CREATE_SPARSE             0x00001
 #define TD_CREATE_MULTITYPE          0x00002
@@ -114,12 +110,6 @@
 typedef struct td_request            td_request_t;
 typedef struct td_driver_handle      td_driver_t;
 typedef struct td_image_handle       td_image_t;
-typedef struct td_sector_count       td_sector_count_t;
-
-/* 
- * Prototype of the callback to activate as requests complete.
- */
-typedef void (*td_callback_t)(td_request_t, int);
 
 struct td_disk_id {
 	char                        *name;
@@ -128,7 +118,7 @@
 
 struct td_disk_info {
 	td_sector_t                  size;
-        long                         sector_size;
+        uint64_t                     sector_size;
 	uint32_t                     info;
 };
 
@@ -138,17 +128,28 @@
 	td_sector_t                  sec;
 	int                          secs;
 
+	uint8_t                      blocked; /* blocked on a dependency */
+
 	td_image_t                  *image;
 
-	td_callback_t                cb;
+	void * /*td_callback_t*/     cb;
 	void                        *cb_data;
 
 	uint64_t                     id;
 	int                          sidx;
 	void                        *private;
+    
+#ifdef MEMSHR
+	share_tuple_t                memshr_hnd;
+#endif
 };
 
 /* 
+ * Prototype of the callback to activate as requests complete.
+ */
+typedef void (*td_callback_t)(td_request_t, int);
+
+/* 
  * Structure describing the interface to a virtual disk implementation.
  * See note at the top of this file describing this interface.
  */
@@ -163,23 +164,6 @@
 	void (*td_queue_read)        (td_driver_t *, td_request_t);
 	void (*td_queue_write)       (td_driver_t *, td_request_t);
 	void (*td_debug)             (td_driver_t *);
-	void (*td_stats)             (td_driver_t *, td_stats_t *);
-};
-
-struct td_sector_count {
-	td_sector_t rd;
-	td_sector_t wr;
 };
 
-static inline void
-td_sector_count_add(td_sector_count_t *s, td_sector_t v, int write)
-{
-	if (write)
-		s->wr += v;
-	else
-		s->rd += v;
-}
-
-void td_panic(void);
-
 #endif
diff -Nur blktap2_oxt//drivers/tapdisk-image.c blktap2_xen//drivers/tapdisk-image.c
--- blktap2_oxt//drivers/tapdisk-image.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-image.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,25 +25,22 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #include <errno.h>
 #include <unistd.h>
 #include <stdlib.h>
-#include <stdio.h>
+#ifdef MEMSHR
+#include <memshr.h>
+#endif
 
 #include "tapdisk-image.h"
 #include "tapdisk-driver.h"
 #include "tapdisk-server.h"
-#include "tapdisk-stats.h"
 
 #define ERR(_err, _f, _a...) tlog_error(_err, _f, ##_a)
 
 td_image_t *
-tapdisk_image_allocate(char *file, int type, td_flag_t flags, void *private)
+tapdisk_image_allocate(const char *file, int type, int storage,
+		       td_flag_t flags, void *private)
 {
 	int err;
 	td_image_t *image;
@@ -58,9 +55,13 @@
 		return NULL;
 	}
 
-	image->type    = type;
-	image->flags   = flags;
-	image->private = private;
+	image->type      = type;
+	image->flags     = flags;
+	image->storage   = storage;
+	image->private   = private;
+#ifdef MEMSHR
+	image->memshr_id = memshr_vbd_image_get(file);
+#endif
 	INIT_LIST_HEAD(&image->next);
 
 	return image;
@@ -74,6 +75,9 @@
 
 	list_del(&image->next);
 
+#ifdef MEMSHR
+	memshr_vbd_image_put(image->memshr_id);
+#endif
 	free(image->name);
 	tapdisk_driver_free(image->driver);
 	free(image);
@@ -82,12 +86,10 @@
 int
 tapdisk_image_check_td_request(td_image_t *image, td_request_t treq)
 {
-	int rdonly, err;
+	int rdonly;
 	td_driver_t *driver;
 	td_disk_info_t *info;
 
-	err = -EINVAL;
-
 	driver = image->driver;
 	if (!driver)
 		return -ENODEV;
@@ -98,10 +100,8 @@
 	if (treq.op != TD_OP_READ && treq.op != TD_OP_WRITE)
 		goto fail;
 
-	if (treq.op == TD_OP_WRITE && rdonly) {
-		err = -EPERM;
+	if (treq.op == TD_OP_WRITE && rdonly)
 		goto fail;
-	}
 
 	if (treq.secs <= 0 || treq.sec + treq.secs > info->size)
 		goto fail;
@@ -109,10 +109,10 @@
 	return 0;
 
 fail:
-	ERR(err, "bad td request on %s (%s, %llu): %d at %llu",
+	ERR(-EINVAL, "bad td request on %s (%s, %"PRIu64"): %d at %"PRIu64,
 	    image->name, (rdonly ? "ro" : "rw"), info->size, treq.op,
 	    treq.sec + treq.secs);
-	return err;
+	return -EINVAL;
 
 }
 
@@ -121,14 +121,13 @@
 {
 	td_driver_t *driver;
 	td_disk_info_t *info;
+	int i, psize, rdonly;
 	uint64_t nsects, total;
-	int i, err, psize, rdonly;
 
 	driver = image->driver;
 	if (!driver)
 		return -ENODEV;
 
-	err    = -EINVAL;
 	nsects = 0;
 	total  = 0;
 	info   = &driver->info;
@@ -139,10 +138,8 @@
 	    req->operation != BLKIF_OP_WRITE)
 		goto fail;
 
-	if (req->operation == BLKIF_OP_WRITE && rdonly) {
-		err = -EPERM;
+	if (req->operation == BLKIF_OP_WRITE && rdonly)
 		goto fail;
-	}
 
 	if (!req->nr_segments || req->nr_segments > MAX_SEGMENTS_PER_REQ)
 		goto fail;
@@ -165,31 +162,8 @@
 	return 0;
 
 fail:
-	ERR(err, "bad request on %s (%s, %llu): id: %llu: %d at %llu",
+	ERR(-EINVAL, "bad request on %s (%s, %"PRIu64"): id: %"PRIu64": %d at %"PRIu64,
 	    image->name, (rdonly ? "ro" : "rw"), info->size, req->id,
 	    req->operation, req->sector_number + total);
-	return err;
-}
-
-void
-tapdisk_image_stats(td_image_t *image, td_stats_t *st)
-{
-	tapdisk_stats_enter(st, '{');
-	tapdisk_stats_field(st, "name", "s", image->name);
-
-	tapdisk_stats_field(st, "hits", "[");
-	tapdisk_stats_val(st, "llu", image->stats.hits.rd);
-	tapdisk_stats_val(st, "llu", image->stats.hits.wr);
-	tapdisk_stats_leave(st, ']');
-
-	tapdisk_stats_field(st, "fail", "[");
-	tapdisk_stats_val(st, "llu", image->stats.fail.rd);
-	tapdisk_stats_val(st, "llu", image->stats.fail.wr);
-	tapdisk_stats_leave(st, ']');
-
-	tapdisk_stats_field(st, "driver", "{");
-	tapdisk_driver_stats(image->driver, st);
-	tapdisk_stats_leave(st, '}');
-
-	tapdisk_stats_leave(st, '}');
+	return -EINVAL;
 }
diff -Nur blktap2_oxt//drivers/tapdisk-image.h blktap2_xen//drivers/tapdisk-image.h
--- blktap2_oxt//drivers/tapdisk-image.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-image.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #ifndef _TAPDISK_IMAGE_H_
 #define _TAPDISK_IMAGE_H_
 
@@ -39,8 +34,10 @@
 struct td_image_handle {
 	int                          type;
 	char                        *name;
+    uint16_t                     memshr_id;
 
 	td_flag_t                    flags;
+	int                          storage;
 
 	td_driver_t                 *driver;
 	td_disk_info_t               info;
@@ -48,32 +45,12 @@
 	void                        *private;
 
 	struct list_head             next;
-
-	/*
-	 * Basic datapath statistics, in sectors read/written.
-	 *
-	 * hits:  requests completed by this image.
-	 * fail:  requests completed with failure by this image.
-	 *
-	 * Not that we do not count e.g.
-	 * miss:  requests forwarded.
-	 * total: requests processed by this image.
-	 *
-	 * This is because we'd have to compensate for restarts due to
-	 * -EBUSY conditions. Those can be extrapolated by following
-	 * the chain instead: sum(image[i].hits, i=0..) == vbd.secs;
-	 */
-	struct {
-		td_sector_count_t    hits;
-		td_sector_count_t    fail;
-	} stats;
 };
 
-td_image_t *tapdisk_image_allocate(char *, int, td_flag_t, void *);
+td_image_t *tapdisk_image_allocate(const char *, int, int, td_flag_t, void *);
 void tapdisk_image_free(td_image_t *);
 
 int tapdisk_image_check_td_request(td_image_t *, td_request_t);
 int tapdisk_image_check_ring_request(td_image_t *, blkif_request_t *);
-void tapdisk_image_stats(td_image_t *, td_stats_t *);
 
 #endif
diff -Nur blktap2_oxt//drivers/tapdisk-interface.c blktap2_xen//drivers/tapdisk-interface.c
--- blktap2_oxt//drivers/tapdisk-interface.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-interface.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,14 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
-#include <signal.h>
-#include <unistd.h>
 #include <errno.h>
 
 #include "tapdisk.h"
@@ -41,11 +33,11 @@
 #include "tapdisk-driver.h"
 #include "tapdisk-server.h"
 #include "tapdisk-interface.h"
-#include "tapdisk-log.h"
 
 int
 td_load(td_image_t *image)
 {
+	int err;
 	td_image_t *shared;
 	td_driver_t *driver;
 
@@ -76,7 +68,8 @@
 	if (!driver) {
 		driver = tapdisk_driver_allocate(image->type,
 						 image->name,
-						 image->flags);
+						 image->flags,
+						 image->storage);
 		if (!driver)
 			return -ENOMEM;
 
@@ -229,7 +222,7 @@
 void
 td_complete_request(td_request_t treq, int res)
 {
-	treq.cb(treq, res);
+	((td_callback_t)treq.cb)(treq, res);
 }
 
 void
@@ -264,11 +257,3 @@
 
 	tapdisk_driver_debug(driver);
 }
-
-void
-td_panic(void)
-{
-	tlog_precious();
-	raise(SIGABRT);
-	_exit(-1); /* not reached */
-}
diff -Nur blktap2_oxt//drivers/tapdisk-interface.h blktap2_xen//drivers/tapdisk-interface.h
--- blktap2_oxt//drivers/tapdisk-interface.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-interface.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #ifndef _TAPDISK_INTERFACE_H_
 #define _TAPDISK_INTERFACE_H_
 
@@ -55,6 +50,5 @@
 		  long long, td_queue_callback_t, void *);
 void td_prep_write(struct tiocb *, int, char *, size_t,
 		   long long, td_queue_callback_t, void *);
-void td_panic(void) __attribute__((noreturn));
 
 #endif
diff -Nur blktap2_oxt//drivers/tapdisk-log.c blktap2_xen//drivers/tapdisk-log.c
--- blktap2_oxt//drivers/tapdisk-log.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-log.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,5 +1,5 @@
-/*
- * Copyright (c) 2008, 2009, XenSource Inc.
+/* 
+ * Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -24,267 +24,234 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
+*/
 
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
-#include <stdlib.h>
+#include <stdio.h>
+#include <fcntl.h>
 #include <unistd.h>
-#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
 #include <stdarg.h>
 #include <syslog.h>
+#include <inttypes.h>
 #include <sys/time.h>
-#include <sys/stat.h>
-#include <sys/types.h>
 
-#include "blktaplib.h"
 #include "tapdisk-log.h"
 #include "tapdisk-utils.h"
-#include "tapdisk-logfile.h"
-#include "tapdisk-syslog.h"
-#include "tapdisk-server.h"
-
-#define TLOG_LOGFILE_BUFSZ (16<<10)
-#define TLOG_SYSLOG_BUFSZ   (8<<10)
 
 #define MAX_ENTRY_LEN      512
+#define MAX_ERROR_MESSAGES 16
+
+struct error {
+	int            cnt;
+	int            err;
+	char          *func;
+	char           msg[MAX_ENTRY_LEN];
+};
+
+struct ehandle {
+	int            cnt;
+	int            dropped;
+	struct error   errors[MAX_ERROR_MESSAGES];
+};
 
 struct tlog {
-	char          *name;
-	td_logfile_t   logfile;
-	int            precious;
+	char          *p;
+	int            size;
+	uint64_t       cnt;
+	char          *buf;
 	int            level;
-
-	char          *ident;
-	td_syslog_t    syslog;
-	unsigned long  errors;
+	char          *file;
+	int            append;
 };
 
+static struct ehandle tapdisk_err;
 static struct tlog tapdisk_log;
 
-static void
-tlog_logfile_vprint(const char *fmt, va_list ap)
-{
-	tapdisk_logfile_vprintf(&tapdisk_log.logfile, fmt, ap);
-}
-
-static void
-__attribute__((format(printf, 1, 2)))
-tlog_logfile_print(const char *fmt, ...)
-{
-	va_list ap;
-
-	va_start(ap, fmt);
-	tlog_logfile_vprint(fmt, ap);
-	va_end(ap);
-}
-
-#define tlog_info(_fmt, _args ...)					\
-	tlog_logfile_print("%s: "_fmt, tapdisk_log.ident, ##_args)
-
-static void
-tlog_logfile_save(void)
+void
+open_tlog(char *file, size_t bytes, int level, int append)
 {
-	td_logfile_t *logfile = &tapdisk_log.logfile;
-	const char *name = tapdisk_log.name;
-	int err;
+	tapdisk_log.size = ((bytes + 511) & (~511));
 
-	tlog_info("saving log, %lu errors", tapdisk_log.errors);
+	if (asprintf(&tapdisk_log.file, "%s.%d", file, getpid()) == -1)
+		return;
 
-	tapdisk_logfile_flush(logfile);
+	if (posix_memalign((void **)&tapdisk_log.buf, 512, tapdisk_log.size)) {
+		free(tapdisk_log.file);
+		tapdisk_log.buf = NULL;
+		return;
+	}
 
-	err = tapdisk_logfile_rename(logfile,
-				     TLOG_DIR, name, ".log");
+	memset(tapdisk_log.buf, 0, tapdisk_log.size);
 
-	tlog_syslog(LOG_INFO,
-		    "logfile saved to %s: %d\n", logfile->path, err);
+	tapdisk_log.p      = tapdisk_log.buf;
+	tapdisk_log.level  = level;
+	tapdisk_log.append = append;
 }
 
-static void
-tlog_logfile_close(void)
+void
+close_tlog(void)
 {
-	td_logfile_t *logfile = &tapdisk_log.logfile;
-	int keep, err;
-
-	keep = tapdisk_log.precious || tapdisk_log.errors;
+	if (!tapdisk_log.buf)
+		return;
 
-	tlog_info("closing log, %lu errors", tapdisk_log.errors);
+	if (tapdisk_log.append)
+		tlog_flush();
 
-	if (keep)
-		tlog_logfile_save();
+	free(tapdisk_log.buf);
+	free(tapdisk_log.file);
 
-	tapdisk_logfile_close(logfile);
-
-	if (!keep)
-		tapdisk_logfile_unlink(logfile);
+	memset(&tapdisk_log, 0, sizeof(struct tlog));
 }
 
-static int
-tlog_logfile_open(const char *name, int level)
+void
+__tlog_write(int level, const char *func, const char *fmt, ...)
 {
-	td_logfile_t *logfile = &tapdisk_log.logfile;
-	int mode, err;
-
-	err = mkdir(TLOG_DIR, 0755);
-	if (err) {
-		err = -errno;
-		if (err != -EEXIST)
-			goto fail;
-	}
-
-	err = tapdisk_logfile_open(logfile,
-				   TLOG_DIR, name, ".tmp",
-				   TLOG_LOGFILE_BUFSZ);
-	if (err)
-		goto fail;
-
-	mode = (level == TLOG_DBG) ? _IOLBF : _IOFBF;
-
-	err = tapdisk_logfile_setvbuf(logfile, mode);
-	if (err)
-		goto fail;
+	char *buf;
+	va_list ap;
+	struct timeval t;
+	int ret, len, avail;
 
-	tlog_info("log start, level %d", level);
+	if (!tapdisk_log.buf)
+		return;
 
-	return 0;
+	if (level > tapdisk_log.level)
+		return;
 
-fail:
-	tlog_logfile_close();
-	return err;
-}
+	avail = tapdisk_log.size - (tapdisk_log.p - tapdisk_log.buf);
+	if (avail < MAX_ENTRY_LEN) {
+		if (tapdisk_log.append)
+			tlog_flush();
+		tapdisk_log.p = tapdisk_log.buf;
+	}
 
-static void
-tlog_syslog_close(void)
-{
-	td_syslog_t *syslog = &tapdisk_log.syslog;
+	buf = tapdisk_log.p;
+	gettimeofday(&t, NULL);
+	len = snprintf(buf, MAX_ENTRY_LEN - 1, "%08"PRIu64":%010ld.%06lld:"
+		       "%s ", tapdisk_log.cnt,
+			t.tv_sec, (unsigned long long)t.tv_usec, func);
 
-	tapdisk_syslog_stats(syslog, LOG_INFO);
-	tapdisk_syslog_flush(syslog);
-	tapdisk_syslog_close(syslog);
-}
+	va_start(ap, fmt);
+	ret = vsnprintf(buf + len, MAX_ENTRY_LEN - (len + 1), fmt, ap);
+	va_end(ap);
 
-static int
-tlog_syslog_open(const char *ident, int facility)
-{
-	td_syslog_t *syslog = &tapdisk_log.syslog;
-	int err;
+	len = (ret < MAX_ENTRY_LEN - (len + 1) ?
+	       len + ret : MAX_ENTRY_LEN - 1);
+	buf[len] = '\0';
 
-	err = tapdisk_syslog_open(syslog,
-				  tapdisk_log.ident, facility,
-				  TLOG_SYSLOG_BUFSZ);
-	return err;
+	tapdisk_log.cnt++;
+	tapdisk_log.p += len;
 }
 
 void
-tlog_vsyslog(int prio, const char *fmt, va_list ap)
+__tlog_error(int err, const char *func, const char *fmt, ...)
 {
-	td_syslog_t *syslog = &tapdisk_log.syslog;
+	va_list ap;
+	int i, len, ret;
+	struct error *e;
+	struct timeval t;
+
+	err = (err > 0 ? err : -err);
+
+	for (i = 0; i < tapdisk_err.cnt; i++) {
+		e = &tapdisk_err.errors[i];
+		if (e->err == err && e->func == func) {
+			e->cnt++;
+			return;
+		}
+	}
 
-	tapdisk_vsyslog(syslog, prio, fmt, ap);
-}
+	if (tapdisk_err.cnt >= MAX_ERROR_MESSAGES) {
+		tapdisk_err.dropped++;
+		return;
+	}
 
-void
-tlog_syslog(int prio, const char *fmt, ...)
-{
-	va_list ap;
+	gettimeofday(&t, NULL);
+	e = &tapdisk_err.errors[tapdisk_err.cnt];
+
+	len = snprintf(e->msg, MAX_ENTRY_LEN - 1, "%010ld.%06lld:%s ",
+		       t.tv_sec, (unsigned long long)t.tv_usec, func);
 
 	va_start(ap, fmt);
-	tlog_vsyslog(prio, fmt, ap);
+	ret = vsnprintf(e->msg + len, MAX_ENTRY_LEN - (len + 1), fmt, ap);
 	va_end(ap);
+
+	len = (ret < MAX_ENTRY_LEN - (len + 1) ?
+	       len + ret : MAX_ENTRY_LEN - 1);
+	e->msg[len] = '\0';
+
+	e->cnt++;
+	e->err  = err;
+	e->func = (char *)func;
+	tapdisk_err.cnt++;
 }
 
-int
-tlog_open(const char *name, int facility, int level)
+void
+tlog_print_errors(void)
 {
-	int err;
-
-	DPRINTF("tapdisk-log: started, level %d\n", level);
+	int i;
+	struct error *e;
 
-	tapdisk_log.level = level;
-	tapdisk_log.name  = strdup(name);
-	tapdisk_log.ident = tapdisk_syslog_ident(name);
-
-	if (!tapdisk_log.name || !tapdisk_log.ident) {
-		err = -errno;
-		goto fail;
+	for (i = 0; i < tapdisk_err.cnt; i++) {
+		e = &tapdisk_err.errors[i];
+		syslog(LOG_INFO, "TAPDISK ERROR: errno %d at %s (cnt = %d): "
+		       "%s\n", e->err, e->func, e->cnt, e->msg);
 	}
 
-#if 0
-	err = tlog_logfile_open(tapdisk_log.name, level);
-	if (err)
-		goto fail;
-#endif
-
-	tlog_syslog_open(tapdisk_log.ident, facility);
-
-	return 0;
-
-fail:
-	tlog_close();
-	return err;
+	if (tapdisk_err.dropped)
+		syslog(LOG_INFO, "TAPDISK ERROR: %d other error messages "
+		       "dropped\n", tapdisk_err.dropped);
 }
 
 void
-tlog_close(void)
+tlog_flush_errors(void)
 {
-	DPRINTF("tapdisk-log: closing after %lu errors\n",
-		tapdisk_log.errors);
+	int i;
+	struct error *e;
 
-	tlog_logfile_close();
-	tlog_syslog_close();
+	for (i = 0; i < tapdisk_err.cnt; i++) {
+		e = &tapdisk_err.errors[i];
+		tlog_write(TLOG_WARN, "TAPDISK ERROR: errno %d at %s "
+			   "(cnt = %d): %s\n", e->err, e->func, e->cnt,
+			   e->msg);
+	}
 
-	free(tapdisk_log.ident);
-	tapdisk_log.ident = NULL;
+	if (tapdisk_err.dropped)
+		tlog_write(TLOG_WARN, "TAPDISK ERROR: %d other error messages "
+		       "dropped\n", tapdisk_err.dropped);
 }
 
 void
-tlog_precious(void)
+tlog_flush(void)
 {
-	if (!tapdisk_log.precious)
-		tlog_logfile_save();
+	int fd, flags;
+	size_t size, wsize;
 
-	tapdisk_log.precious = 1;
-}
+	if (!tapdisk_log.buf)
+		return;
 
-void
-__tlog_write(int level, const char *fmt, ...)
-{
-	va_list ap;
+	flags = O_CREAT | O_WRONLY | O_DIRECT | O_NONBLOCK;
+	if (!tapdisk_log.append)
+		flags |= O_TRUNC;
 
-	if (level <= tapdisk_log.level) {
-		va_start(ap, fmt);
-		tlog_logfile_vprint(fmt, ap);
-		va_end(ap);
-	}
-}
+	fd = open(tapdisk_log.file, flags, 0644);
+	if (fd == -1)
+		return;
 
-void
-__tlog_error(const char *fmt, ...)
-{
-	va_list ap;
+	if (tapdisk_log.append)
+		if (lseek(fd, 0, SEEK_END) == (off_t)-1)
+			goto out;
 
-	va_start(ap, fmt);
-	tlog_vsyslog(LOG_ERR, fmt, ap);
-	va_end(ap);
+	tlog_flush_errors();
 
-	tapdisk_log.errors++;
-}
+	size  = tapdisk_log.p - tapdisk_log.buf;
+	wsize = ((size + 511) & (~511));
 
-void
-tapdisk_start_logging(const char *ident, const char *_facility)
-{
-	static char buf[128];
-	int facility, err;
+	memset(tapdisk_log.buf + size, '\n', wsize - size);
+	write_exact(fd, tapdisk_log.buf, wsize);
 
-	facility = tapdisk_syslog_facility(_facility);
-	tapdisk_server_openlog(ident, LOG_CONS|LOG_ODELAY, facility);
-}
+	tapdisk_log.p = tapdisk_log.buf;
 
-void
-tapdisk_stop_logging(void)
-{
-	tapdisk_server_closelog();
+out:
+	close(fd);
 }
diff -Nur blktap2_oxt//drivers/tapdisk-logfile.c blktap2_xen//drivers/tapdisk-logfile.c
--- blktap2_oxt//drivers/tapdisk-logfile.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-logfile.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,257 +0,0 @@
-/*
- * Copyright (c) 2009, XenSource Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#include <time.h>
-#include <stdarg.h>
-#include <sys/time.h>
-#include <sys/mman.h>
-
-#include "tapdisk-logfile.h"
-#include "tapdisk-utils.h"
-
-#define MIN(a,b) (((a) < (b)) ? (a) : (b))
-
-static inline size_t
-page_align(size_t size)
-{
-	size_t page_size = sysconf(_SC_PAGE_SIZE);
-	return (size + page_size - 1) & ~(page_size - 1);
-}
-
-static void
-tapdisk_logfile_free_buffer(td_logfile_t *log)
-{
-	if (log->vbuf) {
-		munmap(log->vbuf, page_align(log->vbufsz));
-		log->vbuf = NULL;
-	}
-}
-
-static int
-tapdisk_logfile_init_buffer(td_logfile_t *log, size_t size)
-{
-	int prot, flags, err;
-
-	if (!size)
-		return -EINVAL;
-
-	prot  = PROT_READ|PROT_WRITE;
-	flags = MAP_ANONYMOUS|MAP_PRIVATE;
-
-	log->vbuf = mmap(NULL, page_align(size), prot, flags, -1, 0);
-	if (log->vbuf == MAP_FAILED) {
-		log->vbuf = NULL;
-		goto fail;
-	}
-
-	err = mlock(log->vbuf, page_align(size));
-	if (err)
-		goto fail;
-
-	log->vbufsz = size;
-
-	return 0;
-
-fail:
-	tapdisk_logfile_free_buffer(log);
-	err = -errno;
-	return err;
-}
-
-int
-tapdisk_logfile_unlink(td_logfile_t *log)
-{
-	int err;
-
-	err = unlink(log->path);
-	if (err)
-		err = -errno;
-
-	return err;
-}
-
-static int
-__tapdisk_logfile_rename(td_logfile_t *log, const char *newpath)
-{
-	const size_t max = sizeof(log->path);
-	int err;
-
-	if (!strcmp(log->path, newpath))
-		return 0;
-
-	if (strlen(newpath) > max)
-		return -ENAMETOOLONG;
-
-	err = rename(log->path, newpath);
-	if (err) {
-		err = -errno;
-		return err;
-	}
-
-	strncpy(log->path, newpath, max);
-
-	return 0;
-}
-
-static int
-tapdisk_logfile_name(char *path, size_t size,
-		     const char *dir, const char *ident, const char *suffix)
-{
-	const size_t max = MIN(size, TD_LOGFILE_PATH_MAX);
-	return snprintf(path, max, "%s/%s.%d%s", dir, ident, getpid(), suffix);
-}
-
-int
-tapdisk_logfile_rename(td_logfile_t *log,
-		       const char *dir, const char *ident, const char *suffix)
-{
-	char newpath[TD_LOGFILE_PATH_MAX+1];
-
-	tapdisk_logfile_name(newpath, sizeof(newpath), dir, ident, suffix);
-
-	return __tapdisk_logfile_rename(log, newpath);
-}
-
-void
-tapdisk_logfile_close(td_logfile_t *log)
-{
-	if (log->file) {
-		fclose(log->file);
-		log->file = NULL;
-	}
-
-	tapdisk_logfile_free_buffer(log);
-}
-
-int
-tapdisk_logfile_open(td_logfile_t *log,
-		     const char *dir, const char *ident, const char *ext,
-		     size_t bufsz)
-{
-	int err;
-
-	memset(log, 0, sizeof(log));
-
-	tapdisk_logfile_name(log->path, sizeof(log->path), dir, ident, ext);
-
-	log->file = fopen(log->path, "w");
-	if (!log->file) {
-		err = -errno;
-		goto fail;
-	}
-
-	err = tapdisk_logfile_init_buffer(log, bufsz);
-	if (err)
-		goto fail;
-
-	return 0;
-
-fail:
-	tapdisk_logfile_unlink(log);
-	tapdisk_logfile_close(log);
-	return err;
-}
-
-int
-tapdisk_logfile_setvbuf(td_logfile_t *log, int mode)
-{
-	int err = 0;
-
-	if (log->file) {
-		err = setvbuf(log->file, log->vbuf, mode, log->vbufsz);
-		if (err)
-			err = -errno;
-	}
-
-	return err;
-}
-
-ssize_t
-tapdisk_logfile_vprintf(td_logfile_t *log, const char *fmt, va_list ap)
-{
-	char buf[1024];
-	size_t size, n;
-	ssize_t len;
-	struct timeval tv;
-
-	if (!log->file)
-		return -EBADF;
-
-	gettimeofday(&tv, NULL);
-
-	size = sizeof(buf);
-	len  = 0;
-
-	len += tapdisk_syslog_strftime(buf, size, &tv);
-	len += snprintf(buf + len, size - len, ": ");
-	len += tapdisk_syslog_strftv(buf + len, size - len, &tv);
-	len += snprintf(buf + len, size - len, " ");
-	len += vsnprintf(buf + len, size - len, fmt, ap);
-
-	if (buf[len-1] != '\n')
-		len += snprintf(buf + len, size - len, "\n");
-
-	n = fwrite(buf, len, 1, log->file);
-	if (n != len)
-		len = -ferror(log->file);
-
-	return len;
-}
-
-ssize_t
-tapdisk_logfile_printf(td_logfile_t *log, const char *fmt, ...)
-{
-	va_list ap;
-	int rv;
-
-	va_start(ap, fmt);
-	rv = tapdisk_logfile_vprintf(log, fmt, ap);
-	va_end(ap);
-
-	return rv;
-}
-
-int
-tapdisk_logfile_flush(td_logfile_t *log)
-{
-	int rv = EOF;
-
-	if (log->file)
-		rv = fflush(log->file);
-
-	return rv;
-}
diff -Nur blktap2_oxt//drivers/tapdisk-logfile.h blktap2_xen//drivers/tapdisk-logfile.h
--- blktap2_oxt//drivers/tapdisk-logfile.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-logfile.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,65 +0,0 @@
-/*
- * Copyright (c) 2009, XenSource Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
-#ifndef __TAPDISK_LOGFILE_H__
-#define __TAPDISK_LOGFILE_H__
-
-#include <stdio.h>
-
-typedef struct _td_logfile td_logfile_t;
-
-#define TD_LOGFILE_PATH_MAX    128UL
-
-struct _td_logfile {
-	char           path[TD_LOGFILE_PATH_MAX];
-	FILE          *file;
-	char          *vbuf;
-	size_t         vbufsz;
-};
-
-int tapdisk_logfile_open(td_logfile_t *,
-			 const char *dir, const char *ident, const char *ext,
-			 size_t bufsz);
-
-ssize_t tapdisk_logfile_printf(td_logfile_t *, const char *fmt, ...);
-ssize_t tapdisk_logfile_vprintf(td_logfile_t *, const char *fmt, va_list ap);
-
-void tapdisk_logfile_close(td_logfile_t *);
-int tapdisk_logfile_unlink(td_logfile_t *);
-int tapdisk_logfile_rename(td_logfile_t *,
-			   const char *dir, const char *ident, const char *ext);
-
-int tapdisk_logfile_setvbuf(td_logfile_t *log, int mode);
-int tapdisk_logfile_flush(td_logfile_t *);
-
-#endif /* __TAPDISK_LOGFILE_H__ */
diff -Nur blktap2_oxt//drivers/tapdisk-log.h blktap2_xen//drivers/tapdisk-log.h
--- blktap2_oxt//drivers/tapdisk-log.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-log.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,5 +1,5 @@
-/*
- * Copyright (c) 2009, XenSource Inc.
+/* 
+ * Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -24,13 +24,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
+*/
 #ifndef _TAPDISK_LOG_H_
 #define _TAPDISK_LOG_H_
 
@@ -38,27 +32,20 @@
 #define TLOG_INFO       1
 #define TLOG_DBG        2
 
-#define TLOG_DIR "/var/log/blktap"
-
-#include <stdarg.h>
-
-int  tlog_open(const char *, int, int);
-void tlog_close(void);
-void tlog_precious(void);
-void tlog_vsyslog(int, const char *, va_list);
-void tlog_syslog(int, const char *, ...);
-
-void __tlog_write(int, const char *, ...)
-	__attribute__((format(printf, 2, 3)));
-
-void __tlog_error(const char *fmt, ...)
-	__attribute__((format(printf, 1, 2)));
+void open_tlog(char *file, size_t bytes, int level, int append);
+void close_tlog(void);
+void tlog_flush(void);
+void tlog_print_errors(void);
+
+void __tlog_write(int level, const char *func, const char *fmt, ...)
+  __attribute__((format(printf, 3, 4)));
+void __tlog_error(int err, const char *func, const char *fmt, ...)
+  __attribute__((format(printf, 3, 4)));
 
 #define tlog_write(_level, _f, _a...)			\
-	__tlog_write(_level, "%s: " _f,  __func__, ##_a)
+	__tlog_write(_level, __func__, _f, ##_a)
 
 #define tlog_error(_err, _f, _a...)			\
-	__tlog_error("ERROR: errno %d at %s: " _f,	\
-		     _err, __func__, ##_a)
+	__tlog_error(_err, __func__, _f, ##_a)
 
 #endif
diff -Nur blktap2_oxt//drivers/tapdisk-queue.c blktap2_xen//drivers/tapdisk-queue.c
--- blktap2_oxt//drivers/tapdisk-queue.c	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-queue.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,5 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* 
+ * Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,7 +24,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
+*/
 
 #include <errno.h>
 #include <stdlib.h>
@@ -215,7 +213,7 @@
 	ssize_t (*func)(int, void *, size_t) = 
 		(iocb->aio_lio_opcode == IO_CMD_PWRITE ? vwrite : read);
 
-	if (lseek64(fd, off, SEEK_SET) == (off64_t)-1)
+	if (lseek(fd, off, SEEK_SET) == (off_t)-1)
 		return -errno;
 
 	if (atomicio(func, fd, buf, size) != size)
@@ -289,7 +287,11 @@
 static int
 tapdisk_lio_check_resfd(void)
 {
+#if defined(__linux__)
 	return tapdisk_linux_version() >= KERNEL_VERSION(2, 6, 22);
+#else
+	return 1;
+#endif
 }
 
 static void
@@ -432,9 +434,8 @@
 	struct lio *lio = queue->tio_data;
 	uint64_t val;
 
-	if (lio->flags & LIO_FLAG_EVENTFD) {
-		int gcc = read(lio->event_fd, &val, sizeof(val));
-	}
+	if (lio->flags & LIO_FLAG_EVENTFD)
+		read_exact(lio->event_fd, &val, sizeof(val));
 }
 
 static void
@@ -656,7 +657,7 @@
 
 	WARN("TAPDISK QUEUE:\n");
 	WARN("size: %d, tio: %s, queued: %d, iocbs_pending: %d, "
-	     "tiocbs_pending: %d, tiocbs_deferred: %d, deferrals: %llx\n",
+	     "tiocbs_pending: %d, tiocbs_deferred: %d, deferrals: %"PRIx64"\n",
 	     queue->size, queue->tio->name, queue->queued, queue->iocbs_pending,
 	     queue->tiocbs_pending, queue->tiocbs_deferred, queue->deferrals);
 
diff -Nur blktap2_oxt//drivers/tapdisk-queue.h blktap2_xen//drivers/tapdisk-queue.h
--- blktap2_oxt//drivers/tapdisk-queue.h	2016-03-14 14:24:58.160021126 -0400
+++ blktap2_xen//drivers/tapdisk-queue.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,11 +1,30 @@
-/* Copyright (c) 2007, XenSource Inc.
+/* 
+ * Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
- */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of XenSource Inc. nor the names of its contributors
+ *       may be used to endorse or promote products derived from this software
+ *       without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
 
 #ifndef TAPDISK_QUEUE_H
 #define TAPDISK_QUEUE_H
diff -Nur blktap2_oxt//drivers/tapdisk-ring.c blktap2_xen//drivers/tapdisk-ring.c
--- blktap2_oxt//drivers/tapdisk-ring.c	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-ring.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2008 Citrix Systems, Inc.
- */
-
 #include <errno.h>
 
 #include "tapdisk-ring.h"
diff -Nur blktap2_oxt//drivers/tapdisk-ring.h blktap2_xen//drivers/tapdisk-ring.h
--- blktap2_oxt//drivers/tapdisk-ring.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-ring.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2008 Citrix Systems, Inc.
- */
-
 #ifndef _TAPDISK_RING_H_
 #define _TAPDISK_RING_H_
 
diff -Nur blktap2_oxt//drivers/tapdisk-server.c blktap2_xen//drivers/tapdisk-server.c
--- blktap2_oxt//drivers/tapdisk-server.c	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-server.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <unistd.h>
@@ -37,29 +32,15 @@
 #include <sys/ioctl.h>
 #include <sys/signal.h>
 
-#include "tapdisk-syslog.h"
+#include "tapdisk-utils.h"
 #include "tapdisk-server.h"
 #include "tapdisk-driver.h"
 #include "tapdisk-interface.h"
-#include "tapdisk-log.h"
 
 #define DBG(_level, _f, _a...)       tlog_write(_level, _f, ##_a)
 #define ERR(_err, _f, _a...)         tlog_error(_err, _f, ##_a)
 
-#define TAPDISK_TIOCBS              (TAPDISK_DATA_REQUESTS + 50)
-
-typedef struct tapdisk_server {
-	int                          run;
-	struct list_head             vbds;
-	scheduler_t                  scheduler;
-	struct tqueue                aio_queue;
-	char                        *name;
-	char                        *ident;
-	int                          facility;
-	int                          err;
-} tapdisk_server_t;
-
-static tapdisk_server_t server;
+ tapdisk_server_t server;
 
 #define tapdisk_server_for_each_vbd(vbd, tmp)			        \
 	list_for_each_entry_safe(vbd, tmp, &server.vbds, next)
@@ -130,8 +111,7 @@
 	tapdisk_server_for_each_vbd(vbd, tmp)
 		tapdisk_vbd_debug(vbd);
 
-	DBG(TLOG_INFO, "debug log completed\n");
-	tlog_precious();
+	tlog_flush();
 }
 
 void
@@ -156,12 +136,6 @@
 }
 
 void
-tapdisk_server_mask_event(event_id_t event, int masked)
-{
-	return scheduler_mask_event(&server.scheduler, event, masked);
-}
-
-void
 tapdisk_server_set_max_timeout(int seconds)
 {
 	scheduler_set_max_timeout(&server.scheduler, seconds);
@@ -206,6 +180,7 @@
 static void
 tapdisk_server_kick_responses(void)
 {
+	int n;
 	td_vbd_t *vbd, *tmp;
 
 	tapdisk_server_for_each_vbd(vbd, tmp)
@@ -243,54 +218,9 @@
 	tapdisk_free_queue(&server.aio_queue);
 }
 
-int
-tapdisk_server_openlog(const char *name, int options, int facility)
-{
-	server.facility = facility;
-	server.name     = strdup(name);
-	server.ident    = tapdisk_syslog_ident(name);
-
-	if (!server.name || !server.ident)
-		return -errno;
-
-	openlog(server.ident, options, facility);
-
-	return 0;
-}
-
-void
-tapdisk_server_closelog(void)
-{
-	closelog();
-
-	free(server.name);
-	server.name = NULL;
-
-	free(server.ident);
-	server.ident = NULL;
-}
-
-static int
-tapdisk_server_open_tlog(void)
-{
-	int err = 0;
-
-	if (server.name)
-		err = tlog_open(server.name, server.facility, TLOG_WARN);
-
-	return err;
-}
-
-static void
-tapdisk_server_close_tlog(void)
-{
-	tlog_close();
-}
-
 static void
 tapdisk_server_close(void)
 {
-	tapdisk_server_close_tlog();
 	tapdisk_server_close_aio();
 }
 
@@ -328,8 +258,6 @@
 	switch (signal) {
 	case SIGBUS:
 	case SIGINT:
-	case SIGTERM:
-		server.err = 1;
 		tapdisk_server_for_each_vbd(vbd, tmp)
 			tapdisk_vbd_close(vbd);
 		break;
@@ -344,7 +272,6 @@
 		break;
 
 	case SIGUSR1:
-		DBG(TLOG_INFO, "debugging on signal %d\n", signal);
 		tapdisk_server_debug();
 		break;
 	}
@@ -370,22 +297,17 @@
 	if (err)
 		goto fail;
 
-	err = tapdisk_server_open_tlog();
-	if (err)
-		goto fail;
-
 	server.run = 1;
 
 	return 0;
 
 fail:
-	tapdisk_server_close_tlog();
 	tapdisk_server_close_aio();
 	return err;
 }
 
 int
-tapdisk_server_initialize(const char *read, const char *write)
+tapdisk_server_initialize(void)
 {
 	int err;
 
@@ -395,12 +317,6 @@
 	if (err)
 		goto fail;
 
-	err = tapdisk_server_open_tlog();
-	if (err)
-		goto fail;
-
-	server.run = 1;
-
 	return 0;
 
 fail:
@@ -419,12 +335,11 @@
 
 	signal(SIGBUS, tapdisk_server_signal_handler);
 	signal(SIGINT, tapdisk_server_signal_handler);
-	signal(SIGTERM, tapdisk_server_signal_handler);
 	signal(SIGUSR1, tapdisk_server_signal_handler);
 	signal(SIGXFSZ, tapdisk_server_signal_handler);
 
 	__tapdisk_server_run();
 	tapdisk_server_close();
 
-	return server.err;
+	return 0;
 }
diff -Nur blktap2_oxt//drivers/tapdisk-server.h blktap2_xen//drivers/tapdisk-server.h
--- blktap2_oxt//drivers/tapdisk-server.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-server.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #ifndef _TAPDISK_SERVER_H_
 #define _TAPDISK_SERVER_H_
 
@@ -52,18 +47,21 @@
 
 event_id_t tapdisk_server_register_event(char, int, int, event_cb_t, void *);
 void tapdisk_server_unregister_event(event_id_t);
-void tapdisk_server_mask_event(event_id_t, int);
 void tapdisk_server_set_max_timeout(int);
 
 int tapdisk_server_init(void);
-int tapdisk_server_initialize(const char *, const char *);
+int tapdisk_server_initialize(void);
 int tapdisk_server_complete(void);
 int tapdisk_server_run(void);
 void tapdisk_server_iterate(void);
 
-int tapdisk_server_openlog(const char *, int, int);
-void tapdisk_server_closelog(void);
-void tapdisk_start_logging(const char *, const char *);
-void tapdisk_stop_logging(void);
+#define TAPDISK_TIOCBS              (TAPDISK_DATA_REQUESTS + 50)
+
+typedef struct tapdisk_server {
+	int                          run;
+	struct list_head             vbds;
+	scheduler_t                  scheduler;
+	struct tqueue                aio_queue;
+} tapdisk_server_t;
 
 #endif
diff -Nur blktap2_oxt//drivers/tapdisk-stats.c blktap2_xen//drivers/tapdisk-stats.c
--- blktap2_oxt//drivers/tapdisk-stats.c	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-stats.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,163 +0,0 @@
-/*
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <stdio.h>
-#include <stdarg.h>
-
-#include "tapdisk.h"
-#include "tapdisk-stats.h"
-
-#define BUG_ON(_cond) if (_cond) { td_panic(); }
-
-static void
-__stats_vsprintf(td_stats_t *st,
-		      const char *fmt, va_list ap)
-{
-	size_t size = st->buf + st->size - st->pos;
-	st->pos += vsnprintf(st->pos, size, fmt, ap);
-}
-
-static void __attribute__((format (printf, 2, 3)))
-__stats_sprintf(td_stats_t *st,
-		     const char *fmt, ...)
-{
-	va_list ap;
-
-	va_start(ap, fmt);
-	__stats_vsprintf(st, fmt, ap);
-	va_end(ap);
-}
-
-static void
-__stats_enter(td_stats_t *st)
-{
-	st->depth++;
-	BUG_ON(st->depth > TD_STATS_MAX_DEPTH);
-	st->n_elem[st->depth] = 0;
-}
-
-static void
-__stats_leave(td_stats_t *st)
-{
-	st->depth--;
-}
-
-static void
-__stats_next(td_stats_t *st)
-{
-	int n_elem;
-
-	n_elem = st->n_elem[st->depth];
-	if (n_elem > 0)
-		__stats_sprintf(st, ", ");
-	st->n_elem[st->depth]++;
-}
-
-static void
-__tapdisk_stats_enter(td_stats_t *st, char t)
-{
-	__stats_sprintf(st, "%c ", t);
-	__stats_enter(st);
-}
-
-void
-tapdisk_stats_enter(td_stats_t *st, char t)
-{
-	__stats_next(st);
-	__tapdisk_stats_enter(st, t);
-}
-
-void
-tapdisk_stats_leave(td_stats_t *st, char t)
-{
-	__stats_leave(st);
-	__stats_sprintf(st, " %c", t);
-}
-
-static void
-tapdisk_stats_vval(td_stats_t *st, const char *conv, va_list ap)
-{
-	char t = conv[0], fmt[32];
-
-	__stats_next(st);
-
-	switch (t) {
-	case 's':
-		__stats_vsprintf(st, "\"%s\"", ap);
-		break;
-
-	default:
-		sprintf(fmt, "%%%s", conv);
-		__stats_vsprintf(st, fmt, ap);
-		break;
-	}
-}
-
-void
-tapdisk_stats_val(td_stats_t *st, const char *conv, ...)
-{
-	va_list ap;
-
-	va_start(ap, conv);
-	tapdisk_stats_vval(st, conv, ap);
-	va_end(ap);
-}
-
-void
-tapdisk_stats_field(td_stats_t *st, const char *key, const char *conv, ...)
-{
-	va_list ap;
-	int n_elem;
-	char t;
-
-	n_elem = st->n_elem[st->depth]++;
-	if (n_elem > 0)
-		__stats_sprintf(st, ", ");
-
-	__stats_sprintf(st, "\"%s\": ", key);
-
-	if (!conv) {
-		__stats_sprintf(st, "null");
-		return;
-	}
-
-	t = conv[0];
-	switch (t) {
-	case '[':
-	case '{':
-		__tapdisk_stats_enter(st, t);
-		break;
-	default:
-		va_start(ap, conv);
-		__stats_enter(st);
-		tapdisk_stats_vval(st, conv, ap);
-		__stats_leave(st);
-		va_end(ap);
-	}
-}
diff -Nur blktap2_oxt//drivers/tapdisk-stats.h blktap2_xen//drivers/tapdisk-stats.h
--- blktap2_oxt//drivers/tapdisk-stats.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-stats.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,70 +0,0 @@
-/*
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _TAPDISK_STATS_H_
-#define _TAPDISK_STATS_H_
-
-#include <string.h>
-
-#define TD_STATS_MAX_DEPTH 8
-
-struct tapdisk_stats_ctx {
-	void           *pos;
-
-	void           *buf;
-	size_t          size;
-
-	int             n_elem[TD_STATS_MAX_DEPTH];
-	int             depth;
-};
-
-typedef struct tapdisk_stats_ctx td_stats_t;
-
-static inline void
-tapdisk_stats_init(td_stats_t *st, char *buf, size_t size)
-{
-	memset(st, 0, sizeof(*st));
-
-	st->pos  = buf;
-	st->buf  = buf;
-	st->size = size;
-}
-
-static inline size_t
-tapdisk_stats_length(td_stats_t *st)
-{
-	return st->pos - st->buf;
-}
-
-void tapdisk_stats_enter(td_stats_t *st, char t);
-void tapdisk_stats_leave(td_stats_t *st, char t);
-void tapdisk_stats_field(td_stats_t *st, const char *key, const char *conv, ...);
-void tapdisk_stats_val(td_stats_t *st, const char *conv, ...);
-
-#endif /* _TAPDISK_STATS_H_ */
diff -Nur blktap2_oxt//drivers/tapdisk-storage.c blktap2_xen//drivers/tapdisk-storage.c
--- blktap2_oxt//drivers/tapdisk-storage.c	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-storage.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,117 +0,0 @@
-/*
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <errno.h>
-#include <limits.h>
-#include <stdlib.h>
-#include <sys/stat.h>
-#include <sys/vfs.h>
-
-#include "tapdisk-storage.h"
-
-#ifndef NFS_SUPER_MAGIC
-#define NFS_SUPER_MAGIC 0x6969
-#endif
-
-static int
-__tapdisk_fs_storage_type(const char *rpath)
-{
-	struct statfs fst;
-	int type, err;
-
-	err = statfs(rpath, &fst);
-	if (err)
-		return -errno;
-
-	switch (fst.f_type) {
-	case NFS_SUPER_MAGIC:
-		type = TAPDISK_STORAGE_TYPE_NFS;
-		break;
-	default:
-		type = TAPDISK_STORAGE_TYPE_EXT;
-		break;
-	}
-
-	return type;
-}
-
-static int
-__tapdisk_blk_storage_type(const char *rpath)
-{
-	return TAPDISK_STORAGE_TYPE_LVM;
-}
-
-int
-tapdisk_storage_type(const char *path)
-{
-	char rpath[PATH_MAX], *p;
-	struct stat st;
-	int err, rv;
-
-	p = realpath(path, rpath);
-	if (!p)
-		return -errno;
-
-	err = stat(rpath, &st);
-	if (err)
-		return -errno;
-
-	switch (st.st_mode & S_IFMT) {
-	case S_IFBLK:
-		rv = __tapdisk_blk_storage_type(rpath);
-		break;
-	case S_IFREG:
-		rv = __tapdisk_fs_storage_type(rpath);
-		break;
-	default:
-		rv = -EINVAL;
-		break;
-	}
-
-	return rv;
-}
-
-const char *
-tapdisk_storage_name(int type)
-{
-	const char *name;
-
-	switch (type) {
-	case TAPDISK_STORAGE_TYPE_NFS:
-		return "nfs";
-	case TAPDISK_STORAGE_TYPE_EXT:
-		return "ext";
-	case TAPDISK_STORAGE_TYPE_LVM:
-		return "lvm";
-	case -1:
-		return "n/a";
-	default:
-		return "<unknown-type>";
-	}
-}
diff -Nur blktap2_oxt//drivers/tapdisk-storage.h blktap2_xen//drivers/tapdisk-storage.h
--- blktap2_oxt//drivers/tapdisk-storage.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-storage.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,43 +0,0 @@
-/* 
- * Copyright (c) 2008, XenSource Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-#ifndef _TAPDISK_STORAGE_H_
-#define _TAPDISK_STORAGE_H_
-
-#define TAPDISK_STORAGE_TYPE_NFS       1
-#define TAPDISK_STORAGE_TYPE_EXT       2
-#define TAPDISK_STORAGE_TYPE_LVM       3
-
-int tapdisk_storage_type(const char *path);
-const char *tapdisk_storage_name(int type);
-
-#endif
diff -Nur blktap2_oxt//drivers/tapdisk-stream.c blktap2_xen//drivers/tapdisk-stream.c
--- blktap2_oxt//drivers/tapdisk-stream.c	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-stream.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -43,6 +38,7 @@
 #include "tapdisk-vbd.h"
 #include "tapdisk-server.h"
 #include "tapdisk-disktype.h"
+#include "tapdisk-utils.h"
 
 #define POLL_READ                        0
 #define POLL_WRITE                       1
@@ -148,9 +144,9 @@
 static inline void
 tapdisk_stream_poll_clear(struct tapdisk_stream_poll *p)
 {
-	int gcc, dummy;
+	int dummy;
 
-	gcc = read(p->pipe[POLL_READ], &dummy, sizeof(dummy));
+	read_exact(p->pipe[POLL_READ], &dummy, sizeof(dummy));
 	p->set = 0;
 }
 
@@ -160,7 +156,7 @@
 	int dummy = 0;
 
 	if (!p->set) {
-		int gcc = write(p->pipe[POLL_WRITE], &dummy, sizeof(dummy));
+		write_exact(p->pipe[POLL_WRITE], &dummy, sizeof(dummy));
 		p->set = 1;
 	}
 }
@@ -208,7 +204,7 @@
 {
 	unsigned long idx = (unsigned long)tapdisk_stream_request_idx(s, sreq);
 	char *buf = (char *)MMAP_VADDR(s->vbd->ring.vstart, idx, 0);
-	int gcc = write(s->out_fd, buf, sreq->secs << SECTOR_SHIFT);
+	write_exact(s->out_fd, buf, sreq->secs << SECTOR_SHIFT);
 }
 
 static void
@@ -256,7 +252,7 @@
 	else {
 		s->err = EIO;
 		list_add_tail(&sreq->next, &s->free_list);
-		fprintf(stderr, "error reading sector 0x%llx\n", sreq->sec);
+		fprintf(stderr, "error reading sector 0x%"PRIu64"\n", sreq->sec);
 	}
 
 	tapdisk_stream_write_data(s);
@@ -339,11 +335,11 @@
 
 	s->id = tapdisk_stream_count++;
 
-	err = tapdisk_server_initialize(NULL, NULL);
+	err = tapdisk_server_initialize();
 	if (err)
 		goto out;
 
-	err = tapdisk_vbd_initialize(-1, -1, s->id);
+	err = tapdisk_vbd_initialize(s->id);
 	if (err)
 		goto out;
 
@@ -355,11 +351,13 @@
 
 	tapdisk_vbd_set_callback(s->vbd, tapdisk_stream_dequeue, s);
 
-	err = tapdisk_vbd_open_vdi(s->vbd, type, path,
-				   TD_OPEN_RDONLY, -1, -1, NULL);
+	err = tapdisk_vbd_open_vdi(s->vbd, path, type,
+				   TAPDISK_STORAGE_TYPE_DEFAULT,
+				   TD_OPEN_RDONLY);
 	if (err)
 		goto out;
 
+	s->vbd->reopened = 1;
 	err = 0;
 
 out:
@@ -401,8 +399,8 @@
 		count = image.size - skip;
 
 	if (count + skip > image.size) {
-		fprintf(stderr, "0x%llx past end of image 0x%llx\n",
-			count + skip, image.size);
+		fprintf(stderr, "0x%"PRIx64" past end of image 0x%"PRIx64"\n",
+			(uint64_t) (count + skip), (uint64_t) image.size);
 		return -EINVAL;
 	}
 
@@ -588,7 +586,7 @@
 		return err;
 	}
 
-	tapdisk_start_logging("tapdisk-stream", "daemon");
+	tapdisk_start_logging("tapdisk-stream");
 
 	err = tapdisk_stream_open(&stream, path, type, count, skip);
 	if (err)
diff -Nur blktap2_oxt//drivers/tapdisk-syslog.c blktap2_xen//drivers/tapdisk-syslog.c
--- blktap2_oxt//drivers/tapdisk-syslog.c	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-syslog.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,624 +0,0 @@
-/*
- * Copyright (c) 2009, XenSource Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
-/*
- * A non-blocking, buffered BSD syslog client.
- *
- * http://www.ietf.org/rfc/rfc3164.txt (FIXME: Read this.)
- */
-
-#define _ISOC99_SOURCE
-#include <stdlib.h>
-#include <stdio.h>
-#include <errno.h>
-#include <unistd.h>
-#include <time.h>
-#include <fcntl.h>
-#include <stdarg.h>
-#include <sys/mman.h>
-#include <sys/socket.h>
-#include <sys/un.h>
-
-#include <blktaplib.h>
-#include "tapdisk-server.h"
-#include "tapdisk-syslog.h"
-#include "tapdisk-utils.h"
-
-#define MIN(a,b) (((a) < (b)) ? (a) : (b))
-
-static int tapdisk_syslog_sock_send(td_syslog_t *log,
-				    const void *msg, size_t size);
-static int tapdisk_syslog_sock_connect(td_syslog_t *log);
-static int tapdisk_syslog_sock_reconnect(td_syslog_t *log);
-
-static void tapdisk_syslog_sock_mask(td_syslog_t *log);
-static void tapdisk_syslog_sock_unmask(td_syslog_t *log);
-
-static const struct sockaddr_un syslog_addr = {
-	.sun_family = AF_UNIX,
-	.sun_path   = "/dev/log"
-};
-
-#define RING_PTR(_log, _idx)                                            \
-	(&(_log)->ring[(_idx) % (_log)->ringsz])
-
-#define RING_FREE(_log)                                                 \
-	((_log)->ringsz - ((_log)->prod - (_log)->cons))
-
-/*
- * NB. Ring buffer.
- *
- * We allocate a number of pages as indicated by @bufsz during
- * initialization. From that, 1K is reserved for message staging, the
- * rest is cyclic ring space.
- *
- * All producer/consumer offsets wrap on size_t range, not buffer
- * size. Hence the RING() macros.
- */
-
-static void
-__tapdisk_syslog_ring_init(td_syslog_t *log)
-{
-	log->buf     = NULL;
-	log->bufsz   = 0;
-	log->msg     = NULL;
-	log->ring    = NULL;
-	log->ringsz  = 0;
-}
-
-static inline size_t
-page_align(size_t size)
-{
-	size_t page_size = sysconf(_SC_PAGE_SIZE);
-	return (size + page_size - 1) & ~(page_size - 1);
-}
-
-static void
-tapdisk_syslog_ring_uninit(td_syslog_t *log)
-{
-	if (log->buf)
-		munmap(log->buf, log->bufsz);
-
-	__tapdisk_syslog_ring_init(log);
-}
-
-static int
-tapdisk_syslog_ring_init(td_syslog_t *log, size_t size)
-{
-	int prot, flags, err;
-
-	__tapdisk_syslog_ring_init(log);
-
-	log->bufsz = page_align(size);
-
-	prot  = PROT_READ|PROT_WRITE;
-	flags = MAP_ANONYMOUS|MAP_PRIVATE;
-
-	log->buf = mmap(NULL, log->bufsz, prot, flags, -1, 0);
-	if (log->buf == MAP_FAILED) {
-		log->buf = NULL;
-		err = -ENOMEM;
-		goto fail;
-	}
-
-	err = mlock(log->buf, size);
-	if (err) {
-		err = -errno;
-		goto fail;
-	}
-
-	log->msg    = log->buf;
-	log->ring   = log->buf + TD_SYSLOG_PACKET_MAX;
-	log->ringsz = size     - TD_SYSLOG_PACKET_MAX;
-
-	return 0;
-
-fail:
-	tapdisk_syslog_ring_uninit(log);
-
-	return err;
-}
-
-static int
-tapdisk_syslog_ring_write_str(td_syslog_t *log, const char *msg, size_t len)
-{
-	size_t size, prod, i;
-
-	len  = MIN(len, TD_SYSLOG_PACKET_MAX);
-	size = len + 1;
-
-	if (size > RING_FREE(log))
-		return -ENOBUFS;
-
-	prod = log->prod;
-
-	for (i = 0; i < len; ++i) {
-		char c;
-
-		c = msg[i];
-		if (c == 0)
-			break;
-
-		*RING_PTR(log, prod) = c;
-		prod++;
-	}
-
-	*RING_PTR(log, prod) = 0;
-
-	log->prod = prod + 1;
-
-	return 0;
-}
-
-static ssize_t
-tapdisk_syslog_ring_read_pkt(td_syslog_t *log, char *msg, size_t size)
-{
-	size_t cons;
-	ssize_t sz;
-
-	size = MIN(size, TD_SYSLOG_PACKET_MAX);
-
-	sz   = 0;
-	cons = log->cons;
-
-	while (sz < size) {
-		char c;
-
-		if (cons == log->prod)
-			break;
-
-		c = *RING_PTR(log, cons);
-		msg[sz++] = c;
-		cons++;
-
-		if (c == 0)
-			break;
-	}
-
-	return sz - 1;
-}
-
-static int
-tapdisk_syslog_ring_dispatch_one(td_syslog_t *log)
-{
-	size_t len;
-	int err;
-
-	len = tapdisk_syslog_ring_read_pkt(log, log->msg,
-					   TD_SYSLOG_PACKET_MAX);
-	if (len == -1)
-		return -ENOMSG;
-
-	err = tapdisk_syslog_sock_send(log, log->msg, len);
-
-	if (err == -EAGAIN)
-		return err;
-
-	if (err)
-		goto fail;
-
-done:
-	log->cons += len + 1;
-	return 0;
-
-fail:
-	log->stats.fails++;
-	goto done;
-}
-
-static void
-tapdisk_syslog_ring_warning(td_syslog_t *log)
-{
-	int n, err;
-
-	n        = log->oom;
-	log->oom = 0;
-
-	err = tapdisk_syslog(log, LOG_WARNING,
-			     "tapdisk-syslog: %d messages dropped", n);
-	if (err)
-		log->oom = n;
-}
-
-static void
-tapdisk_syslog_ring_dispatch(td_syslog_t *log)
-{
-	int err;
-
-	do {
-		err = tapdisk_syslog_ring_dispatch_one(log);
-	} while (!err);
-
-	if (log->oom)
-		tapdisk_syslog_ring_warning(log);
-}
-
-static int
-tapdisk_syslog_vsprintf(char *buf, size_t size,
-			int prio, const struct timeval *tv, const char *ident,
-			const char *fmt, va_list ap)
-{
-	char tsbuf[TD_SYSLOG_STRTIME_LEN+1];
-	size_t len;
-
-	/*
-	 * PKT       := PRI HEADER MSG
-	 * PRI       := "<" {"0" .. "9"} ">"
-	 * HEADER    := TIMESTAMP HOSTNAME
-	 * MSG       := <TAG> <SEP> <CONTENT>
-	 * SEP       := ":" | " " | "["
-	 */
-
-	tapdisk_syslog_strftime(tsbuf, sizeof(tsbuf), tv);
-
-	len = 0;
-
-	/* NB. meant to work with c99 null buffers */
-
-	len += snprintf(buf ? buf + len : NULL, buf ? size - len : 0,
-			"<%d>%s %s: ", prio, tsbuf, ident);
-
-	len += vsnprintf(buf ? buf + len : NULL, buf ? size - len : 0,
-			 fmt, ap);
-
-	if (buf && len < size && buf[len] != '\n')
-		len += snprintf(buf + len, size - len, "\n");
-
-	return MIN(len, size);
-}
-
-/*
- * NB. Sockets.
- *
- * Syslog is based on a connectionless (DGRAM) unix transport.
- *
- * While it is reliable, we cannot block on syslogd because -- as with
- * any IPC in tapdisk -- we could deadlock in page I/O writeback.
- * Hence the syslog(3) avoidance on the datapath, which this code
- * facilitates.
- *
- * This type of socket has a single (global) receive buffer on
- * syslogd's end, but no send buffer at all. The does just that:
- * headroom on the sender side.
- *
- * The transport is rather stateless, but we still need to connect()
- * the socket, or select() will find no receive buffer to block
- * on. While we never disconnect, connections are unreliable because
- * syslog may shut down.
- *
- * Reconnection will be attempted with every user message submitted.
- * Any send() or connect() failure other than EAGAIN discards the
- * message. Also, the write event handler will go on to discard any
- * remaining ring contents as well, once the socket is disconnected.
- *
- * In summary, no attempts to mask service blackouts in here.
- *
- * Addendum: some syslog variants (e.g., syslog-ng) use STREAM-based
- * transports. So we add a few checks here to handle these cases.
- */
-
-int
-tapdisk_vsyslog(td_syslog_t *log, int prio, const char *fmt, va_list ap)
-{
-	struct timeval now;
-	size_t len;
-	int err;
-
-	gettimeofday(&now, NULL);
-
-	len = tapdisk_syslog_vsprintf(log->msg, TD_SYSLOG_PACKET_MAX,
-				      prio | log->facility,
-				      &now, log->ident, fmt, ap);
-
-	log->stats.count += 1;
-	log->stats.bytes += len;
-
-	if (log->cons != log->prod)
-		goto busy;
-
-send:
-	err = tapdisk_syslog_sock_send(log, log->msg, len);
-	if (!err)
-		return 0;
-
-	switch (err) {
-	case -ENOTCONN:
-	case -EPIPE:
-	case -EBADF:
-		err = tapdisk_syslog_sock_reconnect(log);
-		if (!err)
-			goto send;
-	}
-
-	if (err != -EAGAIN)
-		goto fail;
-
-	tapdisk_syslog_sock_unmask(log);
-
-busy:
-	if (log->oom) {
-		err = -ENOBUFS;
-		goto oom;
-	}
-
-	err = tapdisk_syslog_ring_write_str(log, log->msg, len);
-	if (!err)
-		return 0;
-
-	log->oom_tv = now;
-
-oom:
-	log->oom++;
-	log->stats.drops++;
-	return err;
-
-fail:
-	log->stats.fails++;
-	return err;
-}
-
-int
-tapdisk_syslog(td_syslog_t *log, int prio, const char *fmt, ...)
-{
-	va_list ap;
-	int err;
-
-	va_start(ap, fmt);
-	err = tapdisk_vsyslog(log, prio, fmt, ap);
-	va_end(ap);
-
-	return err;
-}
-
-static int
-tapdisk_syslog_sock_send(td_syslog_t *log, const void *msg, size_t size)
-{
-	ssize_t n;
-
-	log->stats.xmits++;
-
-	n = send(log->sock, msg, size, MSG_DONTWAIT | MSG_NOSIGNAL);
-	if (n < 0)
-		return -errno;
-
-	return 0;
-}
-
-static void
-tapdisk_syslog_sock_event(event_id_t id, char mode, void *private)
-{
-	td_syslog_t *log = private;
-
-	tapdisk_syslog_ring_dispatch(log);
-
-	if (log->cons == log->prod)
-		tapdisk_syslog_sock_mask(log);
-}
-
-static void
-__tapdisk_syslog_sock_init(td_syslog_t *log)
-{
-	log->sock     = -1;
-	log->type     = -1;
-	log->event_id = -1;
-}
-
-static void
-tapdisk_syslog_sock_close(td_syslog_t *log)
-{
-	if (log->sock >= 0)
-		close(log->sock);
-
-	if (log->event_id >= 0)
-		tapdisk_server_unregister_event(log->event_id);
-
-	__tapdisk_syslog_sock_init(log);
-}
-
-static int
-__tapdisk_syslog_sock_open(td_syslog_t *log, int type)
-{
-	int err;
-
-	log->sock = socket(PF_UNIX, type, 0);
-	if (log->sock < 0) {
-		err = -errno;
-		goto fail;
-	}
-
-	err = fcntl(log->sock, F_SETFL, O_NONBLOCK);
-	if (err < 0) {
-		err = -errno;
-		goto fail;
-	}
-
-	err = tapdisk_syslog_sock_connect(log);
-	if (err)
-		goto fail;
-
-	log->type = type;
-	return 0;
-
-fail:
-	if (log->sock > 0) {
-		close(log->sock);
-		log->sock = -1;
-	}
-
-	return err;
-}
-
-static int
-tapdisk_syslog_sock_open(td_syslog_t *log)
-{
-	event_id_t id;
-	int err;
-
-	__tapdisk_syslog_sock_init(log);
-
-	err = __tapdisk_syslog_sock_open(log, SOCK_DGRAM);
-	if (err == -EPROTOTYPE)
-		err = __tapdisk_syslog_sock_open(log, SOCK_STREAM);
-
-	if (err)
-		goto fail;
-
-	id = tapdisk_server_register_event(SCHEDULER_POLL_WRITE_FD,
-					   log->sock, 0,
-					   tapdisk_syslog_sock_event,
-					   log);
-	if (id < 0) {
-		err = id;
-		goto fail;
-	}
-
-	log->event_id = id;
-
-	tapdisk_syslog_sock_mask(log);
-
-	return 0;
-
-fail:
-	tapdisk_syslog_sock_close(log);
-	return err;
-}
-
-static int
-tapdisk_syslog_sock_connect(td_syslog_t *log)
-{
-	int err;
-
-	err = connect(log->sock, &syslog_addr, sizeof(syslog_addr));
-	if (err < 0)
-		err = -errno;
-
-	return err;
-}
-
-static int
-tapdisk_syslog_sock_reconnect(td_syslog_t *log)
-{
-	int err;
-
-	switch (log->type) {
-	case -1:
-	case SOCK_STREAM:
-		tapdisk_syslog_sock_close(log);
-		err = tapdisk_syslog_sock_open(log);
-		if (!err && log->cons != log->prod)
-			tapdisk_syslog_sock_unmask(log);
-		break;
-	default:
-		err = tapdisk_syslog_sock_connect(log);
-	}
-
-	return err;
-}
-
-static void
-tapdisk_syslog_sock_mask(td_syslog_t *log)
-{
-	tapdisk_server_mask_event(log->event_id, 1);
-}
-
-static void
-tapdisk_syslog_sock_unmask(td_syslog_t *log)
-{
-	tapdisk_server_mask_event(log->event_id, 0);
-}
-
-void
-__tapdisk_syslog_init(td_syslog_t *log)
-{
-	memset(log, 0, sizeof(td_syslog_t));
-	__tapdisk_syslog_sock_init(log);
-	__tapdisk_syslog_ring_init(log);
-}
-
-void
-tapdisk_syslog_close(td_syslog_t *log)
-{
-	tapdisk_syslog_ring_uninit(log);
-	tapdisk_syslog_sock_close(log);
-
-	if (log->ident)
-		free(log->ident);
-
-	__tapdisk_syslog_init(log);
-}
-
-int
-tapdisk_syslog_open(td_syslog_t *log, const char *ident, int facility, size_t bufsz)
-{
-	int err;
-
-	__tapdisk_syslog_init(log);
-
-	log->facility = facility;
-	log->ident = ident ? strndup(ident, TD_SYSLOG_IDENT_MAX) : NULL;
-
-	err = tapdisk_syslog_ring_init(log, bufsz);
-	if (err)
-		goto fail;
-
-	/*
-	 * failures here are not fatal because
-	 * we retry at every attempt to log
-	 */
-	tapdisk_syslog_sock_open(log);
-	return 0;
-
-fail:
-	tapdisk_syslog_close(log);
-
-	return err;
-}
-
-void
-tapdisk_syslog_stats(td_syslog_t *log, int prio)
-{
-	struct _td_syslog_stats *s = &log->stats;
-
-	tapdisk_syslog(log, prio,
-		       "tapdisk-syslog: %llu messages, %llu bytes, "
-		       "xmits: %llu, failed: %llu, dropped: %llu",
-		       s->count, s->bytes,
-		       s->xmits, s->fails, s->drops);
-}
-
-void
-tapdisk_syslog_flush(td_syslog_t *log)
-{
-	while (log->cons != log->prod)
-		tapdisk_server_iterate();
-}
diff -Nur blktap2_oxt//drivers/tapdisk-syslog.h blktap2_xen//drivers/tapdisk-syslog.h
--- blktap2_oxt//drivers/tapdisk-syslog.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-syslog.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,87 +0,0 @@
-/*
- * Copyright (c) 2009, XenSource Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
-#ifndef __TAPDISK_SYSLOG_H__
-#define __TAPDISK_SYSLOG_H__
-
-#include <syslog.h>
-#include <stdarg.h>
-#include "scheduler.h"
-
-typedef struct _td_syslog td_syslog_t;
-
-#define TD_SYSLOG_PACKET_MAX  1024
-
-struct _td_syslog_stats {
-	unsigned long long count;
-	unsigned long long bytes;
-	unsigned long long xmits;
-	unsigned long long fails;
-	unsigned long long drops;
-};
-
-struct _td_syslog {
-	char            *ident;
-	int              facility;
-
-	int              sock;
-	int              type;          /* DGRAM or STREAM */
-	event_id_t       event_id;
-
-	void            *buf;
-	size_t           bufsz;
-
-	char            *msg;
-
-	char            *ring;
-	size_t           ringsz;
-
-	size_t           prod;
-	size_t           cons;
-
-	int              oom;
-	struct timeval   oom_tv;
-
-	struct _td_syslog_stats stats;
-};
-
-int  tapdisk_syslog_open(td_syslog_t *,
-			 const char *ident, int facility, size_t bufsz);
-void tapdisk_syslog_close(td_syslog_t *);
-void tapdisk_syslog_flush(td_syslog_t *);
-void tapdisk_syslog_stats(td_syslog_t *, int prio);
-
-int tapdisk_vsyslog(td_syslog_t *, int prio, const char *fmt, va_list ap);
-int tapdisk_syslog(td_syslog_t *, int prio, const char *fmt, ...);
-
-#endif /* __TAPDISK_SYSLOG_H__ */
diff -Nur blktap2_oxt//drivers/tapdisk-utils.c blktap2_xen//drivers/tapdisk-utils.c
--- blktap2_oxt//drivers/tapdisk-utils.c	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-utils.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,18 +25,10 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
-#include <stdlib.h>
 #include <errno.h>
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>
-#include <linux/fs.h>
 #include <sys/stat.h>
 #include <sys/mman.h>
 #include <sys/ioctl.h>
@@ -46,100 +38,27 @@
 #include <linux/version.h>
 #endif
 
-#define SYSLOG_NAMES
-#include <syslog.h>
-
+#include "blk.h"
 #include "tapdisk.h"
 #include "blktaplib.h"
 #include "tapdisk-log.h"
 #include "tapdisk-utils.h"
-#include "tapdisk-syslog.h"
-
-#define MIN(a,b) (((a) < (b)) ? (a) : (b))
-
-static int
-tapdisk_syslog_facility_by_name(const char *name)
-{
-	int facility;
-	CODE *c;
-
-	facility = -1;
-
-	for (c = facilitynames; c->c_name != NULL; ++c)
-		if (!strcmp(c->c_name, name)) {
-			facility = c->c_val;
-			break;
-		}
-
-	return facility;
-}
-
-int
-tapdisk_syslog_facility(const char *arg)
-{
-	int facility;
-	char *endptr;
-
-	if (arg) {
-		facility = strtol(arg, &endptr, 0);
-		if (*endptr == 0)
-			return facility;
-
-		facility = tapdisk_syslog_facility_by_name(arg);
-		if (facility >= 0)
-			return facility;
-	}
-
-	return LOG_DAEMON;
-}
 
-char*
-tapdisk_syslog_ident(const char *name)
+void
+tapdisk_start_logging(const char *name)
 {
-	char ident[TD_SYSLOG_IDENT_MAX+1];
-	size_t size, len;
-	pid_t pid;
-
-	pid  = getpid();
-	size = sizeof(ident);
-	len  = 0;
-
-	len  = snprintf(NULL, 0, "[%d]", pid);
-	len  = snprintf(ident, size - len, "%s", name);
-	len += snprintf(ident + len, size - len, "[%d]", pid);
+	static char buf[128];
 
-	return strdup(ident);
+	snprintf(buf, sizeof(buf), "%s[%d]", name, getpid());
+	openlog(buf, LOG_CONS | LOG_ODELAY, LOG_DAEMON);
+	open_tlog("/tmp/tapdisk.log", (64 << 10), TLOG_WARN, 0);
 }
 
-size_t
-tapdisk_syslog_strftime(char *buf, size_t size, const struct timeval *tv)
+void
+tapdisk_stop_logging(void)
 {
-	const char *mon[] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun",
-			      "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
-	struct tm tm;
-
-	/*
-	 * TIMESTAMP :=  <Mmm> " " <dd> " " <hh> ":" <mm> ":" <ss>.
-	 * Local time, no locales.
-	 */
-
-	localtime_r(&tv->tv_sec, &tm);
-
-	return snprintf(buf, size, "%s %2d %02d:%02d:%02d",
-			mon[tm.tm_mon], tm.tm_mday,
-			tm.tm_hour, tm.tm_min, tm.tm_sec);
-}
-
-size_t
-tapdisk_syslog_strftv(char *buf, size_t size, const struct timeval *tv)
-{
-	struct tm tm;
-
-	localtime_r(&tv->tv_sec, &tm);
-
-	return snprintf(buf, size, "[%02d:%02d:%02d.%03ld]",
-			tm.tm_hour, tm.tm_min, tm.tm_sec,
-			(long)tv->tv_usec / 1000);
+	closelog();
+	close_tlog();
 }
 
 int
@@ -148,12 +67,6 @@
 	int err;
 	struct rlimit rlim;
 
-	err = setpriority(PRIO_PROCESS, 0, PRIO_SPECIAL_IO);
-	if (err) {
-		EPRINTF("PRIO_SPECIAL_IO failed: %d\n", errno);
-		return -errno;
-	}
-
 	rlim.rlim_cur = RLIM_INFINITY;
 	rlim.rlim_max = RLIM_INFINITY;
 
@@ -200,8 +113,8 @@
 {
 	int ret;
 	struct stat stat;
-	uint64_t sectors, bytes;
-	uint32_t sector_size;
+	uint64_t sectors;
+	uint64_t sector_size;
 
 	sectors       = 0;
 	sector_size   = 0;
@@ -215,28 +128,12 @@
 
 	if (S_ISBLK(stat.st_mode)) {
 		/*Accessing block device directly*/
-		if (ioctl(fd,BLKGETSIZE64,&bytes)==0) {
-			sectors = bytes >> SECTOR_SHIFT;
-		} else if (ioctl(fd,BLKGETSIZE,&sectors)!=0) {
-			DPRINTF("ERR: BLKGETSIZE and BLKGETSIZE64 failed, couldn't stat image");
+		if (blk_getimagesize(fd, &sectors) != 0)
 			return -EINVAL;
-		}
 
 		/*Get the sector size*/
-#if defined(BLKSSZGET)
-		{
-			int arg;
+		if (blk_getsectorsize(fd, &sector_size) != 0)
 			sector_size = DEFAULT_SECTOR_SIZE;
-			ioctl(fd, BLKSSZGET, &sector_size);
-
-			if (sector_size != DEFAULT_SECTOR_SIZE)
-				DPRINTF("Note: sector size is %u (not %d)\n",
-					sector_size, DEFAULT_SECTOR_SIZE);
-		}
-#else
-		sector_size = DEFAULT_SECTOR_SIZE;
-#endif
-
 	} else {
 		/*Local file? try fstat instead*/
 		sectors     = (stat.st_size >> SECTOR_SHIFT);
@@ -278,3 +175,40 @@
 }
 
 #endif
+int read_exact(int fd, void *data, size_t size)
+{
+    size_t offset = 0;
+    ssize_t len;
+
+    while ( offset < size )
+    {
+        len = read(fd, (char *)data + offset, size - offset);
+        if ( (len == -1) && (errno == EINTR) )
+            continue;
+        if ( len == 0 )
+            errno = 0;
+        if ( len <= 0 )
+            return -1;
+        offset += len;
+    }
+
+    return 0;
+}
+
+int write_exact(int fd, const void *data, size_t size)
+{
+    size_t offset = 0;
+    ssize_t len;
+
+    while ( offset < size )
+    {
+        len = write(fd, (const char *)data + offset, size - offset);
+        if ( (len == -1) && (errno == EINTR) )
+            continue;
+        if ( len <= 0 )
+            return -1;
+        offset += len;
+    }
+
+    return 0;
+}
diff -Nur blktap2_oxt//drivers/tapdisk-utils.h blktap2_xen//drivers/tapdisk-utils.h
--- blktap2_oxt//drivers/tapdisk-utils.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-utils.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,28 +25,21 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #ifndef _TAPDISK_UTILS_H_
 #define _TAPDISK_UTILS_H_
 
 #include <inttypes.h>
 
-#define MAX_NAME_LEN          1000
-#define TD_SYSLOG_IDENT_MAX   32
-#define TD_SYSLOG_STRTIME_LEN 15
+#define MAX_NAME_LEN                 1000
 
-int tapdisk_syslog_facility(const char *);
-char* tapdisk_syslog_ident(const char *);
-size_t tapdisk_syslog_strftime(char *, size_t, const struct timeval *);
-size_t tapdisk_syslog_strftv(char *, size_t, const struct timeval *);
+void tapdisk_start_logging(const char *);
+void tapdisk_stop_logging(void);
 int tapdisk_set_resource_limits(void);
 int tapdisk_namedup(char **, const char *);
-int tapdisk_parse_disk_type(const char *, char **, int *);
 int tapdisk_get_image_size(int, uint64_t *, uint32_t *);
 int tapdisk_linux_version(void);
 
+int read_exact(int fd, void *data, size_t size); /* EOF => -1, errno=0 */
+int write_exact(int fd, const void *data, size_t size);
+
 #endif
diff -Nur blktap2_oxt//drivers/tapdisk-vbd.c blktap2_xen//drivers/tapdisk-vbd.c
--- blktap2_oxt//drivers/tapdisk-vbd.c	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-vbd.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,5 @@
-/*
+/* 
  * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +24,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -37,17 +34,16 @@
 #include <libgen.h>
 #include <sys/mman.h>
 #include <sys/ioctl.h>
+#ifdef MEMSHR
+#include <memshr.h>
+#endif
 
-#include "libvhd.h"
 #include "tapdisk-image.h"
 #include "tapdisk-driver.h"
 #include "tapdisk-server.h"
-#include "tapdisk-vbd.h"
-#include "tapdisk-disktype.h"
 #include "tapdisk-interface.h"
-#include "tapdisk-stats.h"
-#include "tapdisk-storage.h"
-
+#include "tapdisk-disktype.h"
+#include "tapdisk-vbd.h"
 #include "blktap2.h"
 
 #define DBG(_level, _f, _a...) tlog_write(_level, _f, ##_a)
@@ -72,10 +68,7 @@
 #define TD_VBD_WATCHDOG_TIMEOUT     10
 
 static void tapdisk_vbd_ring_event(event_id_t, char, void *);
-static void tapdisk_vbd_complete_vbd_request(td_vbd_t *, td_vbd_request_t *);
 static void tapdisk_vbd_callback(void *, blkif_response_t *);
-static int  tapdisk_vbd_queue_ready(td_vbd_t *);
-static void tapdisk_vbd_check_queue_state(td_vbd_t *);
 
 /* 
  * initialization
@@ -88,10 +81,15 @@
 	INIT_LIST_HEAD(&vreq->next);
 }
 
-static void
-tapdisk_vbd_mark_progress(td_vbd_t *vbd)
+void
+tapdisk_vbd_free(td_vbd_t *vbd)
 {
-	gettimeofday(&vbd->ts, NULL);
+	if (vbd) {
+		tapdisk_vbd_free_stack(vbd);
+		list_del_init(&vbd->next);
+		free(vbd->name);
+		free(vbd);
+	}
 }
 
 td_vbd_t*
@@ -113,14 +111,19 @@
 	/* default blktap ring completion */
 	vbd->callback = tapdisk_vbd_callback;
 	vbd->argument = vbd;
+    
+#ifdef MEMSHR
+	memshr_vbd_initialize();
+#endif
 
+	INIT_LIST_HEAD(&vbd->driver_stack);
 	INIT_LIST_HEAD(&vbd->images);
 	INIT_LIST_HEAD(&vbd->new_requests);
 	INIT_LIST_HEAD(&vbd->pending_requests);
 	INIT_LIST_HEAD(&vbd->failed_requests);
 	INIT_LIST_HEAD(&vbd->completed_requests);
 	INIT_LIST_HEAD(&vbd->next);
-	tapdisk_vbd_mark_progress(vbd);
+	gettimeofday(&vbd->ts, NULL);
 
 	for (i = 0; i < MAX_REQUESTS; i++)
 		tapdisk_vbd_initialize_vreq(vbd->request_list + i);
@@ -129,7 +132,7 @@
 }
 
 int
-tapdisk_vbd_initialize(int rfd, int wfd, uint16_t uuid)
+tapdisk_vbd_initialize(uint16_t uuid)
 {
 	td_vbd_t *vbd;
 
@@ -162,12 +165,7 @@
 	DPRINTF("VBD CHAIN:\n");
 
 	tapdisk_vbd_for_each_image(vbd, image, tmp) {
-		DPRINTF("%s: type:%s(%d) storage:%s(%d)\n",
-			image->name,
-			tapdisk_disk_types[image->type]->name,
-			image->type,
-			tapdisk_storage_name(image->driver->storage),
-			image->driver->storage);
+		DPRINTF("%s: %d\n", image->name, image->type);
 
 		if (tapdisk_vbd_is_last_image(vbd, image))
 			break;
@@ -191,22 +189,10 @@
 		tapdisk_image_free(image);
 	}
 
-	if (vbd->secondary && vbd->secondary_mode != TD_VBD_SECONDARY_MIRROR) {
-		/* in mirror mode the image will have been closed as part of 
-		 * the chain */
-		td_close(vbd->secondary);
-		tapdisk_image_free(vbd->secondary);
-		DPRINTF("Secondary image closed\n");
-	}
-
-	if (vbd->retired) {
-		td_close(vbd->retired);
-		tapdisk_image_free(vbd->retired);
-		DPRINTF("Retired mirror image closed\n");
-	}
-
 	INIT_LIST_HEAD(&vbd->images);
 	td_flag_set(vbd->state, TD_VBD_CLOSED);
+
+	tapdisk_vbd_free_stack(vbd);
 }
 
 static int
@@ -230,6 +216,7 @@
 
 	cache = tapdisk_image_allocate(target->name,
 				       DISK_TYPE_BLOCK_CACHE,
+				       target->storage,
 				       target->flags,
 				       target->private);
 	if (!cache)
@@ -248,7 +235,8 @@
 
 	cache->driver = tapdisk_driver_allocate(cache->type,
 						cache->name,
-						cache->flags);
+						cache->flags,
+						cache->storage);
 	if (!cache->driver) {
 		err = -ENOMEM;
 		goto fail;
@@ -273,185 +261,6 @@
 }
 
 static int
-tapdisk_vbd_add_local_cache(td_vbd_t *vbd)
-{
-	int err;
-	td_driver_t *driver;
-	td_image_t *cache, *parent;
-
-	parent = tapdisk_vbd_first_image(vbd);
-	if (tapdisk_vbd_is_last_image(vbd, parent)) {
-		DPRINTF("Single-image chain, nothing to cache");
-		return 0;
-	}
-
-	cache = tapdisk_image_allocate(parent->name,
-			DISK_TYPE_LOCAL_CACHE,
-			parent->flags,
-			parent->private);
-
-	if (!cache)
-		return -ENOMEM;
-
-	/* try to load existing cache */
-	err = td_load(cache);
-	if (!err)
-		goto done;
-
-	cache->driver = tapdisk_driver_allocate(cache->type,
-						cache->name,
-						cache->flags);
-
-	if (!cache->driver) {
-		err = -ENOMEM;
-		goto fail;
-	}
-
-	cache->driver->info = parent->driver->info;
-
-	/* try to open new cache */
-	err = td_open(cache);
-	if (!err)
-		goto done;
-
-fail:
-	tapdisk_image_free(cache);
-	return err;
-
-done:
-	/* insert cache right above leaf image */
-	list_add(&cache->next, &parent->next);
-
-	DPRINTF("Added local_cache driver\n");
-	return 0;
-}
-
-static int
-tapdisk_vbd_add_secondary(td_vbd_t *vbd)
-{
-	int err;
-	td_driver_t *driver;
-	td_image_t *leaf, *second;
-
-	DPRINTF("Adding secondary image: %s\n", vbd->secondary_name);
-
-	leaf = tapdisk_vbd_first_image(vbd);
-	second = tapdisk_image_allocate(vbd->secondary_name,
-					vbd->secondary_type,
-					leaf->flags,
-					leaf->private);
-
-	if (!second)
-		return -ENOMEM;
-
-	second->driver = tapdisk_driver_allocate(second->type,
-						 second->name,
-						 second->flags);
-
-	if (!second->driver) {
-		err = -ENOMEM;
-		goto fail;
-	}
-
-	second->driver->info = leaf->driver->info;
-
-	/* try to open the secondary image */
-	err = td_open(second);
-	if (err)
-		goto fail;
-
-	if (second->info.size != leaf->info.size) {
-		EPRINTF("Secondary image size %lld != image size %lld\n",
-				second->info.size, leaf->info.size);
-		err = -EINVAL;
-		goto fail;
-	}
-
-	goto done;
-
-fail:
-	tapdisk_image_free(second);
-	return err;
-
-done:
-	vbd->secondary = second;
-	leaf->flags |= TD_IGNORE_ENOSPC;
-	if (td_flag_test(vbd->flags, TD_OPEN_STANDBY)) {
-		DPRINTF("In standby mode\n");
-		vbd->secondary_mode = TD_VBD_SECONDARY_STANDBY;
-	} else {
-		DPRINTF("In mirror mode\n");
-		vbd->secondary_mode = TD_VBD_SECONDARY_MIRROR;
-		/* we actually need this image to also be part of the chain, 
-		 * since it may already contain data */
-		list_add(&vbd->secondary->next, &leaf->next);
-	}
-
-	DPRINTF("Added secondary image\n");
-	return 0;
-}
-
-static void signal_enospc(td_vbd_t *vbd)
-{
-	int fd, err;
-	char *fn;
-
-	err = asprintf(&fn, BLKTAP2_ENOSPC_SIGNAL_FILE"%d", vbd->minor);
-	if (err == -1) {
-		EPRINTF("Failed to signal ENOSPC condition\n");
-		return;
-	}
-
-	fd = open(fn, O_WRONLY | O_CREAT | O_NONBLOCK, 0644);
-	if (fd == -1)
-		EPRINTF("Failed to open file to signal ENOSPC condition\n");
-	else
-		close(fd);
-
-	free(fn);
-}
-
-static int
-tapdisk_vbd_open_index(td_vbd_t *vbd)
-{
-	int err;
-	char *path;
-	td_flag_t flags;
-	td_image_t *last, *image;
-
-	last = tapdisk_vbd_last_image(vbd);
-	err  = asprintf(&path, "%s.bat", last->name);
-	if (err == -1)
-		return -errno;
-
-	err = access(path, R_OK);
-	if (err == -1) {
-		free(path);
-		return -errno;
-	}
-
-	flags = vbd->flags | TD_OPEN_RDONLY | TD_OPEN_SHAREABLE;
-	image = tapdisk_image_allocate(path, DISK_TYPE_VINDEX, flags, vbd);
-	if (!image) {
-		err = -ENOMEM;
-		goto fail;
-	}
-
-	err = td_open(image);
-	if (err)
-		goto fail;
-
-	tapdisk_vbd_add_image(vbd, image);
-	return 0;
-
-fail:
-	if (image)
-		tapdisk_image_free(image);
-	free(path);
-	return err;
-}
-
-static int
 tapdisk_vbd_add_dirty_log(td_vbd_t *vbd)
 {
 	int err;
@@ -465,6 +274,7 @@
 
 	log    = tapdisk_image_allocate(parent->name,
 					DISK_TYPE_LOG,
+					parent->storage,
 					parent->flags,
 					vbd);
 	if (!log)
@@ -472,7 +282,8 @@
 
 	driver = tapdisk_driver_allocate(log->type,
 					 log->name,
-					 log->flags);
+					 log->flags,
+					 log->storage);
 	if (!driver) {
 		err = -ENOMEM;
 		goto fail;
@@ -485,7 +296,7 @@
 	if (err)
 		goto fail;
 
-	tapdisk_vbd_add_image(vbd, log);
+	list_add(&log->next, &vbd->images);
 	return 0;
 
 fail:
@@ -494,81 +305,117 @@
 }
 
 static int
-__tapdisk_vbd_open_vdi(td_vbd_t *vbd, td_flag_t extra_flags)
+tapdisk_vbd_open_level(td_vbd_t *vbd, struct list_head *head,
+		       const char *params, int driver_type,
+		       td_disk_info_t *driver_info, td_flag_t flags)
 {
-	char *file;
-	int err, type;
-	td_flag_t flags;
+	const char *name;
+	int type, err;
+	td_image_t *image;
 	td_disk_id_t id;
-	td_image_t *image, *tmp;
-	struct tfilter *filter = NULL;
+	td_driver_t *driver;
 
-	flags = (vbd->flags & ~TD_OPEN_SHAREABLE) | extra_flags;
-	file  = vbd->name;
-	type  = vbd->type;
+	name    = params;
+	id.name = NULL;
+	type    = driver_type;
+	INIT_LIST_HEAD(head);
 
 	for (;;) {
 		err   = -ENOMEM;
-		image = tapdisk_image_allocate(file, type, flags, vbd);
+		image = tapdisk_image_allocate(name, type,
+					       vbd->storage, flags, vbd);
 
-		if (file != vbd->name) {
-			free(file);
-			file = NULL;
-		}
+		free(id.name);
 
 		if (!image)
-			goto fail;
+			goto out;
 
-		err = td_load(image);
-		if (err) {
-			if (err != -ENODEV)
-				goto fail;
 
-			if (td_flag_test(flags, TD_OPEN_VHD_INDEX) &&
-			    td_flag_test(flags, TD_OPEN_RDONLY)) {
-				err = tapdisk_vbd_open_index(vbd);
-				if (!err) {
-					tapdisk_image_free(image);
-					image = NULL;
-					break;
-				}
-
-				if (err != -ENOENT)
-					goto fail;
-			}
+		/* this breaks if a driver modifies its info within a layer */
+		err = __td_open(image, driver_info);
+		if (err)
+			goto out;
 
-			err = td_open(image);
-			if (err)
-				goto fail;
-		}
+		/* TODO: non-sink drivers that don't care about their child
+		 * currently return EINVAL. Could return TD_PARENT_OK or
+		 * TD_ANY_PARENT */
 
 		err = td_get_parent_id(image, &id);
-		if (err && err != TD_NO_PARENT) {
+		if (err && (err != TD_NO_PARENT && err != -EINVAL)) {
 			td_close(image);
-			goto fail;
+			goto out;
 		}
 
-		tapdisk_vbd_add_image(vbd, image);
+		/* add this image to the end of the list */
+		list_add_tail(&image->next, head);
 		image = NULL;
 
-		if (err == TD_NO_PARENT)
-			break;
+		/* if the image does not have a parent we return the
+		 * list of images generated by this level of the stack */
+		if (err == TD_NO_PARENT || err == -EINVAL) {
+			err = 0;
+			goto out;
+		}
 
-		file   = id.name;
+		name   = id.name;
 		type   = id.drivertype;
-		if (flags & TD_OPEN_REUSE_PARENT) {
-			free(file);
-			err = asprintf(&file, "%s%d", BLKTAP2_IO_DEVICE,
-					vbd->parent_devnum);
-			if (err == -1) {
-				err = ENOMEM;
-				goto fail;
-			}
-			type = DISK_TYPE_AIO;
-		}
+
 		flags |= (TD_OPEN_RDONLY | TD_OPEN_SHAREABLE);
 	}
 
+out:
+	if (err) {
+		if (image) {
+			td_close(image);
+			tapdisk_image_free(image);
+		}
+		while (!list_empty(head)) {
+			image = list_entry(&head->next, td_image_t, next);
+			td_close(image);
+			tapdisk_image_free(image);
+		}
+	}
+
+	return err;
+}
+
+static int
+__tapdisk_vbd_open_vdi(td_vbd_t *vbd, td_flag_t extra_flags)
+{
+	int err;
+	td_flag_t flags;
+	td_image_t *tmp;
+	td_vbd_driver_info_t *driver_info;
+	struct list_head *images;
+	td_disk_info_t *parent_info = NULL;
+
+	if (list_empty(&vbd->driver_stack))
+		return -ENOENT;
+
+	flags = (vbd->flags & ~TD_OPEN_SHAREABLE) | extra_flags;
+
+	/* loop on each user specified driver.
+	 * NOTE: driver_info is in reverse order. That is, the first
+	 * item is the 'parent' or 'sink' driver */
+	list_for_each_entry(driver_info, &vbd->driver_stack, next) {
+		LIST_HEAD(images);
+
+		err = tapdisk_vbd_open_level(vbd, &images,
+					     driver_info->params,
+					     driver_info->type,
+					     parent_info, flags);
+		if (err)
+			goto fail;
+
+		/* after each loop, 
+		 * append the created stack to the result stack */
+		list_splice(&images, &vbd->images);
+
+		/* set the parent_info to the first diskinfo on the stack */
+		tmp = tapdisk_vbd_first_image(vbd);
+		parent_info = &tmp->info;
+	}
+
 	if (td_flag_test(vbd->flags, TD_OPEN_LOG_DIRTY)) {
 		err = tapdisk_vbd_add_dirty_log(vbd);
 		if (err)
@@ -579,70 +426,144 @@
 		err = tapdisk_vbd_add_block_cache(vbd);
 		if (err)
 			goto fail;
-	}		
-
-	if (td_flag_test(vbd->flags, TD_OPEN_LOCAL_CACHE)) {
-		err = tapdisk_vbd_add_local_cache(vbd);
-		if (err)
-			goto fail;
-	}		
+	}
 
 	err = tapdisk_vbd_validate_chain(vbd);
 	if (err)
 		goto fail;
 
-	if (td_flag_test(vbd->flags, TD_OPEN_SECONDARY)) {
-		err = tapdisk_vbd_add_secondary(vbd);
-		if (err)
-			goto fail;
-	}
-
 	td_flag_clear(vbd->state, TD_VBD_CLOSED);
 
 	return 0;
 
 fail:
-	if (image)
-		tapdisk_image_free(image);
-
 	tapdisk_vbd_close_vdi(vbd);
+	return err;
+}
+
+/* this populates a vbd type based on path */
+int
+tapdisk_vbd_parse_stack(td_vbd_t *vbd, const char *path)
+{
+	int err;
+	char *params, *driver_str;
+	td_vbd_driver_info_t *driver;
+
+	err = tapdisk_namedup(&params, path);
+	if (err)
+		return err;
+
+	/* tokenize params based on pipe '|' */
+	driver_str = strtok(params, "|");
+	while (driver_str != NULL) {
+		const char *path;
+		int type;
+
+		/* parse driver info and add to vbd */
+		driver = calloc(1, sizeof(td_vbd_driver_info_t));
+		if (!driver) {
+			PERROR("malloc");
+			err = -errno;
+			goto out;
+		}
+		INIT_LIST_HEAD(&driver->next);
+
+		err = tapdisk_parse_disk_type(driver_str, &path, &type);
+		if (err) {
+			free(driver);
+			goto out;
+		}
+
+		driver->type   = type;
+		driver->params = strdup(path);
+		if (!driver->params) {
+			err = -ENOMEM;
+			free(driver);
+			goto out;
+		}
+
+		/* build the list backwards as the last driver will be the
+		 * first driver to open in the stack */
+		list_add(&driver->next, &vbd->driver_stack);
+
+		/* get next driver string */
+		driver_str = strtok(NULL, "|");
+	}
+
+out:
+	free(params);
+	if (err)
+		tapdisk_vbd_free_stack(vbd);
 
 	return err;
 }
 
+void
+tapdisk_vbd_free_stack(td_vbd_t *vbd)
+{
+	td_vbd_driver_info_t *driver;
+
+	while (!list_empty(&vbd->driver_stack)) {
+		driver = list_entry(vbd->driver_stack.next,
+				    td_vbd_driver_info_t, next);
+		list_del(&driver->next);
+		free(driver->params);
+		free(driver);
+	}
+}
+
+/* NOTE: driver type, etc. must be set */
 int
-tapdisk_vbd_open_vdi(td_vbd_t *vbd, int type, const char *path,
-		     td_flag_t flags, int prt_devnum,
-		     int secondary_type, const char *secondary_name)
+tapdisk_vbd_open_stack(td_vbd_t *vbd, uint16_t storage, td_flag_t flags)
 {
-	const disk_info_t *info;
 	int i, err;
 
-	info = tapdisk_disk_types[type];
-	if (!info)
-		return -EINVAL;
+	vbd->flags   = flags;
+	vbd->storage = storage;
 
-	DPRINTF("Loading driver '%s' for vbd %u %s 0x%08x\n",
-		info->name, vbd->uuid, path, flags);
+	for (i = 0; i < TD_VBD_EIO_RETRIES; i++) {
+		err = __tapdisk_vbd_open_vdi(vbd, 0);
+		if (err != -EIO)
+			break;
 
-	err = tapdisk_namedup(&vbd->name, path);
+		sleep(TD_VBD_EIO_SLEEP);
+	}
 	if (err)
-		return err;
+		goto fail;
 
-	if (flags & TD_OPEN_REUSE_PARENT)
-		vbd->parent_devnum = prt_devnum;
+	return 0;
 
-	if (flags & TD_OPEN_SECONDARY) {
-		vbd->secondary_type = secondary_type;
-		err = tapdisk_namedup(&vbd->secondary_name, secondary_name);
-		if (err)
-			return err;
-	}
+ fail:
+	return err;
+}
+
+int
+tapdisk_vbd_open_vdi(td_vbd_t *vbd, const char *path,
+		     uint16_t drivertype, uint16_t storage, td_flag_t flags)
+{
+	int i, err;
+	const struct tap_disk *ops;
+
+	ops = tapdisk_disk_drivers[drivertype];
+	if (!ops)
+		return -EINVAL;
+	DPRINTF("Loaded %s driver for vbd %u %s 0x%08x\n",
+		ops->disk_type, vbd->uuid, path, flags);
+
+	err = tapdisk_namedup(&vbd->name, path);
+	if (err)
+		return err;
 
 	vbd->flags   = flags;
-	vbd->type    = type;
+	vbd->storage = storage;
 
-	err = __tapdisk_vbd_open_vdi(vbd, TD_OPEN_STRICT);
+	for (i = 0; i < TD_VBD_EIO_RETRIES; i++) {
+		err = __tapdisk_vbd_open_vdi(vbd, 0);
+		if (err != -EIO)
+			break;
+
+		sleep(TD_VBD_EIO_SLEEP);
+	}
 	if (err)
 		goto fail;
 
@@ -771,12 +692,12 @@
 }
 
 int
-tapdisk_vbd_open(td_vbd_t *vbd, int type, const char *path,
-		 int minor, const char *ring, td_flag_t flags)
+tapdisk_vbd_open(td_vbd_t *vbd, const char *name, uint16_t type,
+		 uint16_t storage, int minor, const char *ring, td_flag_t flags)
 {
 	int err;
 
-	err = tapdisk_vbd_open_vdi(vbd, type, path, flags, -1, -1, NULL);
+	err = tapdisk_vbd_open_stack(vbd, storage, flags);
 	if (err)
 		goto out;
 
@@ -838,19 +759,19 @@
 	DPRINTF("%s: state: 0x%08x, new: 0x%02x, pending: 0x%02x, "
 		"failed: 0x%02x, completed: 0x%02x\n", 
 		vbd->name, vbd->state, new, pending, failed, completed);
-	DPRINTF("last activity: %010ld.%06ld, errors: 0x%04"PRIx64", "
+	DPRINTF("last activity: %010ld.%06lld, errors: 0x%04"PRIx64", "
 		"retries: 0x%04"PRIx64", received: 0x%08"PRIx64", "
-		"returned: 0x%08"PRIx64", kicked: 0x%08"PRIx64", "
-		"kicks in: 0x%08"PRIx64", out: 0x%08"PRIu64"\n",
-		vbd->ts.tv_sec, vbd->ts.tv_usec,
+		"returned: 0x%08"PRIx64", kicked: 0x%08"PRIx64"\n",
+		vbd->ts.tv_sec, (unsigned long long)vbd->ts.tv_usec,
 		vbd->errors, vbd->retries, vbd->received, vbd->returned,
-		vbd->kicked, vbd->kicks_in, vbd->kicks_out);
+		vbd->kicked);
 
 	tapdisk_vbd_close_vdi(vbd);
 	tapdisk_vbd_detach(vbd);
 	tapdisk_server_remove_vbd(vbd);
-	free(vbd->name);
-	free(vbd);
+	tapdisk_vbd_free(vbd);
+
+	tlog_print_errors();
 
 	return 0;
 }
@@ -895,14 +816,13 @@
 	tapdisk_vbd_queue_count(vbd, &new, &pending, &failed, &completed);
 
 	DBG(TLOG_WARN, "%s: state: 0x%08x, new: 0x%02x, pending: 0x%02x, "
-	    "failed: 0x%02x, completed: 0x%02x, last activity: %010ld.%06ld, "
-	    "errors: 0x%04llx, retries: 0x%04llx, received: 0x%08llx, "
-	    "returned: 0x%08llx, kicked: 0x%08llx, "
-	    "kicks in: 0x%08"PRIx64", out: 0x%08"PRIx64"\n",
+	    "failed: 0x%02x, completed: 0x%02x, last activity: %010ld.%06lld, "
+	    "errors: 0x%04"PRIx64", retries: 0x%04"PRIx64", received: 0x%08"PRIx64", "
+	    "returned: 0x%08"PRIx64", kicked: 0x%08"PRIx64"\n",
 	    vbd->name, vbd->state, new, pending, failed, completed,
-	    vbd->ts.tv_sec, vbd->ts.tv_usec, vbd->errors, vbd->retries,
-	    vbd->received, vbd->returned, vbd->kicked,
-	    vbd->kicks_in, vbd->kicks_out);
+	    vbd->ts.tv_sec, (unsigned long long)vbd->ts.tv_usec,
+	    vbd->errors, vbd->retries,
+	    vbd->received, vbd->returned, vbd->kicked);
 
 	tapdisk_vbd_for_each_image(vbd, image, tmp)
 		td_debug(image);
@@ -915,7 +835,7 @@
 		return;
 
 	tapdisk_vbd_debug(vbd);
-	tlog_precious();
+	tlog_flush();
 	td_flag_set(vbd->state, TD_VBD_LOG_DROPPED);
 }
 
@@ -937,7 +857,7 @@
 	return 0;
 }
 
-static int
+int
 tapdisk_vbd_queue_ready(td_vbd_t *vbd)
 {
 	return (!td_flag_test(vbd->state, TD_VBD_DEAD) &&
@@ -949,8 +869,7 @@
 int
 tapdisk_vbd_retry_needed(td_vbd_t *vbd)
 {
-	return !(list_empty(&vbd->failed_requests) &&
-		 list_empty(&vbd->new_requests));
+	return td_flag_test(vbd->state, TD_VBD_RETRY_NEEDED);
 }
 
 int
@@ -977,7 +896,6 @@
 {
 	td_flag_clear(vbd->state, TD_VBD_QUIESCED);
 	td_flag_clear(vbd->state, TD_VBD_QUIESCE_REQUESTED);
-	tapdisk_vbd_mark_progress(vbd);
 	return 0;
 }
 
@@ -1027,7 +945,7 @@
 	}
 
 	if (err)
-		td_flag_set(vbd->state, TD_VBD_CLOSED | TD_VBD_DEAD);
+		td_flag_set(vbd->state, TD_VBD_CLOSED);
 
 	return err;
 }
@@ -1037,8 +955,6 @@
 {
 	int err;
 
-	DBG(TLOG_DBG, "pause requested\n");
-
 	td_flag_set(vbd->state, TD_VBD_PAUSE_REQUESTED);
 
 	err = tapdisk_vbd_quiesce_queue(vbd);
@@ -1047,36 +963,17 @@
 
 	tapdisk_vbd_close_vdi(vbd);
 
-	DBG(TLOG_DBG, "pause completed\n");
-
 	td_flag_clear(vbd->state, TD_VBD_PAUSE_REQUESTED);
 	td_flag_set(vbd->state, TD_VBD_PAUSED);
 
 	return 0;
 }
 
-static void
-tapdisk_vbd_reset_request_timers(td_vbd_t *vbd)
-{
-	struct timeval now;
-	td_vbd_request_t *vreq, *tmp;
-
-	gettimeofday(&now, NULL);
-
-	tapdisk_vbd_for_each_request(vreq, tmp, &vbd->new_requests)
-		vreq->ts = now;
-
-	tapdisk_vbd_for_each_request(vreq, tmp, &vbd->failed_requests)
-		vreq->ts = now;
-}
-
 int
-tapdisk_vbd_resume(td_vbd_t *vbd, int type, const char *path)
+tapdisk_vbd_resume(td_vbd_t *vbd, const char *path, uint16_t drivertype)
 {
 	int i, err;
 
-	DBG(TLOG_DBG, "resume requested\n");
-
 	if (!td_flag_test(vbd->state, TD_VBD_PAUSED)) {
 		EPRINTF("resume request for unpaused vbd %s\n", vbd->name);
 		return -EINVAL;
@@ -1089,12 +986,11 @@
 			EPRINTF("copying new vbd %s name failed\n", path);
 			return -EINVAL;
 		}
-		vbd->type = type;
 	}
 
 	for (i = 0; i < TD_VBD_EIO_RETRIES; i++) {
 		err = __tapdisk_vbd_open_vdi(vbd, TD_OPEN_STRICT);
-		if (!err)
+		if (err != -EIO)
 			break;
 
 		sleep(TD_VBD_EIO_SLEEP);
@@ -1103,16 +999,11 @@
 	if (err)
 		return err;
 
-	DBG(TLOG_DBG, "resume completed\n");
-
 	tapdisk_vbd_start_queue(vbd);
 	td_flag_clear(vbd->state, TD_VBD_PAUSED);
 	td_flag_clear(vbd->state, TD_VBD_PAUSE_REQUESTED);
-	tapdisk_vbd_reset_request_timers(vbd);
 	tapdisk_vbd_check_state(vbd);
 
-	DBG(TLOG_DBG, "state checked\n");
-
 	return 0;
 }
 
@@ -1122,7 +1013,7 @@
 	int n;
 	td_ring_t *ring;
 
-	tapdisk_vbd_check_queue_state(vbd);
+	tapdisk_vbd_check_state(vbd);
 
 	ring = &vbd->ring;
 	if (!ring->sring)
@@ -1132,13 +1023,12 @@
 	if (!n)
 		return 0;
 
-	vbd->kicks_out++;
 	vbd->kicked += n;
 	RING_PUSH_RESPONSES(&ring->fe_ring);
 	ioctl(ring->fd, BLKTAP_IOCTL_KICK_FE, 0);
 
-	DBG(TLOG_INFO, "kicking %d: rec: 0x%08llx, ret: 0x%08llx, kicked: "
-	    "0x%08llx\n", n, vbd->received, vbd->returned, vbd->kicked);
+	DBG(TLOG_INFO, "kicking %d: rec: 0x%08"PRIx64", ret: 0x%08"PRIx64", kicked: "
+	    "0x%08"PRIx64"\n", n, vbd->received, vbd->returned, vbd->kicked);
 
 	return n;
 }
@@ -1179,52 +1069,19 @@
 	    (int)tmp.id, tmp.sector_number, vreq->status);
 
 	if (rsp->status != BLKIF_RSP_OKAY)
-		ERR(-vreq->error, "returning BLKIF_RSP %d", rsp->status);
+		ERR(EIO, "returning BLKIF_RSP %d", rsp->status);
 
 	vbd->returned++;
 	vbd->callback(vbd->argument, rsp);
 }
 
-static int
-tapdisk_vbd_request_ttl(td_vbd_request_t *vreq,
-			const struct timeval *now)
-{
-	struct timeval delta;
-	timersub(now, &vreq->ts, &delta);
-	return TD_VBD_REQUEST_TIMEOUT - delta.tv_sec;
-}
-
-static int
-__tapdisk_vbd_request_timeout(td_vbd_request_t *vreq,
-			      const struct timeval *now)
-{
-	int timeout;
-
-	timeout = tapdisk_vbd_request_ttl(vreq, now) < 0;
-	if (timeout)
-		DBG(TLOG_INFO, "req %"PRIu64" timed out, retried %d times\n",
-		    vreq->req.id, vreq->num_retries);
-
-	return timeout;
-}
-
-static int
-tapdisk_vbd_request_timeout(td_vbd_request_t *vreq)
-{
-	struct timeval now;
-	gettimeofday(&now, NULL);
-	return __tapdisk_vbd_request_timeout(vreq, &now);
-}
-
-static void
-tapdisk_vbd_check_queue_state(td_vbd_t *vbd)
+void
+tapdisk_vbd_check_state(td_vbd_t *vbd)
 {
 	td_vbd_request_t *vreq, *tmp;
-	struct timeval now;
 
-	gettimeofday(&now, NULL);
 	tapdisk_vbd_for_each_request(vreq, tmp, &vbd->failed_requests)
-		if (__tapdisk_vbd_request_timeout(vreq, &now))
+		if (vreq->num_retries >= TD_VBD_MAX_RETRIES)
 			tapdisk_vbd_complete_vbd_request(vbd, vreq);
 
 	if (!list_empty(&vbd->new_requests) ||
@@ -1236,12 +1093,6 @@
 		list_del(&vreq->next);
 		tapdisk_vbd_initialize_vreq(vreq);
 	}
-}
-
-void
-tapdisk_vbd_check_state(td_vbd_t *vbd)
-{
-	tapdisk_vbd_check_queue_state(vbd);
 
 	if (td_flag_test(vbd->state, TD_VBD_QUIESCE_REQUESTED))
 		tapdisk_vbd_quiesce_queue(vbd);
@@ -1256,21 +1107,18 @@
 void
 tapdisk_vbd_check_progress(td_vbd_t *vbd)
 {
-	time_t diff;
-	struct timeval now, delta;
+	int diff;
+	struct timeval now;
 
-	if (list_empty(&vbd->pending_requests) &&
-	    list_empty(&vbd->failed_requests) &&
-	    list_empty(&vbd->new_requests))
+	if (list_empty(&vbd->pending_requests))
 		return;
 
 	gettimeofday(&now, NULL);
-	timersub(&now, &vbd->ts, &delta);
-	diff = delta.tv_sec;
+	diff = now.tv_sec - vbd->ts.tv_sec;
 
-	if (diff >= TD_VBD_WATCHDOG_TIMEOUT && tapdisk_vbd_queue_ready(vbd)) {
+	if (diff >= TD_VBD_WATCHDOG_TIMEOUT) {
 		DBG(TLOG_WARN, "%s: watchdog timeout: pending requests "
-		    "idle for %ld seconds\n", vbd->name, diff);
+		    "idle for %d seconds\n", vbd->name, diff);
 		tapdisk_vbd_drop_log(vbd);
 		return;
 	}
@@ -1294,72 +1142,67 @@
 	if (!tapdisk_vbd_queue_ready(vbd))
 		return -EAGAIN;
 
-	return 0;
-}
+	if (!vbd->reopened) {
+		if (td_flag_test(vbd->state, TD_VBD_LOCKING)) {
+			err = tapdisk_vbd_lock(vbd);
+			if (err)
+				return err;
+		}
 
-static int
-tapdisk_vbd_request_should_retry(td_vbd_t *vbd, td_vbd_request_t *vreq)
-{
-	if (td_flag_test(vbd->state, TD_VBD_DEAD) ||
-	    td_flag_test(vbd->state, TD_VBD_SHUTDOWN_REQUESTED))
-		return 0;
+		image = tapdisk_vbd_first_image(vbd);
+		td_flag_set(image->flags, TD_OPEN_STRICT);
 
-	switch (abs(vreq->error)) {
-	case EPERM:
-	case ENOSYS:
-	case ESTALE:
-	case ENOSPC:
-		return 0;
+		if (tapdisk_vbd_close_and_reopen_image(vbd, image))
+			EPRINTF("reopening disks failed\n");
+		else {
+			DPRINTF("reopening disks succeeded\n");
+			vbd->reopened = 1;
+		}
 	}
 
-	if (tapdisk_vbd_request_timeout(vreq))
-		return 0;
-
-	return 1;
+	return 0;
 }
 
-static void
+void
 tapdisk_vbd_complete_vbd_request(td_vbd_t *vbd, td_vbd_request_t *vreq)
 {
 	if (!vreq->submitting && !vreq->secs_pending) {
 		if (vreq->status == BLKIF_RSP_ERROR &&
-		    tapdisk_vbd_request_should_retry(vbd, vreq))
+		    vreq->num_retries < TD_VBD_MAX_RETRIES &&
+		    !td_flag_test(vbd->state, TD_VBD_DEAD) &&
+		    !td_flag_test(vbd->state, TD_VBD_SHUTDOWN_REQUESTED))
 			tapdisk_vbd_move_request(vreq, &vbd->failed_requests);
 		else
 			tapdisk_vbd_move_request(vreq, &vbd->completed_requests);
 	}
 }
 
-static void
-FIXME_maybe_count_enospc_redirect(td_vbd_t *vbd, td_request_t treq)
+static uint64_t 
+tapdisk_vbd_breq_get_sector(blkif_request_t *breq, td_request_t treq)
 {
-	int write = treq.op == TD_OP_WRITE;
-	if (write &&
-	    treq.image == tapdisk_vbd_first_image(vbd) &&
-	    vbd->FIXME_enospc_redirect_count_enabled)
-		vbd->FIXME_enospc_redirect_count += treq.secs;
+    int seg, nsects; 
+    uint64_t sector_nr = breq->sector_number; 
+    
+    for(seg=0; seg < treq.sidx; seg++) {
+        nsects = breq->seg[seg].last_sect - breq->seg[seg].first_sect + 1;
+        sector_nr += nsects;
+    }
+
+    return sector_nr;
 }
 
 static void
 __tapdisk_vbd_complete_td_request(td_vbd_t *vbd, td_vbd_request_t *vreq,
 				  td_request_t treq, int res)
 {
-	td_image_t *image = treq.image, *prev, *tmp;
 	int err;
+    td_image_t *image = treq.image;
 
 	err = (res <= 0 ? res : -res);
 	vbd->secs_pending  -= treq.secs;
 	vreq->secs_pending -= treq.secs;
 
-	if (err != -EBUSY) {
-		int write = treq.op == TD_OP_WRITE;
-		td_sector_count_add(&image->stats.hits, treq.secs, write);
-		if (err)
-			td_sector_count_add(&image->stats.fail,
-					    treq.secs, write);
-
-		FIXME_maybe_count_enospc_redirect(vbd, treq);
-	}
+	vreq->blocked = treq.blocked;
 
 	if (err) {
 		vreq->status = BLKIF_RSP_ERROR;
@@ -1371,6 +1214,22 @@
 			    (treq.op == TD_OP_WRITE ? "write" : "read"),
 			    treq.secs, treq.sec);
 		}
+	} else {
+#ifdef MEMSHR
+		if (treq.op == TD_OP_READ
+		   && td_flag_test(image->flags, TD_OPEN_RDONLY)) {
+			share_tuple_t hnd = treq.memshr_hnd;
+			uint16_t uid  = image->memshr_id;
+			blkif_request_t *breq = &vreq->req;
+			uint64_t sec  = tapdisk_vbd_breq_get_sector(breq, treq);
+			int secs = breq->seg[treq.sidx].last_sect -
+			    breq->seg[treq.sidx].first_sect + 1;
+
+			if (hnd.handle != 0)
+				memshr_vbd_complete_ro_request(hnd, uid,
+								sec, secs);
+		}
+#endif
 	}
 
 	tapdisk_vbd_complete_vbd_request(vbd, vreq);
@@ -1423,7 +1282,28 @@
 		break;
 
 	case TD_OP_READ:
-		td_queue_read(parent, treq);
+#ifdef MEMSHR
+		if(td_flag_test(parent->flags, TD_OPEN_RDONLY)) {
+			int ret, seg = treq.sidx;
+			blkif_request_t *breq = &vreq->req;
+        
+			ret = memshr_vbd_issue_ro_request(treq.buf,
+			      breq->seg[seg].gref,
+			      parent->memshr_id,
+			      treq.sec,
+			      treq.secs,
+			      &treq.memshr_hnd);
+			if(ret == 0) {
+				/* Reset memshr handle. This'll prevent
+				 * memshr_vbd_complete_ro_request being called
+				 */
+				treq.memshr_hnd.handle = 0;
+				td_complete_request(treq, 0);
+			} else
+				td_queue_read(parent, treq);
+		} else
+#endif
+			td_queue_read(parent, treq);
 		break;
 	}
 
@@ -1444,48 +1324,27 @@
 	vbd   = (td_vbd_t *)image->private;
 	vreq  = (td_vbd_request_t *)treq.private;
 
-	tapdisk_vbd_mark_progress(vbd);
+	gettimeofday(&vbd->ts, NULL);
 
 	if (tapdisk_vbd_queue_ready(vbd))
 		__tapdisk_vbd_reissue_td_request(vbd, image, treq);
 	else
-		__tapdisk_vbd_complete_td_request(vbd, vreq, treq, -EBUSY);
+		__tapdisk_vbd_complete_td_request(vbd, vreq, treq, -EIO);
 }
 
 static void
 tapdisk_vbd_complete_td_request(td_request_t treq, int res)
 {
 	td_vbd_t *vbd;
-	td_image_t *image, *leaf;
+	td_image_t *image;
 	td_vbd_request_t *vreq;
 
 	image = treq.image;
 	vbd   = (td_vbd_t *)image->private;
 	vreq  = (td_vbd_request_t *)treq.private;
 
-	tapdisk_vbd_mark_progress(vbd);
-
-	if (abs(res) == ENOSPC && td_flag_test(image->flags,
-				TD_IGNORE_ENOSPC)) {
-		res = 0;
-		leaf = tapdisk_vbd_first_image(vbd);
-		if (vbd->secondary_mode == TD_VBD_SECONDARY_MIRROR) {
-			DPRINTF("ENOSPC: disabling mirroring\n");
-			list_del_init(&leaf->next);
-			vbd->retired = leaf;
-		} else if (vbd->secondary_mode == TD_VBD_SECONDARY_STANDBY) {
-			DPRINTF("ENOSPC: failing over to secondary image\n");
-			list_add(&vbd->secondary->next, leaf->next.prev);
-			vbd->FIXME_enospc_redirect_count_enabled = 1;
-		}
-		if (vbd->secondary_mode != TD_VBD_SECONDARY_DISABLED) {
-			vbd->secondary = NULL;
-			vbd->secondary_mode = TD_VBD_SECONDARY_DISABLED;
-			signal_enospc(vbd);
-		}
-	}
-
-	DBG(TLOG_DBG, "%s: req %d seg %d sec 0x%08llx "
+	gettimeofday(&vbd->ts, NULL);
+	DBG(TLOG_DBG, "%s: req %d seg %d sec 0x%08"PRIx64" "
 	    "secs 0x%04x buf %p op %d res %d\n", image->name,
 	    (int)treq.id, treq.sidx, treq.sec, treq.secs,
 	    treq.buf, (int)vreq->req.operation, res);
@@ -1493,38 +1352,6 @@
 	__tapdisk_vbd_complete_td_request(vbd, vreq, treq, res);
 }
 
-static inline void
-queue_mirror_req(td_vbd_t *vbd, td_request_t clone)
-{
-	clone.image = vbd->secondary;
-	td_queue_write(vbd->secondary, clone);
-}
-
-static inline void
-tapdisk_vbd_submit_request(td_vbd_t *vbd, blkif_request_t *req,
-		td_request_t treq)
-{
-	switch (req->operation)	{
-	case BLKIF_OP_WRITE:
-		treq.op = TD_OP_WRITE;
-		/* it's important to queue the mirror request before queuing 
-		 * the main one. If the main image runs into ENOSPC, the 
-		 * mirroring could be disabled before td_queue_write returns, 
-		 * so if the mirror request was queued after (which would then 
-		 * not happen), we'd lose that write and cause the process to 
-		 * hang with unacknowledged writes */
-		if (vbd->secondary_mode == TD_VBD_SECONDARY_MIRROR)
-			queue_mirror_req(vbd, treq);
-		td_queue_write(treq.image, treq);
-		break;
-
-	case BLKIF_OP_READ:
-		treq.op = TD_OP_READ;
-		td_queue_read(treq.image, treq);
-		break;
-	}
-}
-
 static int
 tapdisk_vbd_issue_request(td_vbd_t *vbd, td_vbd_request_t *vreq)
 {
@@ -1535,7 +1362,6 @@
 	uint64_t sector_nr;
 	blkif_request_t *req;
 	int i, err, id, nsects;
-	int treq_started = 0;
 
 	req       = &vreq->req;
 	id        = req->id;
@@ -1544,68 +1370,54 @@
 	image     = tapdisk_vbd_first_image(vbd);
 
 	vreq->submitting = 1;
-
-	tapdisk_vbd_mark_progress(vbd);
-	vreq->last_try = vbd->ts;
-
+	gettimeofday(&vbd->ts, NULL);
+	gettimeofday(&vreq->last_try, NULL);
 	tapdisk_vbd_move_request(vreq, &vbd->pending_requests);
 
+#if 0
 	err = tapdisk_vbd_check_queue(vbd);
-	if (err) {
-		vreq->error = err;
+	if (err)
 		goto fail;
-	}
+#endif
 
 	err = tapdisk_image_check_ring_request(image, req);
-	if (err) {
-		vreq->error = err;
+	if (err)
 		goto fail;
-	}
 
-	memset(&treq, 0, sizeof(td_request_t));
 	for (i = 0; i < req->nr_segments; i++) {
 		nsects = req->seg[i].last_sect - req->seg[i].first_sect + 1;
 		page   = (char *)MMAP_VADDR(ring->vstart, 
 					   (unsigned long)req->id, i);
 		page  += (req->seg[i].first_sect << SECTOR_SHIFT);
 
-		if (treq_started) {
-			if (page == treq.buf + (treq.secs << SECTOR_SHIFT)) {
-				treq.secs += nsects;
-			} else {
-				tapdisk_vbd_submit_request(vbd, req, treq);
-				treq_started = 0;
-			}
-		}
-
-		if (!treq_started) {
-			treq.id      = id;
-			treq.sidx    = i;
-			treq.buf     = page;
-			treq.sec     = sector_nr;
-			treq.secs    = nsects;
-			treq.image   = image;
-			treq.cb      = tapdisk_vbd_complete_td_request;
-			treq.cb_data = NULL;
-			treq.private = vreq;
-			treq_started = 1;
-		}
+		treq.id             = id;
+		treq.sidx           = i;
+		treq.blocked        = 0;
+		treq.buf            = page;
+		treq.sec            = sector_nr;
+		treq.secs           = nsects;
+		treq.image          = image;
+		treq.cb             = tapdisk_vbd_complete_td_request;
+		treq.cb_data        = NULL;
+		treq.private        = vreq;
 
-		DBG(TLOG_DBG, "%s: req %d seg %d sec 0x%08llx secs 0x%04x "
+		DBG(TLOG_DBG, "%s: req %d seg %d sec 0x%08"PRIx64" secs 0x%04x "
 		    "buf %p op %d\n", image->name, id, i, treq.sec, treq.secs,
 		    treq.buf, (int)req->operation);
 
 		vreq->secs_pending += nsects;
 		vbd->secs_pending  += nsects;
-		if (vbd->secondary_mode == TD_VBD_SECONDARY_MIRROR &&
-				req->operation == BLKIF_OP_WRITE) {
-			vreq->secs_pending += nsects;
-			vbd->secs_pending  += nsects;
-		}
 
-		if (i == req->nr_segments - 1) {
-			tapdisk_vbd_submit_request(vbd, req, treq);
-			treq_started = 0;
+		switch (req->operation)	{
+		case BLKIF_OP_WRITE:
+			treq.op = TD_OP_WRITE;
+			td_queue_write(image, treq);
+			break;
+
+		case BLKIF_OP_READ:
+			treq.op = TD_OP_READ;
+			td_queue_read(image, treq);
+			break;
 		}
 
 		sector_nr += nsects;
@@ -1628,12 +1440,6 @@
 }
 
 static int
-tapdisk_vbd_request_completed(td_vbd_t *vbd, td_vbd_request_t *vreq)
-{
-	return vreq->list_head == &vbd->completed_requests;
-}
-
-static int
 tapdisk_vbd_reissue_failed_requests(td_vbd_t *vbd)
 {
 	int err;
@@ -1647,17 +1453,31 @@
 		if (vreq->secs_pending)
 			continue;
 
-		if (td_flag_test(vbd->state, TD_VBD_SHUTDOWN_REQUESTED)) {
-			tapdisk_vbd_complete_vbd_request(vbd, vreq);
-			continue;
-		}
+		if (td_flag_test(vbd->state, TD_VBD_SHUTDOWN_REQUESTED))
+			goto fail;
 
 		if (vreq->error != -EBUSY &&
 		    now.tv_sec - vreq->last_try.tv_sec < TD_VBD_RETRY_INTERVAL)
 			continue;
 
-		vbd->retries++;
-		vreq->num_retries++;
+		if (vreq->num_retries >= TD_VBD_MAX_RETRIES) {
+		fail:
+			DBG(TLOG_INFO, "req %"PRIu64"retried %d times\n",
+			    vreq->req.id, vreq->num_retries);
+			tapdisk_vbd_complete_vbd_request(vbd, vreq);
+			continue;
+		}
+
+		/*
+		 * never fail due to too many retries if we are blocked on a 
+		 * dependency
+		 */
+		if (vreq->blocked) {
+			vreq->blocked = 0;
+		} else {
+			vbd->retries++;
+			vreq->num_retries++;
+		}
 		vreq->error  = 0;
 		vreq->status = BLKIF_RSP_OKAY;
 		DBG(TLOG_DBG, "retry #%d of req %"PRIu64", "
@@ -1666,30 +1486,16 @@
 		    vreq->req.nr_segments);
 
 		err = tapdisk_vbd_issue_request(vbd, vreq);
-		/*
-		 * if this request failed, but was not completed,
-		 * we'll back off for a while.
-		 */
-		if (err && !tapdisk_vbd_request_completed(vbd, vreq))
+		if (err)
 			break;
 	}
 
-	return 0;
-}
-
-static void
-tapdisk_vbd_count_new_request(td_vbd_t *vbd, td_vbd_request_t *vreq)
-{
-	blkif_request_t *req = &vreq->req;
-	struct blkif_request_segment *seg;
-	int write;
-
-	write = req->operation == BLKIF_OP_WRITE;
+	if (list_empty(&vbd->failed_requests))
+		td_flag_clear(vbd->state, TD_VBD_RETRY_NEEDED);
+	else
+		td_flag_set(vbd->state, TD_VBD_RETRY_NEEDED);
 
-	for (seg = &req->seg[0]; seg < &req->seg[req->nr_segments]; seg++) {
-		int secs = seg->last_sect - seg->first_sect + 1;
-		td_sector_count_add(&vbd->secs, secs, write);
-	}
+	return err;
 }
 
 static int
@@ -1700,14 +1506,8 @@
 
 	tapdisk_vbd_for_each_request(vreq, tmp, &vbd->new_requests) {
 		err = tapdisk_vbd_issue_request(vbd, vreq);
-		/*
-		 * if this request failed, but was not completed,
-		 * we'll back off for a while.
-		 */
-		if (err && !tapdisk_vbd_request_completed(vbd, vreq))
+		if (err)
 			return err;
-
-		tapdisk_vbd_count_new_request(vbd, vreq);
 	}
 
 	return 0;
@@ -1739,8 +1539,7 @@
 	if (td_flag_test(vbd->state, TD_VBD_DEAD))
 		return tapdisk_vbd_kill_requests(vbd);
 
-	if (td_flag_test(vbd->state, TD_VBD_QUIESCED) ||
-	    td_flag_test(vbd->state, TD_VBD_QUIESCE_REQUESTED))
+	if (!tapdisk_vbd_queue_ready(vbd))
 		return -EAGAIN;
 
 	err = tapdisk_vbd_reissue_failed_requests(vbd);
@@ -1758,14 +1557,11 @@
 	td_ring_t *ring;
 	blkif_request_t *req;
 	td_vbd_request_t *vreq;
-	struct timeval now;
 
 	ring = &vbd->ring;
 	if (!ring->sring)
 		return;
 
-	gettimeofday(&now, NULL);
-
 	rp   = ring->fe_ring.sring->req_prod;
 	xen_rmb();
 
@@ -1782,7 +1578,6 @@
 		memcpy(&vreq->req, req, sizeof(blkif_request_t));
 		vbd->received++;
 		vreq->vbd = vbd;
-		vreq->ts  = now;
 
 		tapdisk_vbd_move_request(vreq, &vbd->new_requests);
 
@@ -1839,9 +1634,8 @@
 		return err;
 	}
 
-	type = tapdisk_disktype_parse_params(message, &path);
-	if (type < 0) {
-		err = type;
+	err = tapdisk_parse_disk_type(message, &path, &type);
+	if (err) {
 		EPRINTF("%s: invalid resume string %s\n", vbd->name, message);
 		goto out;
 	}
@@ -1853,10 +1647,17 @@
 		err = -ENOMEM;
 		goto out;
 	}
-	vbd->type = type;
 
 	tapdisk_vbd_start_queue(vbd);
-	err = __tapdisk_vbd_open_vdi(vbd, TD_OPEN_STRICT);
+
+	for (i = 0; i < TD_VBD_EIO_RETRIES; i++) {
+		err = __tapdisk_vbd_open_vdi(vbd, TD_OPEN_STRICT);
+		if (err != -EIO)
+			break;
+
+		sleep(TD_VBD_EIO_SLEEP);
+	}
+
 out:
 	if (!err) {
 		image_t image;
@@ -1872,6 +1673,7 @@
 		ioctl(vbd->ring.fd, BLKTAP2_IOCTL_SET_PARAMS, &params);
 		td_flag_clear(vbd->state, TD_VBD_PAUSED);
 	}
+
 	ioctl(vbd->ring.fd, BLKTAP2_IOCTL_RESUME, err);
 	return err;
 }
@@ -1907,7 +1709,6 @@
 
 	vbd = (td_vbd_t *)private;
 
-	vbd->kicks_in++;
 	tapdisk_vbd_pull_ring_requests(vbd);
 	tapdisk_vbd_issue_requests(vbd);
 
@@ -1915,28 +1716,8 @@
 	tapdisk_vbd_check_ring_message(vbd);
 }
 
-void
-tapdisk_vbd_stats(td_vbd_t *vbd, td_stats_t *st)
+td_image_t *
+tapdisk_vbd_first_image(td_vbd_t *vbd)
 {
-	td_image_t *image, *next;
-
-	tapdisk_stats_enter(st, '{');
-	tapdisk_stats_field(st, "name", "s", vbd->name);
-	tapdisk_stats_field(st, "minor", "d", vbd->minor);
-
-	tapdisk_stats_field(st, "secs", "[");
-	tapdisk_stats_val(st, "llu", vbd->secs.rd);
-	tapdisk_stats_val(st, "llu", vbd->secs.wr);
-	tapdisk_stats_leave(st, ']');
-
-	tapdisk_stats_field(st, "images", "[");
-	tapdisk_vbd_for_each_image(vbd, image, next)
-		tapdisk_image_stats(image, st);
-	tapdisk_stats_leave(st, ']');
-
-	tapdisk_stats_field(st,
-			    "FIXME_enospc_redirect_count",
-			    "llu", vbd->FIXME_enospc_redirect_count);
-
-	tapdisk_stats_leave(st, '}');
+	return list_entry(vbd->images.next, td_image_t, next);
 }
diff -Nur blktap2_oxt//drivers/tapdisk-vbd.h blktap2_xen//drivers/tapdisk-vbd.h
--- blktap2_oxt//drivers/tapdisk-vbd.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/tapdisk-vbd.h	2015-03-19 11:08:36.000000000 -0400
@@ -24,12 +24,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
+*/
 #ifndef _TAPDISK_VBD_H_
 #define _TAPDISK_VBD_H_
 
@@ -41,7 +36,6 @@
 #include "scheduler.h"
 #include "tapdisk-image.h"
 
-#define TD_VBD_REQUEST_TIMEOUT      120
 #define TD_VBD_MAX_RETRIES          100
 #define TD_VBD_RETRY_INTERVAL       1
 
@@ -53,14 +47,12 @@
 #define TD_VBD_PAUSED               0x0020
 #define TD_VBD_SHUTDOWN_REQUESTED   0x0040
 #define TD_VBD_LOCKING              0x0080
-#define TD_VBD_LOG_DROPPED          0x0100
-
-#define TD_VBD_SECONDARY_DISABLED   0 
-#define TD_VBD_SECONDARY_MIRROR     1
-#define TD_VBD_SECONDARY_STANDBY    2
+#define TD_VBD_RETRY_NEEDED         0x0100
+#define TD_VBD_LOG_DROPPED          0x0200
 
 typedef struct td_ring              td_ring_t;
 typedef struct td_vbd_request       td_vbd_request_t;
+typedef struct td_vbd_driver_info   td_vbd_driver_info_t;
 typedef struct td_vbd_handle        td_vbd_t;
 typedef void (*td_vbd_cb_t)        (void *, blkif_response_t *);
 
@@ -77,15 +69,20 @@
 	int16_t                     status;
 
 	int                         error;
+	int                         blocked; /* blocked on a dependency */
 	int                         submitting;
 	int                         secs_pending;
 	int                         num_retries;
-	struct timeval		    ts;
 	struct timeval              last_try;
 
 	td_vbd_t                   *vbd;
 	struct list_head            next;
-	struct list_head           *list_head;
+};
+
+struct td_vbd_driver_info {
+	char                       *params;
+	int                         type;
+	struct list_head            next;
 };
 
 struct td_vbd_handle {
@@ -93,29 +90,18 @@
 
 	td_uuid_t                   uuid;
 	int                         minor;
-	int                         type;
 
+	struct list_head            driver_stack;
+
+	int                         storage;
+
+	uint8_t                     reopened;
+	uint8_t                     reactivated;
 	td_flag_t                   flags;
 	td_flag_t                   state;
 
 	struct list_head            images;
 
-	int                         parent_devnum;
-	char                       *secondary_name;
-	int                         secondary_type;
-	td_image_t                 *secondary;
-	uint8_t                     secondary_mode;
-
-	int                         FIXME_enospc_redirect_count_enabled;
-	uint64_t                    FIXME_enospc_redirect_count;
-
-	/* when we encounter ENOSPC on the primary leaf image in mirror mode, 
-	 * we need to remove it from the VBD chain so that writes start going 
-	 * on the secondary leaf. However, we cannot free the image at that 
-	 * time since it might still have in-flight treqs referencing it.  
-	 * Therefore, we move it into 'retired' until shutdown. */
-	td_image_t                 *retired;
-
 	struct list_head            new_requests;
 	struct list_head            pending_requests;
 	struct list_head            failed_requests;
@@ -139,10 +125,6 @@
 	uint64_t                    secs_pending;
 	uint64_t                    retries;
 	uint64_t                    errors;
-	td_sector_count_t           secs;
-
-	uint64_t                    kicks_in;
-	uint64_t                    kicks_out;
 };
 
 #define tapdisk_vbd_for_each_request(vreq, tmp, list)	                \
@@ -157,7 +139,6 @@
 	list_del(&vreq->next);
 	INIT_LIST_HEAD(&vreq->next);
 	list_add_tail(&vreq->next, dest);
-	vreq->list_head = dest;
 }
 
 static inline void
@@ -172,11 +153,8 @@
 	return list_is_last(&image->next, &vbd->images);
 }
 
-static inline td_image_t *
-tapdisk_vbd_first_image(td_vbd_t *vbd)
-{
-	return list_entry(vbd->images.next, td_image_t, next);
-}
+td_image_t *
+tapdisk_vbd_first_image(td_vbd_t *vbd);
 
 static inline td_image_t *
 tapdisk_vbd_last_image(td_vbd_t *vbd)
@@ -191,14 +169,18 @@
 }
 
 td_vbd_t *tapdisk_vbd_create(td_uuid_t);
-int tapdisk_vbd_initialize(int, int, td_uuid_t);
+int tapdisk_vbd_initialize(td_uuid_t);
 void tapdisk_vbd_set_callback(td_vbd_t *, td_vbd_cb_t, void *);
-int tapdisk_vbd_open(td_vbd_t *, int, const char *,
-		     int, const char *, td_flag_t);
+int tapdisk_vbd_parse_stack(td_vbd_t *vbd, const char *path);
+int tapdisk_vbd_open(td_vbd_t *, const char *, uint16_t,
+		     uint16_t, int, const char *, td_flag_t);
 int tapdisk_vbd_close(td_vbd_t *);
+void tapdisk_vbd_free(td_vbd_t *);
+void tapdisk_vbd_free_stack(td_vbd_t *);
 
-int tapdisk_vbd_open_vdi(td_vbd_t *, int, const char *, td_flag_t,
-			 int, int, const char *);
+int tapdisk_vbd_open_stack(td_vbd_t *, uint16_t, td_flag_t);
+int tapdisk_vbd_open_vdi(td_vbd_t *, const char *,
+			 uint16_t, uint16_t, td_flag_t);
 void tapdisk_vbd_close_vdi(td_vbd_t *);
 
 int tapdisk_vbd_attach(td_vbd_t *, const char *, int);
@@ -207,17 +189,19 @@
 void tapdisk_vbd_forward_request(td_request_t);
 
 int tapdisk_vbd_get_image_info(td_vbd_t *, image_t *);
+int tapdisk_vbd_queue_ready(td_vbd_t *);
 int tapdisk_vbd_retry_needed(td_vbd_t *);
 int tapdisk_vbd_quiesce_queue(td_vbd_t *);
 int tapdisk_vbd_start_queue(td_vbd_t *);
 int tapdisk_vbd_issue_requests(td_vbd_t *);
 int tapdisk_vbd_kill_queue(td_vbd_t *);
 int tapdisk_vbd_pause(td_vbd_t *);
-int tapdisk_vbd_resume(td_vbd_t *, int, const char *);
+int tapdisk_vbd_resume(td_vbd_t *, const char *, uint16_t);
 int tapdisk_vbd_kick(td_vbd_t *);
 void tapdisk_vbd_check_state(td_vbd_t *);
 void tapdisk_vbd_check_progress(td_vbd_t *);
 void tapdisk_vbd_debug(td_vbd_t *);
-void tapdisk_vbd_stats(td_vbd_t *, td_stats_t *);
+
+void tapdisk_vbd_complete_vbd_request(td_vbd_t *, td_vbd_request_t *);
 
 #endif
diff -Nur blktap2_oxt//drivers/td.c blktap2_xen//drivers/td.c
--- blktap2_oxt//drivers/td.c	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//drivers/td.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,5 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* 
+ * Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,7 +24,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
+*/
 
 #include <errno.h>
 #include <fcntl.h>
@@ -454,7 +452,7 @@
 		}
 
 		if (size)
-			printf("%llu\n", vhd.footer.curr_size >> 20);
+			printf("%"PRIu64"\n", vhd.footer.curr_size >> 20);
 
 		if (parent) {
 			if (vhd.footer.type != HD_TYPE_DIFF)
diff -Nur blktap2_oxt//drivers/xmsnap blktap2_xen//drivers/xmsnap
--- blktap2_oxt//drivers/xmsnap	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//drivers/xmsnap	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,78 @@
+#!/bin/bash
+
+usage () { echo "USAGE: xmsnap <VM ID> <Backing File>"; }
+
+#
+# Check Usage
+#
+if [ -n "$1" ]
+then
+	vmid=$1
+else
+	usage
+	exit 1
+fi
+
+if [ -n "$2" ]
+then
+	target=$2
+else
+	usage
+	exit 1
+fi
+
+if [ -e "$target" ]
+then
+    echo "Creating snapshot of file $target for VM $vmid."
+else
+    usage
+    echo "File $target not found."
+    exit 1
+fi
+
+#
+# Find the snapshot name
+#
+directory=`dirname "$target"`
+target=`basename "$target"`
+
+let maxidx=0
+if [ -e $directory/${target}.snap1 ]
+then
+	for idx in $(ls $directory/${target}.snap*)
+	do
+	    let idx=${idx#$directory/${target}.snap}
+	    if [ "$idx" -gt "$maxidx" ]
+	    then
+		let maxidx=$idx
+	    fi
+	done
+fi
+
+snap=${target}.snap`expr $maxidx + 1`
+
+#
+# Pause VM
+#
+xm pause $vmid
+if [ "$?" -ne "0" ]; then
+  exit 1
+fi
+
+
+#
+# Snap and reposition the files
+#
+mv $directory/$target $directory/$snap
+if [ "$?" -ne "0" ]; then
+  exit 1
+fi
+
+qcow-create 0 $directory/$target $directory/$snap
+
+#
+# Unpause
+#
+xm unpause $vmid
+
+exit
\ No newline at end of file
diff -Nur blktap2_oxt//include/atomicio.h blktap2_xen//include/atomicio.h
--- blktap2_oxt//include/atomicio.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/atomicio.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,8 +1,4 @@
 /*	$OpenBSD: atomicio.h,v 1.6 2005/05/24 17:32:43 avsm Exp $	*/
-/*
- * Copyright (c) 2008 Citrix Systems, Inc.
- */
-
 
 /*
  * Copyright (c) 1995,1999 Theo de Raadt.  All rights reserved.
diff -Nur blktap2_oxt//include/blktap2.h blktap2_xen//include/blktap2.h
--- blktap2_oxt//include/blktap2.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/blktap2.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,16 +25,9 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
 #ifndef _BLKTAP_2_H_
 #define _BLKTAP_2_H_
 
-#define MISC_MAJOR_NUMBER              10
-
 #define BLKTAP2_MAX_MESSAGE_LEN        256
 
 #define BLKTAP2_RING_MESSAGE_PAUSE     1
@@ -49,7 +42,6 @@
 #define BLKTAP2_IOCTL_PAUSE            204
 #define BLKTAP2_IOCTL_REOPEN           205
 #define BLKTAP2_IOCTL_RESUME           206
-#define BLKTAP2_IOCTL_REMOVE_DEVICE    207
 
 #define BLKTAP2_SYSFS_DIR              "/sys/class/blktap2"
 #define BLKTAP2_CONTROL_NAME           "blktap-control"
@@ -59,7 +51,6 @@
 #define BLKTAP2_CONTROL_DEVICE         BLKTAP2_DIRECTORY"/control"
 #define BLKTAP2_RING_DEVICE            BLKTAP2_DIRECTORY"/blktap"
 #define BLKTAP2_IO_DEVICE              BLKTAP2_DIRECTORY"/tapdev"
-#define BLKTAP2_ENOSPC_SIGNAL_FILE     "/var/run/tapdisk-enospc"
 
 struct blktap2_handle {
 	unsigned int                   ring;
diff -Nur blktap2_oxt//include/blktap-int.h blktap2_xen//include/blktap-int.h
--- blktap2_oxt//include/blktap-int.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/blktap-int.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,46 +0,0 @@
-/* taplib-int.h
- *
- * Blktap library userspace code.
- *
- * Copyright (c) 2007, XenSource Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-
-#ifndef __BLKTAP_INT_H__
-# define __BLKTAP_INT_H__
-
-#if 1
-#define DPRINTF(_f, _a...) syslog(LOG_INFO, _f, ##_a)
-#else
-#define DPRINTF(_f, _a...) ((void)0)
-#endif
-
-#endif /* !__BLKTAP_INT_H__ */
diff -Nur blktap2_oxt//include/blktaplib.h blktap2_xen//include/blktaplib.h
--- blktap2_oxt//include/blktaplib.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/blktaplib.h	2015-03-19 11:08:36.000000000 -0400
@@ -29,11 +29,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-
 #ifndef __BLKTAPLIB_H__
 #define __BLKTAPLIB_H__
 
@@ -42,18 +37,7 @@
 #include <xenctrl.h>
 #include <xen/io/blkif.h>
 
-#ifdef TAPDISK
-#if 1
-#define DPRINTF(_f, _a...) syslog(LOG_INFO, _f, ##_a)
-#else
-#define DPRINTF(_f, _a...) ((void)0)
-#endif
-
-#define EPRINTF(_f, _a...) syslog(LOG_ERR, "tap-err:%s: " _f, __func__, ##_a)
-#define PERROR(_f, _a...)  EPRINTF(_f ": %s", ##_a, strerror(errno))
-#endif
-
-#define BLK_RING_SIZE __RING_SIZE((blkif_sring_t *)0, XC_PAGE_SIZE)
+#define BLK_RING_SIZE __CONST_RING_SIZE(blkif, XC_PAGE_SIZE)
 
 /* size of the extra VMA area to map in attached pages. */
 #define BLKTAP_VMA_PAGES BLK_RING_SIZE
@@ -228,8 +212,13 @@
 #define CTLMSG_RESUME          17
 #define CTLMSG_RESUME_RSP      18
 
+#define TAPDISK_STORAGE_TYPE_NFS       1
+#define TAPDISK_STORAGE_TYPE_EXT       2
+#define TAPDISK_STORAGE_TYPE_LVM       3
+#define TAPDISK_STORAGE_TYPE_DEFAULT   TAPDISK_STORAGE_TYPE_EXT
+
 /* Abitrary values, must match the underlying driver... */
-#define MAX_TAP_DEV 1024
+#define MAX_TAP_DEV 256
 
 /* Accessing attached data page mappings */
 #define MMAP_PAGES                                                    \
diff -Nur blktap2_oxt//include/libvhd.h blktap2_xen//include/libvhd.h
--- blktap2_oxt//include/libvhd.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/libvhd.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,27 +23,42 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #ifndef _VHD_LIB_H_
 #define _VHD_LIB_H_
 
-#include <stdio.h>
 #include <string.h>
+#if defined(__linux__)
 #include <endian.h>
 #include <byteswap.h>
-#include <uuid/uuid.h>
+#elif defined(__NetBSD__)
+#include <sys/endian.h>
+#include <sys/bswap.h>
+#endif
 
+#include "vhd-uuid.h"
 #include "vhd.h"
-#include "list.h"
+
+#ifndef O_LARGEFILE
+#define O_LARGEFILE	0
+#endif
 
 #if BYTE_ORDER == LITTLE_ENDIAN
+#if defined(__linux__)
   #define BE16_IN(foo)             (*(foo)) = bswap_16(*(foo))
   #define BE32_IN(foo)             (*(foo)) = bswap_32(*(foo))
   #define BE64_IN(foo)             (*(foo)) = bswap_64(*(foo))
   #define BE16_OUT(foo)            (*(foo)) = bswap_16(*(foo))
   #define BE32_OUT(foo)            (*(foo)) = bswap_32(*(foo))
   #define BE64_OUT(foo)            (*(foo)) = bswap_64(*(foo))
+#elif defined(__NetBSD__)
+  #define BE16_IN(foo)             (*(foo)) = bswap16(*(foo))
+  #define BE32_IN(foo)             (*(foo)) = bswap32(*(foo))
+  #define BE64_IN(foo)             (*(foo)) = bswap64(*(foo))
+  #define BE16_OUT(foo)            (*(foo)) = bswap16(*(foo))
+  #define BE32_OUT(foo)            (*(foo)) = bswap32(*(foo))
+  #define BE64_OUT(foo)            (*(foo)) = bswap64(*(foo))
+#endif
 #else
   #define BE16_IN(foo)
   #define BE32_IN(foo)
@@ -56,8 +68,6 @@
   #define BE64_OUT(foo)
 #endif
 
-#define BIT_MASK                   0x80
-
 #define MIN(a, b)                  (((a) < (b)) ? (a) : (b))
 #define MAX(a, b)                  (((a) > (b)) ? (a) : (b))
 
@@ -75,12 +85,8 @@
 #define VHD_OPEN_FAST              0x00004
 #define VHD_OPEN_STRICT            0x00008
 #define VHD_OPEN_IGNORE_DISABLED   0x00010
-#define VHD_OPEN_CACHED            0x00020
-#define VHD_OPEN_IO_WRITE_SPARSE   0x00040
-#define VHD_OPEN_LOCKED            0x00080
 
-#define VHD_FLAG_CREAT_FILE_SIZE_FIXED   0x00001
-#define VHD_FLAG_CREAT_PARENT_RAW        0x00002
+#define VHD_FLAG_CREAT_PARENT_RAW        0x00001
 
 #define vhd_flag_set(word, flag)         ((word) |= (flag))
 #define vhd_flag_clear(word, flag)       ((word) &= ~(flag))
@@ -118,20 +124,9 @@
 typedef struct vhd_batmap          vhd_batmap_t;
 typedef struct dd_batmap_hdr       vhd_batmap_header_t;
 typedef struct prt_loc             vhd_parent_locator_t;
-typedef struct vhd_devops          vhd_devops_t;
 typedef struct vhd_context         vhd_context_t;
 typedef uint32_t                   vhd_flag_creat_t;
 
-struct vhd_devops {
-	off64_t (*position)        (vhd_context_t *);
-	int (*seek)                (vhd_context_t *, off64_t, int);
-	int (*read)                (vhd_context_t *, void *, size_t);
-	int (*write)               (vhd_context_t *, void *, size_t);
-	int (*pread)               (vhd_context_t *, void *, size_t, off64_t);
-	int (*pwrite)              (vhd_context_t *, void *, size_t, off64_t);
-	void (*close)              (vhd_context_t *);
-};
-
 struct vhd_bat {
 	uint32_t                   spb;
 	uint32_t                   entries;
@@ -143,8 +138,6 @@
 	char                      *map;
 };
 
-struct crypto_blkcipher;
-
 struct vhd_context {
 	int                        fd;
 	char                      *file;
@@ -158,34 +151,8 @@
 	vhd_footer_t               footer;
 	vhd_bat_t                  bat;
 	vhd_batmap_t               batmap;
-
-	struct list_head           next;
-
-	vhd_devops_t              *devops;
-
-	struct crypto_blkcipher   *xts_tfm;
-
-	uint64_t		  offset;
 };
 
-static inline int
-test_bit (volatile char *addr, int nr)
-{
-	return ((addr[nr >> 3] << (nr & 7)) & BIT_MASK) != 0;
-}
-
-static inline void
-set_bit (volatile char *addr, int nr)
-{
-	addr[nr >> 3] |= (BIT_MASK >> (nr & 7));
-}
-
-static inline void
-clear_bit (volatile char *addr, int nr)
-{
-	addr[nr >> 3] &= ~(BIT_MASK >> (nr & 7));
-}
-
 static inline uint32_t
 secs_round_up(uint64_t bytes)
 {
@@ -249,27 +216,7 @@
 static inline int
 vhd_parent_raw(vhd_context_t *ctx)
 {
-	return uuid_is_null(ctx->header.prt_uuid);
-}
-
-/*
- * returns current capacity in bytes
- */
-static inline uint64_t
-vhd_cur_capacity(vhd_context_t *ctx)
-{
-	return ctx->footer.curr_size;
-}
-
-/*
- * returns maximum capacity this vhd can quickly be resized to in bytes
- */
-static inline uint64_t
-vhd_max_capacity(vhd_context_t *ctx)
-{
-	if (!vhd_type_dynamic(ctx))
-		return 0;
-	return (uint64_t)ctx->header.max_bat_size * ctx->header.block_size;
+	return vhd_uuid_is_nil(&ctx->header.prt_uuid);
 }
 
 void libvhd_set_log_level(int);
@@ -282,7 +229,7 @@
 
 uint32_t vhd_checksum_footer(vhd_footer_t *);
 uint32_t vhd_checksum_header(vhd_header_t *);
-uint32_t vhd_checksum_batmap(vhd_context_t *, vhd_batmap_t *);
+uint32_t vhd_checksum_batmap(vhd_batmap_t *);
 
 void vhd_footer_in(vhd_footer_t *);
 void vhd_footer_out(vhd_footer_t *);
@@ -296,40 +243,30 @@
 int vhd_validate_footer(vhd_footer_t *footer);
 int vhd_validate_header(vhd_header_t *header);
 int vhd_validate_batmap_header(vhd_batmap_t *batmap);
-int vhd_validate_batmap(vhd_context_t *, vhd_batmap_t *batmap);
+int vhd_validate_batmap(vhd_batmap_t *batmap);
 int vhd_validate_platform_code(uint32_t code);
 
 int vhd_open(vhd_context_t *, const char *file, int flags);
 void vhd_close(vhd_context_t *);
-/* vhd_create: mbytes is the virtual size for BAT/batmap preallocation - see 
- * vhd-util-resize.c
- */
-int vhd_create(const char *name, uint64_t bytes, int type, uint64_t mbytes,
-		vhd_flag_creat_t);
+int vhd_create(const char *name, uint64_t bytes, int type, vhd_flag_creat_t);
 /* vhd_snapshot: the bytes parameter is optional and can be 0 if the snapshot 
  * is to have the same size as the (first non-empty) parent */
 int vhd_snapshot(const char *snapshot, uint64_t bytes, const char *parent,
-		uint64_t mbytes, vhd_flag_creat_t);
+		vhd_flag_creat_t);
 
 int vhd_hidden(vhd_context_t *, int *);
 int vhd_chain_depth(vhd_context_t *, int *);
-int vhd_marker(vhd_context_t *, char *);   
-int vhd_set_marker(vhd_context_t *, char); 
-int vhd_get_keyhash(vhd_context_t *, struct vhd_keyhash *);
-int vhd_set_keyhash(vhd_context_t *, const struct vhd_keyhash *);
 
-off64_t vhd_position(vhd_context_t *);
-int vhd_seek(vhd_context_t *, off64_t, int);
+off_t vhd_position(vhd_context_t *);
+int vhd_seek(vhd_context_t *, off_t, int);
 int vhd_read(vhd_context_t *, void *, size_t);
 int vhd_write(vhd_context_t *, void *, size_t);
-int vhd_pread(vhd_context_t *, void *, size_t, off64_t);
-int vhd_pwrite(vhd_context_t *, void *, size_t, off64_t);
 
 int vhd_offset(vhd_context_t *, uint32_t, uint32_t *);
 
-int vhd_end_of_headers(vhd_context_t *ctx, off64_t *off);
-int vhd_end_of_data(vhd_context_t *ctx, off64_t *off);
-int vhd_batmap_header_offset(vhd_context_t *ctx, off64_t *off);
+int vhd_end_of_headers(vhd_context_t *ctx, off_t *off);
+int vhd_end_of_data(vhd_context_t *ctx, off_t *off);
+int vhd_batmap_header_offset(vhd_context_t *ctx, off_t *off);
 
 int vhd_get_header(vhd_context_t *);
 int vhd_get_footer(vhd_context_t *);
@@ -345,48 +282,39 @@
 int vhd_batmap_test(vhd_context_t *, vhd_batmap_t *, uint32_t);
 void vhd_batmap_set(vhd_context_t *, vhd_batmap_t *, uint32_t);
 void vhd_batmap_clear(vhd_context_t *, vhd_batmap_t *, uint32_t);
-void vhd_batmap_reset_map(vhd_context_t *, vhd_batmap_t *);
 
-int vhd_file_size_fixed(vhd_context_t *);
-int vhd_get_phys_size(vhd_context_t *, off64_t *);
-int vhd_set_phys_size(vhd_context_t *, off64_t);
-int vhd_set_virt_size(vhd_context_t *, uint64_t);
+int vhd_get_phys_size(vhd_context_t *, off_t *);
+int vhd_set_phys_size(vhd_context_t *, off_t);
 
 int vhd_bitmap_test(vhd_context_t *, char *, uint32_t);
 void vhd_bitmap_set(vhd_context_t *, char *, uint32_t);
 void vhd_bitmap_clear(vhd_context_t *, char *, uint32_t);
 
-int vhd_initialize_header_parent_name(vhd_context_t *, const char *);
-int vhd_write_parent_locators(vhd_context_t *, const char *);
 int vhd_parent_locator_count(vhd_context_t *);
 int vhd_parent_locator_get(vhd_context_t *, char **);
 int vhd_parent_locator_read(vhd_context_t *, vhd_parent_locator_t *, char **);
 int vhd_find_parent(vhd_context_t *, const char *, char **);
 int vhd_parent_locator_write_at(vhd_context_t *, const char *,
-				off64_t, uint32_t, size_t,
+				off_t, uint32_t, size_t,
 				vhd_parent_locator_t *);
 
 int vhd_header_decode_parent(vhd_context_t *, vhd_header_t *, char **);
 int vhd_change_parent(vhd_context_t *, char *parent_path, int raw);
-int vhd_macx_encode_location(char *name, char **out, int *outlen);
-int vhd_w2u_encode_location(char *name, char **out, int *outlen);
 
 int vhd_read_footer(vhd_context_t *, vhd_footer_t *);
-int vhd_read_footer_at(vhd_context_t *, vhd_footer_t *, off64_t);
+int vhd_read_footer_at(vhd_context_t *, vhd_footer_t *, off_t);
 int vhd_read_footer_strict(vhd_context_t *, vhd_footer_t *);
 int vhd_read_header(vhd_context_t *, vhd_header_t *);
-int vhd_read_header_at(vhd_context_t *, vhd_header_t *, off64_t);
+int vhd_read_header_at(vhd_context_t *, vhd_header_t *, off_t);
 int vhd_read_bat(vhd_context_t *, vhd_bat_t *);
 int vhd_read_batmap(vhd_context_t *, vhd_batmap_t *);
-int vhd_read_batmap_header(vhd_context_t *, vhd_batmap_t *);
-int vhd_read_batmap_map(vhd_context_t *, vhd_batmap_t *);
 int vhd_read_bitmap(vhd_context_t *, uint32_t block, char **bufp);
 int vhd_read_block(vhd_context_t *, uint32_t block, char **bufp);
 
 int vhd_write_footer(vhd_context_t *, vhd_footer_t *);
-int vhd_write_footer_at(vhd_context_t *, vhd_footer_t *, off64_t);
+int vhd_write_footer_at(vhd_context_t *, vhd_footer_t *, off_t);
 int vhd_write_header(vhd_context_t *, vhd_header_t *);
-int vhd_write_header_at(vhd_context_t *, vhd_header_t *, off64_t);
+int vhd_write_header_at(vhd_context_t *, vhd_header_t *, off_t);
 int vhd_write_bat(vhd_context_t *, vhd_bat_t *);
 int vhd_write_batmap(vhd_context_t *, vhd_batmap_t *);
 int vhd_write_bitmap(vhd_context_t *, uint32_t block, char *bitmap);
@@ -394,16 +322,5 @@
 
 int vhd_io_read(vhd_context_t *, char *, uint64_t, uint32_t);
 int vhd_io_write(vhd_context_t *, char *, uint64_t, uint32_t);
-int vhd_io_read_bytes(vhd_context_t *, char *, size_t, uint64_t);
-int vhd_io_write_bytes(vhd_context_t *, char *, size_t, uint64_t);
-
-int vhd_print_headers(vhd_context_t *, int hex);
-
-vhd_context_t *vhd_stream_initialize(FILE *, vhd_context_t *);
-vhd_context_t *vhd_stream_load(FILE *);
-char *vhd_realpath(const char *path, char *resolved_path);
-
-struct ICBINN_struct * vhd_icbinn_key (void);
-struct ICBINN_struct * vhd_icbinn_vhd (void);
 
 #endif
diff -Nur blktap2_oxt//include/libvhd-index.h blktap2_xen//include/libvhd-index.h
--- blktap2_oxt//include/libvhd-index.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/libvhd-index.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,102 +0,0 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _LIB_VHDI_H_
-#define _LIB_VHDI_H_
-
-#include <inttypes.h>
-#include <uuid/uuid.h>
-
-#define VHD_MAX_NAME_LEN                    1024
-
-typedef struct vhdi_context                 vhdi_context_t;
-typedef struct vhdi_bat                     vhdi_bat_t;
-typedef struct vhdi_block                   vhdi_block_t;
-typedef struct vhdi_entry                   vhdi_entry_t;
-typedef uint32_t                            vhdi_file_id_t;
-typedef struct vhdi_file_ref                vhdi_file_ref_t;
-typedef struct vhdi_file_table              vhdi_file_table_t;
-
-struct vhdi_context {
-	int                                 fd;
-	int                                 spb;
-	char                               *name;
-	uint32_t                            vhd_block_size;
-};
-
-struct vhdi_bat {
-	uint32_t                           *table;
-	uint64_t                            vhd_blocks;
-	uint32_t                            vhd_block_size;
-	char                                vhd_path[VHD_MAX_NAME_LEN];
-	char                                index_path[VHD_MAX_NAME_LEN];
-	char                                file_table_path[VHD_MAX_NAME_LEN];
-};
-
-struct vhdi_entry {
-	vhdi_file_id_t                      file_id;
-	uint32_t                            offset;
-};
-
-struct vhdi_block {
-	int                                 entries;
-	vhdi_entry_t                       *table;
-};
-
-struct vhdi_file_ref {
-	vhdi_file_id_t                      file_id;
-	char                               *path;
-	uuid_t                              vhd_uuid;
-	uint32_t                            vhd_timestamp;
-};
-
-struct vhdi_file_table {
-	int                                 entries;
-	vhdi_file_ref_t                    *table;
-};
-
-void vhdi_entry_in(vhdi_entry_t *);
-
-int vhdi_create(const char *, uint32_t);
-int vhdi_open(vhdi_context_t *, const char *, int);
-void vhdi_close(vhdi_context_t *);
-int vhdi_read_block(vhdi_context_t *, vhdi_block_t *, uint32_t);
-int vhdi_write_block(vhdi_context_t *, vhdi_block_t *, uint32_t);
-int vhdi_append_block(vhdi_context_t *, vhdi_block_t *, uint32_t *);
-
-int vhdi_bat_create(const char *, const char *, const char *, const char *);
-int vhdi_bat_load(const char *, vhdi_bat_t *);
-int vhdi_bat_write(const char *, vhdi_bat_t *);
-
-int vhdi_file_table_create(const char *);
-int vhdi_file_table_load(const char *, vhdi_file_table_t *);
-int vhdi_file_table_add(const char *, const char *, vhdi_file_id_t *);
-void vhdi_file_table_free(vhdi_file_table_t *);
-
-#endif
diff -Nur blktap2_oxt//include/libvhd-journal.h blktap2_xen//include/libvhd-journal.h
--- blktap2_oxt//include/libvhd-journal.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/libvhd-journal.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,6 +1,5 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
+/* Copyright (c) 2008, XenSource Inc.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -24,7 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
+*/
 #ifndef _VHD_JOURNAL_H_
 #define _VHD_JOURNAL_H_
 
@@ -36,11 +35,11 @@
 #define VHD_JOURNAL_DATA           0x02
 
 #define VHD_JOURNAL_HEADER_COOKIE  "vjournal"
-#define VHD_JOURNAL_ENTRY_COOKIE   0xaaaa12344321aaaaULL
+#define VHD_JOURNAL_ENTRY_COOKIE   0xaaaa12344321aaaa
 
 typedef struct vhd_journal_header {
 	char                       cookie[8];
-	uuid_t                     uuid;
+	vhd_uuid_t                 uuid;
 	uint64_t                   vhd_footer_offset;
 	uint32_t                   journal_data_entries;
 	uint32_t                   journal_metadata_entries;
diff -Nur blktap2_oxt//include/list.h blktap2_xen//include/list.h
--- blktap2_oxt//include/list.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/list.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,11 +1,8 @@
 /*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-/*
  * list.h
  * 
  * This is a subset of linux's list.h intended to be used in user-space.
+ * XXX The namespace conflicts with NetBSD's <sys/queue.h>
  * 
  */
 
@@ -19,6 +16,16 @@
         struct list_head *next, *prev;
 };
  
+/* XXX workaround for conflicts. The list API should use its own
+ * namespace prefix, i.e. BLK_
+ */
+#ifdef LIST_HEAD_INIT
+#undef LIST_HEAD_INIT
+#endif
+#ifndef LIST_HEAD
+#undef LIST_HEAD
+#endif
+
 #define LIST_HEAD_INIT(name) { &(name), &(name) }
  
 #define LIST_HEAD(name) \
@@ -59,8 +66,8 @@
 static inline void list_del(struct list_head *entry)
 {
         __list_del(entry->prev, entry->next);
-        entry->next = (struct list_head *)LIST_POISON1;
-        entry->prev = (struct list_head *)LIST_POISON2;
+        entry->next = LIST_POISON1;
+        entry->prev = LIST_POISON2;
 }
 
 static inline void list_del_init(struct list_head *entry)
@@ -69,19 +76,6 @@
 	INIT_LIST_HEAD(entry);
 }
 
-static inline void list_move(struct list_head *list, struct list_head *head)
-{
-	__list_del(list->prev, list->next);
-	list_add(list, head);
-}
-
-static inline void list_move_tail(struct list_head *list,
-				  struct list_head *head)
-{
-	__list_del(list->prev, list->next);
-	list_add_tail(list, head);
-}
-
 static inline int list_empty(const struct list_head *head)
 {
 	return head->next == head;
@@ -114,13 +108,6 @@
 		__list_splice(list, head, head->next);
 }
 
-static inline void list_splice_tail(struct list_head *list,
-				    struct list_head *head)
-{
-	if (!list_empty(list))
-		__list_splice(list, head->prev, head);
-}
-
 #define list_entry(ptr, type, member)                                   \
         ((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
 
diff -Nur blktap2_oxt//include/lvm-util.h blktap2_xen//include/lvm-util.h
--- blktap2_oxt//include/lvm-util.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/lvm-util.h	2015-03-19 11:08:36.000000000 -0400
@@ -25,11 +25,6 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2008 Citrix Systems, Inc.
- */
-
 #ifndef _LVM_UTIL_H_
 #define _LVM_UTIL_H_
 
diff -Nur blktap2_oxt//include/Makefile blktap2_xen//include/Makefile
--- blktap2_oxt//include/Makefile	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/Makefile	2015-03-19 11:08:36.000000000 -0400
@@ -1,25 +1,13 @@
-#
-# Copyright (c) 2013 Citrix Systems, Inc.
-#
-
-BLKTAP_ROOT := ..
-include $(BLKTAP_ROOT)/Rules.mk
-
-LIBVHDDIR      := vhd
-LIBVHD_HEADERS := vhd.h libvhd.h libvhd-index.h libvhd-journal.h list.h vhd-util.h
-
-BLKTAPDIR      := blktap
-BLKTAP_HEADERS := blktap2.h blktaplib.h tapdisk-message.h
+XEN_ROOT := $(CURDIR)/../../..
+include $(XEN_ROOT)/tools/Rules.mk
 
 .PHONY: all
 all:
 
 .PHONY: install
 install:
-	$(INSTALL_DIR) -p $(DESTDIR)/usr/include/$(BLKTAPDIR)
-	$(INSTALL_DATA) $(BLKTAP_HEADERS) $(DESTDIR)/usr/include/$(BLKTAPDIR)
-	$(INSTALL_DIR) -p $(DESTDIR)/usr/include/$(LIBVHDDIR)
-	$(INSTALL_DATA) $(LIBVHD_HEADERS) $(DESTDIR)/usr/include/$(LIBVHDDIR)
+	$(INSTALL_DIR) -p $(DESTDIR)$(INCLUDEDIR)
+
 
 .PHONY: clean
 clean:
diff -Nur blktap2_oxt//include/partition.h blktap2_xen//include/partition.h
--- blktap2_oxt//include/partition.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/partition.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,49 +0,0 @@
-/*
- * Copyright (c) 2009 Citrix Systems, Inc.
- */
-
-#ifndef _PARTITION_H_
-#define _PARTITION_H_
-
-#include <inttypes.h>
-
-#define PARTITION_BOOTABLE            0x80
-#define PARTITION_NON_BOOTABLE        0x00
-
-#define MBR_SIGNATURE                 0xAA55
-#define MBR_START_SECTOR              0x80
-
-struct partition_geometry {
-	unsigned char                 heads;
-	unsigned char                 sectors;
-	unsigned int                  cylinders;
-};
-
-struct partition_chs {
-	uint8_t                       chs[3];
-} __attribute__((__packed__));
-
-struct primary_partition {
-	uint8_t                       status;
-	struct partition_chs          chs_first;
-	uint8_t                       type;
-	struct partition_chs          chs_last;
-	uint32_t                      lba;
-	uint32_t                      blocks;
-} __attribute__((__packed__));
-
-struct partition_table {
-	uint8_t                       code[0x1b8];
-	uint32_t                      disk_signature;
-	uint8_t                       pad[0x2];
-	struct primary_partition      partitions[4];
-	uint16_t                      mbr_signature;
-} __attribute__((__packed__));
-
-void partition_table_in(struct partition_table *);
-void partition_table_out(struct partition_table *);
-int partition_table_validate(struct partition_table *);
-void partition_table_dump(struct partition_table *);
-struct partition_chs lba_to_chs(struct partition_geometry *, uint64_t);
-
-#endif
diff -Nur blktap2_oxt//include/relative-path.h blktap2_xen//include/relative-path.h
--- blktap2_oxt//include/relative-path.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/relative-path.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,6 +1,5 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
+/* Copyright (c) 2008, XenSource Inc.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -24,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #ifndef _RELATIVE_PATH_H_
 #define _RELATIVE_PATH_H_
 
diff -Nur blktap2_oxt//include/tapdisk-message.h blktap2_xen//include/tapdisk-message.h
--- blktap2_oxt//include/tapdisk-message.h	2016-03-14 14:24:58.164021126 -0400
+++ blktap2_xen//include/tapdisk-message.h	2015-03-19 11:08:36.000000000 -0400
@@ -23,12 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
+*/
 #ifndef _TAPDISK_MESSAGE_H_
 #define _TAPDISK_MESSAGE_H_
 
@@ -41,34 +36,29 @@
 #define TAPDISK_MESSAGE_MAX_MINORS \
 	((TAPDISK_MESSAGE_MAX_PATH_LENGTH / sizeof(int)) - 1)
 
-#define TAPDISK_MESSAGE_FLAG_SHARED      0x001
-#define TAPDISK_MESSAGE_FLAG_RDONLY      0x002
-#define TAPDISK_MESSAGE_FLAG_ADD_CACHE   0x004
-#define TAPDISK_MESSAGE_FLAG_VHD_INDEX   0x008
-#define TAPDISK_MESSAGE_FLAG_LOG_DIRTY   0x010
-#define TAPDISK_MESSAGE_FLAG_ADD_LCACHE  0x020
-#define TAPDISK_MESSAGE_FLAG_REUSE_PRT   0x040
-#define TAPDISK_MESSAGE_FLAG_SECONDARY   0x080
-#define TAPDISK_MESSAGE_FLAG_STANDBY     0x100
+#define TAPDISK_MESSAGE_FLAG_SHARED      0x01
+#define TAPDISK_MESSAGE_FLAG_RDONLY      0x02
+#define TAPDISK_MESSAGE_FLAG_ADD_CACHE   0x04
+#define TAPDISK_MESSAGE_FLAG_VHD_INDEX   0x08
+#define TAPDISK_MESSAGE_FLAG_LOG_DIRTY   0x10
 
 typedef struct tapdisk_message           tapdisk_message_t;
-typedef uint32_t                         tapdisk_message_flag_t;
+typedef uint8_t                          tapdisk_message_flag_t;
 typedef struct tapdisk_message_image     tapdisk_message_image_t;
 typedef struct tapdisk_message_params    tapdisk_message_params_t;
 typedef struct tapdisk_message_string    tapdisk_message_string_t;
 typedef struct tapdisk_message_response  tapdisk_message_response_t;
 typedef struct tapdisk_message_minors    tapdisk_message_minors_t;
 typedef struct tapdisk_message_list      tapdisk_message_list_t;
-typedef struct tapdisk_message_stat      tapdisk_message_stat_t;
 
 struct tapdisk_message_params {
 	tapdisk_message_flag_t           flags;
 
+	uint8_t                          storage;
 	uint32_t                         devnum;
 	uint32_t                         domid;
+	uint16_t                         path_len;
 	char                             path[TAPDISK_MESSAGE_MAX_PATH_LENGTH];
-	uint32_t                         prt_devnum;
-	char                             secondary[TAPDISK_MESSAGE_MAX_PATH_LENGTH];
 };
 
 struct tapdisk_message_image {
@@ -98,13 +88,6 @@
 	char                             path[TAPDISK_MESSAGE_MAX_PATH_LENGTH];
 };
 
-struct tapdisk_message_stat {
-	uint16_t                         type;
-	uint16_t                         cookie;
-	size_t                           length;
-};
-
-
 struct tapdisk_message {
 	uint16_t                         type;
 	uint16_t                         cookie;
@@ -117,7 +100,6 @@
 		tapdisk_message_minors_t minors;
 		tapdisk_message_response_t response;
 		tapdisk_message_list_t   list;
-		tapdisk_message_stat_t   info;
 	} u;
 };
 
@@ -142,14 +124,10 @@
 	TAPDISK_MESSAGE_LIST_MINORS_RSP,
 	TAPDISK_MESSAGE_LIST,
 	TAPDISK_MESSAGE_LIST_RSP,
-	TAPDISK_MESSAGE_STATS,
-	TAPDISK_MESSAGE_STATS_RSP,
 	TAPDISK_MESSAGE_FORCE_SHUTDOWN,
 	TAPDISK_MESSAGE_EXIT,
 };
 
-#define TAPDISK_MESSAGE_MAX TAPDISK_MESSAGE_EXIT
-
 static inline char *
 tapdisk_message_name(enum tapdisk_message_id id)
 {
@@ -214,12 +192,6 @@
 	case TAPDISK_MESSAGE_LIST_RSP:
 		return "list response";
 
-	case TAPDISK_MESSAGE_STATS:
-		return "stats";
-
-	case TAPDISK_MESSAGE_STATS_RSP:
-		return "stats response";
-
 	case TAPDISK_MESSAGE_EXIT:
 		return "exit";
 
diff -Nur blktap2_oxt//include/vhd.h blktap2_xen//include/vhd.h
--- blktap2_oxt//include/vhd.h	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//include/vhd.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,6 +1,5 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
+/* Copyright (c) 2008, XenSource Inc.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -24,17 +23,14 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #ifndef __VHD_H__
 #define __VHD_H__
 
-#include <asm/types.h>
-#include <uuid/uuid.h>
 #include <inttypes.h>
 
-typedef __u32 u32;
-typedef __u64 u64;
+typedef uint32_t u32;
+typedef uint64_t u64;
 
 #define DEBUG 1
 
@@ -63,7 +59,7 @@
   u32    geometry;        /* Disk geometry                                */
   u32    type;            /* Disk type                                    */
   u32    checksum;        /* 1's comp sum of this struct.                 */
-  uuid_t uuid;            /* Unique disk ID, used for naming parents      */
+  vhd_uuid_t uuid;        /* Unique disk ID, used for naming parents      */
   char   saved;           /* one-bit -- is this disk/VM in a saved state? */
   char   hidden;          /* tapdisk-specific field: is this vdi hidden?  */
   char   reserved[426];   /* padding                                      */
@@ -110,7 +106,15 @@
 #define HD_TYPE_DIFF       4  /* differencing disk */
 
 /* String table for hd.type */
-extern const char *HD_TYPE_STR[7];
+static const char *HD_TYPE_STR[7] = {
+        "None",                    /* 0 */
+        "Reserved (deprecated)",   /* 1 */
+        "Fixed hard disk",         /* 2 */
+        "Dynamic hard disk",       /* 3 */
+        "Differencing hard disk",  /* 4 */
+        "Reserved (deprecated)",   /* 5 */
+        "Reserved (deprecated)"    /* 6 */
+};
 
 #define HD_TYPE_MAX 6
 
@@ -143,7 +147,7 @@
   u32    max_bat_size;    /* Maximum number of entries in the BAT         */
   u32    block_size;      /* Block size in bytes. Must be power of 2.     */
   u32    checksum;        /* Header checksum.  1's comp of all fields.    */
-  uuid_t prt_uuid;        /* ID of the parent disk.                       */
+  vhd_uuid_t prt_uuid;    /* ID of the parent disk.                       */
   u32    prt_ts;          /* Modification time of the parent disk         */
   u32    res1;            /* Reserved.                                    */
   char   prt_name[512];   /* Parent unicode name.                         */
@@ -162,21 +166,12 @@
 
 #define DD_BLK_UNUSED 0xFFFFFFFF
 
-struct vhd_keyhash {
-  uint8_t cookie;         /* 1 if keyhash is set, 0 otherwise            */
-  uint8_t nonce[32];      /* arbitrary 256 bit nonce                     */
-  uint8_t hash[32];       /* SHA256 sum of nonce appended by keyhash     */
-};
-
 struct dd_batmap_hdr {
   char   cookie[8];       /* should contain "tdbatmap"                    */
   u64    batmap_offset;   /* byte offset to batmap                        */
   u32    batmap_size;     /* batmap size in sectors                       */
   u32    batmap_version;  /* version of batmap                            */
   u32    checksum;        /* batmap checksum -- 1's complement of batmap  */
-  char   marker;          /* generic marker field                         */
-  struct vhd_keyhash keyhash;  /* nonce & SHA256 hash of encryption key   */
-  char   res[418];        /* reserved                                     */
 };
 
 static const char VHD_BATMAP_COOKIE[9] = "tdbatmap";
diff -Nur blktap2_oxt//include/vhd-util.h blktap2_xen//include/vhd-util.h
--- blktap2_oxt//include/vhd-util.h	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//include/vhd-util.h	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,13 +23,10 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #ifndef _VHD_UTIL_H_
 #define _VHD_UTIL_H_
 
-#include "vhd.h"
-
 int vhd_util_create(int argc, char **argv);
 int vhd_util_snapshot(int argc, char **argv);
 int vhd_util_query(int argc, char **argv);
@@ -46,17 +40,5 @@
 int vhd_util_scan(int argc, char **argv);
 int vhd_util_check(int argc, char **argv);
 int vhd_util_revert(int argc, char **argv);
-int vhd_util_stream_coalesce(int argc, char **argv);
-int vhd_util_clone_metadata(int argc, char **argv);
-int vhd_util_dm_encrypt(int argc, char **argv);
-int vhd_util_dm_decrypt(int argc, char **argv);
-int vhd_util_key(int argc, char **argv);
-
-int __vhd_util_clone_metadata(vhd_context_t *, const char *, int);
-int __vhd_util_clone_metadata_s(vhd_context_t *, const char *,
-				uint64_t, uint64_t, int);
-
-int __vhd_util_calculate_keyhash(struct vhd_keyhash *,
-				 const uint8_t *, size_t);
 
 #endif
diff -Nur blktap2_oxt//include/vhd-uuid.h blktap2_xen//include/vhd-uuid.h
--- blktap2_oxt//include/vhd-uuid.h	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//include/vhd-uuid.h	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,63 @@
+/* Copyright (c) 2008, XenSource Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of XenSource Inc. nor the names of its contributors
+ *       may be used to endorse or promote products derived from this software
+ *       without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef __BLKTAP2_VHD_UUID_H__
+#define __BLKTAP2_VHD_UUID_H__
+
+#if defined(__linux__)
+
+#include <uuid/uuid.h>
+typedef struct {
+    uuid_t uuid;
+} vhd_uuid_t;
+
+#elif defined(__NetBSD__)
+
+#include <uuid.h>
+
+typedef uuid_t vhd_uuid_t;
+
+#else
+
+#error "Please update vhd-uuid.h for your OS"
+
+#endif
+
+int vhd_uuid_is_nil(vhd_uuid_t *uuid);
+
+void vhd_uuid_generate(vhd_uuid_t *uuid);
+
+void vhd_uuid_to_string(vhd_uuid_t *uuid, char *out, size_t size);
+
+void vhd_uuid_from_string(vhd_uuid_t *uuid, const char *in);
+
+void vhd_uuid_copy(vhd_uuid_t *dst, vhd_uuid_t *src);
+
+void vhd_uuid_clear(vhd_uuid_t *uuid);
+
+int vhd_uuid_compare(vhd_uuid_t *uuid1, vhd_uuid_t *uuid2);
+
+#endif /* __BLKTAP2_VHD_UUID_H__ */
diff -Nur blktap2_oxt//lvm/lvm-util.c blktap2_xen//lvm/lvm-util.c
--- blktap2_oxt//lvm/lvm-util.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//lvm/lvm-util.c	2015-03-19 11:08:36.000000000 -0400
@@ -25,24 +25,13 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
-#include <syslog.h>
 
 #include "lvm-util.h"
 
-#define EPRINTF(_f, _a...)					\
-	do {							\
-		syslog(LOG_INFO, "%s: " _f, __func__, ##_a);	\
-	} while (0)
-
 #define _NAME "%255s"
 static char line[1024];
 
@@ -135,16 +124,12 @@
 			break;
 
 		err = -EINVAL;
-		if (sscanf(line, _NAME" %llu %d %d "_NAME" %llu", vg->name, 
-			   &size, &lvs, &pvs, pvname, &pv_start) != 6) {
-			EPRINTF("sscanf failed on '%s'\n", line);
+                if (sscanf(line, _NAME" %"SCNu64" %d %d "_NAME" %"SCNu64,
+			   vg->name, &size, &lvs, &pvs, pvname, &pv_start) != 6)
 			goto out;
-		}
 
-		if (strcmp(vg->name, vgname)) {
-			EPRINTF("VG name '%s' != '%s'\n", vg->name, vgname);
+		if (strcmp(vg->name, vgname))
 			goto out;
-		}
 
 		err = lvm_parse_pv(vg, pvname, pvs, pv_start);
 		if (err)
@@ -155,16 +140,12 @@
 	}
 
 	err = -EINVAL;
-	if (strcmp(vg->name, vgname)) {
-		EPRINTF("VG name '%s' != '%s'\n", vg->name, vgname);
+	if (strcmp(vg->name, vgname))
 		goto out;
-	}
 
 	for (i = 0; i < pvs; i++)
-		if (!vg->pvs[i].name[0]) {
-			EPRINTF("pvs %d name empty\n", i);
+		if (!vg->pvs[i].name[0])
 			goto out;
-		}
 
 	err = -ENOMEM;
 	vg->lvs = calloc(lvs, sizeof(struct lv));
@@ -195,10 +176,8 @@
 		if (strchr(",()", devices[i]))
 			devices[i] = ' ';
 
-	if (sscanf(devices, _NAME" %llu", seg->device, &start) != 2) {
-		EPRINTF("sscanf failed on '%s'\n", devices);
+        if (sscanf(devices, _NAME" %"SCNu64, seg->device, &start) != 2)
 		return -EINVAL;
-	}
 
 	pe_start = -1;
 	for (i = 0; i < vg->pv_cnt; i++)
@@ -207,10 +186,8 @@
 			break;
 		}
 
-	if (pe_start == -1) {
-		EPRINTF("invalid pe_start value\n");
+	if (pe_start == -1)
 		return -EINVAL;
-	}
 
 	seg->pe_start = (start * vg->extent_size) + pe_start;
 	return 0;
@@ -240,8 +217,8 @@
 		int segs;
 		struct lv *lv;
 		struct lv_segment seg;
-		unsigned long long size, seg_start;
-		char type[32], name[256], devices[1024];
+		uint64_t size, seg_start;
+		char type[32], name[256], dev[256], devices[1024];
 
 		if (i >= vg->lv_cnt)
 			break;
@@ -254,12 +231,10 @@
 		err = -EINVAL;
 		lv  = vg->lvs + i;
 
-		if (sscanf(line, _NAME" %llu %31s %u %llu %llu %1023s",
+                if (sscanf(line, _NAME" %"SCNu64" %31s %u %"SCNu64" %"SCNu64" %1023s",
 			   name, &size, type, &segs, &seg_start,
-			   &seg.pe_size, devices) != 7) {
-			EPRINTF("sscanf failed on '%s'\n", line);
+			   &seg.pe_size, devices) != 7)
 			goto out;
-		}
 
 		if (seg_start)
 			goto next;
@@ -283,11 +258,8 @@
 		err = -EINVAL;
 
 	next:
-		if (lvm_next_line(scan)) {
-			if (err)
-				EPRINTF("fscanf failed\n");
+		if (lvm_next_line(scan))
 			goto out;
-		}
 	}
 
 	err = 0;
@@ -353,19 +325,20 @@
 		return (err >= 0 ? err : -err);
 	}
 
-	printf("vg %s: extent_size: %llu, pvs: %d, lvs: %d\n",
+	
+        printf("vg %s: extent_size: %"PRIu64", pvs: %d, lvs: %d\n",
 	       vg.name, vg.extent_size, vg.pv_cnt, vg.lv_cnt);
 
 	for (i = 0; i < vg.pv_cnt; i++) {
 		pv = vg.pvs + i;
-		printf("pv %s: start %llu\n", pv->name, pv->start);
+                printf("pv %s: start %"PRIu64"\n", pv->name, pv->start);
 	}
 
 	for (i = 0; i < vg.lv_cnt; i++) {
 		lv  = vg.lvs + i;
-		seg = &lv->first_segment;
-		printf("lv %s: size: %llu, segments: %u, type: %u, "
-		       "dev: %s, pe_start: %llu, pe_size: %llu\n",
+		seg = &lv->first_segment;                
+                printf("lv %s: size: %"PRIu64", segments: %u, type: %u, "
+                       "dev: %s, pe_start: %"PRIu64", pe_size: %"PRIu64"\n",
 		       lv->name, lv->size, lv->segments, seg->type,
 		       seg->device, seg->pe_start, seg->pe_size);
 	}
diff -Nur blktap2_oxt//lvm/Makefile blktap2_xen//lvm/Makefile
--- blktap2_oxt//lvm/Makefile	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//lvm/Makefile	2015-03-19 11:08:36.000000000 -0400
@@ -1,9 +1,6 @@
-#
-# Copyright (c) 2008 Citrix Systems, Inc.
-#
-
-BLKTAP_ROOT := ../
-include $(BLKTAP_ROOT)/Rules.mk
+XEN_ROOT = $(CURDIR)/../../..
+BLKTAP_ROOT := ..
+include $(XEN_ROOT)/tools/Rules.mk
 
 ifeq ($(LVM_UTIL_TEST),y)
 TEST              := lvm-util
@@ -14,9 +11,9 @@
 CFLAGS            += -I../include
 CFLAGS            += -D_GNU_SOURCE
 
-# Get gcc to generate the dependencies for us.
-CFLAGS            += -Wp,-MD,.$(@F).d
-DEPS               = .*.d
+ifeq ($(CONFIG_X86_64),y)
+CFLAGS            += -fPIC
+endif
 
 LVM-OBJS          := lvm-util.o
 
@@ -27,10 +24,10 @@
 install: all
 
 lvm-util: lvm-util.o
-	$(CC) $(CFLAGS) -DLVM_UTIL -o lvm-util lvm-util.c
+	$(CC) -DLVM_UTIL $(LDFLAGS) -o lvm-util lvm-util.c
 
 clean:
-	rm -rf *.o *~ $(DEPS) $(IBIN)
+	rm -rf *.o *.opic *~ $(DEPS) $(IBIN)
 
 .PHONY: all build clean install lvm-util
 
diff -Nur blktap2_oxt//Makefile blktap2_xen//Makefile
--- blktap2_oxt//Makefile	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//Makefile	2015-03-19 11:08:36.000000000 -0400
@@ -1,37 +1,18 @@
-#
-# Copyright (c) 2011 Citrix Systems, Inc.
-#
+XEN_ROOT = $(CURDIR)/../..
+include $(XEN_ROOT)/tools/Rules.mk
 
-BLKTAP_ROOT := .
-include $(BLKTAP_ROOT)/Rules.mk
+CFLAGS  += $(CFLAGS_libxenctrl)
+LDLIBS += $(LDLIBS_libxenctrl)
 
 SUBDIRS-y :=
 SUBDIRS-y += include
 SUBDIRS-y += lvm
-SUBDIRS-y += part
 SUBDIRS-y += vhd
-SUBDIRS-y += drivers
-SUBDIRS-y += control
-SUBDIRS-y += scripts
+SUBDIRS-$(CONFIG_Linux) += drivers
+SUBDIRS-$(CONFIG_Linux) += control
 
-.PHONY: all
-all: build
-
-.PHONY: build
-build:
-	@set -e; for subdir in $(SUBDIRS-y); do \
-	$(MAKE) -C $$subdir all;       \
-		done
-
-.PHONY: install
-install:
-	@set -e; for subdir in $(SUBDIRS-y); do \
-		$(MAKE) -C $$subdir install; \
-	done
-
-.PHONY: clean
 clean:
 	rm -rf *.a *.so *.o *.rpm $(LIB) *~ $(DEPS) TAGS
-	@set -e; for subdir in $(SUBDIRS-y); do \
-	$(MAKE) -C $$subdir clean;       \
-		done
+
+.PHONY: all clean install
+all clean install: %: subdirs-%
diff -Nur blktap2_oxt//README blktap2_xen//README
--- blktap2_oxt//README	2016-03-14 14:24:58.152021126 -0400
+++ blktap2_xen//README	2015-03-19 11:08:36.000000000 -0400
@@ -1,19 +1,21 @@
-Blktap Userspace Tools + Library
+Blktap2 Userspace Tools + Library
 ================================
 
+Dutch Meyer
+4th June 2009
+
 Andrew Warfield and Julian Chesterfield
 16th June 2006
 
-{firstname.lastname}@cl.cam.ac.uk
 
-The blktap userspace toolkit provides a user-level disk I/O
-interface. The blktap mechanism involves a kernel driver that acts
+The blktap2 userspace toolkit provides a user-level disk I/O
+interface. The blktap2 mechanism involves a kernel driver that acts
 similarly to the existing Xen/Linux blkback driver, and a set of
-associated user-level libraries.  Using these tools, blktap allows
+associated user-level libraries.  Using these tools, blktap2 allows
 virtual block devices presented to VMs to be implemented in userspace
 and to be backed by raw partitions, files, network, etc.
 
-The key benefit of blktap is that it makes it easy and fast to write
+The key benefit of blktap2 is that it makes it easy and fast to write
 arbitrary block backends, and that these user-level backends actually
 perform very well.  Specifically:
 
@@ -38,7 +40,7 @@
 
 How it works (in one paragraph):
 
-Working in conjunction with the kernel blktap driver, all disk I/O
+Working in conjunction with the kernel blktap2 driver, all disk I/O
 requests from VMs are passed to the userspace deamon (using a shared
 memory interface) through a character device. Each active disk is
 mapped to an individual device node, allowing per-disk processes to
@@ -49,74 +51,271 @@
 code.  We provide a simple, asynchronous virtual disk interface that
 makes it quite easy to add new disk implementations.
 
-As of June 2006 the current supported disk formats are:
+As of June 2009 the current supported disk formats are:
 
  - Raw Images (both on partitions and in image files)
- - File-backed Qcow disks
- - Standalone sparse Qcow disks
- - Fast shareable RAM disk between VMs (requires some form of cluster-based 
-   filesystem support e.g. OCFS2 in the guest kernel)
- - Some VMDK images - your mileage may vary
-
-Raw and QCow images have asynchronous backends and so should perform
-fairly well.  VMDK is based directly on the qemu vmdk driver, which is
-synchronous (a.k.a. slow).
+ - Fast sharable RAM disk between VMs (requires some form of 
+   cluster-based filesystem support e.g. OCFS2 in the guest kernel)
+ - VHD, including snapshots and sparse images
+ - Qcow, including snapshots and sparse images
+
 
 Build and Installation Instructions
 ===================================
 
-Make to configure the blktap backend driver in your dom0 kernel.  It
-will cooperate fine with the existing backend driver, so you can
-experiment with tap disks without breaking existing VM configs.
+Make to configure the blktap2 backend driver in your dom0 kernel.  It
+will inter-operate with the existing backend and frontend drivers.  It
+will also cohabitate with the original blktap driver.  However, some
+formats (currently aio and qcow) will default to their blktap2
+versions when specified in a vm configuration file.
 
-To build the tools separately, "make && make install" in 
-tools/blktap.
+To build the tools separately, "make && make install" in
+tools/blktap2.
 
 
 Using the Tools
 ===============
 
-Prepare the image for booting. For qcow files use the qcow utilities
-installed earlier. e.g. qcow-create generates a blank standalone image
-or a file-backed CoW image. img2qcow takes an existing image or
-partition and creates a sparse, standalone qcow-based file.
+Preparing an image for boot:
 
 The userspace disk agent is configured to start automatically via xend
-(alternatively you can start it manually => 'blktapctrl')
 
-Customise the VM config file to use the 'tap' handler, followed by the
-driver type. e.g. for a raw image such as a file or partition:
+Customize the VM config file to use the 'tap:tapdisk' handler,
+followed by the driver type. e.g. for a raw image such as a file or
+partition:
+
+disk = ['tap:tapdisk:aio:<FILENAME>,sda1,w']
+
+Alternatively, the vhd-util tool (installed with make install, or in
+/blktap2/vhd) can be used to build sparse copy-on-write vhd images.
+
+For example, to build a sparse image -
+  vhd-util create -n MyVHDFile -s 1024
+
+This creates a sparse 1GB file named "MyVHDFile" that can be mounted
+and populated with data.
+
+One can also base the image on a raw file -
+  vhd-util snapshot -n MyVHDFile -p SomeRawFile -m
+
+This creates a sparse VHD file named "MyVHDFile" using "SomeRawFile"
+as a parent image.  Copy-on-write semantics ensure that writes will be
+stored in "MyVHDFile" while reads will be directed to the most
+recently written version of the data, either in "MyVHDFile" or
+"SomeRawFile" as is appropriate.  Other options exist as well, consult
+the vhd-util application for the complete set of VHD tools.
 
-disk = ['tap:aio:<FILENAME>,sda1,w']
+VHD files can be mounted automatically in a guest similarly to the
+above AIO example simply by specifying the vhd driver.
 
-e.g. for a qcow image:
+disk = ['tap:tapdisk:vhd:<VHD FILENAME>,sda1,w']
 
-disk = ['tap:qcow:<FILENAME>,sda1,w']
 
+Snapshots:
 
-Mounting images in Dom0 using the blktap driver
+Pausing a guest will also plug the corresponding IO queue for blktap2
+devices and stop blktap2 drivers.  This can be used to implement a
+safe live snapshot of qcow and vhd disks.  An example script "xmsnap"
+is shown in the tools/blktap2/drivers directory.  This script will
+perform a live snapshot of a qcow disk.  VHD files can use the
+"vhd-util snapshot" tool discussed above.  If this snapshot command is
+applied to a raw file mounted with tap:tapdisk:AIO, include the -m
+flag and the driver will be reloaded as VHD.  If applied to an already
+mounted VHD file, omit the -m flag.
+
+
+Mounting images in Dom0 using the blktap2 driver
 ===============================================
 Tap (and blkback) disks are also mountable in Dom0 without requiring an
-active VM to attach. You will need to build a xenlinux Dom0 kernel that
-includes the blkfront driver (e.g. the default 'make world' or 
-'make kernels' build. Simply use the xm command-line tool to activate
-the backend disks, and blkfront will generate a virtual block device that
-can be accessed in the same way as a loop device or partition:
-
-e.g. for a raw image file <FILENAME> that would normally be mounted using
-the loopback driver (such as 'mount -o loop <FILENAME> /mnt/disk'), do the
-following:
-
-xm block-attach 0 tap:aio:<FILENAME> /dev/xvda1 w 0
-mount /dev/xvda1 /mnt/disk        <--- don't use loop driver
-
-In this way, you can use any of the userspace device-type drivers built
-with the blktap userspace toolkit to open and mount disks such as qcow
-or vmdk images:
+active VM to attach. 
+
+The syntax is -
+  tapdisk2 -n <type>:<full path to file>
+
+For example -
+  tapdisk2  -n aio:/home/images/rawFile.img
 
-xm block-attach 0 tap:qcow:<FILENAME> /dev/xvda1 w 0
-mount /dev/xvda1 /mnt/disk
+When successful the location of the new device will be provided by
+tapdisk2 to stdout and tapdisk2 will terminate.  From that point
+forward control of the device is provided through sysfs in the
+directory-
 
+  /sys/class/blktap2/blktap#/
 
+Where # is a blktap2 device number present in the path that tapdisk2
+printed before terminating.  The sysfs interface is largely intuitive,
+for example, to remove tap device 0 one would-
+  
+  echo 1 > /sys/class/blktap2/blktap0/remove
 
+Similarly, a pause control is available, which is can be used to plug
+the request queue of a live running guest.
+
+Previous versions of blktap mounted devices in dom0 by using blkfront
+in dom0 and the xm block-attach command.  This approach is still
+available, though slightly more cumbersome.
+
+
+Tapdisk Development
+===============================================
+
+People regularly ask how to develop their own tapdisk drivers, and
+while it has not yet been well documented, the process is relatively
+easy.  Here I will provide a brief overview.  The best reference, of
+course, comes from the existing drivers.  Specifically,
+blktap2/drivers/block-ram.c and blktap2/drivers/block-aio.c provide
+the clearest examples of simple drivers.
  
+
+Setup:
+
+First you need to register your new driver with blktap. This is done
+in disktypes.h.  There are five things that you must do.  To
+demonstrate, I will create a disk called "mynewdisk", you can name
+yours freely.
+
+1) Forward declare an instance of struct tap_disk.
+
+e.g. -  
+  extern struct tap_disk tapdisk_mynewdisk;
+
+2) Claim one of the unused disk type numbers, take care to observe the
+MAX_DISK_TYPES macro, increasing the number if necessary.
+
+e.g. -
+  #define DISK_TYPE_MYNEWDISK         10
+
+3) Create an instance of disk_info_t.  The bulk of this file contains examples of these.
+
+e.g. -
+  static disk_info_t mynewdisk_disk = {
+          DISK_TYPE_MYNEWDISK,
+          "My New Disk (mynewdisk)",
+          "mynewdisk",
+          0,
+  #ifdef TAPDISK
+          &tapdisk_mynewdisk,
+  #endif
+  };
+
+A few words about what these mean.  The first field must be the disk
+type number you claimed in step (2).  The second field is a string
+describing your disk, and may contain any relevant info.  The third
+field is the name of your disk as will be used by the tapdisk2 utility
+and xend (for example tapdisk2 -n mynewdisk:/path/to/disk.image, or in
+your xm create config file).  The forth is binary and determines
+whether you will have one instance of your driver, or many.  Here, a 1
+means that your driver is a singleton and will coordinate access to
+any number of tap devices.  0 is more common, meaning that you will
+have one driver for each device that is created.  The final field
+should contain a reference to the struct tap_disk you created in step
+(1).
+
+4) Add a reference to your disk info structure (from step (3)) to the
+dtypes array.  Take care here - you need to place it in the position
+corresponding to the device type number you claimed in step (2).  So
+we would place &mynewdisk_disk in dtypes[10].  Look at the other
+devices in this array and pad with "&null_disk," as necessary.
+
+5) Modify the xend python scripts.  You need to add your disk name to
+the list of disks that xend recognizes.
+
+edit:
+  tools/python/xen/xend/server/BlktapController.py
+
+And add your disk to the "blktap_disk_types" array near the top of
+your file.  Use the same name you specified in the third field of step
+(3).  The order of this list is not important.
+
+
+Now your driver is ready to be written.  Create a block-mynewdisk.c in
+tools/blktap2/drivers and add it to the Makefile.
+
+
+Development:
+
+Copying block-aio.c and block-ram.c would be a good place to start.
+Read those files as you go through this, I will be assisting by
+commenting on a few useful functions and structures.
+
+struct tap_disk:
+
+Remember the forward declaration in step (1) of the setup phase above?
+Now is the time to make that structure a reality.  This structure
+contains a list of function pointers for all the routines that will be
+asked of your driver.  Currently the required functions are open,
+close, read, write, get_parent_id, validate_parent, and debug.
+
+e.g. -
+  struct tap_disk tapdisk_mynewdisk = {
+          .disk_type          = "tapdisk_mynewdisk",
+          .flags              = 0,
+          .private_data_size  = sizeof(struct tdmynewdisk_state),
+          .td_open            = tdmynewdisk_open,
+                 ....
+
+The private_data_size field is used to provide a structure to store
+the state of your device.  It is very likely that you will want
+something here, but you are free to design whatever structure you
+want.  Blktap will allocate this space for you, you just need to tell
+it how much space you want.
+
+
+tdmynewdisk_open:
+
+This is the open routine.  The first argument is a structure
+representing your driver.  Two fields in this array are
+interesting. 
+
+driver->data will contain a block of memory of the size your requested
+in in the .private_data_size field of your struct tap_disk (above).
+
+driver->info contains a structure that details information about your
+disk.  You need to fill this out.  By convention this is done with a
+_get_image_info() function.  Assign a size (the total number of
+sectors), sector_size (the size of each sector in bytes, and set
+driver->info->info to 0.
+
+The second parameter contains the name that was specified in the
+creation of your device, either through xend, or on the command line
+with tapdisk2.  Usually this specifies a file that you will open in
+this routine.  The final parameter, flags, contains one of a number of
+flags specified in tapdisk.h that may change the way you treat the
+disk.
+
+
+_queue_read/write:
+
+These are your read and write operations.  What you do here will
+depend on your disk, but you should do exactly one of- 
+
+1) call td_complete_request with either error or success code.
+
+2) Call td_forward_request, which will forward the request to the next
+driver in the stack.
+
+3) Queue the request for asynchronous processing with
+td_prep_read/write.  In doing so, you will also register a callback
+for request completion.  When the request completes you must do one of
+options (1) or (2) above.  Finally, call td_queue_tiocb to submit the
+request to a wait queue.
+
+The above functions are defined in tapdisk-interface.c.  If you don't
+use them as specified you will run into problems as your driver will
+fail to inform blktap of the state of requests that have been
+submitted.  Blktap keeps track of all requests and does not like losing track.
+
+
+_close, _get_parent_id, _validate_parent:
+
+These last few tend to be very routine.  _close is called when the
+device is closed, and also when it is paused (in this case, open will
+also be called later).  The other functions are used in stacking
+drivers.  Most often drivers will return TD_NO_PARENT and -EINVAL,
+respectively.
+
+
+
+
+
+
diff -Nur blktap2_oxt//vhd/lib/atomicio.c blktap2_xen//vhd/lib/atomicio.c
--- blktap2_oxt//vhd/lib/atomicio.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/atomicio.c	2015-03-19 11:08:36.000000000 -0400
@@ -24,11 +24,6 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- * Copyright (c) 2008 Citrix Systems, Inc.
- */
-
-
 #include <stdlib.h>
 #include <errno.h>
 #include "atomicio.h"
diff -Nur blktap2_oxt//vhd/lib/icbinn.c blktap2_xen//vhd/lib/icbinn.c
--- blktap2_oxt//vhd/lib/icbinn.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/icbinn.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,334 +0,0 @@
-/*
- * Copyright (c) 2012 Citrix Systems, Inc.
- */
-
-#include <icbinn.h>
-
-static ICBINN *icb_vhd;
-
-static ICBINN *icb_key;
-
-ICBINN *
-vhd_icbinn_key (void)
-{
-  char proto[1024], *ptr, *host;
-  int port;
-
-  if (icb_key)
-    return icb_key;
-
-  ptr = getenv ("LIBVHD_ICBINN_KEY_SERVER");
-  if (!ptr)
-    return NULL;
-
-  strncpy (proto, ptr, sizeof (proto));
-  proto[sizeof (proto) - 1] = 0;
-
-  host = index (proto, ':');
-  if (!host)
-    return NULL;
-  *(host++) = 0;
-
-  ptr = index (host, ':');
-  if (!ptr)
-    {
-      port = ICBINN_PORT;
-    }
-  else
-    {
-      *ptr = 0;
-      port = atoi (ptr + 1);
-    }
-
-  if (!strcmp (proto, "v4v"))
-    {
-      icb_key = icbinn_clnt_create_v4v (atoi (host), port);
-    }
-  else if (!strcmp (proto, "tcp"))
-    {
-      icb_key = icbinn_clnt_create_tcp (host, port);
-    }
-
-  return icb_key;
-}
-
-ICBINN *
-vhd_icbinn_vhd (void)
-{
-  char proto[1024], *ptr, *host;
-  int port;
-
-  if (icb_vhd)
-    return icb_vhd;
-
-  ptr = getenv ("LIBVHD_ICBINN_VHD_SERVER");
-  if (!ptr)
-    return NULL;
-
-  strncpy (proto, ptr, sizeof (proto));
-  proto[sizeof (proto) - 1] = 0;
-
-  host = index (proto, ':');
-  if (!host)
-    return NULL;
-  *(host++) = 0;
-
-  ptr = index (host, ':');
-  if (!ptr)
-    {
-      port = ICBINN_PORT;
-    }
-  else
-    {
-      *ptr = 0;
-      port = atoi (ptr + 1);
-    }
-
-  if (!strcmp (proto, "v4v"))
-    {
-      icb_vhd = icbinn_clnt_create_v4v (atoi (host), port);
-    }
-  else if (!strcmp (proto, "tcp"))
-    {
-      icb_vhd = icbinn_clnt_create_tcp (host, port);
-    }
-
-  return icb_vhd;
-}
-
-static off64_t
-vhd_icbinn_devops_position (vhd_context_t * vhd)
-{
-  return (off64_t) vhd->offset;
-}
-
-static int
-vhd_icbinn_devops_seek (vhd_context_t * vhd, off64_t off, int whence)
-{
-  struct icbinn_stat buf;
-
-  switch (whence)
-    {
-      //XXX: both of these ought to check for seeks beyond EOF, but they don't
-    case SEEK_SET:
-      vhd->offset = off;
-      break;
-    case SEEK_CUR:
-      vhd->offset += off;
-      break;
-    case SEEK_END:
-
-      if (icbinn_stat (icb_vhd, vhd->file, &buf))
-        return -1;
-
-      if (buf.type != ICBINN_TYPE_FILE)
-        return -1;
-
-      vhd->offset = buf.size + off;
-      break;
-    default:
-      return -1;
-    }
-
-  return 0;
-}
-
-static int
-vhd_icbinn_devops_read (vhd_context_t * vhd, void *buf, size_t count)
-{
-  size_t ret;
-
-  ret = icbinn_pread (icb_vhd, vhd->fd, buf, count, vhd->offset);
-
-  if (ret > 0)
-    vhd->offset += ret;
-
-  return (ret == count) ? 0 : -EIO;
-}
-
-static int
-vhd_icbinn_devops_pread (vhd_context_t * vhd,
-                         void *buf, size_t size, off64_t off)
-{
-  size_t ret = icbinn_pread (icb_vhd, vhd->fd, buf, size, off);
-
-  return (ret == size) ? 0 : -EIO;
-}
-
-static int
-vhd_icbinn_devops_write (vhd_context_t * vhd, void *buf, size_t count)
-{
-  size_t ret;
-
-  ret = icbinn_pwrite (icb_vhd, vhd->fd, buf, count, vhd->offset);
-
-  if (ret > 0)
-    vhd->offset += ret;
-
-  return (ret == count) ? 0 : -EIO;
-}
-
-static int
-vhd_icbinn_devops_pwrite (vhd_context_t * vhd,
-                          void *buf, size_t size, off64_t off)
-{
-  size_t ret = icbinn_pwrite (icb_vhd, vhd->fd, buf, size, off);
-
-  return (ret == size) ? 0 : -EIO;
-}
-
-static void
-vhd_icbinn_devops_close (vhd_context_t * vhd)
-{
-  char *file = vhd->file;
-  int fd = vhd->fd;
-
-  vhd->fd = -1;
-  __vhd_close (vhd);
-
-  if (file)
-    icbinn_close (icb_vhd, fd);
-}
-
-static vhd_devops_t vhd_icbinn_devops = {
-  .position = vhd_icbinn_devops_position,
-  .seek = vhd_icbinn_devops_seek,
-  .read = vhd_icbinn_devops_read,
-  .write = vhd_icbinn_devops_write,
-  .pread = vhd_icbinn_devops_pread,
-  .pwrite = vhd_icbinn_devops_pwrite,
-  .close = vhd_icbinn_devops_close,
-};
-
-
-
-/* Shamelessly stolen of glibc 2.9 with modifications */
-
-/* Return the canonical absolute name of file NAME.  A canonical name
-   does not contain any `.', `..' components nor any repeated path
-   separators ('/') or symlinks.  All path components must exist.  If
-   RESOLVED is null, the result is malloc'd; otherwise, if the
-   canonical name is PATH_MAX chars or more, returns null with `errno'
-   set to ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,
-   returns the name in RESOLVED.  If the name cannot be resolved and
-   RESOLVED is non-NULL, it contains the path of the first component
-   that cannot be resolved.  If the path can be resolved, RESOLVED
-   holds the same value as the value returned.  */
-
-char *
-vhd_realpath (const char *name, char *resolved)
-{
-  char *rpath, *dest;
-  const char *start, *end, *rpath_limit;
-  long int path_max;
-
-  if (!vhd_icbinn_vhd ())
-    return realpath (name, resolved);
-
-  if ((name == NULL) || (name[0] == '\0'))
-    return realpath (name, resolved);
-
-#ifdef PATH_MAX
-  path_max = PATH_MAX;
-#else
-  path_max = pathconf (name, _PC_PATH_MAX);
-  if (path_max <= 0)
-    path_max = 1024;
-#endif
-
-  if (resolved == NULL)
-    {
-      rpath = malloc (path_max);
-      if (rpath == NULL)
-        return NULL;
-    }
-  else
-    rpath = resolved;
-  rpath_limit = rpath + path_max;
-
-  rpath[0] = '/';
-  dest = rpath + 1;
-
-  for (start = end = name; *start; start = end)
-    {
-      struct icbinn_stat st;
-
-      /* Skip sequence of multiple path-separators.  */
-      while (*start == '/')
-        ++start;
-
-      /* Find end of path component.  */
-      for (end = start; *end && *end != '/'; ++end)
-        /* Nothing.  */ ;
-
-      if (end - start == 0)
-        break;
-      else if (end - start == 1 && start[0] == '.')
-        /* nothing */ ;
-      else if (end - start == 2 && start[0] == '.' && start[1] == '.')
-        {
-          /* Back up to previous component, ignore if at root already.  */
-          if (dest > rpath + 1)
-            while ((--dest)[-1] != '/');
-        }
-      else
-        {
-          size_t new_size;
-
-          if (dest[-1] != '/')
-            *dest++ = '/';
-
-          if (dest + (end - start) >= rpath_limit)
-            {
-              ptrdiff_t dest_offset = dest - rpath;
-              char *new_rpath;
-
-              if (resolved)
-                {
-                  errno = ENAMETOOLONG;
-                  if (dest > rpath + 1)
-                    dest--;
-                  *dest = '\0';
-                  goto error;
-                }
-              new_size = rpath_limit - rpath;
-              if (end - start + 1 > path_max)
-                new_size += end - start + 1;
-              else
-                new_size += path_max;
-              new_rpath = (char *) realloc (rpath, new_size);
-              if (new_rpath == NULL)
-                goto error;
-              rpath = new_rpath;
-              rpath_limit = rpath + new_size;
-
-              dest = rpath + dest_offset;
-            }
-
-          dest = mempcpy (dest, start, end - start);
-          *dest = '\0';
-
-          if (icbinn_stat (icb_vhd, rpath, &st) < 0)
-            {
-              errno = ENOENT;
-              goto error;
-            }
-
-          if ((st.type != ICBINN_TYPE_DIRECTORY) && (*end != '\0'))
-            {
-              errno = ENOTDIR;
-              goto error;
-            }
-        }
-    }
-  if (dest > rpath + 1 && dest[-1] == '/')
-    --dest;
-  *dest = '\0';
-
-  return rpath;
-
-error:
-  if (resolved == NULL)
-    free (rpath);
-  return NULL;
-}
diff -Nur blktap2_oxt//vhd/lib/libvhd.c blktap2_xen//vhd/lib/libvhd.c
--- blktap2_oxt//vhd/lib/libvhd.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/libvhd.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #ifndef _GNU_SOURCE
 #define _GNU_SOURCE
 #endif
@@ -39,21 +35,14 @@
 #include <string.h>
 #include <libgen.h>
 #include <iconv.h>
-#include <sys/file.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
-#include <stddef.h>
 
-#include "xattr.h"
 #include "libvhd.h"
 #include "relative-path.h"
 
-#define VHD_HEADER_MAX_RETRIES 10
-
 static int libvhd_dbg = 0;
 
-
-
 void
 libvhd_set_log_level(int level)
 {
@@ -68,13 +57,7 @@
 			       __func__, ##_a);				\
 	} while (0)
 
-#define ASSERT(_p)							\
-	if (!(_p)) {							\
-		libvhd_set_log_level(1);                                \
-		VHDLOG("%s:%d: FAILED ASSERTION: '%s'\n",		\
-			__FILE__, __LINE__, #_p);			\
-		*(int*)0 = 0;						\
-	}
+#define BIT_MASK 0x80
 
 #ifdef ENABLE_FAILURE_TESTING
 const char* ENV_VAR_FAIL[NUM_FAIL_TESTS] = {
@@ -89,14 +72,23 @@
 int TEST_FAIL[NUM_FAIL_TESTS];
 #endif // ENABLE_FAILURE_TESTING
 
-static void vhd_cache_init(vhd_context_t *);
-static int vhd_cache_enabled(vhd_context_t *);
-static int vhd_cache_load(vhd_context_t *);
-static int vhd_cache_unload(vhd_context_t *);
-static vhd_context_t * vhd_cache_get_parent(vhd_context_t *);
-static void __vhd_close(vhd_context_t *ctx);
+static inline int
+test_bit (volatile char *addr, int nr)
+{
+	return ((addr[nr >> 3] << (nr & 7)) & BIT_MASK) != 0;
+}
+
+static inline void
+set_bit (volatile char *addr, int nr)
+{
+	addr[nr >> 3] |= (BIT_MASK >> (nr & 7));
+}
 
-#include "icbinn.c"
+static inline void
+clear_bit (volatile char *addr, int nr)
+{
+	addr[nr >> 3] &= ~(BIT_MASK >> (nr & 7));
+}
 
 static inline int
 old_test_bit(volatile char *addr, int nr)
@@ -210,7 +202,6 @@
 	BE32_OUT(&batmap->header.batmap_size);
 	BE32_OUT(&batmap->header.batmap_version);
 	BE32_OUT(&batmap->header.checksum);
-	memset(batmap->header.res, 0, sizeof(batmap->header.res));
 }
 
 void
@@ -260,8 +251,8 @@
 	if (memcmp(footer->cookie, HD_COOKIE, csize) != 0 &&
 	    memcmp(footer->cookie, VHD_POISON_COOKIE, csize) != 0) {
 		char buf[9];
-		memcpy(buf, footer->cookie, 8);
-		buf[8]= '\0';
+		strncpy(buf, footer->cookie, sizeof(buf));
+		buf[sizeof(buf)-1]= '\0';
 		VHDLOG("invalid footer cookie: %s\n", buf);
 		return -EINVAL;
 	}
@@ -321,8 +312,8 @@
 
 	if (memcmp(header->cookie, DD_COOKIE, 8) != 0) {
 		char buf[9];
-		memcpy(buf, header->cookie, 8);
-		buf[8] = '\0';
+		strncpy(buf, header->cookie, sizeof(buf));
+		buf[sizeof(buf)-1]= '\0';
 		VHDLOG("invalid header cookie: %s\n", buf);
 		return -EINVAL;
 	}
@@ -332,8 +323,8 @@
 		return -EINVAL;
 	}
 
-	if (header->data_offset != 0xFFFFFFFFFFFFFFFFULL) {
-		VHDLOG("invalid header data_offset 0x%016llx\n",
+	if (header->data_offset != 0xFFFFFFFFFFFFFFFF) {
+		VHDLOG("invalid header data_offset 0x%016"PRIx64"\n",
 		       header->data_offset);
 		return -EINVAL;
 	}
@@ -364,20 +355,18 @@
 }
 
 uint32_t
-vhd_checksum_batmap(vhd_context_t *ctx, vhd_batmap_t *batmap)
+vhd_checksum_batmap(vhd_batmap_t *batmap)
 {
-	int i;
+	int i, n;
 	char *blob;
 	uint32_t checksum;
-	size_t map_size;
 
 	blob     = batmap->map;
 	checksum = 0;
 
-	map_size = vhd_sectors_to_bytes(secs_round_up_no_zero(
-			ctx->footer.curr_size >> (VHD_BLOCK_SHIFT + 3)));
+	n = vhd_sectors_to_bytes(batmap->header.batmap_size);
 
-	for (i = 0; i < map_size; i++) {
+	for (i = 0; i < n; i++) {
 		if (batmap->header.batmap_version == VHD_BATMAP_VERSION(1, 1))
 			checksum += (uint32_t)blob[i];
 		else
@@ -400,27 +389,24 @@
 }
 
 int
-vhd_validate_batmap(vhd_context_t *ctx, vhd_batmap_t *batmap)
+vhd_validate_batmap(vhd_batmap_t *batmap)
 {
 	uint32_t checksum;
 
 	if (!batmap->map)
 		return -EINVAL;
 
-	checksum = vhd_checksum_batmap(ctx, batmap);
-	if (checksum != batmap->header.checksum) {
-		VHDLOG("checksum mismtch: 0x%x != 0x%x\n",
-		       checksum, batmap->header.checksum);
+	checksum = vhd_checksum_batmap(batmap);
+	if (checksum != batmap->header.checksum)
 		return -EINVAL;
-	}
 
 	return 0;
 }
 
 int
-vhd_batmap_header_offset(vhd_context_t *ctx, off64_t *_off)
+vhd_batmap_header_offset(vhd_context_t *ctx, off_t *_off)
 {
-	off64_t off;
+	off_t off;
 	size_t  bat;
 
 	*_off = 0;
@@ -607,11 +593,11 @@
  * byte of the file which is not vhd metadata
  */
 int
-vhd_end_of_headers(vhd_context_t *ctx, off64_t *end)
+vhd_end_of_headers(vhd_context_t *ctx, off_t *end)
 {
 	int err, i, n;
 	uint32_t bat_bytes;
-	off64_t eom, bat_end;
+	off_t eom, bat_end;
 	vhd_parent_locator_t *loc;
 
 	*end = 0;
@@ -627,14 +613,11 @@
 	eom       = MAX(eom, bat_end);
 
 	if (vhd_has_batmap(ctx)) {
-		off64_t hdr_end, hdr_secs, map_end, map_secs;
+		off_t hdr_end, hdr_secs, map_end, map_secs;
 
 		err = vhd_get_batmap(ctx);
-		if (err) {
-			err = vhd_read_batmap_header(ctx, &ctx->batmap);
-			if (err)
-				return err;
-		}
+		if (err)
+			return err;
 
 		hdr_secs = secs_round_up_no_zero(sizeof(vhd_batmap_header_t));
 		err      = vhd_batmap_header_offset(ctx, &hdr_end);
@@ -654,7 +637,7 @@
 	n = sizeof(ctx->header.loc) / sizeof(vhd_parent_locator_t);
 
 	for (i = 0; i < n; i++) {
-		off64_t loc_end;
+		off_t loc_end;
 
 		loc = &ctx->header.loc[i];
 		if (loc->code == PLAT_CODE_NONE)
@@ -669,10 +652,10 @@
 }
 
 int
-vhd_end_of_data(vhd_context_t *ctx, off64_t *end)
+vhd_end_of_data(vhd_context_t *ctx, off_t *end)
 {
 	int i, err;
-	off64_t max;
+	off_t max;
 	uint64_t blk;
 
 	if (!vhd_type_dynamic(ctx)) {
@@ -681,7 +664,7 @@
 			return err;
 
 		max = vhd_position(ctx);
-		if (max == (off64_t)-1)
+		if (max == (off_t)-1)
 			return -errno;
 
 		*end = max - sizeof(vhd_footer_t);
@@ -839,7 +822,7 @@
 	if (!vhd_has_batmap(ctx))
 		return -EINVAL;
 
-	if (!vhd_validate_batmap(ctx, &ctx->batmap))
+	if (!vhd_validate_batmap(&ctx->batmap))
 		return 0;
 
 	vhd_put_batmap(ctx);
@@ -889,7 +872,7 @@
 {
 	int err;
 	char *buf;
-	off64_t eof;
+	off_t eof;
 
 	buf = NULL;
 
@@ -898,7 +881,7 @@
 		goto out;
 
 	eof = vhd_position(ctx);
-	if (eof == (off64_t)-1) {
+	if (eof == (off_t)-1) {
 		err = -errno;
 		goto out;
 	}
@@ -936,7 +919,7 @@
 }
 
 int
-vhd_read_footer_at(vhd_context_t *ctx, vhd_footer_t *footer, off64_t off)
+vhd_read_footer_at(vhd_context_t *ctx, vhd_footer_t *footer, off_t off)
 {
 	int err;
 	char *buf;
@@ -976,14 +959,14 @@
 vhd_read_footer(vhd_context_t *ctx, vhd_footer_t *footer)
 {
 	int err;
-	off64_t off;
+	off_t off;
 
 	err = vhd_seek(ctx, 0, SEEK_END);
 	if (err)
 		return err;
 
 	off = vhd_position(ctx);
-	if (off == (off64_t)-1)
+	if (off == (off_t)-1)
 		return -errno;
 
 	err = vhd_read_footer_at(ctx, footer, off - 512);
@@ -994,19 +977,14 @@
 	if (err != -EINVAL)
 		return err;
 
-	/* 
-	 * Disable the enforcement of VHD_OPEN_STRICT until we figure out how 
-	 * to recover from crashes. Note that we never enforced it before 
-	 * anyways due to a bug (CA-28285) and everything was ok.
-	 */
-	/* if (ctx->oflags & VHD_OPEN_STRICT)
-		return -EINVAL; */
+	if (ctx->oflags & VHD_OPEN_STRICT)
+		return -EINVAL;
 
 	return vhd_read_footer_at(ctx, footer, 0);
 }
 
 int
-vhd_read_header_at(vhd_context_t *ctx, vhd_header_t *header, off64_t off)
+vhd_read_header_at(vhd_context_t *ctx, vhd_header_t *header, off_t off)
 {
 	int err;
 	char *buf;
@@ -1050,7 +1028,8 @@
 int
 vhd_read_header(vhd_context_t *ctx, vhd_header_t *header)
 {
-	off64_t off;
+	int err;
+	off_t off;
 
 	if (!vhd_type_dynamic(ctx)) {
 		VHDLOG("%s is not dynamic!\n", ctx->file);
@@ -1066,8 +1045,7 @@
 {
 	int err;
 	char *buf;
-	off64_t off;
-	uint32_t vhd_blks;
+	off_t off;
 	size_t size;
 
 	buf  = NULL;
@@ -1078,12 +1056,7 @@
 	}
 
 	off  = ctx->header.table_offset;
-	/* The BAT size is stored in ctx->header.max_bat_size. However, we
-	 * sometimes preallocate BAT + batmap for max VHD size, so only read in
-	 * the BAT entries that are in use for curr_size */
-	vhd_blks = ctx->footer.curr_size >> VHD_BLOCK_SHIFT;
-	ASSERT(ctx->header.max_bat_size >= vhd_blks);
-	size = vhd_bytes_padded(vhd_blks * sizeof(uint32_t));
+	size = vhd_bytes_padded(ctx->header.max_bat_size * sizeof(uint32_t));
 
 	err  = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, size);
 	if (err) {
@@ -1101,7 +1074,7 @@
 		goto fail;
 
 	bat->spb     = ctx->header.block_size >> VHD_SECTOR_SHIFT;
-	bat->entries = vhd_blks;
+	bat->entries = ctx->header.max_bat_size;
 	bat->bat     = (uint32_t *)buf;
 
 	vhd_bat_in(bat);
@@ -1115,12 +1088,12 @@
 	return err;
 }
 
-int
+static int
 vhd_read_batmap_header(vhd_context_t *ctx, vhd_batmap_t *batmap)
 {
 	int err;
 	char *buf;
-	off64_t off;
+	off_t off;
 	size_t size;
 
 	buf = NULL;
@@ -1160,17 +1133,15 @@
 	return err;
 }
 
-int
+static int
 vhd_read_batmap_map(vhd_context_t *ctx, vhd_batmap_t *batmap)
 {
 	int err;
 	char *buf;
-	off64_t off;
+	off_t off;
 	size_t map_size;
 
-	map_size = vhd_sectors_to_bytes(secs_round_up_no_zero(
-			ctx->footer.curr_size >> (VHD_BLOCK_SHIFT + 3)));
-	ASSERT(vhd_sectors_to_bytes(batmap->header.batmap_size) >= map_size);
+	map_size = vhd_sectors_to_bytes(batmap->header.batmap_size);
 
 	err = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, map_size);
 	if (err) {
@@ -1220,7 +1191,7 @@
 	if (err)
 		return err;
 
-	err = vhd_validate_batmap(ctx, batmap);
+	err = vhd_validate_batmap(batmap);
 	if (err)
 		goto fail;
 
@@ -1260,21 +1231,6 @@
 	return (!vhd_validate_batmap_header(&ctx->batmap));
 }
 
-void
-vhd_batmap_reset_map(vhd_context_t *ctx, vhd_batmap_t *batmap)
-{
-	if (batmap->map) {
-		size_t map_size =
-			vhd_sectors_to_bytes(
-				secs_round_up_no_zero(
-					(ctx->footer.curr_size >>
-					 (VHD_BLOCK_SHIFT + 3))
-					)
-				);
-		memset(batmap->map, 0, map_size);
-	}
-}
-
 /* 
  * Is this a block device (with a fixed size)? This affects whether the file 
  * can be truncated and where the footer is written for VHDs.
@@ -1305,7 +1261,7 @@
 	location   = NULL;
 	*_location = NULL;
 
-	if (!parent || !strcmp(parent, ""))
+	if (!parent)
 		return -EINVAL;
 
 	if (parent[0] == '/') {
@@ -1318,34 +1274,8 @@
 		}
 	}
 
-	if (parent[0] == '.') {
-		/* XCE synchroniser encodes relative paths which need to be resolved w/o using
-		 * realpath due to layers of symlinks */
-		cpath = strdup(ctx->file);
-		if (!cpath) {
-			err = -errno;
-			goto out;
-		}
-
-		cdir = dirname(cpath);
-		if (asprintf(&location, "%s/%s", cdir, parent) == -1) {
-			err = -errno;
-			location = NULL;
-			goto out;
-		}
-		if (!access(location, R_OK)) {
-			free(cpath);
-			*_location = location;
-			return 0;
-		} else {
-			err = -errno;
-			goto out;
-		}
-
-	}
-
 	/* check parent path relative to child's directory */
-	cpath = vhd_realpath(ctx->file, NULL);
+	cpath = realpath(ctx->file, NULL);
 	if (!cpath) {
 		err = -errno;
 		goto out;
@@ -1359,7 +1289,7 @@
 	}
 
 	if (!access(location, R_OK)) {
-		path = vhd_realpath(location, NULL);
+		path = realpath(location, NULL);
 		if (path) {
 			*_location = path;
 			return 0;
@@ -1373,13 +1303,14 @@
 	return err;
 }
 
-int 
+static int 
 vhd_macx_encode_location(char *name, char **out, int *outlen)
 {
 	iconv_t cd;
 	int len, err;
 	size_t ibl, obl;
-	char *uri, *urip, *uri_utf8, *uri_utf8p, *ret;
+	char *uri, *uri_utf8, *uri_utf8p, *ret;
+	const char *urip;
 
 	err     = 0;
 	ret     = NULL;
@@ -1390,7 +1321,7 @@
 	ibl     = len;
 	obl     = len;
 
-	uri = urip = malloc(ibl + 1);
+	urip = uri = malloc(ibl + 1);
 	uri_utf8 = uri_utf8p = malloc(obl);
 
 	if (!uri || !uri_utf8)
@@ -1402,9 +1333,13 @@
 		goto out;
 	}
 
-	sprintf(uri, "file://%s", name);
+	snprintf(uri, ibl+1, "file://%s", name);
 
-	if (iconv(cd, &urip, &ibl, &uri_utf8p, &obl) == (size_t)-1 ||
+	if (iconv(cd,
+#ifdef __linux__
+	    (char **)
+#endif
+	    &urip, &ibl, &uri_utf8p, &obl) == (size_t)-1 ||
 	    ibl || obl) {
 		err = (errno ? -errno : -EIO);
 		goto out;
@@ -1429,13 +1364,14 @@
 	return err;
 }
 
-int
+static int
 vhd_w2u_encode_location(char *name, char **out, int *outlen)
 {
 	iconv_t cd;
 	int len, err;
 	size_t ibl, obl;
-	char *uri, *urip, *uri_utf16, *uri_utf16p, *tmp, *ret;
+	char *uri, *uri_utf16, *uri_utf16p, *tmp, *ret;
+	const char *urip;
 
 	err     = 0;
 	ret     = NULL;
@@ -1489,7 +1425,11 @@
 		goto out;
 	}
 
-	if (iconv(cd, &urip, &ibl, &uri_utf16p, &obl) == (size_t)-1 ||
+	if (iconv(cd,
+#ifdef __linux__
+	    (char **)
+#endif
+	    &urip, &ibl, &uri_utf16p, &obl) == (size_t)-1 ||
 	    ibl || obl) {
 		err = (errno ? -errno : -EIO);
 		goto out;
@@ -1517,7 +1457,7 @@
 }
 
 static char *
-vhd_macx_decode_location(char *in, char *out, int len)
+vhd_macx_decode_location(const char *in, char *out, int len)
 {
 	iconv_t cd;
 	char *name;
@@ -1530,7 +1470,11 @@
 	if (cd == (iconv_t)-1) 
 		return NULL;
 
-	if (iconv(cd, &in, &ibl, &out, &obl) == (size_t)-1 || ibl)
+	if (iconv(cd,
+#ifdef __linux__
+		(char **)
+#endif
+		&in, &ibl, &out, &obl) == (size_t)-1 || ibl)
 		return NULL;
 
 	iconv_close(cd);
@@ -1545,7 +1489,7 @@
 }
 
 static char *
-vhd_w2u_decode_location(char *in, char *out, int len, char *utf_type)
+vhd_w2u_decode_location(const char *in, char *out, int len, char *utf_type)
 {
 	iconv_t cd;
 	char *name, *tmp;
@@ -1558,7 +1502,11 @@
 	if (cd == (iconv_t)-1) 
 		return NULL;
 
-	if (iconv(cd, &in, &ibl, &out, &obl) == (size_t)-1 || ibl)
+	if (iconv(cd,
+#ifdef __linux__
+		(char **)
+#endif
+		&in, &ibl, &out, &obl) == (size_t)-1 || ibl)
 		return NULL;
 
 	iconv_close(cd);
@@ -1673,7 +1621,7 @@
 		VHDLOG("%s: error reading parent locator: %d\n",
 		       ctx->file, err);
 		VHDLOG("%s: locator: code %u, space 0x%x, len 0x%x, "
-		       "off 0x%llx\n", ctx->file, loc->code, loc->data_space,
+		       "off 0x%"PRIx64"\n", ctx->file, loc->code, loc->data_space,
 		       loc->data_len, loc->data_offset);
 	}
 
@@ -1717,14 +1665,13 @@
 
 int
 vhd_parent_locator_write_at(vhd_context_t *ctx,
-			    const char *parent, off64_t off, uint32_t code,
+			    const char *parent, off_t off, uint32_t code,
 			    size_t max_bytes, vhd_parent_locator_t *loc)
 {
+	struct stat stats;
 	int err, len, size;
 	char *absolute_path, *relative_path, *encoded, *block;
 
-	ICBINN *icb = vhd_icbinn_vhd();
-
 	memset(loc, 0, sizeof(vhd_parent_locator_t));
 
 	if (ctx->footer.type != HD_TYPE_DIFF)
@@ -1746,36 +1693,21 @@
 		return -EINVAL;
 	}
 
-	absolute_path = vhd_realpath(parent, NULL);
+	absolute_path = realpath(parent, NULL);
 	if (!absolute_path) {
 		err = -errno;
 		goto out;
 	}
 
-	if (icb) {
-		struct icbinn_stat stats;
-		err = icbinn_stat(icb,absolute_path, &stats);
-		if (err) {
-			err = -ENOENT;
-			goto out;
-		}
-		if (stats.type != ICBINN_TYPE_FILE) {
-			err = -EINVAL;
-			goto out;
-		}
-	} else {
-		struct stat stats;
-
-		err = stat(absolute_path, &stats);
-		if (err) {
-			err = -errno;
-			goto out;
-		}
+	err = stat(absolute_path, &stats);
+	if (err) {
+		err = -errno;
+		goto out;
+	}
 
-		if (!S_ISREG(stats.st_mode) && !S_ISBLK(stats.st_mode)) {
-			err = -EINVAL;
-			goto out;
-		}
+	if (!S_ISREG(stats.st_mode) && !S_ISBLK(stats.st_mode)) {
+		err = -EINVAL;
+		goto out;
 	}
 
 	relative_path = relative_path_to(ctx->file, absolute_path, &err);
@@ -1849,11 +1781,11 @@
 }
 
 static int
-vhd_footer_offset_at_eof(vhd_context_t *ctx, off64_t *off)
+vhd_footer_offset_at_eof(vhd_context_t *ctx, off_t *off)
 {
 	int err;
 	if ((err = vhd_seek(ctx, 0, SEEK_END)))
-		return err;
+		return errno;
 	*off = vhd_position(ctx) - sizeof(vhd_footer_t);
 	return 0;
 }
@@ -1864,7 +1796,7 @@
 	int err;
 	char *buf;
 	size_t size;
-	off64_t off;
+	off_t off;
 	uint64_t blk;
 
 	buf   = NULL;
@@ -1914,7 +1846,7 @@
 	char *buf;
 	size_t size;
 	uint64_t blk;
-	off64_t end, off;
+	off_t end, off;
 
 	buf   = NULL;
 	*bufp = NULL;
@@ -1968,7 +1900,7 @@
 }
 
 int
-vhd_write_footer_at(vhd_context_t *ctx, vhd_footer_t *footer, off64_t off)
+vhd_write_footer_at(vhd_context_t *ctx, vhd_footer_t *footer, off_t off)
 {
 	int err;
 	vhd_footer_t *f;
@@ -2010,7 +1942,7 @@
 vhd_write_footer(vhd_context_t *ctx, vhd_footer_t *footer)
 {
 	int err;
-	off64_t off;
+	off_t off;
 
 	if (ctx->is_block)
 		err = vhd_footer_offset_at_eof(ctx, &off);
@@ -2023,16 +1955,6 @@
 	if (err)
 		return err;
 
-	if (!ctx->is_block) {
-		err = ftruncate(ctx->fd, off + sizeof(vhd_footer_t));
-		if (err)
-			return -errno;
-
-		err = fdatasync(ctx->fd);
-		if (err)
-			return -errno;
-	}
-
 	if (!vhd_type_dynamic(ctx))
 		return 0;
 
@@ -2040,7 +1962,7 @@
 }
 
 int
-vhd_write_header_at(vhd_context_t *ctx, vhd_header_t *header, off64_t off)
+vhd_write_header_at(vhd_context_t *ctx, vhd_header_t *header, off_t off)
 {
 	int err;
 	vhd_header_t *h;
@@ -2086,7 +2008,8 @@
 int
 vhd_write_header(vhd_context_t *ctx, vhd_header_t *header)
 {
-	off64_t off;
+	int err;
+	off_t off;
 
 	if (!vhd_type_dynamic(ctx))
 		return -EINVAL;
@@ -2099,7 +2022,7 @@
 vhd_write_bat(vhd_context_t *ctx, vhd_bat_t *bat)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	vhd_bat_t b;
 	size_t size;
 
@@ -2138,49 +2061,11 @@
 	return err;
 }
 
-static int
-vhd_write_batmap_header(vhd_context_t *ctx, vhd_batmap_t *batmap)
-{
-	int err;
-	size_t size;
-	off64_t off;
-	char *buf = NULL;
-
-	err = vhd_batmap_header_offset(ctx, &off);
-	if (err)
-		goto out;
-
-	size = vhd_bytes_padded(sizeof(batmap->header));
-
-	err = vhd_seek(ctx, off, SEEK_SET);
-	if (err)
-		goto out;
-
-	err = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, size);
-	if (err) {
-		err = -err;
-		buf = NULL;
-		goto out;
-	}
-
-	vhd_batmap_header_out(batmap);
-	memset(buf, 0, size);
-	memcpy(buf, &batmap->header, sizeof(batmap->header));
-
-	err = vhd_write(ctx, buf, size);
-
-out:
-	if (err)
-		VHDLOG("%s: failed writing batmap: %d\n", ctx->file, err);
-	free(buf);
-	return err;
-}
-
 int
 vhd_write_batmap(vhd_context_t *ctx, vhd_batmap_t *batmap)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	vhd_batmap_t b;
 	char *buf, *map;
 	size_t size, map_size;
@@ -2196,15 +2081,13 @@
 	b.header = batmap->header;
 	b.map    = batmap->map;
 
-	b.header.checksum = vhd_checksum_batmap(ctx, &b);
-	err = vhd_validate_batmap(ctx, &b);
+	b.header.checksum = vhd_checksum_batmap(&b);
+	err = vhd_validate_batmap(&b);
 	if (err)
 		goto out;
 
 	off      = b.header.batmap_offset;
-	map_size = vhd_sectors_to_bytes(secs_round_up_no_zero(
-			ctx->footer.curr_size >> (VHD_BLOCK_SHIFT + 3)));
-	ASSERT(vhd_sectors_to_bytes(b.header.batmap_size) >= map_size);
+	map_size = vhd_sectors_to_bytes(b.header.batmap_size);
 
 	err  = vhd_seek(ctx, off, SEEK_SET);
 	if (err)
@@ -2258,9 +2141,9 @@
 vhd_write_bitmap(vhd_context_t *ctx, uint32_t block, char *bitmap)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	uint64_t blk;
-	size_t size;
+	size_t secs, size;
 
 	if (!vhd_type_dynamic(ctx))
 		return -EINVAL;
@@ -2297,7 +2180,7 @@
 vhd_write_block(vhd_context_t *ctx, uint32_t block, char *data)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	size_t size;
 	uint64_t blk;
 
@@ -2311,7 +2194,7 @@
 	if (block >= ctx->bat.entries)
 		return -ERANGE;
 
-	if ((unsigned long)data & (VHD_SECTOR_SIZE - 1))
+	if ((unsigned long)data & ~(VHD_SECTOR_SIZE -1))
 		return -EINVAL;
 
 	blk  = ctx->bat.bat[block];
@@ -2347,82 +2230,13 @@
 	return 0;
 }
 
-#define vwrite (ssize_t (*)(int, void *, size_t))write
-#define vpwrite (ssize_t (*)(int, void *, size_t, off_t))pwrite
-
-static ssize_t
-vhd_atomic_pio(ssize_t (*f) (int, void *, size_t, off_t),
-	       int fd, void *_s, size_t n, off_t off)
-{
-	char *s = _s;
-	size_t pos = 0;
-	ssize_t res;
-	struct stat st;
-
-	memset(&st, 0, sizeof(st));
-
-	for (;;) {
-		res = (f) (fd, s + pos, n - pos, off + pos);
-		switch (res) {
-		case -1:
-			if (errno == EINTR || errno == EAGAIN)
-				continue;
-			else
-				return 0;
-			break;
-		case 0:
-			errno = EPIPE;
-			return pos;
-		}
-
-		if (pos + res == n)
-			return n;
-
-		if (!st.st_size) {
-			if (fstat(fd, &st) == -1)
-				return -1;
-
-			if (S_ISBLK(st.st_mode))
-				return pos;
-		}
-
-		if (off + pos + res == st.st_size)
-			return pos + res;
-
-		pos += (res & ~(VHD_SECTOR_SIZE - 1));
-	}
-
-	return -1;
-}
-
-static ssize_t
-vhd_atomic_io(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n)
-{
-	off64_t off;
-	ssize_t res;
-	ssize_t (*pf) (int, void *, size_t, off_t);
-
-	off = lseek64(fd, 0, SEEK_CUR);
-	if (off == (off_t)-1)
-		return -1;
-
-	pf = (f == read ? pread : vpwrite);
-	res = vhd_atomic_pio(pf, fd, _s, n, off);
-
-	if (res > 0)
-		if (lseek64(fd, off + res, SEEK_SET) == (off64_t)-1)
-			return -1;
-
-	return res;
-}
-
-static int
-__vhd_seek(vhd_context_t *ctx, off64_t offset, int whence)
+int
+vhd_seek(vhd_context_t *ctx, off_t offset, int whence)
 {
-	off64_t off;
+	off_t off;
 
-	off = lseek64(ctx->fd, offset, whence);
-	if (off == (off64_t)-1) {
+	off = lseek(ctx->fd, offset, whence);
+	if (off == (off_t)-1) {
 		VHDLOG("%s: seek(0x%08"PRIx64", %d) failed: %d\n",
 		       ctx->file, offset, whence, -errno);
 		return -errno;
@@ -2431,20 +2245,20 @@
 	return 0;
 }
 
-static off64_t
-__vhd_position(vhd_context_t *ctx)
+off_t
+vhd_position(vhd_context_t *ctx)
 {
-	return lseek64(ctx->fd, 0, SEEK_CUR);
+	return lseek(ctx->fd, 0, SEEK_CUR);
 }
 
-static int
-__vhd_read(vhd_context_t *ctx, void *buf, size_t size)
+int
+vhd_read(vhd_context_t *ctx, void *buf, size_t size)
 {
 	size_t ret;
 
 	errno = 0;
 
-	ret = vhd_atomic_io(read, ctx->fd, buf, size);
+	ret = read(ctx->fd, buf, size);
 	if (ret == size)
 		return 0;
 
@@ -2454,14 +2268,14 @@
 	return (errno ? -errno : -EIO);
 }
 
-static int
-__vhd_write(vhd_context_t *ctx, void *buf, size_t size)
+int
+vhd_write(vhd_context_t *ctx, void *buf, size_t size)
 {
 	size_t ret;
 
 	errno = 0;
 
-	ret = vhd_atomic_io(vwrite, ctx->fd, buf, size);
+	ret = write(ctx->fd, buf, size);
 	if (ret == size)
 		return 0;
 
@@ -2471,88 +2285,6 @@
 	return (errno ? -errno : -EIO);
 }
 
-static int
-__vhd_pread(vhd_context_t *ctx, void *buf, size_t size, off64_t offset)
-{
-	ssize_t ret;
-
-	errno = 0;
-
-	ret = vhd_atomic_pio(pread, ctx->fd, buf, size, offset);
-	if (ret == size)
-		return 0;
-
-	VHDLOG("%s: pread of %zu returned %zd, errno: %d\n",
-	       ctx->file, size, ret, -errno);
-
-	return (errno ? -errno : -EIO);
-}
-
-static int
-__vhd_pwrite(vhd_context_t *ctx, void *buf, size_t size, off64_t offset)
-{
-	ssize_t ret;
-
-	errno = 0;
-
-	ret = vhd_atomic_pio(vpwrite, ctx->fd, buf, size, offset);
-	if (ret == size)
-		return 0;
-
-	VHDLOG("%s: pwrite of %zu returned %zd, errno: %d\n",
-	       ctx->file, size, ret, -errno);
-
-	return (errno ? -errno : -EIO);
-}
-
-int
-vhd_seek(vhd_context_t *ctx, off64_t offset, int whence)
-{
-	if (ctx->devops && ctx->devops->seek)
-		return ctx->devops->seek(ctx, offset, whence);
-	return __vhd_seek(ctx, offset, whence);
-}
-
-off64_t
-vhd_position(vhd_context_t *ctx)
-{
-	if (ctx->devops && ctx->devops->position)
-		return ctx->devops->position(ctx);
-	return __vhd_position(ctx);
-}
-
-int
-vhd_read(vhd_context_t *ctx, void *buf, size_t size)
-{
-	if (ctx->devops && ctx->devops->read)
-		return ctx->devops->read(ctx, buf, size);
-	return __vhd_read(ctx, buf, size);
-}
-
-int
-vhd_write(vhd_context_t *ctx, void *buf, size_t size)
-{
-	if (ctx->devops && ctx->devops->write)
-		return ctx->devops->write(ctx, buf, size);
-	return __vhd_write(ctx, buf, size);
-}
-
-int
-vhd_pread(vhd_context_t *ctx, void *buf, size_t size, off64_t offset)
-{
-	if (ctx->devops && ctx->devops->pread)
-		return ctx->devops->pread(ctx, buf, size, offset);
-	return __vhd_pread(ctx, buf, size, offset);
-}
-
-int
-vhd_pwrite(vhd_context_t *ctx, void *buf, size_t size, off64_t offset)
-{
-	if (ctx->devops && ctx->devops->pwrite)
-		return ctx->devops->pwrite(ctx, buf, size, offset);
-	return __vhd_pwrite(ctx, buf, size, offset);
-}
-
 int
 vhd_offset(vhd_context_t *ctx, uint32_t sector, uint32_t *offset)
 {
@@ -2628,84 +2360,35 @@
 int
 vhd_open(vhd_context_t *ctx, const char *file, int flags)
 {
-	int i, err, oflags;
-	ICBINN *icb;
+	int err, oflags;
 
 	if (flags & VHD_OPEN_STRICT)
 		vhd_flag_clear(flags, VHD_OPEN_FAST);
 
 	memset(ctx, 0, sizeof(vhd_context_t));
-	vhd_cache_init(ctx);
-
 	ctx->fd     = -1;
 	ctx->oflags = flags;
 
-	icb    = vhd_icbinn_vhd();
-
 	err = namedup(&ctx->file, file);
 	if (err)
 		return err;
 
-	if (icb){
-		oflags = 0;
-		if (flags & VHD_OPEN_RDONLY)
-			oflags |= ICBINN_RDONLY;
-		if (flags & VHD_OPEN_RDWR)
-			oflags |= ICBINN_RDWR;
-
-		ctx->fd = icbinn_open(icb, ctx->file, oflags);
-		ctx->devops = &vhd_icbinn_devops;
-        } else {
-		oflags = O_LARGEFILE;
-		if (!(flags & VHD_OPEN_CACHED))
-			oflags |= O_DIRECT;
-		if (flags & VHD_OPEN_RDONLY)
-			oflags |= O_RDONLY;
-		if (flags & VHD_OPEN_RDWR)
-			oflags |= O_RDWR;
-
-		ctx->fd = open(ctx->file, oflags, 0644);
-	}
+	oflags = O_DIRECT | O_LARGEFILE;
+	if (flags & VHD_OPEN_RDONLY)
+		oflags |= O_RDONLY;
+	if (flags & VHD_OPEN_RDWR)
+		oflags |= O_RDWR;
 
+	ctx->fd = open(ctx->file, oflags, 0644);
 	if (ctx->fd == -1) {
 		err = -errno;
 		VHDLOG("failed to open %s: %d\n", ctx->file, err);
 		goto fail;
 	}
 
-	if (flags & VHD_OPEN_LOCKED) {
-		if (icb) {
-			if (icbinn_lock(icb, ctx->fd, oflags & ICBINN_RDWR ? ICBINN_LTYPE_WRLCK:ICBINN_LTYPE_RDLCK)) {
-				if (!getenv("VHD_BREAK_LOCKS")) {
-					VHDLOG("Failed to lock %s\n", file);
-					goto fail;
-				} else {
-					err = 0;
-					VHDLOG("Forcing lock for %s\n", file);
-				}
-			}
-		} else {
-			int op = (oflags & O_RDWR ? LOCK_EX : LOCK_SH);
-			if (flock(ctx->fd, op | LOCK_NB)) {
-				err = -errno;
-				if (!getenv("VHD_BREAK_LOCKS")) {
-					VHDLOG("Failed to lock %s: %d\n", file, err);
-					goto fail;
-				} else {
-					err = 0;
-					VHDLOG("Forcing lock for %s\n", file);
-				}
-			}
-		}
-	}
-
-	if (icb) {
-		ctx->is_block = 0;
-	} else {
-		err = vhd_test_file_fixed(ctx->file, &ctx->is_block);
-		if (err)
-			goto fail;
-	}
+	err = vhd_test_file_fixed(ctx->file, &ctx->is_block);
+	if (err)
+		goto fail;
 
 	if (flags & VHD_OPEN_FAST) {
 		err = vhd_open_fast(ctx);
@@ -2725,13 +2408,7 @@
 	}
 
 	if (vhd_type_dynamic(ctx)) {
-		for (i = 0; i < VHD_HEADER_MAX_RETRIES; i++) {
-			err = vhd_read_header(ctx, &ctx->header);
-			if (!err)
-				break;
-			VHDLOG("Error reading header, retry %d\n", i);
-			sleep(1);
-		}
+		err = vhd_read_header(ctx, &ctx->header);
 		if (err)
 			goto fail;
 
@@ -2739,49 +2416,27 @@
 		ctx->bm_secs = secs_round_up_no_zero(ctx->spb >> 3);
 	}
 
-	err = vhd_cache_load(ctx);
-	if (err) {
-		VHDLOG("failed to load cache: %d\n", err);
-		goto fail;
-	}
-
 	return 0;
 
 fail:
-	if (ctx->fd != -1) {
-		if (icb) icbinn_close(icb,ctx->fd);
-			else close(ctx->fd);
-	}
-
+	if (ctx->fd != -1)
+		close(ctx->fd);
 	free(ctx->file);
 	memset(ctx, 0, sizeof(vhd_context_t));
 	return err;
 }
 
-static void
-__vhd_close(vhd_context_t *ctx)
+void
+vhd_close(vhd_context_t *ctx)
 {
-	vhd_cache_unload(ctx);
-
-	if (ctx->file && ctx->fd != -1) {
-		fsync(ctx->fd);
+	if (ctx->file)
 		close(ctx->fd);
-	}
-
 	free(ctx->file);
 	free(ctx->bat.bat);
 	free(ctx->batmap.map);
 	memset(ctx, 0, sizeof(vhd_context_t));
 }
 
-void
-vhd_close(vhd_context_t *ctx)
-{
-	if (ctx->devops && ctx->devops->close)
-		return ctx->devops->close(ctx);
-	return __vhd_close(ctx);
-}
-
 static inline void
 vhd_initialize_footer(vhd_context_t *ctx, int type, uint64_t size)
 {
@@ -2797,18 +2452,19 @@
 	ctx->footer.geometry     = vhd_chs(size);
 	ctx->footer.type         = type;
 	ctx->footer.saved        = 0;
-	ctx->footer.data_offset  = 0xFFFFFFFFFFFFFFFFULL;
+	ctx->footer.data_offset  = 0xFFFFFFFFFFFFFFFF;
 	strcpy(ctx->footer.crtr_app, "tap");
-	uuid_generate(ctx->footer.uuid);
+	vhd_uuid_generate(&ctx->footer.uuid);
 }
 
-int
+static int
 vhd_initialize_header_parent_name(vhd_context_t *ctx, const char *parent_path)
 {
 	int err;
 	iconv_t cd;
 	size_t ibl, obl;
-	char *pname, *ppath, *dst;
+	char *ppath, *dst;
+	const char *pname;
 
 	err   = 0;
 	pname = NULL;
@@ -2842,7 +2498,11 @@
 
 	memset(dst, 0, obl);
 
-	if (iconv(cd, &pname, &ibl, &dst, &obl) == (size_t)-1 || ibl)
+	if (iconv(cd,
+#ifdef __linux__
+		(char **)
+#endif
+		&pname, &ibl, &dst, &obl) == (size_t)-1 || ibl)
 		err = (errno ? -errno : -EINVAL);
 
 out:
@@ -2851,39 +2511,25 @@
 	return err;
 }
 
-static off64_t
+static off_t
 get_file_size(const char *name)
 {
 	int fd;
-	off64_t end;
-
-	ICBINN *icb=vhd_icbinn_vhd();
-
-	if (icb) {
-		struct icbinn_stat buf;
-
-		if (icbinn_stat(icb,name,&buf))
-			return -1;
+	off_t end;
 
-		if (buf.type != ICBINN_TYPE_FILE)
-			return -1;
-		
-		end=buf.size;
-	} else {
-		fd = open(name, O_LARGEFILE | O_RDONLY);
-		if (fd == -1) {
-			VHDLOG("unable to open '%s': %d\n", name, errno);
-			return -errno;
-		}
-		end = lseek64(fd, 0, SEEK_END);
-		close(fd); 
+	fd = open(name, O_LARGEFILE | O_RDONLY);
+	if (fd == -1) {
+		VHDLOG("unable to open '%s': %d\n", name, errno);
+		return -errno;
 	}
+	end = lseek(fd, 0, SEEK_END);
+	close(fd); 
 	return end;
 }
 
 static int
-vhd_initialize_header(ICBINN *icb, vhd_context_t *ctx, const char *parent_path, 
-		uint64_t size, int raw, uint64_t *psize)
+vhd_initialize_header(vhd_context_t *ctx, const char *parent_path, 
+		uint64_t size, int raw)
 {
 	int err;
 	struct stat stats;
@@ -2901,30 +2547,21 @@
 	ctx->header.prt_ts       = 0;
 	ctx->header.res1         = 0;
 	ctx->header.max_bat_size = (ctx->footer.curr_size +
-			VHD_BLOCK_SIZE - 1) >> VHD_BLOCK_SHIFT;
+				    VHD_BLOCK_SIZE - 1) >> VHD_BLOCK_SHIFT;
 
 	ctx->footer.data_offset  = VHD_SECTOR_SIZE;
 
 	if (ctx->footer.type == HD_TYPE_DYNAMIC)
 		return 0;
 
-	if (icb) {
-		struct icbinn_stat buf;
-		err = icbinn_stat(icb,parent_path,&buf);
-		time( &stats.st_mtime );
-	} else {
-		err = stat(parent_path, &stats);
-	}
-
-
+	err = stat(parent_path, &stats);
 	if (err == -1)
 		return -errno;
 
 	if (raw) {
 		ctx->header.prt_ts = vhd_time(stats.st_mtime);
-		*psize = get_file_size(parent_path);
 		if (!size)
-			size = *psize;
+			size = get_file_size(parent_path);
 	}
 	else {
 		err = vhd_open(&parent, parent_path, VHD_OPEN_RDONLY);
@@ -2932,17 +2569,11 @@
 			return err;
 
 		ctx->header.prt_ts = vhd_time(stats.st_mtime);
-		uuid_copy(ctx->header.prt_uuid, parent.footer.uuid);
-		*psize = parent.footer.curr_size;
+		vhd_uuid_copy(&ctx->header.prt_uuid, &parent.footer.uuid);
 		if (!size)
-			size = *psize;
+			size = parent.footer.curr_size;
 		vhd_close(&parent);
 	}
-	if (size < *psize) {
-		VHDLOG("snapshot size (%llu) < parent size (%llu)\n",
-				size, *psize);
-		return -EINVAL;
-	}
 	ctx->footer.orig_size    = size;
 	ctx->footer.curr_size    = size;
 	ctx->footer.geometry     = vhd_chs(size);
@@ -2952,11 +2583,11 @@
 	return vhd_initialize_header_parent_name(ctx, parent_path);
 }
 
-int
+static int
 vhd_write_parent_locators(vhd_context_t *ctx, const char *parent)
 {
 	int i, err;
-	off64_t off;
+	off_t off;
 	uint32_t code;
 
 	code = PLAT_CODE_NONE;
@@ -3001,7 +2632,7 @@
 	struct stat stats;
 	vhd_context_t parent;
 
-	ppath = vhd_realpath(parent_path, NULL);
+	ppath = realpath(parent_path, NULL);
 	if (!ppath) {
 		VHDLOG("error resolving parent path %s for %s: %d\n",
 		       parent_path, child->file, errno);
@@ -3020,7 +2651,7 @@
 	}
 
 	if (raw) {
-		uuid_clear(child->header.prt_uuid);
+		vhd_uuid_clear(&child->header.prt_uuid);
 	} else {
 		err = vhd_open(&parent, ppath, VHD_OPEN_RDONLY);
 		if (err) {
@@ -3028,7 +2659,7 @@
 			       ppath, child->file, err);
 			goto out;
 		}
-		uuid_copy(child->header.prt_uuid, parent.footer.uuid);
+		vhd_uuid_copy(&child->header.prt_uuid, &parent.footer.uuid);
 		vhd_close(&parent);
 	}
 
@@ -3076,7 +2707,7 @@
 static int
 vhd_create_batmap(vhd_context_t *ctx)
 {
-	off64_t off;
+	off_t off;
 	int err, map_bytes;
 	vhd_batmap_header_t *header;
 
@@ -3156,7 +2787,7 @@
 		return err;
 
 	buf = mmap(0, VHD_BLOCK_SIZE, PROT_READ,
-		   MAP_SHARED | MAP_ANONYMOUS, -1, 0);
+		   MAP_SHARED | MAP_ANON, -1, 0);
 	if (buf == MAP_FAILED)
 		return -errno;
 
@@ -3174,7 +2805,7 @@
 }
 
 int 
-vhd_get_phys_size(vhd_context_t *ctx, off64_t *size)
+vhd_get_phys_size(vhd_context_t *ctx, off_t *size)
 {
 	int err;
 
@@ -3185,9 +2816,9 @@
 }
 
 int 
-vhd_set_phys_size(vhd_context_t *ctx, off64_t size)
+vhd_set_phys_size(vhd_context_t *ctx, off_t size)
 {
-	off64_t phys_size;
+	off_t phys_size;
 	int err;
 
 	err = vhd_get_phys_size(ctx, &phys_size);
@@ -3204,45 +2835,15 @@
 }
 
 static int
-vhd_set_virt_size_no_write(vhd_context_t *ctx, uint64_t size)
-{
-	if ((size >> VHD_BLOCK_SHIFT) > ctx->header.max_bat_size) {
-		VHDLOG("not enough metadata space reserved for fast "
-				"resize (BAT size %u, need %llu)\n",
-				ctx->header.max_bat_size, 
-				size >> VHD_BLOCK_SHIFT);
-		return -EINVAL;
-	}
-
-	/* update footer */
-	ctx->footer.curr_size = size;
-	ctx->footer.geometry  = vhd_chs(ctx->footer.curr_size);
-	ctx->footer.checksum  = vhd_checksum_footer(&ctx->footer);
-	return 0;
-}
-
-int
-vhd_set_virt_size(vhd_context_t *ctx, uint64_t size)
-{
-	int err;
-
-	err = vhd_set_virt_size_no_write(ctx, size);
-	if (err)
-		return err;
-	return vhd_write_footer(ctx, &ctx->footer);
-}
-
-static int
 __vhd_create(const char *name, const char *parent, uint64_t bytes, int type,
-		uint64_t mbytes, vhd_flag_creat_t flags)
+		vhd_flag_creat_t flags)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	vhd_context_t ctx;
 	vhd_footer_t *footer;
 	vhd_header_t *header;
-	uint64_t size, psize, blks;
-	ICBINN *icb;
+	uint64_t size, blks;
 
 	switch (type) {
 	case HD_TYPE_DIFF:
@@ -3258,34 +2859,14 @@
 	if (strnlen(name, VHD_MAX_NAME_LEN - 1) == VHD_MAX_NAME_LEN - 1)
 		return -ENAMETOOLONG;
 
-	if (bytes && mbytes && mbytes < bytes)
-		return -EINVAL;
-
 	memset(&ctx, 0, sizeof(vhd_context_t));
-	psize = 0;
 	footer = &ctx.footer;
 	header = &ctx.header;
 	blks   = (bytes + VHD_BLOCK_SIZE - 1) >> VHD_BLOCK_SHIFT;
-	/* If mbytes is provided (virtual-size-for-metadata-preallocation),
-	 * create the VHD of size mbytes, which will create the BAT & the 
-	 * batmap of the appropriate size. Once the BAT & batmap are 
-	 * initialized, reset the virtual size to the requested one.
-	 */
-	if (mbytes)
-		blks = (mbytes + VHD_BLOCK_SIZE - 1) >> VHD_BLOCK_SHIFT;
-	size = blks << VHD_BLOCK_SHIFT;
-
-
-	icb = vhd_icbinn_vhd();
-	
-	if (icb) {
-		ctx.fd = icbinn_open(icb, (char *) name, ICBINN_WRONLY | ICBINN_CREAT | ICBINN_TRUNC);
-		ctx.devops = &vhd_icbinn_devops;
-	} else {
-		ctx.fd = open(name, O_WRONLY | O_CREAT |
-			      O_TRUNC | O_LARGEFILE | O_DIRECT, 0644);
-	}
+	size   = blks << VHD_BLOCK_SHIFT;
 
+	ctx.fd = open(name, O_WRONLY | O_CREAT |
+		      O_TRUNC | O_LARGEFILE | O_DIRECT, 0644);
 	if (ctx.fd == -1)
 		return -errno;
 
@@ -3295,13 +2876,9 @@
 		goto out;
 	}
 
-	if (icb) {
-		ctx.is_block = 0;
-	} else {
-		err = vhd_test_file_fixed(ctx.file, &ctx.is_block);
-		if (err)
-			goto out;
-	}
+	err = vhd_test_file_fixed(ctx.file, &ctx.is_block);
+	if (err)
+		goto out;
 
 	vhd_initialize_footer(&ctx, type, size);
 
@@ -3311,7 +2888,15 @@
 			goto out;
 	} else {
 		int raw = vhd_flag_test(flags, VHD_FLAG_CREAT_PARENT_RAW);
-		err = vhd_initialize_header(icb, &ctx, parent, size, raw, &psize);
+		err = vhd_initialize_header(&ctx, parent, size, raw);
+		if (err)
+			goto out;
+
+		err = vhd_write_footer_at(&ctx, &ctx.footer, 0);
+		if (err)
+			goto out;
+
+		err = vhd_write_header_at(&ctx, &ctx.header, VHD_SECTOR_SIZE);
 		if (err)
 			goto out;
 
@@ -3328,29 +2913,8 @@
 			if (err)
 				goto out;
 		}
-	}
-
-	if (mbytes) {
-		/* set the virtual size to the requested size */
-		if (bytes) {
-			blks = (bytes + VHD_BLOCK_SIZE - 1) >> VHD_BLOCK_SHIFT;
-			size = blks << VHD_BLOCK_SHIFT;
-
-		}
-		else {
-			size = psize;
-		}
-		ctx.footer.orig_size = size;
-		err = vhd_set_virt_size_no_write(&ctx, size);
-		if (err)
-			goto out;
-	}
-
-	if (type != HD_TYPE_FIXED) {
-		err = vhd_write_footer_at(&ctx, &ctx.footer, 0);
-		if (err)
-			goto out;
 
+		/* write header again since it may have changed */
 		err = vhd_write_header_at(&ctx, &ctx.header, VHD_SECTOR_SIZE);
 		if (err)
 			goto out;
@@ -3361,7 +2925,7 @@
 		goto out;
 
 	off = vhd_position(&ctx);
-	if (off == (off64_t)-1) {
+	if (off == (off_t)-1) {
 		err = -errno;
 		goto out;
 	}
@@ -3377,25 +2941,22 @@
 
 out:
 	vhd_close(&ctx);
-	if (err && !ctx.is_block) {
-		if (icb) icbinn_unlink(icb, name);
-			else unlink(name);
-	}
+	if (err && !ctx.is_block)
+		unlink(name);
 	return err;
 }
 
 int
-vhd_create(const char *name, uint64_t bytes, int type, uint64_t mbytes,
-		vhd_flag_creat_t flags)
+vhd_create(const char *name, uint64_t bytes, int type, vhd_flag_creat_t flags)
 {
-	return __vhd_create(name, NULL, bytes, type, mbytes, flags);
+	return __vhd_create(name, NULL, bytes, type, flags);
 }
 
 int
 vhd_snapshot(const char *name, uint64_t bytes, const char *parent,
-		uint64_t mbytes, vhd_flag_creat_t flags)
+		vhd_flag_creat_t flags)
 {
-	return __vhd_create(name, parent, bytes, HD_TYPE_DIFF, mbytes, flags);
+	return __vhd_create(name, parent, bytes, HD_TYPE_DIFF, flags);
 }
 
 static int
@@ -3439,7 +3000,7 @@
 __vhd_io_dynamic_read_link(vhd_context_t *ctx, char *map,
 			   char *buf, uint64_t sector, uint32_t secs)
 {
-	off64_t off;
+	off_t off;
 	uint32_t blk, sec;
 	int err, cnt, map_off;
 	char *bitmap, *data, *src;
@@ -3495,7 +3056,7 @@
 		char *map, char *buf, uint64_t sec, uint32_t secs)
 {
 	int fd, err;
-	off64_t off;
+	off_t off;
 	uint64_t size;
 	char *data;
 
@@ -3507,8 +3068,8 @@
 		return -errno;
 	}
 
-	off = lseek64(fd, vhd_sectors_to_bytes(sec), SEEK_SET);
-	if (off == (off64_t)-1) {
+	off = lseek(fd, vhd_sectors_to_bytes(sec), SEEK_SET);
+	if (off == (off_t)-1) {
 		VHDLOG("%s: seek(0x%08"PRIx64") failed: %d\n",
 		       filename, vhd_sectors_to_bytes(sec), -errno);
 		err = -errno;
@@ -3573,16 +3134,6 @@
 		}
 
 		if (vhd->footer.type == HD_TYPE_DIFF) {
-			vhd_context_t *p;
-			p = vhd_cache_get_parent(vhd);
-			if (p) {
-				vhd = p;
-				err = vhd_get_bat(vhd);
-				if (err)
-					goto out;
-				continue;
-			}
-
 			err = vhd_parent_locator_get(vhd, &next);
 			if (err)
 				goto close;
@@ -3613,7 +3164,7 @@
 	}
 
 close:
-	if (vhd != ctx && !vhd_flag_test(vhd->oflags, VHD_OPEN_CACHED))
+	if (vhd != ctx)
 		vhd_close(vhd);
 out:
 	free(map);
@@ -3651,8 +3202,8 @@
 {
 	char *buf;
 	size_t size;
-	off64_t off, max;
-	int err, gap, spp, secs;
+	off_t off, max;
+	int i, err, gap, spp;
 
 	spp = getpagesize() >> VHD_SECTOR_SHIFT;
 
@@ -3674,12 +3225,8 @@
 	if (err)
 		return err;
 
-	secs = ctx->bm_secs + gap;
-	if (!vhd_flag_test(ctx->oflags, VHD_OPEN_IO_WRITE_SPARSE))
-		secs += ctx->spb;
-
-	size = vhd_sectors_to_bytes(secs);
-	buf  = mmap(0, size, PROT_READ, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
+	size = vhd_sectors_to_bytes(ctx->spb + ctx->bm_secs + gap);
+	buf  = mmap(0, size, PROT_READ, MAP_SHARED | MAP_ANON, -1, 0);
 	if (buf == MAP_FAILED)
 		return -errno;
 
@@ -3704,7 +3251,7 @@
 		       char *buf, uint64_t sector, uint32_t secs)
 {
 	char *map;
-	off64_t off;
+	off_t off;
 	uint32_t blk, sec;
 	int i, err, cnt, ret;
 
@@ -3803,833 +3350,3 @@
 
 	return __vhd_io_dynamic_write(ctx, buf, sec, secs);
 }
-
-static void
-vhd_cache_init(vhd_context_t *ctx)
-{
-	INIT_LIST_HEAD(&ctx->next);
-}
-
-static int
-vhd_cache_enabled(vhd_context_t *ctx)
-{
-	return vhd_flag_test(ctx->oflags, VHD_OPEN_CACHED);
-}
-
-static int
-vhd_cache_load(vhd_context_t *ctx)
-{
-	char *next;
-	int err, pflags;
-	vhd_context_t *vhd;
-
-	err    = 1;
-	pflags = ctx->oflags;
-	vhd    = ctx;
-	next   = NULL;
-
-	vhd_flag_set(pflags, VHD_OPEN_RDONLY);
-	vhd_flag_clear(pflags, VHD_OPEN_CACHED);
-
-	if (!vhd_cache_enabled(vhd))
-		goto done;
-
-	while (vhd->footer.type == HD_TYPE_DIFF) {
-		vhd_context_t *parent;
-
-		parent = NULL;
-
-		if (vhd_parent_raw(vhd))
-			goto done;
-
-		err = vhd_parent_locator_get(vhd, &next);
-		if (err)
-			goto out;
-
-		parent = calloc(1, sizeof(*parent));
-		if (!parent)
-			goto out;
-
-		err = vhd_open(parent, next, pflags);
-		if (err) {
-			free(parent);
-			parent = NULL;
-			goto out;
-		}
-
-		fcntl(parent->fd, F_SETFL,
-		      fcntl(parent->fd, F_GETFL) & ~O_DIRECT);
-		vhd_flag_set(parent->oflags, VHD_OPEN_CACHED);
-		list_add(&parent->next, &vhd->next);
-
-		free(next);
-		next = NULL;
-		vhd  = parent;
-	}
-
-done:
-	err = 0;
-out:
-	free(next);
-	if (err)
-		vhd_cache_unload(vhd);
-
-	return err;
-}
-
-static int
-vhd_cache_unload(vhd_context_t *ctx)
-{
-	vhd_context_t *vhd, *tmp;
-
-	if (!vhd_cache_enabled(ctx))
-		goto out;
-
-	list_for_each_entry_safe(vhd, tmp, &ctx->next, next) {
-		list_del_init(&vhd->next);
-		vhd_close(vhd);
-		free(vhd);
-	}
-
-	INIT_LIST_HEAD(&ctx->next);
-
-out:
-	return 0;
-}
-
-static vhd_context_t *
-vhd_cache_get_parent(vhd_context_t *ctx)
-{
-	vhd_context_t *vhd;
-
-	vhd = NULL;
-
-	if (!vhd_cache_enabled(ctx))
-		goto out;
-
-	if (list_empty(&ctx->next))
-		goto out;
-
-	vhd = list_entry(ctx->next.next, vhd_context_t, next);
-
-out:
-	return vhd;
-}
-
-typedef struct vhd_block_vector vhd_block_vector_t;
-typedef struct vhd_block_vector_entry vhd_block_vector_entry_t;
-
-struct vhd_block_vector_entry {
-	uint64_t                   off;       /* byte offset from block */
-	uint32_t                   bytes;     /* size in bytes */
-	char                      *buf;       /* destination buffer */
-};
-
-struct vhd_block_vector {
-	uint32_t                   block;     /* logical block in vhd */
-	int                        entries;   /* number of vector entries */
-	vhd_block_vector_entry_t  *array;     /* vector list */
-};
-
-/**
- * @vec: block vector describing read
- *
- * @vec describes a list of byte-spans within a given block
- * and a corresponding list of destination buffers.
- */
-static int
-vhd_block_vector_read(vhd_context_t *ctx, vhd_block_vector_t *vec)
-{
-	int err, i;
-	off64_t off;
-	uint32_t blk;
-
-	err = vhd_get_bat(ctx);
-	if (err)
-		goto out;
-
-	if (vec->block >= ctx->bat.entries) {
-		err = -ERANGE;
-		goto out;
-	}
-
-	blk = ctx->bat.bat[vec->block];
-	if (blk == DD_BLK_UNUSED) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	off = vhd_sectors_to_bytes(blk + ctx->bm_secs);
-
-	for (i = 0; i < vec->entries; i++) {
-		vhd_block_vector_entry_t *v = vec->array + i;
-		err = vhd_pread(ctx, v->buf, v->bytes, off + v->off);
-		if (err)
-			goto out;
-	}
-
-out:
-	return err;
-}
-
-/**
- * @vec: block vector to initialize
- * @block: vhd block number
- * @map: optional bitmap of sectors to map (relative to beginning of block)
- * @buf: destination buffer
- * @blk_start: byte offset relative to beginning of block
- * @blk_end: byte offset relative to beginning of block
- *
- * initializes @vec to describe a read into a contiguous buffer
- * of potentially non-contiguous byte ranges in a given vhd block.
- * only sectors with corresponding bits set in @map (if it is not NULL)
- * will be mapped; bits corresponding to unmapped sectors will be cleared.
- * first and last sector maps may be smaller than vhd sector size.
- */
-static int
-vhd_block_vector_init(vhd_context_t *ctx,
-		      vhd_block_vector_t *vec, uint32_t block, char *map,
-		      char *buf, uint64_t blk_start, uint64_t blk_end)
-{
-	int err, sec;
-	char *bitmap;
-	uint32_t first_sec, last_sec;
-
-	bitmap = NULL;
-	memset(vec, 0, sizeof(*vec));
-
-	first_sec = blk_start >> VHD_SECTOR_SHIFT;
-	last_sec  = secs_round_up_no_zero(blk_end);
-
-	err = vhd_read_bitmap(ctx, block, &bitmap);
-	if (err)
-		goto out;
-
-	vec->array = calloc(ctx->spb, sizeof(vhd_block_vector_entry_t));
-	if (!vec->array) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	for (sec = first_sec; sec < last_sec; sec++) {
-		uint32_t cnt;
-		vhd_block_vector_entry_t *v;
-
-		cnt = VHD_SECTOR_SIZE - (blk_start & (VHD_SECTOR_SIZE - 1));
-		if (cnt > blk_end - blk_start)
-			cnt = blk_end - blk_start;
-
-		if (map && !test_bit(map, sec))
-			goto next;
-
-		if (vhd_bitmap_test(ctx, bitmap, sec)) {
-			if (vec->entries > 0) {
-				v = vec->array + vec->entries - 1;
-				if (v->off + v->bytes == blk_start) {
-					v->bytes += cnt;
-					goto next;
-				}
-			}
-
-			v        = vec->array + vec->entries;
-			v->off   = blk_start;
-			v->bytes = cnt;
-			v->buf   = buf;
-
-			vec->entries++;
-
-		} else if (map) {
-			clear_bit(map, sec);
-		}
-
-	next:
-		blk_start += cnt;
-		buf       += cnt;
-	}
-
-	vec->block = block;
-
-out:
-	free(bitmap);
-	return err;
-}
-
-#if 0
-/**
- * @block: vhd block number
- * @buf: buffer to place data in
- * @size: number of bytes to read
- * @start: byte offset into block from which to start reading
- * @end: byte offset in block at which to stop reading
- *
- * reads data (if it exists) into @buf.  partial reads may occur
- * for the first and last sectors if @start and @end are not multiples
- * of vhd sector size.
- */
-static int
-vhd_block_vector_read_allocated(vhd_context_t *ctx, uint32_t block,
-				char *buf, uint64_t start, uint64_t end)
-{
-	int err;
-	vhd_block_vector_t vec;
-
-	vec.array = NULL;
-
-	err = vhd_block_vector_init(ctx, &vec, block, NULL, buf, start, end);
-	if (err)
-		goto out;
-
-	err = vhd_block_vector_read(ctx, &vec);
-
-out:
-	free(vec.array);
-	return err;
-}
-#endif
-
-/**
- * @block: vhd block number
- * @map: bitmap of sectors in block which should be read
- * @buf: buffer to place data in
- * @start: byte offset into block from which to start reading
- * @end: byte offset in block at which to stop reading
- *
- * for every bit set in @map (corresponding to sectors in @block),
- * reads data (if it exists) into @buf.  if data does not exist,
- * clears corresponding bit in @map.  partial reads may occur
- * for the first and last sectors if @start and @end are not multiples
- * of vhd sector size.
- */
-static int
-vhd_block_vector_read_allocated_selective(vhd_context_t *ctx,
-					  uint32_t block, char *map, char *buf,
-					  uint64_t start, uint64_t end)
-{
-	int err;
-	vhd_block_vector_t vec;
-
-	vec.array = NULL;
-
-	err = vhd_block_vector_init(ctx, &vec, block, map, buf, start, end);
-	if (err)
-		goto out;
-
-	err = vhd_block_vector_read(ctx, &vec);
-
-out:
-	free(vec.array);
-	return err;
-}
-
-/**
- * @map: bitmap of sectors which have already been read
- * @buf: destination buffer
- * @size: size in bytes to read
- * @off: byte offset in virtual disk to read
- *
- * reads @size bytes into @buf, starting at @off, skipping sectors
- * which have corresponding bits set in @map
- */
-static int
-__vhd_io_dynamic_read_link_bytes(vhd_context_t *ctx, char *map,
-				 char *buf, size_t size, uint64_t off)
-{
-	char *blkmap;
-	int i, err, map_off;
-	off64_t blk_off, blk_size;
-	uint32_t blk, bytes, first_sec, last_sec;
-
-	blkmap = malloc((ctx->spb + 7) >> 3);
-	if (!blkmap) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	map_off  = 0;
-	blk_size = vhd_sectors_to_bytes(ctx->spb);
-
-	do {
-		blk     = off / blk_size;
-		blk_off = off % blk_size;
-		bytes   = MIN(blk_size - blk_off, size);
-
-		first_sec = blk_off >> VHD_SECTOR_SHIFT;
-		last_sec  = secs_round_up_no_zero(blk_off + bytes);
-
-		if (ctx->bat.bat[blk] == DD_BLK_UNUSED)
-			goto next;
-
-		memset(blkmap, 0, (ctx->spb + 7) >> 3);
-
-		for (i = 0; i < (last_sec - first_sec); i++)
-			if (!test_bit(map, map_off + i))
-				set_bit(blkmap, first_sec + i);
-
-		err = vhd_block_vector_read_allocated_selective(ctx, blk,
-								blkmap, buf,
-								blk_off,
-								blk_off +
-								bytes);
-		if (err)
-			goto out;
-
-		for (i = 0; i < (last_sec - first_sec); i++)
-			if (test_bit(blkmap, first_sec + i))
-				set_bit(map, map_off + i);
-
-	next:
-		size    -= bytes;
-		off     += bytes;
-		map_off += (last_sec - first_sec);
-		buf     += bytes;
-
-	} while (size);
-
-	err = 0;
-out:
-	free(blkmap);
-	return err;
-}
-
-static int
-__raw_read_link_bytes(const char *filename,
-		      char *map, char *buf, size_t size, uint64_t off)
-{
-	int fd, err;
-	uint32_t i, first_sec, last_sec;
-
-	fd = open(filename, O_RDONLY | O_LARGEFILE);
-	if (fd == -1) {
-		VHDLOG("%s: failed to open: %d\n", filename, -errno);
-		return -errno;
-	}
-
-	first_sec = off >> VHD_SECTOR_SHIFT;
-	last_sec  = secs_round_up_no_zero(off + size);
-
-	for (i = first_sec; i < last_sec; i++) {
-		if (!test_bit(map, i - first_sec)) {
-			uint32_t secs = 0;
-			uint64_t coff, csize;
-
-			while (i + secs < last_sec &&
-			       !test_bit(map, i + secs - first_sec))
-				secs++;
-
-			coff  = vhd_sectors_to_bytes(i);
-			csize = vhd_sectors_to_bytes(secs);
-
-			if (i == first_sec)
-				coff = off;
-			if (secs == last_sec - 1)
-				csize = (off + size) - coff;
-
-			if (pread(fd, buf + coff - off, csize, coff) != csize) {
-				err = (errno ? -errno : -EIO);
-				goto close;
-			}
-
-			i += secs - 1;
-		}
-	}
-
-	err = 0;
-
-close:
-	close(fd);
-	return err;
-}
-
-static int
-__vhd_io_dynamic_read_bytes(vhd_context_t *ctx,
-			    char *buf, size_t size, uint64_t off)
-{
-	int err;
-	char *next, *map;
-	vhd_context_t parent, *vhd;
-	uint32_t i, done, first_sec, last_sec;
-
-	err  = vhd_get_bat(ctx);
-	if (err)
-		return err;
-
-	first_sec = off >> VHD_SECTOR_SHIFT;
-	last_sec  = secs_round_up_no_zero(off + size);
-
-	vhd  = ctx;
-	next = NULL;
-	map  = calloc(1, ((last_sec - first_sec) + 7) >> 3);
-	if (!map) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	for (;;) {
-		err = __vhd_io_dynamic_read_link_bytes(vhd, map,
-						       buf, size, off);
-		if (err)
-			goto close;
-
-		for (done = 0, i = 0; i < (last_sec - first_sec); i++)
-			if (test_bit(map, i))
-				done++;
-
-		if (done == last_sec - first_sec) {
-			err = 0;
-			goto close;
-		}
-
-		if (vhd->footer.type == HD_TYPE_DIFF) {
-			vhd_context_t *p;
-			p = vhd_cache_get_parent(vhd);
-			if (p) {
-				vhd = p;
-				err = vhd_get_bat(vhd);
-				if (err)
-					goto out;
-				continue;
-			}
-
-			err = vhd_parent_locator_get(vhd, &next);
-			if (err)
-				goto close;
-
-			if (vhd_parent_raw(vhd)) {
-				err = __raw_read_link_bytes(next, map,
-							    buf, size, off);
-				goto close;
-			}
-		} else {
-			err = 0;
-			goto close;
-		}
-
-		if (vhd != ctx)
-			vhd_close(vhd);
-		vhd = &parent;
-
-		err = vhd_open(vhd, next, VHD_OPEN_RDONLY);
-		if (err)
-			goto out;
-
-		err = vhd_get_bat(vhd);
-		if (err)
-			goto close;
-
-		free(next);
-		next = NULL;
-	}
-
-close:
-	if (!err) {
-		/*
-		 * clear any regions not present on disk
-		 */
-		for (i = first_sec; i < last_sec; i++) {
-			if (!test_bit(map, i - first_sec)) {
-				uint64_t coff  = vhd_sectors_to_bytes(i);
-				uint32_t csize = VHD_SECTOR_SIZE;
-
-				if (i == first_sec)
-					coff = off;
-				if (i == last_sec - 1)
-					csize = (off + size) - coff;
-
-				memset(buf + coff - off, 0, csize);
-			}
-		}
-	}
-
-	if (vhd != ctx && !vhd_flag_test(vhd->oflags, VHD_OPEN_CACHED))
-		vhd_close(vhd);
-out:
-	free(map);
-	free(next);
-	return err;
-}
-
-int
-vhd_io_read_bytes(vhd_context_t *ctx, char *buf, size_t size, uint64_t off)
-{
-	if (off + size > ctx->footer.curr_size)
-		return -ERANGE;
-
-	if (!vhd_type_dynamic(ctx))
-		return vhd_pread(ctx, buf, size, off);
-
-	return __vhd_io_dynamic_read_bytes(ctx, buf, size, off);
-}
-
-static int
-__vhd_io_dynamic_write_bytes_aligned(vhd_context_t *ctx,
-				     char *buf, size_t size, uint64_t off)
-{
-	char *map;
-	int i, err, ret, new;
-	uint64_t blk_off, blk_size, blk_start;
-	uint32_t blk, bytes, first_sec, last_sec;
-
-	if (off & (VHD_SECTOR_SIZE - 1) || size & (VHD_SECTOR_SIZE - 1))
-		return -EINVAL;
-
-	err = vhd_get_bat(ctx);
-	if (err)
-		return err;
-
-	if (vhd_has_batmap(ctx)) {
-		err = vhd_get_batmap(ctx);
-		if (err)
-			return err;
-	}
-
-	new      = 0;
-	map      = NULL;
-	blk_size = vhd_sectors_to_bytes(ctx->spb);
-
-	do {
-		blk     = off / blk_size;
-		blk_off = off % blk_size;
-		bytes   = MIN(blk_size - blk_off, size);
-
-		first_sec = blk_off >> VHD_SECTOR_SHIFT;
-		last_sec  = secs_round_up_no_zero(blk_off + bytes);
-
-		blk_start = ctx->bat.bat[blk];
-		if (blk_start == DD_BLK_UNUSED) {
-			err = __vhd_io_allocate_block(ctx, blk);
-			if (err)
-				goto fail;
-
-			blk_start = ctx->bat.bat[blk];
-			new = 1;
-		}
-
-		blk_start = vhd_sectors_to_bytes(blk_start + ctx->bm_secs);
-
-		err = vhd_pwrite(ctx, buf, bytes, blk_start + blk_off);
-		if (err)
-			goto fail;
-
-		if (vhd_has_batmap(ctx) &&
-		    vhd_batmap_test(ctx, &ctx->batmap, blk))
-			goto next;
-
-		err = vhd_read_bitmap(ctx, blk, &map);
-		if (err) {
-			map = NULL;
-			goto fail;
-		}
-
-		for (i = first_sec; i < last_sec; i++)
-			vhd_bitmap_set(ctx, map, i);
-
-		err = vhd_write_bitmap(ctx, blk, map);
-		if (err)
-			goto fail;
-
-		if (vhd_has_batmap(ctx)) {
-			for (i = 0; i < ctx->spb; i++)
-				if (!vhd_bitmap_test(ctx, map, i)) {
-					free(map);
-					map = NULL;
-					goto next;
-				}
-
-			vhd_batmap_set(ctx, &ctx->batmap, blk);
-			err = vhd_write_batmap(ctx, &ctx->batmap);
-			if (err)
-				goto fail;
-		}
-
-		free(map);
-		map = NULL;
-
-	next:
-		size   -= bytes;
-		off    += bytes;
-		buf    += bytes;
-
-	} while (size);
-
-	err = 0;
-
-out:
-	ret = (new ? vhd_write_footer(ctx, &ctx->footer) : 0);
-	return (err ? err : ret);
-
-fail:
-	free(map);
-	goto out;
-}
-
-static int
-__vhd_io_dynamic_write_bytes(vhd_context_t *ctx,
-			     char *buf, size_t size, uint64_t off)
-{
-	int err;
-	char *tmp;
-	uint32_t first_sec, last_sec, first_sec_off, last_sec_off;
-
-	err = 0;
-	tmp = NULL;
-
-	first_sec = off >> VHD_SECTOR_SHIFT;
-	last_sec  = secs_round_up_no_zero(off + size);
-
-	first_sec_off = off & (VHD_SECTOR_SIZE - 1);
-	last_sec_off  = (off + size) & (VHD_SECTOR_SIZE - 1);
-
-	if (first_sec_off || last_sec_off) {
-		tmp = malloc(VHD_SECTOR_SIZE);
-		if (!tmp) {
-			err = -ENOMEM;
-			goto out;
-		}
-
-		if (first_sec_off) {
-			uint32_t new = VHD_SECTOR_SIZE - first_sec_off;
-			if (new > size)
-				new = size;
-
-			err = vhd_io_read_bytes(
-				ctx, tmp, VHD_SECTOR_SIZE,
-				vhd_sectors_to_bytes(first_sec));
-			if (err)
-				goto out;
-
-			memcpy(tmp + first_sec_off, buf, new);
-
-			err = __vhd_io_dynamic_write_bytes_aligned(
-				ctx, tmp, VHD_SECTOR_SIZE,
-				vhd_sectors_to_bytes(first_sec));
-			if (err)
-				goto out;
-
-			buf  += new;
-			off  += new;
-			size -= new;
-		}
-
-		if (last_sec_off &&
-		    (last_sec - first_sec > 1 || !first_sec_off)) {
-			uint32_t new = last_sec_off;
-
-			err = vhd_io_read_bytes(
-				ctx, tmp, VHD_SECTOR_SIZE,
-				vhd_sectors_to_bytes(last_sec - 1));
-			if (err)
-				goto out;
-
-			memcpy(tmp, buf + size - new, new);
-
-			err = __vhd_io_dynamic_write_bytes_aligned(
-				ctx, tmp, VHD_SECTOR_SIZE,
-				vhd_sectors_to_bytes(last_sec - 1));
-			if (err)
-				goto out;
-
-			size -= new;
-		}
-	}
-
-	if (size)
-		err = __vhd_io_dynamic_write_bytes_aligned(ctx, buf, size, off);
-
-out:
-	free(tmp);
-	return err;
-}
-
-int
-vhd_io_write_bytes(vhd_context_t *ctx, char *buf, size_t size, uint64_t off)
-{
-	if (off + size > ctx->footer.curr_size)
-		return -ERANGE;
-
-	if (!vhd_type_dynamic(ctx))
-		return vhd_pwrite(ctx, buf, size, off);
-
-	return __vhd_io_dynamic_write_bytes(ctx, buf, size, off);
-}
-
-int
-vhd_marker(vhd_context_t *ctx, char *marker)
-{
-	int err;
-	vhd_batmap_t batmap;
-
-	*marker = 0;
-
-	if (!vhd_has_batmap(ctx))
-		return xattr_get(ctx->fd,
-				 VHD_XATTR_MARKER,
-				 (void *)marker,
-				 sizeof(*marker));
-
-	err = vhd_read_batmap_header(ctx, &batmap);
-	if (err)
-		return err;
-
-	*marker = batmap.header.marker;
-	return 0;
-}
-
-int
-vhd_set_marker(vhd_context_t *ctx, char marker)
-{
-	int err;
-	vhd_batmap_t batmap;
-
-	if (!vhd_has_batmap(ctx))
-		return xattr_set(ctx->fd,
-				 VHD_XATTR_MARKER,
-				 (void *)&marker,
-				 sizeof(marker));
-
-	err = vhd_read_batmap_header(ctx, &batmap);
-	if (err)
-		return err;
-
-	batmap.header.marker = marker;
-	return vhd_write_batmap_header(ctx, &batmap);
-}
-
-int
-vhd_get_keyhash(vhd_context_t *ctx, struct vhd_keyhash *keyhash)
-{
-	int err;
-	vhd_batmap_t batmap;
-
-	if (!vhd_has_batmap(ctx))
-		return xattr_get(ctx->fd,
-				 VHD_XATTR_KEYHASH,
-				 (void *)keyhash,
-				 sizeof(*keyhash));
-
-	err = vhd_read_batmap_header(ctx, &batmap);
-	if (err)
-		return err;
-
-	memcpy(keyhash, &batmap.header.keyhash, sizeof(*keyhash));
-	return 0;
-}
-
-int
-vhd_set_keyhash(vhd_context_t *ctx, const struct vhd_keyhash *keyhash)
-{
-	int err;
-	vhd_batmap_t batmap;
-
-	if (!vhd_has_batmap(ctx))
-		return xattr_set(ctx->fd,
-				 VHD_XATTR_KEYHASH,
-				 (void *)keyhash,
-				 sizeof(*keyhash));
-
-	err = vhd_read_batmap_header(ctx, &batmap);
-	if (err)
-		return err;
-
-	memcpy(&batmap.header.keyhash, keyhash, sizeof(*keyhash));
-	return vhd_write_batmap_header(ctx, &batmap);
-}
diff -Nur blktap2_oxt//vhd/lib/libvhd-index.c blktap2_xen//vhd/lib/libvhd-index.c
--- blktap2_oxt//vhd/lib/libvhd-index.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/libvhd-index.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,1204 +0,0 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <stdio.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <libgen.h>
-#include <sys/stat.h>
-
-#include "libvhd.h"
-#include "libvhd-index.h"
-#include "relative-path.h"
-
-#define ignore(expr) if (expr) {}
-
-typedef struct vhdi_path                    vhdi_path_t;
-typedef struct vhdi_header                  vhdi_header_t;
-typedef struct vhdi_bat_header              vhdi_bat_header_t;
-typedef struct vhdi_file_table_header       vhdi_file_table_header_t;
-typedef struct vhdi_file_table_entry        vhdi_file_table_entry_t;
-
-static const char                           VHDI_HEADER_COOKIE[] = "vhdindex";
-static const char                           VHDI_BAT_HEADER_COOKIE[] = "vhdi-bat";
-static const char                           VHDI_FILE_TABLE_HEADER_COOKIE[] = "vhdifile";
-
-struct vhdi_path {
-	char                                path[VHD_MAX_NAME_LEN];
-	uint16_t                            bytes;
-};
-
-struct vhdi_header {
-	char                                cookie[8];
-	uint32_t                            vhd_block_size;
-	uint64_t                            table_offset;
-};
-
-struct vhdi_bat_header {
-	char                                cookie[8];
-	uint64_t                            vhd_blocks;
-	uint32_t                            vhd_block_size;
-	vhdi_path_t                         vhd_path;
-	vhdi_path_t                         index_path;
-	vhdi_path_t                         file_table_path;
-	uint64_t                            table_offset;
-};
-
-struct vhdi_file_table_header {
-	char                                cookie[8];
-	uint32_t                            files;
-	uint64_t                            table_offset;
-};
-
-struct vhdi_file_table_entry {
-	vhdi_path_t                         p;
-	vhdi_file_id_t                      file_id;
-	uuid_t                              vhd_uuid;
-	uint32_t                            vhd_timestamp;
-};
-
-static inline int
-vhdi_seek(vhdi_context_t *ctx, off64_t off, int whence)
-{
-	int err;
-
-	err = lseek64(ctx->fd, off, whence);
-	if (err == (off64_t)-1)
-		return -errno;
-
-	return 0;
-}
-
-static inline off64_t
-vhdi_position(vhdi_context_t *ctx)
-{
-	return lseek64(ctx->fd, 0, SEEK_CUR);
-}
-
-static inline int
-vhdi_read(vhdi_context_t *ctx, void *buf, size_t size)
-{
-	int err;
-
-	err = read(ctx->fd, buf, size);
-	if (err != size)
-		return (errno ? -errno : -EIO);
-
-	return 0;
-}
-
-static inline int
-vhdi_write(vhdi_context_t *ctx, void *buf, size_t size)
-{
-	int err;
-
-	err = write(ctx->fd, buf, size);
-	if (err != size)
-		return (errno ? -errno : -EIO);
-
-	return 0;
-}
-
-static inline int
-vhdi_check_block_size(uint32_t block_size)
-{
-	int i, cnt;
-
-	cnt = 0;
-	for (i = 0; i < 32; i++)
-		if ((block_size >> i) & 0x0001)
-			cnt++;
-
-	if (cnt == 1)
-		return 0;
-
-	return -EINVAL;
-}
-
-static inline void
-vhdi_header_in(vhdi_header_t *header)
-{
-	BE32_IN(&header->vhd_block_size);
-	BE64_IN(&header->table_offset);
-}
-
-static inline void
-vhdi_header_out(vhdi_header_t *header)
-{
-	BE32_OUT(&header->vhd_block_size);
-	BE64_OUT(&header->table_offset);
-}
-
-static inline int
-vhdi_header_validate(vhdi_header_t *header)
-{
-	if (memcmp(header->cookie, VHDI_HEADER_COOKIE, sizeof(header->cookie)))
-		return -EINVAL;
-
-	return vhdi_check_block_size(header->vhd_block_size);
-}
-
-void
-vhdi_entry_in(vhdi_entry_t *entry)
-{
-	BE32_IN(&entry->file_id);
-	BE32_IN(&entry->offset);
-}
-
-static inline vhdi_entry_t
-vhdi_entry_out(vhdi_entry_t *entry)
-{
-	vhdi_entry_t e;
-
-	e = *entry;
-	BE32_OUT(&e.file_id);
-	BE32_OUT(&e.offset);
-
-	return e;
-}
-
-static inline void
-vhdi_path_in(vhdi_path_t *path)
-{
-	BE16_IN(&path->bytes);
-}
-
-static inline void
-vhdi_path_out(vhdi_path_t *path)
-{
-	BE16_OUT(&path->bytes);
-}
-
-static inline void
-vhdi_bat_header_in(vhdi_bat_header_t *header)
-{
-	BE64_IN(&header->vhd_blocks);
-	BE32_IN(&header->vhd_block_size);
-	vhdi_path_in(&header->vhd_path);
-	vhdi_path_in(&header->index_path);
-	vhdi_path_in(&header->file_table_path);
-	BE64_IN(&header->table_offset);
-}
-
-static inline void
-vhdi_bat_header_out(vhdi_bat_header_t *header)
-{
-	BE64_OUT(&header->vhd_blocks);
-	BE32_OUT(&header->vhd_block_size);
-	vhdi_path_out(&header->vhd_path);
-	vhdi_path_out(&header->index_path);
-	vhdi_path_out(&header->file_table_path);
-	BE64_OUT(&header->table_offset);
-}
-
-static inline int
-vhdi_path_validate(vhdi_path_t *path)
-{
-	int i;
-
-	if (path->bytes >= VHD_MAX_NAME_LEN - 1)
-		return -ENAMETOOLONG;
-
-	for (i = 0; i < path->bytes; i++)
-		if (path->path[i] == '\0')
-			return 0;
-
-	return -EINVAL;
-}
-
-static inline char *
-vhdi_path_expand(const char *src, vhdi_path_t *dest, int *err)
-{
-	int len;
-	char *path, *base, *absolute_path, copy[VHD_MAX_NAME_LEN];
-
-	strcpy(copy, src);
-	base = dirname(copy);
-
-	*err = asprintf(&path, "%s/%s", base, dest->path);
-	if (*err == -1) {
-		*err = -ENOMEM;
-		return NULL;
-	}
-
-	absolute_path = vhd_realpath(path, NULL);
-	free(path);
-
-	if (!absolute_path) {
-		*err = -errno;
-		return NULL;
-	}
-
-	len = strnlen(absolute_path, VHD_MAX_NAME_LEN - 1);
-	if (len == VHD_MAX_NAME_LEN - 1) {
-		free(absolute_path);
-		*err = -ENAMETOOLONG;
-		return NULL;
-	}
-
-	*err = 0;
-	return absolute_path;
-}
-
-static inline int
-vhdi_bat_header_validate(vhdi_bat_header_t *header)
-{
-	int err;
-
-	if (memcmp(header->cookie,
-		   VHDI_BAT_HEADER_COOKIE, sizeof(header->cookie)))
-		return -EINVAL;
-
-	err = vhdi_check_block_size(header->vhd_block_size);
-	if (err)
-		return err;
-
-	err = vhdi_path_validate(&header->vhd_path);
-	if (err)
-		return err;
-
-	err = vhdi_path_validate(&header->index_path);
-	if (err)
-		return err;
-
-	err = vhdi_path_validate(&header->file_table_path);
-	if (err)
-		return err;
-
-	return 0;
-}
-
-static inline int
-vhdi_bat_load_header(int fd, vhdi_bat_header_t *header)
-{
-	int err;
-
-	err = lseek64(fd, 0, SEEK_SET);
-	if (err == (off64_t)-1)
-		return -errno;
-
-	err = read(fd, header, sizeof(vhdi_bat_header_t));
-	if (err != sizeof(vhdi_bat_header_t))
-		return (errno ? -errno : -EIO);
-
-	vhdi_bat_header_in(header);
-	return vhdi_bat_header_validate(header);
-}
-
-static inline void
-vhdi_file_table_header_in(vhdi_file_table_header_t *header)
-{
-	BE32_OUT(&header->files);
-	BE64_OUT(&header->table_offset);
-}
-
-static inline void
-vhdi_file_table_header_out(vhdi_file_table_header_t *header)
-{
-	BE32_OUT(&header->files);
-	BE64_OUT(&header->table_offset);
-}
-
-static inline int
-vhdi_file_table_header_validate(vhdi_file_table_header_t *header)
-{
-	if (memcmp(header->cookie,
-		   VHDI_FILE_TABLE_HEADER_COOKIE, sizeof(header->cookie)))
-		return -EINVAL;
-
-	return 0;
-}
-
-static inline int
-vhdi_file_table_load_header(int fd, vhdi_file_table_header_t *header)
-{
-	int err;
-
-	err = lseek64(fd, 0, SEEK_SET);
-	if (err == (off64_t)-1)
-		return -errno;
-
-	err = read(fd, header, sizeof(vhdi_file_table_header_t));
-	if (err != sizeof(vhdi_file_table_header_t))
-		return (errno ? -errno : -EIO);
-
-	vhdi_file_table_header_in(header);
-	return vhdi_file_table_header_validate(header);
-}
-
-static inline int
-vhdi_file_table_write_header(int fd, vhdi_file_table_header_t *header)
-{
-	int err;
-
-	err = lseek64(fd, 0, SEEK_SET);
-	if (err == (off64_t)-1)
-		return -errno;
-
-	err = vhdi_file_table_header_validate(header);
-	if (err)
-		return err;
-
-	vhdi_file_table_header_out(header);
-
-	err = write(fd, header, sizeof(vhdi_file_table_header_t));
-	if (err != sizeof(vhdi_file_table_header_t))
-		return (errno ? -errno : -EIO);
-
-	return 0;
-}
-
-static inline void
-vhdi_file_table_entry_in(vhdi_file_table_entry_t *entry)
-{
-	vhdi_path_in(&entry->p);
-	BE32_IN(&entry->file_id);
-	BE32_IN(&entry->vhd_timestamp);
-}
-
-static inline void
-vhdi_file_table_entry_out(vhdi_file_table_entry_t *entry)
-{
-	vhdi_path_out(&entry->p);
-	BE32_OUT(&entry->file_id);
-	BE32_OUT(&entry->vhd_timestamp);
-}
-
-static inline int
-vhdi_file_table_entry_validate(vhdi_file_table_entry_t *entry)
-{
-	return vhdi_path_validate(&entry->p);
-}
-
-static inline int
-vhdi_file_table_entry_validate_vhd(vhdi_file_table_entry_t *entry,
-				   const char *path)
-{
-	int err;
-	vhd_context_t vhd;
-	struct stat stats;
-
-	err = stat(path, &stats);
-	if (err == -1)
-		return -errno;
-
-	if (entry->vhd_timestamp != vhd_time(stats.st_mtime))
-		return -EINVAL;
-
-	err = vhd_open(&vhd, path, VHD_OPEN_RDONLY);
-	if (err)
-		return err;
-
-	err = vhd_get_footer(&vhd);
-	if (err)
-		goto out;
-
-	if (uuid_compare(entry->vhd_uuid, vhd.footer.uuid)) {
-		err = -EINVAL;
-		goto out;
-	}
-
-out:
-	vhd_close(&vhd);
-	return err;
-}
-
-int
-vhdi_create(const char *name, uint32_t vhd_block_size)
-{
-	char *buf;
-	int err, fd;
-	size_t size;
-	vhdi_header_t header;
-
-	memset(&header, 0, sizeof(vhdi_header_t));
-
-	err = vhdi_check_block_size(vhd_block_size);
-	if (err)
-		return err;
-
-	err = access(name, F_OK);
-	if (!err || errno != ENOENT)
-		return (err ? err : -EEXIST);
-
-	memcpy(header.cookie, VHDI_HEADER_COOKIE, sizeof(header.cookie));
-	header.vhd_block_size = vhd_block_size;
-	header.table_offset   = vhd_bytes_padded(sizeof(vhdi_header_t));
-
-	err = vhdi_header_validate(&header);
-	if (err)
-		return err;
-
-	vhdi_header_out(&header);
-
-	size = vhd_bytes_padded(sizeof(vhdi_header_t));
-	err  = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, size);
-	if (err)
-		return -err;
-
-	memset(buf, 0, size);
-	memcpy(buf, &header, sizeof(vhdi_header_t));
-
-	fd = open(name, O_CREAT | O_TRUNC | O_RDWR, 0600);
-	if (fd == -1)
-		return -errno;
-
-	err = write(fd, buf, size);
-	if (err != size) {
-		err = (errno ? -errno : -EIO);
-		goto fail;
-	}
-
-	close(fd);
-	free(buf);
-
-	return 0;
-
-fail:
-	close(fd);
-	free(buf);
-	unlink(name);
-	return err;
-}
-
-int
-vhdi_open(vhdi_context_t *ctx, const char *file, int flags)
-{
-	int err, fd;
-	size_t size;
-	char *name, *buf;
-	vhdi_header_t header;
-
-	buf = NULL;
-	memset(ctx, 0, sizeof(vhdi_context_t));
-
-	name = strdup(file);
-	if (!name)
-		return -ENOMEM;
-
-	fd = open(file, flags | O_LARGEFILE);
-	if (fd == -1) {
-		free(name);
-		return -errno;
-	}
-
-	size = vhd_bytes_padded(sizeof(vhdi_header_t));
-	err = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, size);
-	if (err) {
-		err = -err;
-		goto fail;
-	}
-
-	err = read(fd, buf, size);
-	if (err != size) {
-		err = (errno ? -errno : -EIO);
-		goto fail;
-	}
-
-	memcpy(&header, buf, sizeof(vhdi_header_t));
-	free(buf);
-	buf = NULL;
-
-	vhdi_header_in(&header);
-	err = vhdi_header_validate(&header);
-	if (err)
-		goto fail;
-
-	ctx->fd             = fd;
-	ctx->name           = name;
-	ctx->spb            = header.vhd_block_size >> VHD_SECTOR_SHIFT;
-	ctx->vhd_block_size = header.vhd_block_size;
-
-	return 0;
-
-fail:
-	close(fd);
-	free(buf);
-	free(name);
-	return err;
-}
-
-void
-vhdi_close(vhdi_context_t *ctx)
-{
-	close(ctx->fd);
-	free(ctx->name);
-}
-
-int
-vhdi_read_block(vhdi_context_t *ctx, vhdi_block_t *block, uint32_t sector)
-{
-	int i, err;
-	size_t size;
-
-	err = vhdi_seek(ctx, vhd_sectors_to_bytes(sector), SEEK_SET);
-	if (err)
-		return err;
-
-	size = vhd_bytes_padded(ctx->spb * sizeof(vhdi_entry_t));
-
-	block->entries = ctx->spb;
-	err = posix_memalign((void **)&block->table, VHD_SECTOR_SIZE, size);
-	if (err)
-		return -err;
-
-	err = vhdi_read(ctx, block->table, size);
-	if (err)
-		goto fail;
-
-	for (i = 0; i < block->entries; i++)
-		vhdi_entry_in(&block->table[i]);
-
-	return 0;
-
-fail:
-	free(block->table);
-	return err;
-}
-
-int
-vhdi_write_block(vhdi_context_t *ctx, vhdi_block_t *block, uint32_t sector)
-{
-	char *buf;
-	int i, err;
-	size_t size;
-	vhdi_entry_t *entries;
-
-	err = vhdi_seek(ctx, vhd_sectors_to_bytes(sector), SEEK_SET);
-	if (err)
-		return err;
-
-	size = vhd_bytes_padded(ctx->spb * sizeof(vhdi_entry_t));
-	err = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, size);
-	if (err)
-		return -err;
-
-	memset(buf, 0, size);
-	entries = (vhdi_entry_t *)buf;
-
-	for (i = 0; i < block->entries; i++)
-		entries[i] = vhdi_entry_out(&block->table[i]);
-
-	err = vhdi_write(ctx, entries, size);
-	if (err)
-		goto out;
-
-	err = 0;
-
-out:
-	free(entries);
-	return err;
-}
-
-int
-vhdi_append_block(vhdi_context_t *ctx, vhdi_block_t *block, uint32_t *sector)
-{
-	char *buf;
-	int i, err;
-	off64_t off;
-	size_t size;
-	vhdi_entry_t *entries;
-
-	err = vhdi_seek(ctx, 0, SEEK_END);
-	if (err)
-		return err;
-
-	off = vhd_bytes_padded(vhdi_position(ctx));
-
-	err = vhdi_seek(ctx, off, SEEK_SET);
-	if (err)
-		return err;
-
-	size = vhd_bytes_padded(block->entries * sizeof(vhdi_entry_t));
-	err = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, size);
-	if (err)
-		return -err;
-
-	memset(buf, 0, size);
-	entries = (vhdi_entry_t *)buf;
-
-	for (i = 0; i < block->entries; i++)
-		entries[i] = vhdi_entry_out(&block->table[i]);
-
-	err = vhdi_write(ctx, entries, block->entries * sizeof(vhdi_entry_t));
-	if (err)
-		goto out;
-
-	err     = 0;
-	*sector = off >> VHD_SECTOR_SHIFT;
-out:
-	if (err)
-		ignore(ftruncate(ctx->fd, off));
-	free(entries);
-	return err;
-}
-
-static int
-vhdi_copy_path_to(vhdi_path_t *path, const char *src, const char *dest)
-{
-	int len, err;
-	char *file, *absolute_path, *relative_path, copy[VHD_MAX_NAME_LEN];
-
-	strcpy(copy, dest);
-
-	file          = basename(copy);
-	absolute_path = vhd_realpath(copy, NULL);
-	relative_path = NULL;
-
-	if (!absolute_path || !strcmp(file, "")) {
-		err = (errno ? -errno : -EINVAL);
-		goto out;
-	}
-
-	relative_path = relative_path_to((char *)src, absolute_path, &err);
-	if (!relative_path || err) {
-		err = (err ? err : -EINVAL);
-		goto out;
-	}
-
-	len = strnlen(relative_path, VHD_MAX_NAME_LEN - 1);
-	if (len == VHD_MAX_NAME_LEN - 1) {
-		err = -ENAMETOOLONG;
-		goto out;
-	}
-
-	strcpy(path->path, relative_path);
-	path->bytes = len + 1;
-
-	err = 0;
-
-out:
-	free(absolute_path);
-	free(relative_path);
-	return err;
-}
-
-int
-vhdi_bat_create(const char *name, const char *vhd,
-		const char *index, const char *file_table)
-{
-	int err, fd;
-	off64_t off;
-	vhd_context_t ctx;
-	vhdi_bat_header_t header;
-
-	memset(&header, 0, sizeof(vhdi_bat_header_t));
-
-	err = access(name, F_OK);
-	if (!err || errno != ENOENT)
-		return (err ? -err : -EEXIST);
-
-	err = vhd_open(&ctx, vhd, VHD_OPEN_RDONLY);
-	if (err)
-		return err;
-
-	err = vhd_get_header(&ctx);
-	if (err) {
-		vhd_close(&ctx);
-		return err;
-	}
-
-	header.vhd_blocks     = ctx.header.max_bat_size;
-	header.vhd_block_size = ctx.header.block_size;
-
-	vhd_close(&ctx);
-
-	fd = open(name, O_CREAT | O_TRUNC | O_RDWR, 0600);
-	if (fd == -1)
-		return -errno;
-
-	err = vhdi_copy_path_to(&header.vhd_path, name, vhd);
-	if (err)
-		goto fail;
-
-	err = vhdi_copy_path_to(&header.index_path, name, index);
-	if (err)
-		goto fail;
-
-	err = vhdi_copy_path_to(&header.file_table_path, name, file_table);
-	if (err)
-		goto fail;
-
-	off = vhd_bytes_padded(sizeof(vhdi_bat_header_t));
-
-	header.table_offset = off;
-	memcpy(header.cookie, VHDI_BAT_HEADER_COOKIE, sizeof(header.cookie));
-
-	err = vhdi_bat_header_validate(&header);
-	if (err)
-		goto fail;
-
-	vhdi_bat_header_out(&header);
-
-	err = write(fd, &header, sizeof(vhdi_bat_header_t));
-	if (err != sizeof(vhdi_bat_header_t)) {
-		err = (errno ? -errno : -EIO);
-		goto fail;
-	}
-
-	close(fd);
-	return 0;
-
-fail:
-	close(fd);
-	unlink(name);
-	return err;
-}
-
-int
-vhdi_bat_load(const char *name, vhdi_bat_t *bat)
-{
-	char *path;
-	int err, fd;
-	size_t size;
-	uint32_t *table;
-	vhdi_bat_header_t header;
-
-	table = NULL;
-
-	fd = open(name, O_RDONLY | O_LARGEFILE);
-	if (fd == -1)
-		return -errno;
-
-	err = vhdi_bat_load_header(fd, &header);
-	if (err)
-		goto out;
-
-	size = header.vhd_blocks * sizeof(uint32_t);
-	table = malloc(size);
-	if (!table) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	err = lseek64(fd, header.table_offset, SEEK_SET);
-	if (err == (off64_t)-1) {
-		err = -errno;
-		goto out;
-	}
-
-	err = read(fd, table, size);
-	if (err != size) {
-		err = (errno ? -errno : -EIO);
-		goto out;
-	}
-
-	path = vhdi_path_expand(name, &header.vhd_path, &err);
-	if (err)
-		goto out;
-	strcpy(bat->vhd_path, path);
-	free(path);
-
-	err = access(bat->vhd_path, F_OK);
-	if (err == -1) {
-		err = -errno;
-		goto out;
-	}
-
-	path = vhdi_path_expand(name, &header.index_path, &err);
-	if (err)
-		goto out;
-	strcpy(bat->index_path, path);
-	free(path);
-
-	err = access(bat->index_path, F_OK);
-	if (err == -1) {
-		err = -errno;
-		goto out;
-	}
-
-	path = vhdi_path_expand(name, &header.file_table_path, &err);
-	if (err)
-		goto out;
-	strcpy(bat->file_table_path, path);
-	free(path);
-
-	err = access(bat->file_table_path, F_OK);
-	if (err == -1) {
-		err = -errno;
-		goto out;
-	}
-
-	bat->vhd_blocks     = header.vhd_blocks;
-	bat->vhd_block_size = header.vhd_block_size;
-	bat->table          = table;
-
-	err = 0;
-
-out:
-	close(fd);
-	if (err) {
-		free(table);
-		memset(bat, 0, sizeof(vhdi_bat_t));
-	}
-
-	return err;
-}
-
-int
-vhdi_bat_write(const char *name, vhdi_bat_t *bat)
-{
-	int err, fd;
-	size_t size;
-	vhdi_bat_header_t header;
-
-	fd = open(name, O_RDWR | O_LARGEFILE);
-	if (fd == -1)
-		return -errno;
-
-	err = vhdi_bat_load_header(fd, &header);
-	if (err)
-		goto out;
-
-	if (header.vhd_blocks != bat->vhd_blocks ||
-	    header.vhd_block_size != bat->vhd_block_size) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	err = lseek64(fd, header.table_offset, SEEK_SET);
-	if (err == (off64_t)-1) {
-		err = -errno;
-		goto out;
-	}
-
-	size = bat->vhd_blocks * sizeof(uint32_t);
-	err = write(fd, bat->table, size);
-	if (err != size) {
-		err = (errno ? -errno : -EIO);
-		goto out;
-	}
-
-	err = 0;
-
-out:
-	close(fd);
-	return err;
-}
-
-int
-vhdi_file_table_create(const char *file)
-{
-	int err, fd;
-	off64_t off;
-	vhdi_file_table_header_t header;
-
-	memset(&header, 0, sizeof(vhdi_file_table_header_t));
-
-	err = access(file, F_OK);
-	if (!err || errno != ENOENT)
-		return (err ? err : -EEXIST);
-
-	off = vhd_bytes_padded(sizeof(vhdi_file_table_header_t));
-
-	header.files        = 0;
-	header.table_offset = off;
-	memcpy(header.cookie,
-	       VHDI_FILE_TABLE_HEADER_COOKIE, sizeof(header.cookie));
-
-	vhdi_file_table_header_out(&header);
-
-	fd = open(file, O_CREAT | O_TRUNC | O_RDWR, 0600);
-	if (fd == -1)
-		return -errno;
-
-	err = write(fd, &header, sizeof(vhdi_file_table_header_t));
-	if (err != sizeof(vhdi_file_table_header_t)) {
-		err = (errno ? -errno : -EIO);
-		goto out;
-	}
-
-	err = 0;
-
-out:
-	close(fd);
-	return err;
-}
-
-int
-vhdi_file_table_load(const char *name, vhdi_file_table_t *table)
-{
-	off64_t off;
-	size_t size;
-	int err, i, fd;
-	vhdi_file_table_header_t header;
-	vhdi_file_table_entry_t *entries;
-
-	entries = NULL;
-
-	fd = open(name, O_RDONLY | O_LARGEFILE);
-	if (fd == -1)
-		return -errno;
-
-	err = vhdi_file_table_load_header(fd, &header);
-	if (err)
-		goto out;
-
-	if (!header.files)
-		goto out;
-
-	table->table = calloc(header.files, sizeof(vhdi_file_ref_t));
-	if (!table->table) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	off = header.table_offset;
-	err = lseek64(fd, off, SEEK_SET);
-	if (err == (off64_t)-1) {
-		err = -errno;
-		goto out;
-	}
-
-	size = header.files * sizeof(vhdi_file_table_entry_t);
-	entries = calloc(header.files, sizeof(vhdi_file_table_entry_t));
-	if (!entries) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	err = read(fd, entries, size);
-	if (err != size) {
-		err = (errno ? -errno : -EIO);
-		goto out;
-	}
-
-	for (i = 0; i < header.files; i++) {
-		vhdi_file_table_entry_t *entry;
-
-		entry = entries + i;
-		vhdi_file_table_entry_in(entry);
-
-		err = vhdi_file_table_entry_validate(entry);
-		if (err)
-			goto out;
-
-		table->table[i].path = vhdi_path_expand(name,
-							&entry->p, &err);
-		if (err)
-			goto out;
-
-		err = vhdi_file_table_entry_validate_vhd(entry,
-							 table->table[i].path);
-		if (err)
-			goto out;
-
-		table->table[i].file_id       = entry->file_id;
-		table->table[i].vhd_timestamp = entry->vhd_timestamp;
-		uuid_copy(table->table[i].vhd_uuid, entry->vhd_uuid);
-	}
-
-	err = 0;
-	table->entries = header.files;
-
-out:
-	close(fd);
-	free(entries);
-	if (err) {
-		if (table->table) {
-			for (i = 0; i < header.files; i++)
-				free(table->table[i].path);
-			free(table->table);
-		}
-		memset(table, 0, sizeof(vhdi_file_table_t));
-	}
-
-	return err;
-}
-
-static int
-vhdi_file_table_next_fid(const char *name,
-			 const char *file, vhdi_file_id_t *fid)
-{
-	int i, err;
-	char *path;
-	vhdi_file_id_t max;
-	vhdi_file_table_t files;
-
-	max  = 0;
-	path = NULL;
-
-	err = vhdi_file_table_load(name, &files);
-	if (err)
-		return err;
-
-	path = vhd_realpath(file, NULL);
-	if (!path) {
-		err = -errno;
-		goto out;
-	}
-
-	for (i = 0; i < files.entries; i++) {
-		if (!strcmp(path, files.table[i].path)) {
-			err = -EEXIST;
-			goto out;
-		}
-
-		max = MAX(max, files.table[i].file_id);
-	}
-
-	*fid = max + 1;
-	err  = 0;
-
-out:
-	vhdi_file_table_free(&files);
-	free(path);
-
-	return err;
-}
-
-static inline int
-vhdi_file_table_entry_initialize(vhdi_file_table_entry_t *entry,
-				 const char *file_table, const char *file,
-				 vhdi_file_id_t fid)
-{
-	int err;
-	struct stat stats;
-	vhd_context_t vhd;
-
-	memset(entry, 0, sizeof(vhdi_file_table_entry_t));
-
-	err = stat(file, &stats);
-	if (err == -1)
-		return -errno;
-
-	entry->file_id       = fid;
-	entry->vhd_timestamp = vhd_time(stats.st_mtime);
-
-	err = vhd_open(&vhd, file, VHD_OPEN_RDONLY);
-	if (err)
-		goto out;
-
-	err = vhd_get_footer(&vhd);
-	if (err) {
-		vhd_close(&vhd);
-		goto out;
-	}
-
-	uuid_copy(entry->vhd_uuid, vhd.footer.uuid);
-
-	vhd_close(&vhd);
-
-	err = vhdi_copy_path_to(&entry->p, file_table, file);
-	if (err)
-		goto out;
-
-	err = 0;
-
-out:
-	if (err)
-		memset(entry, 0, sizeof(vhdi_file_table_entry_t));
-
-	return err;
-}
-
-int
-vhdi_file_table_add(const char *name, const char *file, vhdi_file_id_t *_fid)
-{
-	off64_t off;
-	size_t size;
-	vhdi_file_id_t fid;
-	int err, fd, len;
-	vhdi_file_table_entry_t entry;
-	vhdi_file_table_header_t header;
-
-	off   = 0;
-	fid   = 0;
-	*_fid = 0;
-
-        len = strnlen(file, VHD_MAX_NAME_LEN - 1);
-	if (len == VHD_MAX_NAME_LEN - 1)
-		return -ENAMETOOLONG;
-
-	err = vhdi_file_table_next_fid(name, file, &fid);
-	if (err)
-		return err;
-
-	fd = open(name, O_RDWR | O_LARGEFILE);
-	if (fd == -1)
-		return -errno;
-
-	err = vhdi_file_table_load_header(fd, &header);
-	if (err)
-		goto out;
-
-	size = sizeof(vhdi_file_table_entry_t);
-	off  = header.table_offset + size * header.files;
-
-	err = lseek64(fd, off, SEEK_SET);
-	if (err == (off64_t)-1) {
-		err = -errno;
-		goto out;
-	}
-
-	err = vhdi_file_table_entry_initialize(&entry, name, file, fid);
-	if (err)
-		goto out;
-
-	vhdi_file_table_entry_out(&entry);
-
-	err = write(fd, &entry, size);
-	if (err != size) {
-		err = (errno ? -errno : -EIO);
-		goto out;
-	}
-
-	header.files++;
-	err = vhdi_file_table_write_header(fd, &header);
-	if (err)
-		goto out;
-
-	err   = 0;
-	*_fid = fid;
-
-out:
-	if (err && off)
-		ignore(ftruncate(fd, off));
-	close(fd);
-
-	return err;
-}
-
-void
-vhdi_file_table_free(vhdi_file_table_t *table)
-{
-	int i;
-
-	if (table->table) {
-		for (i = 0; i < table->entries; i++)
-			free(table->table[i].path);
-		free(table->table);
-	}
-
-	memset(table, 0, sizeof(vhdi_file_table_t));
-}
diff -Nur blktap2_oxt//vhd/lib/libvhdio.c blktap2_xen//vhd/lib/libvhdio.c
--- blktap2_oxt//vhd/lib/libvhdio.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/libvhdio.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,1679 +0,0 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _GNU_SOURCE
-#define _GNU_SOURCE
-#endif
-
-#ifdef _LARGEFILE_SOURCE
-#undef _LARGEFILE_SOURCE
-#endif
-
-#ifdef _LARGEFILE64_SOURCE
-#undef _LARGEFILE64_SOURCE
-#endif
-
-#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64
-#undef _FILE_OFFSET_BITS
-#define _FILE_OFFSET_BITS 32
-#endif
-
-#ifdef _LARGEFILE_SOURCE
-#undef _LARGEFILE_SOURCE
-#endif
-
-#include <time.h>
-#include <stdio.h>
-#include <errno.h>
-#include <dlfcn.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <stdarg.h>
-#include <signal.h>
-#include <malloc.h>
-#include <sys/stat.h>
-#include <linux/fs.h>
-#include <linux/hdreg.h>
-
-#define _FCNTL_H
-#include <bits/fcntl.h>
-
-#include "libvhd.h"
-#include "partition.h"
-
-#define _ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))
-
-#define __RESOLVE(func, name)				                \
-	do {								\
-		if (!_libvhd_io_initialized)				\
-			_libvhd_io_init();				\
-		if (!(func))						\
-			(func) = _get_std_fn((name));			\
-	} while (0)
-
-#define _RESOLVE(func) __RESOLVE((func), __func__)
-
-#define LIBVHD_IO_DEBUG "LIBVHD_IO_DEBUG"
-#define LIBVHD_IO_DUMP  "LIBVHD_IO_DUMP"
-#define LIBVHD_IO_TEST  "LIBVHD_IO_TEST"
-
-static int libvhdio_logging;
-static FILE *libvhdio_log;
-#define LOG(_f, _a...)						        \
-	do {								\
-		if (libvhdio_logging && libvhdio_log) {			\
-			fprintf(libvhdio_log, _f, ##_a);		\
-			fflush(libvhdio_log);				\
-		}							\
-	} while (0)
-
-static int libvhdio_dump;
-#define DUMP(_buf, _size)						\
-	do {								\
-		if (libvhdio_log && libvhdio_dump) {			\
-			int i;						\
-			LOG("'");					\
-			for (i = 0; i < (_size); i++)			\
-				fputc(((char *)(_buf))[i],		\
-				      libvhdio_log);			\
-			LOG("'\n");					\
-		}							\
-	} while (0)
-
-struct _function {
-	const char                    *name;
-	void                          *fn;
-};
-
-struct vhd_object {
-	vhd_context_t                  vhd;
-	int                            refcnt;
-	uint64_t                       ino;
-	struct list_head               next;
-};
-
-struct vhd_partition {
-	struct vhd_object             *vhd_obj;
-	int                            partition;
-	int                            flags;
-	off64_t                        start;     /* in sectors */
-	off64_t                        end;       /* in sectors */
-	off64_t                        size;      /* in sectors */
-};
-
-struct vhd_fd_context {
-	struct vhd_partition           vhd_part;
-	off64_t                        off;
-	int                            users;
-};
-
-typedef struct vhd_object vhd_object_t;
-typedef struct vhd_partition vhd_partition_t;
-typedef struct vhd_fd_context vhd_fd_context_t;
-typedef int (*_std_open_t)(const char *, int, int);
-typedef int (*_std_close_t)(int);
-typedef FILE *(*_std_fopen_t)(const char *, const char *);
-
-static struct _function _function_table[] = {
-	{ .name = "open",             .fn = NULL },
-	{ .name = "open64",           .fn = NULL },
-#ifdef __open_2
-	{ .name = "__open_2",         .fn = NULL },
-#endif // __open_2
-#ifdef __open64_2
-	{ .name = "__open64_2",       .fn = NULL },
-#endif // __open64_2
-	{ .name = "close",            .fn = NULL },
-	{ .name = "dup",              .fn = NULL },
-	{ .name = "dup2",             .fn = NULL },
-#ifdef dup3
-	{ .name = "dup3",             .fn = NULL },
-#endif // dup3
-	{ .name = "lseek",            .fn = NULL },
-	{ .name = "lseek64",          .fn = NULL },
-	{ .name = "read",             .fn = NULL },
-	{ .name = "write",            .fn = NULL },
-	{ .name = "pread",            .fn = NULL },
-	{ .name = "pread64",          .fn = NULL },
-	{ .name = "pwrite",           .fn = NULL },
-	{ .name = "pwrite64",         .fn = NULL },
-	{ .name = "fsync",            .fn = NULL },
-	{ .name = "__xstat",          .fn = NULL },
-	{ .name = "__xstat64",        .fn = NULL },
-	{ .name = "__fxstat",         .fn = NULL },
-	{ .name = "__fxstat64",       .fn = NULL },
-	{ .name = "__lxstat",         .fn = NULL },
-	{ .name = "__lxstat64",       .fn = NULL },
-	{ .name = "ioctl",            .fn = NULL },
-	{ .name = "fcntl",            .fn = NULL },
-
-	{ .name = "fopen",            .fn = NULL },
-	{ .name = "fopen64",          .fn = NULL },
-	{ .name = "fclose",           .fn = NULL },
-	{ .name = "_IO_getc",         .fn = NULL },
-	{ .name = "fread",            .fn = NULL },
-
-	{ .name = "posix_memalign",   .fn = NULL },
-};
-
-static int _libvhd_io_interpose = 1;
-static struct list_head _vhd_objects;
-static vhd_fd_context_t **_vhd_map;
-static int _vhd_map_size;
-
-static int _libvhd_io_initialized;
-static void _libvhd_io_init(void) __attribute__((constructor));
-
-static volatile sig_atomic_t _libvhd_io_reset_vhds;
-
-static void *
-_load_std_fn(const char *name)
-{
-	void *fn;
-	char *msg;
-
-	LOG("loading %s\n", name);
-
-	fn = dlsym(RTLD_NEXT, name);
-	msg = dlerror();
-	if (!fn || msg) {
-		LOG("dlsym '%s' failed: %s\n", name, msg);
-		exit(1);
-	}
-
-	return fn;
-}
-
-static void *
-_get_std_fn(const char *name)
-{
-	int i;
-
-	for (i = 0; i < _ARRAY_SIZE(_function_table); i++)
-		if (!strcmp(name, _function_table[i].name))
-			return _function_table[i].fn;
-
-	return NULL;
-}
-
-static void
-_init_vhd_log(void)
-{
-	int (*_std_dup)(int) = _load_std_fn("dup");
-	int log_fd = _std_dup(STDERR_FILENO);
-
-	libvhdio_log = fdopen(log_fd, "a");
-
-	if (getenv(LIBVHD_IO_DEBUG)) {
-		libvhdio_logging = 1;
-		libvhd_set_log_level(1);
-	}
-
-	if (getenv(LIBVHD_IO_DUMP))
-		libvhdio_dump = 1;
-}
-
-static void
-_init_vhd_map(void)
-{
-	_vhd_map_size = sysconf(_SC_OPEN_MAX);
-	_vhd_map = calloc(_vhd_map_size, sizeof(vhd_fd_context_t *));
-	if (!_vhd_map) {
-		LOG("failed to init vhd map\n");
-		exit(1);
-	}
-}
-
-static void
-_init_vhd_objs(void)
-{
-	INIT_LIST_HEAD(&_vhd_objects);
-}
-
-static void
-_libvhd_io_reset(void)
-{
-	int i, err;
-
-	if (!_libvhd_io_interpose)
-		return;
-
-	_libvhd_io_reset_vhds = 0;
-
-	if (!_vhd_map)
-		return;
-
-	_libvhd_io_interpose = 0;
-
-	for (i = 0; i < _vhd_map_size; i++) {
-		int flags;
-		vhd_context_t *vhd;
-		char *child, *parent;
-		vhd_fd_context_t *vhd_fd = _vhd_map[i];
-
-		if (!vhd_fd)
-			continue;
-
-		vhd = &vhd_fd->vhd_part.vhd_obj->vhd;
-
-		flags = vhd->oflags;
-		child = strdup(vhd->file);
-		if (!child)
-			exit(ENOMEM);
-
-		LOG("resetting vhd fd %d user fd %d\n", vhd->fd, i);
-		vhd_close(vhd);
-
-		if (asprintf(&parent, "%s.%d.vhd",
-			     child, (int)time(NULL)) == -1)
-			exit(ENOMEM);
-
-		if (rename(child, parent))
-			exit(errno);
-
-		err = vhd_snapshot(child, 0, parent, 0, 0);
-		if (err) {
-			LOG("snapshot of %s failed on reset: %d\n",
-			    child, err);
-			exit(1);
-		}
-
-		err = vhd_open(vhd, child, flags);
-		if (err) {
-			LOG("opening new snapshot %s failed on reset: %d\n",
-			    child, err);
-			exit(1);
-		}
-
-		LOG("snapshot %s %s vhd fd %d user fd %d\n",
-		    child, parent, vhd->fd, i);
-
-		free(child);
-		free(parent);
-	}
-
-	_libvhd_io_interpose = 1;
-}
-
-static void
-_libvhd_io_continue(int signo)
-{
-	_libvhd_io_reset_vhds = 1;
-}
-
-static void
-_init_vhd_test(void)
-{
-	if (getenv(LIBVHD_IO_TEST)) {
-		sigset_t set;
-		struct sigaction act;
-
-		if (sigemptyset(&set))
-			exit(1);
-
-		act = (struct sigaction) {
-			.sa_handler  = _libvhd_io_continue,
-			.sa_mask     = set,
-			.sa_flags    = 0,
-		};
-
-		if (sigaction(SIGCONT, &act, NULL)) {
-			LOG("failed to set signal handler: %d\n", errno);
-			exit(1);
-		}
-
-		LOG("testing enabled\n");
-	}
-}
-
-static void
-_libvhd_io_init(void)
-{
-	int i;
-
-	if (_libvhd_io_initialized)
-		return;
-
-	_init_vhd_log();
-	_init_vhd_map();
-	_init_vhd_objs();
-	_init_vhd_test();
-
-	for (i = 0; i < _ARRAY_SIZE(_function_table); i++)
-		_function_table[i].fn = _load_std_fn(_function_table[i].name);
-
-	LOG("\n");
-	_libvhd_io_initialized = 1;
-}
-
-static vhd_object_t *
-_libvhd_io_get_vhd(const char *path, int flags)
-{
-	struct stat64 st;
-	int err, vhd_flags;
-	vhd_object_t *tmp, *obj = NULL;
-
-	_libvhd_io_interpose = 0;
-
-	if (stat64(path, &st))
-		goto out;
-
-	list_for_each_entry(tmp, &_vhd_objects, next)
-		if (tmp->ino == st.st_ino) {
-			obj = tmp;
-			if (flags & (O_RDWR | O_WRONLY) &&
-			    obj->vhd.oflags & VHD_OPEN_RDONLY) {
-				errno = EACCES;
-				obj = NULL;
-			}
-			goto out;
-		}
-
-	vhd_flags = VHD_OPEN_CACHED;
-
-	/*
-	 * we open RDWR whenever we can since vhd objects may be shared and
-	 * we don't have a clean way to switch RDONLY vhds to RDWR.  we'll
-	 * only open RDONLY when (flags & O_RDONLY) and we lack permission
-	 * to open RDWR.
-	 */
-	if (access(path, W_OK) == -1) {
-		if (errno != EACCES)
-			goto out;
-
-		if (flags & (O_WRONLY | O_RDWR))
-			goto out;
-
-		vhd_flags |= VHD_OPEN_RDONLY;
-	} else {
-		vhd_flags |= VHD_OPEN_RDWR;
-	}
-
-	obj = malloc(sizeof(*obj));
-	if (!obj) {
-		errno = ENOMEM;
-		goto out;
-	}
-
-	INIT_LIST_HEAD(&obj->next);
-	obj->refcnt = 0;
-	obj->ino = st.st_ino;
-
-	err = vhd_open(&obj->vhd, path, vhd_flags);
-	if (err) {
-		free(obj);
-		obj = NULL;
-		errno = err;
-		goto out;
-	}
-
-	list_add(&obj->next, &_vhd_objects);
-
-out:
-	_libvhd_io_interpose = 1;
-	if (obj) {
-		obj->refcnt++;
-		LOG("%s: %s 0x%llx 0x%x\n",
-		    __func__, path, obj->ino, obj->refcnt);
-	}
-	return obj;
-}
-
-static void
-_libvhd_io_put_vhd(vhd_object_t *obj)
-{
-	LOG("%s: 0x%llx 0x%x\n", __func__, obj->ino, obj->refcnt - 1);
-	if (--obj->refcnt == 0) {
-		vhd_close(&obj->vhd);
-		list_del(&obj->next);
-		free(obj);
-	}
-}
-
-static inline vhd_fd_context_t *
-_libvhd_io_map_get(int idx)
-{
-	if (_libvhd_io_reset_vhds)
-		_libvhd_io_reset();
-	return _vhd_map[idx];
-}
-
-static inline void
-_libvhd_io_map_set(int idx, vhd_fd_context_t *vhd_fd)
-{
-	vhd_fd->users++;
-	_vhd_map[idx] = vhd_fd;
-	LOG("mapping 0x%x to %s (0x%x users)\n",
-	    idx, vhd_fd->vhd_part.vhd_obj->vhd.file, vhd_fd->users);
-}
-
-static inline void
-_libvhd_io_map_clear(int idx)
-{
-	vhd_fd_context_t *vhd_fd;
-
-	if (idx < 0 || idx >= _vhd_map_size)
-		return;
-
-	vhd_fd = _vhd_map[idx];
-	_vhd_map[idx] = NULL;
-
-	if (vhd_fd) {
-		if (--vhd_fd->users == 0) {
-			_libvhd_io_put_vhd(vhd_fd->vhd_part.vhd_obj);
-			free(vhd_fd);
-		}
-	}
-}
-
-static int
-_libvhd_io_read_bytes(vhd_partition_t *vhd_part,
-		      void *buf, size_t size, uint64_t off)
-{
-	int ret;
-	vhd_context_t *vhd = &vhd_part->vhd_obj->vhd;
-
-	_libvhd_io_interpose = 0;
-	ret = vhd_io_read_bytes(vhd, buf, size, off);
-	_libvhd_io_interpose = 1;
-
-	if (ret) {
-		LOG("vhd_io_read_bytes %s %p 0x%x 0x%llx failed: %d\n",
-		    vhd->file, buf, size, off, ret);
-		errno = -ret;
-		ret = 1;
-	} else {
-		LOG("vhd_io_read_bytes %s %p 0x%x 0x%llx\n",
-		    vhd->file, buf, size, off);
-		DUMP(buf, size);
-	}
-
-	return ret;
-}
-
-static int
-_libvhd_io_write_bytes(vhd_partition_t *vhd_part,
-		       const void *buf, size_t size, uint64_t off)
-{
-	int ret;
-	vhd_context_t *vhd = &vhd_part->vhd_obj->vhd;
-
-	_libvhd_io_interpose = 0;
-	ret = vhd_io_write_bytes(vhd, (void *)buf, size, off);
-	_libvhd_io_interpose = 1;
-
-	if (ret) {
-		LOG("vhd_io_write_bytes %s %p 0x%x 0x%llx failed: %d\n",
-		    vhd->file, buf, size, off, ret);
-		errno = -ret;
-		ret = 1;
-	} else {
-		LOG("vhd_io_write_bytes %s %p 0x%x 0x%llx\n",
-		    vhd->file, buf, size, off);
-		DUMP(buf, size);
-	}
-
-	return ret;
-}
-
-/*
- * symlink pathnames like *.vhd[1-4] are treated specially
- */
-static int
-_libvhd_io_guess_partition(const char *path, int *partition, int *skip)
-{
-	char *sfx;
-	int err, len;
-	struct stat64 st;
-
-	*skip      = 0;
-	*partition = 0;
-
-	_libvhd_io_interpose = 0;
-	err = lstat64(path, &st);
-	_libvhd_io_interpose = 1;
-
-	if (err == -1)
-		return errno;
-
-	if ((st.st_mode & __S_IFMT) != __S_IFLNK) {
-		if (st.st_size < VHD_SECTOR_SIZE)
-			*skip = 1;
-		return 0;
-	}
-
-	sfx = strstr(path, ".vhd");
-	if (!sfx)
-		return 0;
-
-	sfx += strlen(".vhd");
-	len = strlen(sfx);
-	if (!len)
-		return 0;
-	if (len > 1)
-		return EINVAL;
-
-	switch (*sfx) {
-	case '1' ... '4':
-		*partition = atoi(sfx);
-		break;
-	default:
-		return EINVAL;
-	}
-
-	return 0;
-}
-
-static int
-_libvhd_io_init_partition(vhd_partition_t *vhd_part, int partition)
-{
-	int err;
-	vhd_context_t *vhd;
-	struct partition_table *pt;
-	struct primary_partition *p;
-
-	if (partition < 0 || partition > 4)
-		return ENOENT;
-
-	vhd = &vhd_part->vhd_obj->vhd;
-
-	if (!partition) {
-		vhd_part->partition = 0;
-		vhd_part->start     = 0;
-		vhd_part->end       = (vhd->footer.curr_size >> VHD_SECTOR_SHIFT);
-		vhd_part->size      = vhd_part->end;
-		return 0;
-	}
-
-	err = posix_memalign((void **)&pt, VHD_SECTOR_SIZE, VHD_SECTOR_SIZE);
-	if (err)
-		return err;
-
-	err = _libvhd_io_read_bytes(vhd_part, (char *)pt, 512, 0);
-	if (err) {
-		LOG("reading partition failed: %d\n", err);
-		goto out;
-	}
-
-	partition_table_in(pt);
-	err = partition_table_validate(pt);
-	if (err) {
-		LOG("bad partition table read\n");
-		goto out;
-	}
-
-	p = pt->partitions + (partition - 1);
-	if (!p->lba || !p->blocks) {
-		err = ENOENT;
-		goto out;
-	}
-
-	vhd_part->partition = partition;
-	vhd_part->start     = p->lba;
-	vhd_part->end       = p->lba + p->blocks;
-	vhd_part->size      = p->blocks;
-	err                 = 0;
-
-	LOG("%s: opening %s partition 0x%x start 0x%08llx end 0x%08llx\n",
-	    __func__, vhd->file, partition, vhd_part->start, vhd_part->end);
-
-out:
-	free(pt);
-	return err;
-}
-
-static int
-_libvhd_io_vhd_open(vhd_partition_t *vhd_part, const char *path, int flags)
-{
-	int err, skip, partition;
-
-	memset(vhd_part, 0, sizeof(*vhd_part));
-	vhd_part->flags = flags;
-
-	err = _libvhd_io_guess_partition(path, &partition, &skip);
-	if (err)
-		return err;
-
-	if (skip)
-		return EINVAL;
-
-	LOG("%s: attempting vhd_open of %s\n", __func__, path);
-
-	vhd_part->vhd_obj = _libvhd_io_get_vhd(path, flags);
-	if (!vhd_part->vhd_obj)
-		err = errno;
-
-	if (!err) {
-		err = _libvhd_io_init_partition(vhd_part, partition);
-		if (err) {
-			_libvhd_io_put_vhd(vhd_part->vhd_obj);
-			memset(vhd_part, 0, sizeof(*vhd_part));
-		}
-	}
-
-	return (err >= 0 ? err : -err);
-}
-
-static int
-_libvhd_io_open(const char *pathname,
-		int flags, mode_t mode, _std_open_t _std_open)
-{
-	int err, fd;
-	vhd_fd_context_t *vhd_fd;
-
-	errno    = 0;
-	vhd_fd   = NULL;
-
-	vhd_fd = calloc(1, sizeof(*vhd_fd));
-	if (!vhd_fd) {
-		err = ENOMEM;
-		goto fail;
-	}
-
-	err = _libvhd_io_vhd_open(&vhd_fd->vhd_part, pathname, flags);
-	if (err) {
-		if (err == EINVAL || err == ENOENT)
-			goto std_open;
-
-		LOG("%s: vhd_open of %s failed: %d\n",
-		    __func__, pathname, err);
-		goto fail;
-	}
-
-#ifdef O_CLOEXEC
-	if (flags & (O_APPEND | O_ASYNC | O_CLOEXEC |
-		     O_DIRECTORY | O_NONBLOCK)) {
-#else
-	if (flags & (O_APPEND | O_ASYNC | O_DIRECTORY | O_NONBLOCK)) {
-#endif //O_CLOEXEC
-		LOG("%s: invalid flags for vhd_open: 0x%x\n", __func__, flags);
-		err = EINVAL;
-		goto fail;
-	}
-
-	fd = _std_open("/dev/null", O_RDONLY, 0);
-	if (fd == -1) {
-		err = errno;
-		goto fail;
-	}
-
-	_libvhd_io_map_set(fd, vhd_fd);
-	return fd;
-
-std_open:
-	free(vhd_fd);
-	return _std_open(pathname, flags, mode);
-
-fail:
-	if (vhd_fd && vhd_fd->vhd_part.vhd_obj)
-		_libvhd_io_put_vhd(vhd_fd->vhd_part.vhd_obj);
-	free(vhd_fd);
-	errno = err;
-	return -1;
-}
-
-static int
-_libvhd_io_close(int fd, _std_close_t _std_close)
-{
-	_libvhd_io_map_clear(fd);
-	return _std_close(fd);
-}
-
-static FILE *
-_libvhd_io_fopen(const char *path, const char *mode)
-{
-	char *m;
-	FILE *f;
-	int fd, flags;
-	vhd_fd_context_t *vhd_fd;
-	static _std_open_t _std_open64;
-
-	__RESOLVE(_std_open64, "open64");
-
-	flags = 0;
-	if (strchr(mode, 'a')) {
-		if (strchr(mode, '+'))
-			flags |= O_APPEND | O_RDWR;
-		else
-			flags |= O_APPEND | O_WRONLY;
-	}
-	if (strchr(mode, 'r')) {
-		if (strchr(mode, '+'))
-			flags |= O_RDWR;
-		else
-			flags |= O_RDONLY;
-	}
-	if (strchr(mode, 'w')) {
-		errno = EINVAL;
-		return NULL;
-	}
-
-	fd = _libvhd_io_open(path, flags, 0, _std_open64);
-	if (fd == -1)
-		return NULL;
-
-	vhd_fd = _libvhd_io_map_get(fd);
-	if (vhd_fd)
-		m = "r";
-	else
-		m = (char *)mode;
-
-	f = fdopen(fd, m);
-	if (!f) {
-		int err = errno;
-		close(fd);
-		errno = err;
-	}
-
-	return f;
-}
-
-static ssize_t
-_libvhd_io_pread(vhd_partition_t *vhd_part,
-		 void *buf, size_t count, off64_t offset)
-{
-	ssize_t ret;
-	off64_t psize;
-
-	ret   = (ssize_t)-1;
-	psize = vhd_part->size << VHD_SECTOR_SHIFT;
-
-	if (vhd_part->flags & O_WRONLY) {
-		errno = EPERM;
-		goto out;
-	}
-
-	if (offset >= psize) {
-		ret = 0;
-		goto out;
-	}
-
-	count   = MIN(count, psize - offset);
-	offset += (vhd_part->start << VHD_SECTOR_SHIFT);
-
-	if (_libvhd_io_read_bytes(vhd_part, buf, count, offset))
-		goto out;
-
-	ret = count;
-
-out:
-	return ret;
-}
-
-static ssize_t
-_libvhd_io_pwrite(vhd_partition_t *vhd_part,
-		  const void *buf, size_t count, off64_t offset)
-{
-	ssize_t ret;
-	off64_t psize;
-
-	ret   = (ssize_t)-1;
-	psize = vhd_part->size << VHD_SECTOR_SHIFT;
-
-	if (vhd_part->flags & O_RDONLY) {
-		errno = EPERM;
-		goto out;
-	}
-
-	if (offset >= psize) {
-		ret = 0;
-		goto out;
-	}
-
-	count   = MIN(count, psize - offset);
-	offset += (vhd_part->start << VHD_SECTOR_SHIFT);
-
-	if (_libvhd_io_write_bytes(vhd_part, buf, count, offset))
-		goto out;
-
-	ret = count;
-
-out:
-	return ret;
-}
-
-static int
-_libvhd_io_fstat(int version, vhd_partition_t *vhd_part, struct stat *stats)
-{
-	int ret;
-	static int (*_std___fxstat)(int, int, struct stat *);
-
-	__RESOLVE(_std___fxstat, "__fxstat");
-	ret = _std___fxstat(version, vhd_part->vhd_obj->vhd.fd, stats);
-	if (ret)
-		return ret;
-
-	/*
-	 * emulate block device
-	 */
-	stats->st_size = 0;
-	stats->st_blocks = 0;
-	stats->st_blksize = getpagesize();
-	stats->st_mode &= ~__S_IFREG;
-	stats->st_mode |= __S_IFBLK;
-
-	return 0;
-}
-
-static int
-_libvhd_io_fstat64(int version,
-		   vhd_partition_t *vhd_part, struct stat64 *stats)
-{
-	int ret;
-	static int (*_std___fxstat64)(int, int, struct stat64 *);
-
-	__RESOLVE(_std___fxstat64, "__fxstat64");
-	ret = _std___fxstat64(version, vhd_part->vhd_obj->vhd.fd, stats);
-	if (ret)
-		return ret;
-
-	/*
-	 * emulate block device
-	 */
-	stats->st_size = 0;
-	stats->st_blocks = 0;
-	stats->st_blksize = getpagesize();
-	stats->st_mode &= ~__S_IFREG;
-	stats->st_mode |= __S_IFBLK;
-
-	return 0;
-}
-
-static int
-_libvhd_io_stat(int version, const char *path, struct stat *stats)
-{
-	int err;
-	vhd_partition_t vhd_part;
-
-	err = _libvhd_io_vhd_open(&vhd_part, path, O_RDONLY);
-	if (err) {
-		errno = (err > 0 ? err : -err);
-		return -1;
-	}
-
-	err = _libvhd_io_fstat(version, &vhd_part, stats);
-	_libvhd_io_put_vhd(vhd_part.vhd_obj);
-
-	return err;
-}
-
-static int
-_libvhd_io_stat64(int version, const char *path, struct stat64 *stats)
-{
-	int err;
-	vhd_partition_t vhd_part;
-
-	err = _libvhd_io_vhd_open(&vhd_part, path, O_RDONLY);
-	if (err) {
-		errno = (err > 0 ? err : -err);
-		return -1;
-	}
-
-	err = _libvhd_io_fstat64(version, &vhd_part, stats);
-	_libvhd_io_put_vhd(vhd_part.vhd_obj);
-
-	return err;
-}
-
-int
-open(const char *pathname, int flags, mode_t _mode)
-{
-	int fd;
-	mode_t mode;
-	static _std_open_t _std_open;
-
-	_RESOLVE(_std_open);
-	mode = (flags & O_CREAT ? _mode : 0);
-
-	if (!_libvhd_io_interpose)
-		return _std_open(pathname, flags, mode);
-
-	fd = _libvhd_io_open(pathname, flags, mode, _std_open);
-
-	LOG("%s %s 0x%x 0x%x: 0x%x\n", __func__, pathname, flags, mode, fd);
-
-	return fd;
-}
-
-int
-open64(const char *pathname, int flags, mode_t _mode)
-{
-	int fd;
-	mode_t mode;
-	static _std_open_t _std_open64;
-
-	_RESOLVE(_std_open64);
-	mode = (flags & O_CREAT ? _mode : 0);
-
-	if (!_libvhd_io_interpose)
-		return _std_open64(pathname, flags, mode);
-
-	fd = _libvhd_io_open(pathname, flags, mode, _std_open64);
-
-	LOG("%s %s 0x%x 0x%x: 0x%x\n", __func__, pathname, flags, mode, fd);
-
-	return fd;
-}
-
-int
-__open_2(const char *pathname, int flags, mode_t _mode)
-{
-	int fd;
-	mode_t mode;
-	static _std_open_t _std_open64;
-
-	__RESOLVE(_std_open64, "open64");
-	mode = (flags & O_CREAT ? _mode : 0);
-
-	if (!_libvhd_io_interpose)
-		return _std_open64(pathname, flags, mode);
-
-	fd = _libvhd_io_open(pathname, flags, mode, _std_open64);
-
-	LOG("%s %s 0x%x 0x%x: 0x%x\n", __func__, pathname, flags, mode, fd);
-
-	return fd;
-}
-
-int
-__open64_2(const char *pathname, int flags, mode_t _mode)
-{
-	int fd;
-	mode_t mode;
-	static _std_open_t _std_open64;
-
-	__RESOLVE(_std_open64, "open64");
-	mode = (flags & O_CREAT ? _mode : 0);
-
-	if (!_libvhd_io_interpose)
-		return _std_open64(pathname, flags, mode);
-
-	fd = _libvhd_io_open(pathname, flags, mode, _std_open64);
-
-	LOG("%s %s 0x%x 0x%x: 0x%x\n", __func__, pathname, flags, mode, fd);
-
-	return fd;
-}
-
-int
-close(int fd)
-{
-	static _std_close_t _std_close;
-
-	_RESOLVE(_std_close);
-
-	LOG("%s 0x%x\n", __func__, fd);
-
-	return _libvhd_io_close(fd, _std_close);
-}
-
-int
-dup(int oldfd)
-{
-	int newfd;
-	vhd_fd_context_t *vhd_fd;
-	static int (*_std_dup)(int);
-
-	_RESOLVE(_std_dup);
-	vhd_fd = _libvhd_io_map_get(oldfd);
-
-	LOG("%s 0x%x\n", __func__, oldfd);
-
-	newfd = _std_dup(oldfd);
-	if (newfd != -1 && vhd_fd)
-		_libvhd_io_map_set(newfd, vhd_fd);
-
-	return newfd;
-}
-
-int
-dup2(int oldfd, int newfd)
-{
-	int ret;
-	vhd_fd_context_t *vhd_fd;
-	static int (*_std_dup2)(int, int);
-
-	_RESOLVE(_std_dup2);
-	vhd_fd = _libvhd_io_map_get(oldfd);
-
-	LOG("%s 0x%x 0x%x\n", __func__, oldfd, newfd);
-
-	ret = _std_dup2(oldfd, newfd);
-	if (ret != -1 && vhd_fd)
-		_libvhd_io_map_set(ret, vhd_fd);
-
-	return ret;
-}
-
-#ifdef dup3
-int
-dup3(int oldfd, int newfd, int flags)
-{
-	int ret;
-	vhd_fd_context_t *vhd_fd;
-	static int (*_std_dup3)(int, int, int);
-
-	_RESOLVE(_std_dup3);
-	vhd_fd = _libvhd_io_map_get(oldfd);
-
-	LOG("%s 0x%x 0x%x 0x%x\n", __func__, oldfd, newfd, flags);
-
-	/*
-	 * TODO: handle O_CLOEXEC...
-	 */
-	ret = _std_dup3(oldfd, newfd, flags);
-	if (ret != -1 && vhd_fd)
-		_libvhd_io_map_set(ret, vhd_fd);
-
-	return ret;
-}
-#endif
-
-off_t
-lseek(int fd, off_t offset, int whence)
-{
-	off_t new_off;
-	vhd_fd_context_t *vhd_fd;
-	static off_t (*_std_lseek)(int, off_t, int);
-
-	_RESOLVE(_std_lseek);
-	vhd_fd = _libvhd_io_map_get(fd);
-
-	LOG("%s 0x%x 0x%lx 0x%x\n", __func__, fd, offset, whence);
-
-	if (!vhd_fd)
-		return _std_lseek(fd, offset, whence);
-
-	switch (whence) {
-	case SEEK_SET:
-		new_off = offset;
-		break;
-	case SEEK_CUR:
-		new_off = vhd_fd->off + offset;
-		break;
-	case SEEK_END:
-		new_off = (vhd_fd->vhd_part.size << VHD_SECTOR_SHIFT) + offset;
-		break;
-	default:
-		errno = EINVAL;
-		return (off_t)-1;
-	}
-
-	if (new_off < 0 ||
-	    new_off > vhd_fd->vhd_part.size << VHD_SECTOR_SHIFT) {
-		errno = EINVAL;
-		return (off_t)-1;
-	}
-
-	vhd_fd->off = new_off;
-	return vhd_fd->off;
-}
-
-off64_t
-lseek64(int fd, off64_t offset, int whence)
-{
-	off64_t new_off;
-	vhd_fd_context_t *vhd_fd;
-	static off64_t (*_std_lseek64)(int, off64_t, int);
-
-	_RESOLVE(_std_lseek64);
-	vhd_fd = _libvhd_io_map_get(fd);
-
-	LOG("%s 0x%x 0x%llx 0x%x\n", __func__, fd, offset, whence);
-
-	if (!vhd_fd)
-		return _std_lseek64(fd, offset, whence);
-
-	switch (whence) {
-	case SEEK_SET:
-		new_off = offset;
-		break;
-	case SEEK_CUR:
-		new_off = vhd_fd->off + offset;
-		break;
-	case SEEK_END:
-		new_off = (vhd_fd->vhd_part.size << VHD_SECTOR_SHIFT) + offset;
-		break;
-	default:
-		errno = EINVAL;
-		return (off64_t)-1;
-	}
-
-	if (new_off < 0 ||
-	    new_off > vhd_fd->vhd_part.size << VHD_SECTOR_SHIFT) {
-		errno = EINVAL;
-		return (off64_t)-1;
-	}
-
-	vhd_fd->off = new_off;
-	return vhd_fd->off;
-}
-
-ssize_t
-read(int fd, void *buf, size_t count)
-{
-	ssize_t ret;
-	vhd_fd_context_t *vhd_fd;
-	static ssize_t (*_std_read)(int, void *, size_t);
-
-	_RESOLVE(_std_read);
-	vhd_fd = _libvhd_io_map_get(fd);
-
-	LOG("%s 0x%x %p 0x%x\n", __func__, fd, buf, count);
-
-	if (!vhd_fd)
-		return _std_read(fd, buf, count);
-
-	ret = _libvhd_io_pread(&vhd_fd->vhd_part, buf, count, vhd_fd->off);
-	if (ret != -1)
-		vhd_fd->off += count;
-
-	return ret;
-}
-
-ssize_t
-write(int fd, const void *buf, size_t count)
-{
-	ssize_t ret;
-	vhd_fd_context_t *vhd_fd;
-	static ssize_t (*_std_write)(int, const void *, size_t);
-
-	_RESOLVE(_std_write);
-	vhd_fd = _libvhd_io_map_get(fd);
-
-	LOG("%s 0x%x %p 0x%x\n", __func__, fd, buf, count);
-
-	if (!vhd_fd)
-		return _std_write(fd, buf, count);
-
-	ret = _libvhd_io_pwrite(&vhd_fd->vhd_part, buf, count, vhd_fd->off);
-	if (ret != -1)
-		vhd_fd->off += count;
-
-	return ret;
-}
-
-ssize_t
-pread(int fd, void *buf, size_t count, off_t offset)
-{
-	vhd_fd_context_t *vhd_fd;
-	static ssize_t (*_std_pread)(int, void *, size_t, off_t);
-
-	_RESOLVE(_std_pread);
-	vhd_fd = _libvhd_io_map_get(fd);
-
-	LOG("%s 0x%x %p 0x%x 0x%lx\n", __func__, fd, buf, count, offset);
-
-	if (!vhd_fd)
-		return _std_pread(fd, buf, count, offset);
-
-	return _libvhd_io_pread(&vhd_fd->vhd_part, buf, count, offset);
-}
-
-ssize_t
-pread64(int fd, void *buf, size_t count, off64_t offset)
-{
-	vhd_fd_context_t *vhd_fd;
-	static ssize_t (*_std_pread64)(int, void *, size_t, off64_t);
-
-	_RESOLVE(_std_pread64);
-	vhd_fd = _libvhd_io_map_get(fd);
-
-	LOG("%s 0x%x %p 0x%x 0x%llx\n", __func__, fd, buf, count, offset);
-
-	if (!vhd_fd)
-		return _std_pread64(fd, buf, count, offset);
-
-	return _libvhd_io_pread(&vhd_fd->vhd_part, buf, count, offset);
-}
-
-ssize_t
-pwrite(int fd, const void *buf, size_t count, off_t offset)
-{
-	vhd_fd_context_t *vhd_fd;
-	static ssize_t (*_std_pwrite)(int, const void *, size_t, off_t);
-
-	_RESOLVE(_std_pwrite);
-	vhd_fd = _libvhd_io_map_get(fd);
-
-	LOG("%s 0x%x %p 0x%x, 0x%lx\n", __func__, fd, buf, count, offset);
-
-	if (!vhd_fd)
-		return _std_pwrite(fd, buf, count, offset);
-
-	return _libvhd_io_pwrite(&vhd_fd->vhd_part, buf, count, offset);
-}
-
-ssize_t
-pwrite64(int fd, const void *buf, size_t count, off64_t offset)
-{
-	vhd_fd_context_t *vhd_fd;
-	static ssize_t (*_std_pwrite64)(int, const void *, size_t, off64_t);
-
-	_RESOLVE(_std_pwrite64);
-	vhd_fd = _libvhd_io_map_get(fd);
-
-	LOG("%s 0x%x %p 0x%x, 0x%llx\n", __func__, fd, buf, count, offset);
-
-	if (!vhd_fd)
-		return _std_pwrite64(fd, buf, count, offset);
-
-	return _libvhd_io_pwrite(&vhd_fd->vhd_part, buf, count, offset);
-}
-
-int
-fsync(int fd)
-{
-	vhd_fd_context_t *vhd_fd;
-	static int (*_std_fsync)(int);
-
-	_RESOLVE(_std_fsync);
-	vhd_fd = _libvhd_io_map_get(fd);
-	if (!vhd_fd)
-		return _std_fsync(fd);
-
-	LOG("%s 0x%x\n", __func__, fd);
-
-	return _std_fsync(vhd_fd->vhd_part.vhd_obj->vhd.fd);
-}
-
-int
-__xstat(int version, const char *path, struct stat *buf)
-{
-	int ret;
-	static int (*_std___xstat)(int, const char *, struct stat *);
-
-	_RESOLVE(_std___xstat);
-	if (!_libvhd_io_interpose)
-		return _std___xstat(version, path, buf);
-
-	LOG("%s 0x%x %s %p\n", __func__, version, path, buf);
-
-	ret = _libvhd_io_stat(version, path, buf);
-	if (ret)
-		ret = _std___xstat(version, path, buf);
-
-	return ret;
-}
-
-int
-__xstat64(int version, const char *path, struct stat64 *buf)
-{
-	int ret;
-	static int (*_std___xstat64)(int, const char *, struct stat64 *);
-
-	_RESOLVE(_std___xstat64);
-	if (!_libvhd_io_interpose)
-		return _std___xstat64(version, path, buf);
-
-	LOG("%s 0x%x %s %p\n", __func__, version, path, buf);
-
-	ret = _libvhd_io_stat64(version, path, buf);
-	if (ret)
-		ret = _std___xstat64(version, path, buf);
-
-
-	return ret;
-}
-
-int
-__fxstat(int version, int fd, struct stat *buf)
-{
-	vhd_fd_context_t *vhd_fd;
-	static int (*_std___fxstat)(int, int, struct stat *);
-
-	_RESOLVE(_std___fxstat);
-	vhd_fd = _libvhd_io_map_get(fd);
-
-	LOG("%s 0x%x 0x%x %p\n", __func__, version, fd, buf);
-
-	if (vhd_fd)
-		return _libvhd_io_fstat(version, &vhd_fd->vhd_part, buf);
-	else
-		return _std___fxstat(version, fd, buf);
-}
-
-int
-__fxstat64(int version, int fd, struct stat64 *buf)
-{
-	vhd_fd_context_t *vhd_fd;
-	static int (*_std___fxstat64)(int, int, struct stat64 *);
-
-	_RESOLVE(_std___fxstat64);
-	vhd_fd = _libvhd_io_map_get(fd);
-
-	LOG("%s 0x%x 0x%x %p\n", __func__, version, fd, buf);
-
-	if (vhd_fd)
-		return _libvhd_io_fstat64(version, &vhd_fd->vhd_part, buf);
-	else
-		return _std___fxstat64(version, fd, buf);
-}
-
-/*
- * NB: symlinks to vhds will be stat'ed rather than lstat'ed.
- */
-int
-__lxstat(int version, const char *path, struct stat *buf)
-{
-	int ret;
-	static int (*_std___lxstat)(int, const char *, struct stat *);
-
-	_RESOLVE(_std___lxstat);
-	if (!_libvhd_io_interpose)
-		return _std___lxstat(version, path, buf);
-
-	LOG("%s 0x%x %s %p\n", __func__, version, path, buf);
-
-	ret = _libvhd_io_stat(version, path, buf);
-	if (ret)
-		ret = _std___lxstat(version, path, buf);
-
-	return ret;
-}
-
-/*
- * NB: symlinks to vhds will be stat'ed rather than lstat'ed.
- */
-int
-__lxstat64(int version, const char *path, struct stat64 *buf)
-{
-	int ret;
-	static int (*_std___lxstat64)(int, const char *, struct stat64 *);
-
-	_RESOLVE(_std___lxstat64);
-	if (!_libvhd_io_interpose)
-		return _std___lxstat64(version, path, buf);
-
-	LOG("%s 0x%x %s %p\n", __func__, version, path, buf);
-
-	ret = _libvhd_io_stat64(version, path, buf);
-	if (ret)
-		ret = _std___lxstat64(version, path, buf);
-
-	return ret;
-}
-
-int
-ioctl(int fd, int request, char *argp)
-{
-	vhd_fd_context_t *vhd_fd;
-	static int (*_std_ioctl)(int, int, char *);
-
-	_RESOLVE(_std_ioctl);
-	vhd_fd = _libvhd_io_map_get(fd);
-	if (!vhd_fd)
-		return _std_ioctl(fd, request, argp);
-
-	LOG("%s 0x%x 0x%x %p\n", __func__, fd, request, argp);
-
-#ifdef BLKGETSIZE64
-	if (request == BLKGETSIZE64) {
-		uint64_t *size = (uint64_t *)argp;
-		*size = vhd_fd->vhd_part.size << VHD_SECTOR_SHIFT;
-		return 0;
-	}
-#endif
-#ifdef BLKGETSIZE
-	if (request == BLKGETSIZE) {
-		unsigned long *size = (unsigned long *)argp;
-		*size = vhd_fd->vhd_part.size << VHD_SECTOR_SHIFT;
-		return 0;
-	}
-#endif
-#ifdef BLKSSZGET
-	if (request == BLKSSZGET) {
-		int *sec_size = (int *)argp;
-		*sec_size = VHD_SECTOR_SIZE;
-		return 0;
-	}
-#endif
-#ifdef HDIO_GETGEO
-	if (request == HDIO_GETGEO) {
-		vhd_context_t *vhd = &vhd_fd->vhd_part.vhd_obj->vhd;
-		struct hd_geometry *geo = (struct hd_geometry *)argp;
-		geo->heads = GEOM_GET_HEADS(vhd->footer.geometry);
-		geo->sectors = GEOM_GET_SPT(vhd->footer.geometry);
-		geo->cylinders = GEOM_GET_CYLS(vhd->footer.geometry);
-		geo->start = vhd_fd->vhd_part.start;
-		return 0;
-	}
-#endif
-
-	return _std_ioctl(fd, request, argp);
-}
-
-int
-fcntl(int fd, int cmd, ...)
-{
-	int real_fd;
-	va_list args;
-	vhd_fd_context_t *vhd_fd;
-	static int (*_std_fcntl)(int, int, ...);
-
-	_RESOLVE(_std_fcntl);
-
-	real_fd = fd;
-	vhd_fd = _libvhd_io_map_get(fd);
-	if (vhd_fd)
-		real_fd = vhd_fd->vhd_part.vhd_obj->vhd.fd;
-
-	LOG("%s 0x%x 0x%x\n", __func__, fd, cmd);
-
-	switch (cmd) {
-	case F_GETFD:
-	case F_GETFL:
-	case F_GETOWN:
-	case F_GETSIG:
-	case F_GETLEASE:
-		LOG("%s 0x%x void\n", __func__, real_fd);
-		return _std_fcntl(real_fd, cmd);
-
-	case F_DUPFD:
-#ifdef F_DUPFD_CLOEXEC
-	case F_DUPFD_CLOEXEC:
-#endif // F_DUPFD_CLOEXEC
-	case F_SETFD:
-	case F_SETFL:
-	case F_SETOWN:
-	case F_SETSIG:
-	case F_SETLEASE:
-	case F_NOTIFY:
-	{
-		long arg;
-		va_start(args, cmd);
-		arg = va_arg(args, long);
-		va_end(args);
-		LOG("%s 0x%x long 0x%lx\n", __func__, real_fd, arg);
-		return _std_fcntl(real_fd, cmd, arg);
-	}
-
-	case F_SETLK:
-	case F_SETLKW:
-	case F_GETLK:
-	{
-		struct flock *flk;
-		va_start(args, cmd);
-		flk = va_arg(args, struct flock *);
-		va_end(args);
-		LOG("%s 0x%x lock %p\n", __func__, real_fd, flk);
-		return _std_fcntl(real_fd, cmd, flk);
-	}
-
-	case F_SETLK64:
-	case F_SETLKW64:
-	case F_GETLK64:
-	{
-		struct flock64 *flk;
-		va_start(args, cmd);
-		flk = va_arg(args, struct flock64 *);
-		va_end(args);
-		LOG("%s 0x%x lock64 %p (%p)\n",
-		    __func__, real_fd, flk, _std_fcntl);
-		return _std_fcntl(real_fd, cmd, flk);
-	}
-
-	default:
-		LOG("%s unrecognized cmd\n", __func__);
-		errno = EINVAL;
-		return -1;
-	}
-}
-
-FILE *
-fopen(const char *path, const char *mode)
-{
-	FILE *f;
-	static _std_fopen_t _std_fopen;
-
-	_RESOLVE(_std_fopen);
-
-	if (!_libvhd_io_interpose || strchr(mode, 'w'))
-		return _std_fopen(path, mode);
-
-	f = _libvhd_io_fopen(path, mode);
-
-	LOG("%s %s %s: 0x%x\n", __func__, path, mode, (f ? fileno(f) : -1));
-
-	return f;
-}
-
-FILE *
-fopen64(const char *path, const char *mode)
-{
-	FILE *f;
-	static _std_fopen_t _std_fopen64;
-
-	_RESOLVE(_std_fopen64);
-
-	if (!_libvhd_io_interpose || strchr(mode, 'w'))
-		return _std_fopen64(path, mode);
-
-	f = _libvhd_io_fopen(path, mode);
-
-	LOG("%s %s %s: 0x%x\n", __func__, path, mode, (f ? fileno(f) : -1));
-
-	return f;
-}
-
-int
-fclose(FILE *fp)
-{
-	static int (*_std_fclose)(FILE *);
-
-	_RESOLVE(_std_fclose);
-
-	LOG("%s %p\n", __func__, fp);
-
-	_libvhd_io_map_clear(fileno(fp));
-	return _std_fclose(fp);
-}
-
-int
-_IO_getc(FILE *f)
-{
-	int cnt;
-	unsigned char c;
-	vhd_fd_context_t *vhd_fd;
-	static int (*_std__IO_getc)(FILE *);
-
-	_RESOLVE(_std__IO_getc);
-	vhd_fd = _libvhd_io_map_get(fileno(f));
-	if (!vhd_fd)
-		return _std__IO_getc(f);
-
-	LOG("%s %p (0x%x)\n", __func__, f, fileno(f));
-	cnt = _libvhd_io_pread(&vhd_fd->vhd_part, &c, sizeof(c), vhd_fd->off);
-	if (cnt > 0)
-		vhd_fd->off += cnt;
-
-	return (int)c;
-}
-
-#ifdef _IO_getc_unlocked
-#undef _IO_getc_unlocked
-#endif
-int
-_IO_getc_unlocked(FILE *f)
-{
-	return _IO_getc(f);
-}
-
-size_t
-fread(void *buf, size_t size, size_t n, FILE *f)
-{
-	ssize_t cnt;
-	vhd_fd_context_t *vhd_fd;
-	static size_t (*_std_fread)(void *, size_t, size_t, FILE *);
-
-	_RESOLVE(_std_fread);
-	vhd_fd = _libvhd_io_map_get(fileno(f));
-	if (!vhd_fd)
-		return _std_fread(buf, size, n, f);
-
-	LOG("%s %p 0x%x 0x%x %p (0x%x)\n",
-	    __func__, buf, size, n, f, fileno(f));
-	cnt = _libvhd_io_pread(&vhd_fd->vhd_part, buf, n * size, vhd_fd->off);
-	if (cnt > 0) {
-		vhd_fd->off += cnt;
-		cnt /= size;
-	}
-
-	return cnt;
-}
-
-#ifdef fread_unlocked
-#undef fread_unlocked
-#endif
-size_t fread_unlocked(void *buf, size_t size, size_t n, FILE *f)
-{
-	return fread(buf, size, n, f);
-}
-
-/*
- * sigh... preloading with bash causes problems, since bash has its own
- * malloc(), memalign(), and free() functions, but no posix_memalign().
- * this causes problems when libvhd free()'s posix_memalign()'ed memory.
- */
-#define _libvhd_power_of_2(x) ((((x) - 1) & (x)) == 0)
-int
-posix_memalign(void **memptr, size_t alignment, size_t size)
-{
-	if (!alignment || alignment % sizeof(void *) ||
-	    !_libvhd_power_of_2(alignment / sizeof(void *)))
-		return EINVAL;
-
-	*memptr = memalign(alignment, size);
-	if (!*memptr)
-		return ENOMEM;
-
-	return 0;
-}
diff -Nur blktap2_oxt//vhd/lib/libvhd-journal.c blktap2_xen//vhd/lib/libvhd-journal.c
--- blktap2_oxt//vhd/lib/libvhd-journal.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/libvhd-journal.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -56,21 +52,21 @@
 } vhd_journal_entry_t;
 
 static inline int
-vhd_journal_seek(vhd_journal_t *j, off64_t offset, int whence)
+vhd_journal_seek(vhd_journal_t *j, off_t offset, int whence)
 {
-	off64_t off;
+	off_t off;
 
-	off = lseek64(j->jfd, offset, whence);
-	if (off == (off64_t)-1)
+	off = lseek(j->jfd, offset, whence);
+	if (off == (off_t)-1)
 		return -errno;
 
 	return 0;
 }
 
-static inline off64_t
+static inline off_t
 vhd_journal_position(vhd_journal_t *j)
 {
-	return lseek64(j->jfd, 0, SEEK_CUR);
+	return lseek(j->jfd, 0, SEEK_CUR);
 }
 
 static inline int
@@ -102,7 +98,7 @@
 }
 
 static inline int
-vhd_journal_truncate(vhd_journal_t *j, off64_t length)
+vhd_journal_truncate(vhd_journal_t *j, off_t length)
 {
 	int err;
 
@@ -149,7 +145,7 @@
 vhd_journal_validate_header(vhd_journal_t *j, vhd_journal_header_t *header)
 {
 	int err;
-	off64_t eof;
+	off_t eof;
 
 	if (memcmp(header->cookie,
 		   VHD_JOURNAL_HEADER_COOKIE, sizeof(header->cookie)))
@@ -160,7 +156,7 @@
 		return err;
 
 	eof = vhd_journal_position(j);
-	if (eof == (off64_t)-1)
+	if (eof == (off_t)-1)
 		return -errno;
 
 	if (j->header.journal_data_offset > j->header.journal_eof)
@@ -223,7 +219,7 @@
 vhd_journal_add_journal_header(vhd_journal_t *j)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	vhd_context_t *vhd;
 
 	vhd = &j->vhd;
@@ -234,14 +230,14 @@
 		return err;
 
 	off = vhd_position(vhd);
-	if (off == (off64_t)-1)
+	if (off == (off_t)-1)
 		return -errno;
 
 	err = vhd_get_footer(vhd);
 	if (err)
 		return err;
 
-	uuid_copy(j->header.uuid, vhd->footer.uuid);
+	vhd_uuid_copy(&j->header.uuid, &vhd->footer.uuid);
 	memcpy(j->header.cookie,
 	       VHD_JOURNAL_HEADER_COOKIE, sizeof(j->header.cookie));
 	j->header.vhd_footer_offset = off - sizeof(vhd_footer_t);
@@ -357,10 +353,11 @@
 }
 
 static int
-vhd_journal_update(vhd_journal_t *j, off64_t offset,
+vhd_journal_update(vhd_journal_t *j, off_t offset,
 		   char *buf, size_t size, uint32_t type)
 {
 	int err;
+	off_t eof;
 	uint64_t *off, off_bak;
 	uint32_t *entries;
 	vhd_journal_entry_t entry;
@@ -416,7 +413,7 @@
 vhd_journal_add_footer(vhd_journal_t *j)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	vhd_context_t *vhd;
 	vhd_footer_t footer;
 
@@ -427,7 +424,7 @@
 		return err;
 
 	off = vhd_position(vhd);
-	if (off == (off64_t)-1)
+	if (off == (off_t)-1)
 		return -errno;
 
 	err = vhd_read_footer_at(vhd, &footer, off - sizeof(vhd_footer_t));
@@ -462,7 +459,7 @@
 vhd_journal_add_header(vhd_journal_t *j)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	vhd_context_t *vhd;
 	vhd_header_t header;
 
@@ -498,7 +495,7 @@
 	n = sizeof(vhd->header.loc) / sizeof(vhd_parent_locator_t);
 	for (i = 0; i < n; i++) {
 		char *buf;
-		off64_t off;
+		off_t off;
 		size_t size;
 		vhd_parent_locator_t *loc;
 
@@ -545,7 +542,7 @@
 vhd_journal_add_bat(vhd_journal_t *j)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	size_t size;
 	vhd_bat_t bat;
 	vhd_context_t *vhd;
@@ -575,7 +572,7 @@
 vhd_journal_add_batmap(vhd_journal_t *j)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	size_t size;
 	vhd_context_t *vhd;
 	vhd_batmap_t batmap;
@@ -614,6 +611,7 @@
 vhd_journal_add_metadata(vhd_journal_t *j)
 {
 	int err;
+	off_t eof;
 	vhd_context_t *vhd;
 
 	vhd = &j->vhd;
@@ -906,7 +904,7 @@
 	if (err)
 		return err;
 
-	err = vhd_validate_batmap(&j->vhd, batmap);
+	err = vhd_validate_batmap(batmap);
 	if (err) {
 		free(batmap->map);
 		batmap->map = NULL;
@@ -932,7 +930,7 @@
 static int
 vhd_journal_restore_header(vhd_journal_t *j, vhd_header_t *header)
 {
-	off64_t off;
+	off_t off;
 	vhd_context_t *vhd;
 
 	vhd = &j->vhd;
@@ -987,7 +985,7 @@
 static int
 vhd_journal_restore_metadata(vhd_journal_t *j)
 {
-	off64_t off;
+	off_t off;
 	char **locators;
 	vhd_footer_t copy;
 	vhd_context_t *vhd;
@@ -1048,7 +1046,7 @@
 
 restore:
 	off  = vhd_journal_position(j);
-	if (off == (off64_t)-1)
+	if (off == (off_t)-1)
 		return -errno;
 
 	if (j->header.journal_data_offset != off)
@@ -1258,7 +1256,11 @@
 int
 vhd_journal_create(vhd_journal_t *j, const char *file, const char *jfile)
 {
-	int err;
+	char *buf;
+	int i, err;
+	size_t size;
+	off_t off;
+	struct stat stats;
 
 	memset(j, 0, sizeof(vhd_journal_t));
 	j->jfd = -1;
@@ -1343,7 +1345,7 @@
 {
 	int err;
 	char *buf;
-	off64_t off;
+	off_t off;
 	size_t size;
 	uint64_t blk;
 	vhd_context_t *vhd;
diff -Nur blktap2_oxt//vhd/lib/libvhd-stream.c blktap2_xen//vhd/lib/libvhd-stream.c
--- blktap2_oxt//vhd/lib/libvhd-stream.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/libvhd-stream.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,523 +0,0 @@
-/*
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <errno.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stddef.h>
-
-#include "libvhd.h"
-
-struct vhd_stream {
-	FILE            *stream;
-	off64_t          pos;
-	vhd_context_t    vhd;
-};
-
-#define ERR(_fmt, _args...) fprintf(stderr, "%d: " _fmt, __LINE__, ##_args)
-
-#define VERR(_v, _fmt, _args...)					\
-	do {								\
-		char uuid[37];						\
-		uuid_unparse((_v)->vhd.footer.uuid, uuid);		\
-		ERR("%s: " _fmt, uuid, ##_args);			\
-	} while (0)							\
-
-#define vhd_to_stream(_vhd)						\
-	((struct vhd_stream *)((unsigned long)(_vhd) -			\
-			       offsetof(struct vhd_stream, vhd)))
-
-static off64_t
-vhd_stream_position(struct vhd_stream *vstream)
-{
-	if (!vstream->stream)
-		return (off64_t) -EBADF;
-	return vstream->pos;
-}
-
-static int
-vhd_stream_read(struct vhd_stream *vstream, void *buf, size_t count)
-{
-	int err;
-
-	if (!vstream->stream) {
-		err = -EBADF;
-		goto out;
-	}
-
-	if (fread(buf, count, 1, vstream->stream) == 1) {
-		err = 0;
-		vstream->pos += count;
-	} else {
-		err = ferror(vstream->stream);
-		if (err)
-			err = (errno ? -errno : -EIO);
-		else
-			err = -EIO;
-	}
-
-out:
-	if (err)
-		VERR(vstream, "error reading 0x%x bytes: %d\n", count, err);
-	return err;
-}
-
-static int
-vhd_stream_write(struct vhd_stream *vstream, const void *buf, size_t count)
-{
-	int err;
-
-	if (!vstream->stream) {
-		err = -EBADF;
-		goto out;
-	}
-
-	if (fwrite(buf, count, 1, vstream->stream) == 1 &&
-	    !fflush(vstream->stream)) {
-		err = 0;
-		vstream->pos += count;
-	} else {
-		err = ferror(vstream->stream);
-		if (err)
-			err = (errno ? -errno : -EIO);
-		else
-			err = -EIO;
-	}
-
-out:
-	if (err)
-		VERR(vstream, "error writing 0x%x bytes: %d\n", count, err);
-	return err;
-}
-
-static int
-vhd_stream_seek(struct vhd_stream *vstream, off64_t off, int whence)
-{
-	int err, rw;
-	off64_t pos;
-	char buf[4096];
-
-	rw = vhd_flag_test(vstream->vhd.oflags, VHD_OPEN_RDWR);
-
-	if (!vstream->stream) {
-		err = -EBADF;
-		goto out;
-	}
-
-
-	err = fseeko(vstream->stream, off, whence);
-	if (!err) {
-		vstream->pos = off;
-		goto out;
-	} else if (errno != ESPIPE) {
-		err = -errno;
-		goto out;
-	}
-
-	switch (whence) {
-	case SEEK_SET:
-		pos = off;
-		break;
-	case SEEK_CUR:
-		pos = vstream->pos + off;
-		break;
-	case SEEK_END:
-		err = -ESPIPE;
-		goto out;
-	default:
-		err = -EINVAL;
-		goto out;
-	}
-
-	if (pos < 0) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	if (pos < vstream->pos) {
-		err = -ESPIPE;
-		goto out;
-	}
-
-	err = 0;
-
-	if (rw && vstream->pos < pos)
-		memset(buf, 0, sizeof(buf));
-
-	while (vstream->pos < pos) {
-		size_t size = sizeof(buf);
-
-		if (size > (pos - vstream->pos))
-			size = (pos - vstream->pos);
-
-		if (rw)
-			err = vhd_stream_write(vstream, buf, size);
-		else
-			err = vhd_stream_read(vstream, buf, size);
-
-		if (err)
-			goto out;
-	}
-
-out:
-	if (err)
-		VERR(vstream, "error seeking 0x%llx 0x%x: %d\n",
-		     off, whence, err);
-	return err;
-}
-
-static int
-vhd_stream_pread(struct vhd_stream *vstream,
-		 void *buf, size_t size, off64_t off)
-{
-	int err;
-
-	if (!vstream->stream) {
-		err = -EBADF;
-		goto out;
-	}
-
-	err = vhd_stream_seek(vstream, off, SEEK_SET);
-	if (err)
-		goto out;
-
-	err = vhd_stream_read(vstream, buf, size);
-	if (err)
-		goto out;
-
-out:
-	if (err)
-		VERR(vstream, "error reading 0x%x bytes at 0x%llx: %d\n",
-		     size, off, err);
-	return err;
-}
-
-static int
-vhd_stream_pwrite(struct vhd_stream *vstream,
-		  const void *buf, size_t size, off64_t off)
-{
-	int err;
-
-	if (!vstream->stream) {
-		err = -EBADF;
-		goto out;
-	}
-
-	err = vhd_stream_seek(vstream, off, SEEK_SET);
-	if (err)
-		goto out;
-
-	err = vhd_stream_write(vstream, buf, size);
-	if (err)
-		goto out;
-
-out:
-	if (err)
-		VERR(vstream, "error reading 0x%x bytes at 0x%llx: %d\n",
-		     size, off, err);
-	return err;
-}
-
-static void
-vhd_stream_close(struct vhd_stream *vstream)
-{
-	if (vstream->stream)
-		fclose(vstream->stream);
-	vstream->vhd.devops = NULL;
-	vhd_close(&vstream->vhd);
-	free(vstream);
-}
-
-static off64_t
-vhd_stream_devops_position(vhd_context_t *vhd)
-{
-	return vhd_stream_position(vhd_to_stream(vhd));
-}
-
-static int
-vhd_stream_devops_seek(vhd_context_t *vhd, off64_t off, int whence)
-{
-	return vhd_stream_seek(vhd_to_stream(vhd), off, whence);
-}
-
-static int
-vhd_stream_devops_read(vhd_context_t *vhd, void *buf, size_t count)
-{
-	return vhd_stream_read(vhd_to_stream(vhd), buf, count);
-}
-
-static int
-vhd_stream_devops_pread(vhd_context_t *vhd,
-			void *buf, size_t size, off64_t off)
-{
-	return vhd_stream_pread(vhd_to_stream(vhd), buf, size, off);
-}
-
-static int
-vhd_stream_devops_write(vhd_context_t *vhd, void *buf, size_t count)
-{
-	return vhd_stream_write(vhd_to_stream(vhd), buf, count);
-}
-
-static int
-vhd_stream_devops_pwrite(vhd_context_t *vhd,
-			 void *buf, size_t size, off64_t off)
-{
-	return vhd_stream_pwrite(vhd_to_stream(vhd), buf, size, off);
-}
-
-static void
-vhd_stream_devops_close(vhd_context_t *vhd)
-{
-	vhd_stream_close(vhd_to_stream(vhd));
-}
-
-vhd_devops_t vhd_stream_devops = {
-	.position = vhd_stream_devops_position,
-	.seek     = vhd_stream_devops_seek,
-	.read     = vhd_stream_devops_read,
-	.write    = vhd_stream_devops_write,
-	.pread    = vhd_stream_devops_pread,
-	.pwrite   = vhd_stream_devops_pwrite,
-	.close    = vhd_stream_devops_close,
-};
-
-struct vhd_stream *
-vhd_stream_allocate(FILE *stream, const char *mode)
-{
-	int fd, err;
-	struct vhd_stream *vstream;
-
-	fd      = -1;
-	err     = 0;
-	vstream = NULL;
-
-	vstream = calloc(1, sizeof(*vstream));
-	if (!vstream) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	fd = dup(fileno(stream));
-	if (fd == -1) {
-		err = -errno;
-		goto out;
-	}
-
-	vstream->stream = fdopen(fd, mode);
-	if (!vstream->stream) {
-		err = -errno;
-		goto out;
-	}
-
-	vstream->vhd.devops = &vhd_stream_devops;
-
-out:
-	if (err) {
-		if (fd != -1)
-			close(fd);
-
-		free(vstream);
-		vstream = NULL;
-
-		errno = -err;
-	}
-	return vstream;
-}
-
-/**
- * vhd_stream_load(): initialize a vhd_context_t from a stream of data
- *
- * @stream: the stream (fifo, pipe, etc.) containing the vhd
- *
- * This function dups the input stream and attempts to initialize a vhd context
- * from the stream's data.  The resulting vhd_context can be used as any file-
- * based context would be, with the exception that forward seeks may take a
- * long time, backward seeks will fail with ESPIPE, and writes/pwrites will
- * fail with ENOSYS.
- */
-vhd_context_t *
-vhd_stream_load(FILE *stream)
-{
-	int err;
-	vhd_context_t *vhd;
-	struct vhd_stream *vstream;
-
-	vhd = NULL;
-
-	vstream = vhd_stream_allocate(stream, "rb");
-	if (!vstream) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	vhd = &vstream->vhd;
-	vhd->oflags = VHD_OPEN_RDONLY;
-
-	err = vhd_read_footer_at(vhd, &vhd->footer, 0);
-	if (err)
-		goto out;
-
-	err = vhd_read_header(vhd, &vhd->header);
-	if (err)
-		goto out;
-
-	vhd->spb     = vhd->header.block_size >> VHD_SECTOR_SHIFT;
-	vhd->bm_secs = secs_round_up_no_zero(vhd->spb >> 3);
-
-	err = vhd_read_bat(vhd, &vhd->bat);
-	if (err)
-		goto out;
-
-	if (vhd_has_batmap(vhd)) {
-		err = vhd_read_batmap(vhd, &vhd->batmap);
-		if (err)
-			goto out;
-	}
-
-out:
-	if (err) {
-		vhd = NULL;
-		errno = -err;
-		ERR("error loading stream: %d\n", err);
-		if (vstream)
-			vhd_stream_close(vstream);
-	}
-	return vhd;
-}
-
-/**
- * vhd_stream_initialize() - initialze a vhd_stream, possibly cloning @in
- *
- * @stream: the stream to be associated with this vhd
- * @in: (an optional) vhd whose metadata will be used to initialize the stream
- *
- * vhd_stream_initialize prepares a vhd_stream for further use.  If @in is not
- * NULL, its metadata (footer, header, bat, and batmap) will be used to
- * populate the stream metadata.
- */
-vhd_context_t *
-vhd_stream_initialize(FILE *stream, vhd_context_t *in)
-{
-	int err;
-	char *buf;
-	size_t size;
-	vhd_context_t *out;
-	struct vhd_stream *vstream;
-
-	err     = 0;
-	buf     = NULL;
-	out     = NULL;
-	vstream = NULL;
-
-	vstream = vhd_stream_allocate(stream, "wb");
-	if (!vstream) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	if (!in) {
-		out = &vstream->vhd;
-		goto out;
-	}
-
-	if (!vhd_type_dynamic(in)) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	err = vhd_get_footer(in);
-	if (err)
-		goto out;
-
-	err = vhd_get_header(in);
-	if (err)
-		goto out;
-
-	err = vhd_get_bat(in);
-	if (err)
-		goto out;
-
-	if (vhd_has_batmap(in)) {
-		err = vhd_get_batmap(in);
-		if (err)
-			goto out;
-	}
-
-	out = &vstream->vhd;
-	vstream->stream = stream;
-	out->oflags = VHD_OPEN_RDWR;
-
-	memcpy(&out->footer, &in->footer, sizeof(out->footer));
-	memcpy(&out->header, &in->header, sizeof(out->header));
-
-	size = vhd_bytes_padded(in->bat.entries * sizeof(uint32_t));
-
-	err = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, size);
-	if (err) {
-		buf = NULL;
-		err = -err;
-		goto out;
-	}
-
-	out->spb         = in->spb;
-	out->bm_secs     = in->bm_secs;
-	out->bat.spb     = in->bat.spb;
-	out->bat.entries = in->bat.entries;
-	out->bat.bat     = (uint32_t *)buf;
-	memcpy(out->bat.bat, in->bat.bat, size);
-
-	if (vhd_has_batmap(in)) {
-		size = vhd_bytes_padded(in->footer.curr_size /
-					(in->header.block_size * 8));
-
-		err = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, size);
-		if (err) {
-			buf = NULL;
-			err = -err;
-			goto out;
-		}
-
-		out->batmap.map = buf;
-		memcpy(out->batmap.map, in->batmap.map, size);
-
-		memcpy(&out->batmap.header,
-		       &in->batmap.header, sizeof(out->batmap.header));
-	}
-
-out:
-	if (err) {
-		free(buf);
-		if (out)
-			vhd_close(out);
-		vstream = NULL;
-	}
-	return out;
-}
diff -Nur blktap2_oxt//vhd/lib/Makefile blktap2_xen//vhd/lib/Makefile
--- blktap2_oxt//vhd/lib/Makefile	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/Makefile	2015-03-19 11:08:36.000000000 -0400
@@ -1,41 +1,34 @@
-#
-# Copyright (c) 2012 Citrix Systems, Inc.
-#
-
-BLKTAP_ROOT := ../../
-include $(BLKTAP_ROOT)/Rules.mk
+XEN_ROOT=$(CURDIR)/../../../..
+BLKTAP_ROOT := ../..
+include $(XEN_ROOT)/tools/Rules.mk
 
 LIBVHD-MAJOR     = 1.0
 LIBVHD-MINOR     = 0
 LIBVHD-SONAME    = libvhd.so.$(LIBVHD-MAJOR)
 
-LVM-UTIL-OBJ    := $(BLKTAP_ROOT)lvm/lvm-util.o
+LVM-UTIL-OBJ    := $(BLKTAP_ROOT)/lvm/lvm-util.o
 
-LIBVHD          := libvhd.a libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR)
-LIBVHDIO        := libvhdio.a libvhdio.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR)
-LIBVHD-BUILD    := $(LIBVHD) $(LIBVHDIO)
+LIBVHD-BUILD    := libvhd.a
 
-INST-DIR         = /usr/lib
+INST-DIR         = $(LIBDIR)
 
-CFLAGS          += -Wall
-CFLAGS          += -Werror -Wno-error=unused-but-set-variable -Wno-error=uninitialized
+CFLAGS          += -Werror
+CFLAGS          += -Wno-unused
 CFLAGS          += -I../../include
 CFLAGS          += -D_GNU_SOURCE
-ifndef TRANSFERVM
 CFLAGS          += -fPIC
-endif
 CFLAGS          += -g
 
-LIBS            := -luuid -lcrypto -licbinn_resolved -ldl
+ifeq ($(CONFIG_Linux),y)
+LIBS            := -luuid
+endif
 
-# Get gcc to generate the dependencies for us.
-CFLAGS          += -Wp,-MD,.$(@F).d
-DEPS             = .*.d
+ifeq ($(CONFIG_LIBICONV),y)
+LIBS            += -liconv
+endif
 
 LIB-SRCS        := libvhd.c
 LIB-SRCS        += libvhd-journal.c
-LIB-SRCS        += libvhd-index.c
-LIB-SRCS        += libvhd-stream.c
 LIB-SRCS        += vhd-util-coalesce.c
 LIB-SRCS        += vhd-util-create.c
 LIB-SRCS        += vhd-util-fill.c
@@ -49,65 +42,39 @@
 LIB-SRCS        += vhd-util-snapshot.c
 LIB-SRCS        += vhd-util-scan.c
 LIB-SRCS        += vhd-util-check.c
-LIB-SRCS        += vhd-util-clone-metadata.c
-LIB-SRCS        += vhd-util-stream-coalesce.c
-LIB-SRCS        += vhd-util-dm-encrypt.c
-LIB-SRCS        += vhd-util-dm-decrypt.c
-LIB-SRCS        += vhd-util-key.c
+LIB-SRCS        += vhd-util-uuid.c
 LIB-SRCS        += relative-path.c
 LIB-SRCS        += atomicio.c
-LIB-SRCS        += xattr.c
 
 LIB-OBJS         = $(patsubst %.c,%.o,$(LIB-SRCS))
-ifndef TRANSFERVM
 LIB-OBJS        += $(LVM-UTIL-OBJ)
-endif
-
-LIBVHD-IO-LIBS  := -ldl -L./ -lvhd
-LIBVHD-IO-OBJS  := libvhdio.o $(BLKTAP_ROOT)/part/partition.o
-LIBVHD-IO        = libvhdio.a libvhdio.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR)
-LIBVHD-IO-SONAME = libvhdio.so.$(LIBVHD-MAJOR)
 
-all: build
+LIB-PICOBJS      = $(patsubst %.o,%.opic,$(LIB-OBJS))
 
-build: $(LIBVHD-BUILD)
+LIBVHD           = libvhd.a libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR)
 
-libvhd.so: libvhd.so.$(LIBVHD-MAJOR)
-	ln -sf $^ $@
-
-libvhdio.so: libvhdio.so.$(LIBVHD-MAJOR)
-	ln -sf $^ $@
-
-libvhd.so.$(LIBVHD-MAJOR): libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR)
-	ln -sf $^ $@
-
-libvhdio.so.$(LIBVHD-MAJOR): libvhdio.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR)
-	ln -sf $^ $@
-
-libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR): $(LIB-OBJS)
-	$(CC) $(CFLAGS) -Wl,$(SONAME_LDFLAG),$(LIBVHD-SONAME) $(SHLIB_CFLAGS) \
-		-o $@ $^ ${LIBS}
+all: build
 
-libvhdio.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR): $(LIBVHD-IO-OBJS) libvhd.so
-	$(CC) $(CFLAGS) -Wl,$(SONAME_LDFLAG),$(LIBVHD-IO-SONAME) $(SHLIB_CFLAGS) \
-		-o $@ $(LIBVHD-IO-LIBS) $^
+build: libvhd.a libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR)
 
 libvhd.a: $(LIB-OBJS)
 	$(AR) rc $@ $^
 
-libvhdio.a: $(LIBVHD-IO-OBJS)
-	$(AR) rc $@ $^
+libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR): $(LIB-PICOBJS)
+	$(CC) -Wl,$(SONAME_LDFLAG),$(LIBVHD-SONAME) $(SHLIB_LDFLAGS) \
+		$(LDFLAGS) -o libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR) $^ $(LIBS)
+	ln -sf libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR) libvhd.so.$(LIBVHD-MAJOR)
+	ln -sf libvhd.so.$(LIBVHD-MAJOR) libvhd.so
 
 install: all
 	$(INSTALL_DIR) -p $(DESTDIR)$(INST-DIR)
-	$(INSTALL_DATA) $(LIBVHD) $(LIBVHD-IO) $(DESTDIR)$(INST-DIR)
+	$(INSTALL_DATA) libvhd.a $(DESTDIR)$(INST-DIR)
+	$(INSTALL_PROG) libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR) $(DESTDIR)$(INST-DIR)
 	ln -sf libvhd.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR) $(DESTDIR)$(INST-DIR)/libvhd.so.$(LIBVHD-MAJOR)
 	ln -sf libvhd.so.$(LIBVHD-MAJOR) $(DESTDIR)$(INST-DIR)/libvhd.so
-	ln -sf libvhdio.so.$(LIBVHD-MAJOR).$(LIBVHD-MINOR) $(DESTDIR)$(INST-DIR)/libvhdio.so.$(LIBVHD-MAJOR)
-	ln -sf libvhdio.so.$(LIBVHD-MAJOR) $(DESTDIR)$(INST-DIR)/libvhdio.so
 
 clean:
-	rm -rf *.a *.so* *.o *~ $(DEPS) $(LIBVHD) $(LIBVHD-IO)
+	rm -rf *.a *.so* *.o *.opic *~ $(DEPS) $(LIBVHD)
 
 .PHONY: all build clean install libvhd
 
diff -Nur blktap2_oxt//vhd/lib/README.libvhdio blktap2_xen//vhd/lib/README.libvhdio
--- blktap2_oxt//vhd/lib/README.libvhdio	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/README.libvhdio	1969-12-31 19:00:00.000000000 -0500
@@ -1,132 +0,0 @@
-LIBVHDIO
-
-libvhdio.so is an interposition library which presents VHDs as block
-devices. When pre-loaded with dynamically linked binaries, it
-intercepts all file-level IO calls (such as open, read, write, etc.)
-made against VHDs and interprets them as if they were against the VHD
-virtual block device. Thus, for example, when libvhdio intercepts a
-read() call at offset 0 of a VHD, it parses the VHD metadata, maps the
-offset into the virtual block device address space, and returns the
-data corresponding to byte 0 of the virtual block device. This
-essentially makes the VHD regular file appear as a 'mounted' block
-device, and it allows unmodified binaries (like dd, mkfs, etc.) to
-manipulate VHDs without knowing anything about the VHD file format.
-
-
-DETAILS
-
-During calls to open(), libvhdio inspects the file to be opened. If
-the given file is a VHD (i.e., it contains a valid VHD header and
-footer), libvhdio opens the file with libvhd::vhd_open(), saves the
-vhd_context_t in a private table, opens /dev/null to create a dummy
-file descriptor, maps the descriptor to the vhd_context_t, and returns
-the dummy descriptor to the caller. Any subsequent calls made against
-the dummy file descriptor will be intercepted and applied to the VHD.
-
-It is not safe to have multiple vhd_context_t objects opened for
-writing against the same VHD because each context keeps a private
-in-memory cache of metadata. For this reason libvhdio wraps each
-vhd_context_t in a vhd_object, which contains a reference count and
-the inode number of the underlying VHD file. When a call is made to
-open a VHD, libvhdio first searches its table of open vhd_objects for
-a context whose inode number matches that of the given file
-argument. If a match is found, libvhdio increments a reference count
-for the vhd_object, allocates a new vhd_fd_context and links it to the
-vhd_object, and returns the vhd_fd_context.
-
-Each vhd_fd_context maintains the seek offset for the file descriptor
-it represents. It also maintains a 'users' count. When a
-vhd_fd_context is dup()'ed, this 'users' count is incremented,
-allowing the same vhd_fd_context_t to be shared across all dup()'ed
-instances of a given file descriptor.
-
-libvhdio is able to expose individual primary partitions within a
-VHD. This is accomplished by a naming convention. When opening a VHD
-file, libvhdio checks the path argument provided to open; if the path
-names a symbolic link whose name matches "*.vhd[1-4]", and the file
-referenced by the link is indeed a VHD, libvhdio will parse the
-partition table in the VHD to determine the logical offsets of the
-given partition. All subsequent read/write/seek/etc. calls will be
-made relative to the partition offset. This state is maintained in the
-vhd_partition structure, a simple wrapper of the vhd_object struct.
-
-A convenience script blktap.git:/part/vhdpartx is provided to
-facilitate the creation of the symbolic links used by
-libvhdio. vhdpartx is analogous to kpartx -- it scans the VHD
-partition table and creates or removes symlinks for each
-partition. 'vhdpartx -a /path/to/vhd' will create symlinks, while
-'vhdpartx -d /path/to/vhd' will remove them, and 'vhdpartx -l
-/path/to/vhd' will list all valid partitions.
-
-The full association of libvhdio data structures is:
-
-fd -> vhd_fd_context -> vhd_partition -> vhd_object -> vhd_context_t
-
-Multiple dummy fds may map to a single vhd_fd_context by virtue of
-calls to dup(), and multiple vhd_partition structs may link to a
-single vhd_object struct by virtue of multiple calls to open() of the
-same VHD file.
-
-
-CAVEATS
-
-As with all LD_PRELOAD libraries, libvhdio can only intercept calls to
-dynamically linked library functions. Thus libvhdio will not work with
-statically linked binaries.
-
-Also, while effort has been made to interpose on all relevant IO
-functions (in all their various incarnations), your mileage may vary.
-
-Finally, crypto support is not currently provided.
-
-**DO NOT USE libvhdio WITH ENCRYPTED VHDs!**
-
-
-DEBUGGING
-
-There are a few environment variables which can be set to increase the
-verbosity of libvhdio:
-
-  LIBVHD_IO_DEBUG: if set, libvhdio will log every function it
-    intercepts and will provide mapping details between dummy fds and
-    vhd_context_t objects. This makes it easy to verify that IO
-    operations against VHDs are being successfully intercepted.
-
-  LIBVHD_IO_DUMP: if set, libvhdio will log hex dumps of all data
-    written to and read from vhd_context_t objects.
-
-  LIBVHD_IO_TEST: if set, libvhdio will install a signal handler which
-    will cause libvhdio to snapshot any given VHDs on the reception of
-    SIGCONT. The intention is to facilitate testing libvhdio on
-    arbitrary VHD chain configurations by performing a test while
-    repeatedly pausing and continuing it to increase the VHD chain
-    length. See test/test-snapshot.c.
-
-
-EXAMPLES
-
-Create a raw image of a VHD's contents:
-
-  LD_PRELOAD=./libvhdio.so dd if=file.vhd of=file.raw
-
-Create a sparse raw image of a VHD's contents:
-
-  LD_PRELOAD=./libvhdio.so dd if=file.vhd | \
-    cp --sparse=always /proc/self/fd/0 file.raw
-
-Inspect a VHD's partition table:
-
-  LD_PRELOAD=./libvhdio.so fdisk -l file.vhd
-
-Format the first partition of a VHD (assuming the partition exists):
-
-  vhdpartx -a file.vhd
-  LD_PRELOAD=./libvhdio.so mkfs.ext3 file.vhd1
-  vhdpartx -d file.vhd
-
-List the contents of the NTFS file system on the second partition of a
-VHD:
-
-  vhdpartx -a file.vhd
-  LD_PRELOAD=./libvhdio.so ntfsls file.vhd2
-  vhdpartx -d file.vhd
diff -Nur blktap2_oxt//vhd/lib/relative-path.c blktap2_xen//vhd/lib/relative-path.c
--- blktap2_oxt//vhd/lib/relative-path.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/relative-path.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,15 +23,12 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
 
-char *vhd_realpath(const char *path, char *resolved_path);
-
 #include "relative-path.h"
 
 #define sfree(ptr)         \
@@ -235,14 +229,14 @@
 		return NULL;
 	}
 
-	to_absolute = vhd_realpath(to, NULL);
+	to_absolute = realpath(to, NULL);
 	if (!to_absolute) {
 		EPRINTF("failed to get absolute path of %s\n", to);
 		*err = -errno;
 		goto out;
 	}
 
-	from_absolute = vhd_realpath(from, NULL);
+	from_absolute = realpath(from, NULL);
 	if (!from_absolute) {
 		EPRINTF("failed to get absolute path of %s\n", from);
 		*err = -errno;
diff -Nur blktap2_oxt//vhd/lib/test/aio-test.c blktap2_xen//vhd/lib/test/aio-test.c
--- blktap2_oxt//vhd/lib/test/aio-test.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/test/aio-test.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,265 +0,0 @@
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-/*
- * gcc -o aio-test aio-test.c -laio
- *
- * This workload was produced by mkntfs on a 100MB image. It's pretty
- * good at exposing a bug in ext4 which was fixed in Linux 2.6.38 by
- * cset e9e3bcecf44c04b9e6b505fd8e2eb9cea58fb94d.
- *
- * Example usage:
- *   for i in {1..100}; do ./aio-test -f /mnt/ext4fs/foo; done
- */
-
-#ifndef _GNU_SOURCE
-  #define _GNU_SOURCE
-#endif
-#define _XOPEN_SOURCE 500
-#define _FILE_OFFSET_BITS 64
-
-#include <stdio.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include <libaio.h>
-#include <getopt.h>
-#include <inttypes.h>
-#include <sys/syscall.h>
-
-typedef enum {
-    EXT_NOOP,
-    EXT_WRITE,
-    EXT_FTRUNCATE,
-    EXT_FALLOCATE,
-} extend_t;
-
-struct iodesc {
-    off_t off;
-    size_t len;
-};
-
-static struct iodesc workload[] = {
-    { .off = 0,       .len = 0x1600 },
-    { .off = 0x1600,  .len = 0x1600 },
-    { .off = 0x2c00,  .len = 0x400  },
-    { .off = 0x4000,  .len = 0x1600 },
-    { .off = 0x5600,  .len = 0x1600 },
-    { .off = 0x6C00,  .len = 0x1600 },
-    { .off = 0x8200,  .len = 0x1600 },
-    { .off = 0x9800,  .len = 0x1600 },
-    { .off = 0xae00,  .len = 0x200  },
-};
-
-#define IOCBS (sizeof(workload) / sizeof(workload[0]))
-
-static void
-usage(const char *app, int err)
-{
-    fprintf(stderr, "usage: %s <file> [-v verbose] [-h help]"
-            "[(-f fallocate|-t truncate|-w write)]\n", app);
-    exit(err);
-}
-
-static int
-_fallocate(int fd, int mode, off_t offset, off_t length)
-{
-    return syscall(SYS_fallocate, fd, mode, offset, length);
-}
-
-int
-main(int argc, char * const argv[])
-{
-    size_t len;
-    extend_t extend;
-    io_context_t aio;
-    char *buf, *rbuf, *p;
-    int i, c, fd, err, verbose;
-    struct io_event events[IOCBS], *ep;
-    struct iocb iocbs[IOCBS], *piocbs[IOCBS];
-
-    fd = -1;
-    aio = 0;
-    buf = NULL;
-    rbuf = NULL;
-    verbose = 0;
-    extend = EXT_NOOP;
-
-    while ((c = getopt(argc, argv, "wtfvh")) != -1) {
-        switch (c) {
-        case 'w':
-            extend = EXT_WRITE;
-            break;
-        case 't':
-            extend = EXT_FTRUNCATE;
-            break;
-        case 'f':
-            extend = EXT_FALLOCATE;
-            break;
-        case 'v':
-            verbose = 1;
-            break;
-        case 'h':
-            usage(argv[0], 0);
-            break;
-        }
-    }
-
-    if (argc - optind != 1)
-        usage(argv[0], EINVAL);
-
-    for (i = 0, len = 0; i < IOCBS; i++)
-        len += workload[i].len;
-
-    err = posix_memalign((void *)&buf, 4096, len);
-    if (err) {
-        fprintf(stderr, "memalign: %s\n", strerror(err));
-        goto out;
-    }
-
-    err = io_setup(IOCBS, &aio);
-    if (err) {
-        perror("io_setup");
-        err = errno;
-        goto out;
-    }
-
-    fd = open(argv[optind], O_RDWR | O_CREAT | O_TRUNC | O_DIRECT, 0644);
-    if (fd == -1) {
-        perror("open");
-        err = errno;
-        goto out;
-    }
-
-    if (extend != EXT_NOOP) {
-        switch (extend) {
-        case EXT_WRITE:
-            memset(buf, 0, len);
-            err = pwrite(fd, buf, len, 0) != len;
-            break;
-        case EXT_FTRUNCATE:
-            err = ftruncate(fd, len);
-            break;
-        case EXT_FALLOCATE:
-            err = _fallocate(fd, 0, 0, len);
-            break;
-        default:
-            break;
-        }
-
-        if (err) {
-            const char *msg;
-            switch (extend) {
-            case EXT_WRITE:
-                msg = "pwrite";
-                break;
-            case EXT_FTRUNCATE:
-                msg = "ftruncate";
-                break;
-            case EXT_FALLOCATE:
-                msg = "fallocate";
-                break;
-            default:
-                msg = "gcc";
-                break;
-            }
-            perror(msg);
-            err = errno;
-            goto out;
-        }
-
-        err = fdatasync(fd);
-        if (err) {
-            perror("fdatasync");
-            goto out;
-        }
-    }
-
-    for (i = 0, p = buf; i < IOCBS; i++) {
-        struct iocb *io = iocbs + i;
-        struct iodesc *pd = workload + i;
-        if (verbose)
-            printf("io 0x%x off 0x%llx len 0x%x\n",
-                   i, (uint64_t)pd->off, pd->len);
-        memset(p, i, pd->len);
-        io_prep_pwrite(io, fd, p, pd->len, pd->off);
-        piocbs[i] = io;
-        p += pd->len;
-    }
-
-    err = io_submit(aio, IOCBS, piocbs);
-    if (err < 0) {
-        err = abs(err);
-        fprintf(stderr, "io_submit: %s\n", strerror(err));
-        goto out;
-    }
-
-    err = io_getevents(aio, IOCBS, IOCBS, events, NULL);
-    if (err < 0) {
-        err = abs(err);
-        fprintf(stderr, "io_getevents: %s\n", strerror(err));
-        goto out;
-    }
-
-    for (i = 0, ep = events; i < IOCBS; i++, ep++) {
-        struct iocb *io = ep->obj;
-        if (ep->res != io->u.c.nbytes) {
-            err = abs(ep->res);
-            fprintf(stderr, "io_pwrite: %s\n", strerror(err));
-            goto out;
-        }
-    }
-
-    err = fsync(fd);
-    if (err) {
-        err = errno;
-        perror("fsync");
-        goto out;
-    }
-
-    for (i = 0, p = buf; i < IOCBS; i++) {
-        ssize_t ret;
-        struct iodesc *pd = workload + i;
-
-        err = posix_memalign((void *)&rbuf, 4096, pd->len);
-        if (err) {
-            fprintf(stderr, "memalign: %s\n", strerror(err));
-            goto out;
-        }
-
-        ret = pread(fd, rbuf, pd->len, pd->off);
-        if (ret < 0) {
-            err = errno;
-            perror("pread");
-            goto out;
-        } else if (ret != pd->len) {
-            err = EIO;
-            fprintf(stderr, "pread: %s\n", strerror(err));
-            goto out;
-        }
-
-        if (memcmp(p, rbuf, pd->len)) {
-            err = EIO;
-            fprintf(stderr, "data mismatch: io %i\n", i);
-            goto out;
-        }
-
-        p += pd->len;
-        free(rbuf);
-        rbuf = NULL;
-    }
-
-    err = 0;
-
- out:
-    free(buf);
-    free(rbuf);
-    if (aio)
-        io_destroy(aio);
-    if (fd != -1)
-        close(fd);
-    return err;
-}
diff -Nur blktap2_oxt//vhd/lib/test/Makefile blktap2_xen//vhd/lib/test/Makefile
--- blktap2_oxt//vhd/lib/test/Makefile	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/test/Makefile	1969-12-31 19:00:00.000000000 -0500
@@ -1,35 +0,0 @@
-#
-# Copyright (c) 2011 Citrix Systems, Inc.
-#
-
-BLKTAP_ROOT := ../../../
-include $(BLKTAP_ROOT)/Rules.mk
-
-CFLAGS            += -Werror
-CFLAGS            += -Wno-unused
-CFLAGS            += -I../include
-CFLAGS            += -D_GNU_SOURCE
-
-# Get gcc to generate the dependencies for us.
-CFLAGS            += -Wp,-MD,.$(@F).d
-DEPS               = .*.d
-
-BINS              := random-copy test-snapshot aio-test
-
-all: $(BINS)
-
-random-copy: random-copy.c
-	$(CC) $(CFLAGS) -o $@ $^
-
-test-snapshot: test-snapshot.c
-	$(CC) $(CFLAGS) -o $@ $^
-
-aio-test: aio-test.c
-	$(CC) $(CFLAGS) -o $@ $^ -laio
-
-clean:
-	rm -rf *.o *~ $(DEPS) $(BINS)
-
-.PHONY: all clean
-
--include $(DEPS)
diff -Nur blktap2_oxt//vhd/lib/test/random-copy.c blktap2_xen//vhd/lib/test/random-copy.c
--- blktap2_oxt//vhd/lib/test/random-copy.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/test/random-copy.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,223 +0,0 @@
-/*
- * Copyright (c) 2009 Citrix Systems, Inc.
- */
-
-#include <stdio.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/stat.h>
-
-struct range {
-	off64_t         start;
-	off64_t         end;
-};
-
-struct random_copy_ctx {
-	int             sfd;
-	int             dfd;
-	int             total_chunks;
-	struct range   *chunks;
-};
-
-static void
-usage(const char *app, int err)
-{
-	printf("usage: %s <src> <dst>\n", app);
-	exit(err);
-}
-
-static int
-random_copy_carve_source(struct random_copy_ctx *ctx)
-{
-	int err, i, n;
-	struct stat64 st;
-	off64_t bytes, start;
-
-	err = fstat64(ctx->sfd, &st);
-	if (err) {
-		perror("stat source");
-		return errno;
-	}
-
-	n     = 100;
-	start = 0;
-	bytes = st.st_size;
-
-	ctx->chunks = calloc(n, sizeof(struct range));
-	if (!ctx->chunks) {
-		printf("calloc failed\n");
-		return ENOMEM;
-	}
-
-	for (i = 0; start < st.st_size; i++) {
-		int chunk;
-		off64_t end;
-
-		if (i == n) {
-			struct range *new;
-
-			n  *= 2;
-			new = realloc(ctx->chunks, n * sizeof(struct range));
-			if (!new) {
-				free(ctx->chunks);
-				ctx->chunks = NULL;
-				printf("realloc failed\n");
-				return ENOMEM;
-			}
-
-			ctx->chunks = new;
-		}
-
-		chunk = (random() % (st.st_size / 10)) + 1;
-		end = start + chunk;
-		if (end >= st.st_size)
-			end = st.st_size - 1;
-
-		ctx->chunks[i].start = start;
-		ctx->chunks[i].end   = end;
-
-		bytes -= (end - start);
-		start  = end + 1;
-	}
-
-	ctx->total_chunks = i;
-
-	return 0;
-}
-
-static int
-random_copy_permute_source(struct random_copy_ctx *ctx)
-{
-	int i;
-
-	for (i = 0; i < ctx->total_chunks; i++) {
-		int idx          = random() % ctx->total_chunks;
-		struct range tmp = ctx->chunks[idx];
-		ctx->chunks[idx] = ctx->chunks[i];
-		ctx->chunks[i]   = tmp;
-	}
-
-	return 0;
-}
-
-static int
-random_copy_init(struct random_copy_ctx *ctx, const char *src, const char *dst)
-{
-	int err;
-
-	memset(ctx, 0, sizeof(*ctx));
-	ctx->sfd = ctx->dfd = -1;
-
-	ctx->sfd = open(src, O_LARGEFILE | O_RDONLY);
-	if (ctx->sfd == -1) {
-		err = errno;
-		perror("opening source");
-		goto fail;
-	}
-
-	ctx->dfd = open(dst, O_LARGEFILE | O_WRONLY);
-	if (ctx->dfd == -1) {
-		err = errno;
-		perror("opening destination");
-		goto fail;
-	}
-
-	err = random_copy_carve_source(ctx);
-	if (err) {
-		printf("failed to carve source: %d\n", err);
-		goto fail;
-	}
-
-	err = random_copy_permute_source(ctx);
-	if (err) {
-		printf("failed to permute source: %d\n", err);
-		goto fail;
-	}
-
-	return 0;
-
-fail:
-	close(ctx->sfd);
-	close(ctx->dfd);
-	memset(ctx, 0, sizeof(*ctx));
-	return err;
-}
-
-static int
-random_copy(struct random_copy_ctx *ctx)
-{
-	char *buf;
-	int i, err;
-
-	for (i = 0; i < ctx->total_chunks; i++) {
-		struct range *r = &ctx->chunks[i];
-		size_t count    = r->end - r->start + 1;
-
-		buf = calloc(1, count);
-		if (!buf) {
-			printf("calloc failed\n");
-			return ENOMEM;
-		}
-
-		fprintf(stderr, "copying 0x%x from 0x%llx\n", count, r->start);
-
-		err = pread(ctx->sfd, buf, count, r->start);
-		if (err != count) {
-			printf("pread(0x%x 0x%llx) returned 0x%x (%d)\n",
-			       count, r->start, err, errno);
-			free(buf);
-			return (errno ? : EIO);
-		}
-
-		err = pwrite(ctx->dfd, buf, count, r->start);
-		if (err != count) {
-			printf("pwrite(0x%x 0x%llx) returned 0x%x (%d)\n",
-			       count, r->start, err, errno);
-			free(buf);
-			return (errno ? : EIO);
-		}
-
-		free(buf);
-	}
-
-	return 0;
-}
-
-static void
-random_copy_close(struct random_copy_ctx *ctx)
-{
-	close(ctx->sfd);
-	close(ctx->dfd);
-	free(ctx->chunks);
-}
-
-int
-main(int argc, char *argv[])
-{
-	int err;
-	char *src, *dst;
-	struct random_copy_ctx ctx;
-
-	if (argc != 3)
-		usage(argv[0], EINVAL);
-
-	src = argv[1];
-	dst = argv[2];
-
-	err = random_copy_init(&ctx, src, dst);
-	if (err) {
-		printf("failed to init: %d\n", err);
-		exit(err);
-	}
-
-	err = random_copy(&ctx);
-	if (err)
-		printf("copy failed: %d\n", err);
-
-	random_copy_close(&ctx);
-
-	return err;
-}
diff -Nur blktap2_oxt//vhd/lib/test/test-snapshot.c blktap2_xen//vhd/lib/test/test-snapshot.c
--- blktap2_oxt//vhd/lib/test/test-snapshot.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/test/test-snapshot.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,161 +0,0 @@
-/*
- * Copyright (c) 2011 Citrix Systems, Inc.
- */
-
-/*
- * libvhdio.so supports a simple test hook for validating vhd chains:
- * if LIBVHD_IO_TEST is set, libvhdio will handle SIGCONT specially
- * by closing, snapshotting, and reopening any vhds it is tracking.
- *
- * this harness simply forks a test and stops/continues it at a given interval.
- */
-
-#include <stdio.h>
-#include <errno.h>
-#include <signal.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-
-static void
-usage(const char *app, int err)
-{
-	printf("usage: %s <-i interval> -- <app and args>\n", app);
-	exit(err);
-}
-
-static void
-sighandler(int sig)
-{
-	fprintf(stderr, "child exited\n");
-	exit(0);
-}
-
-static void
-stop(pid_t pid)
-{
-	int status;
-
-	fprintf(stderr, "stopping %d\n", pid);
-
-	if (kill(pid, SIGSTOP)) {
-		perror("stop child");
-		exit(1);
-	}
-
-	if (waitpid(pid, &status, WUNTRACED) == -1) {
-		perror("waiting for child to stop");
-		exit(1);
-	}
-
-	if (WIFEXITED(status))
-		exit(0);
-
-	if (!WIFSTOPPED(status)) {
-		perror("child not stopped");
-		exit(1);
-	}
-}
-
-static void
-resume(pid_t pid)
-{
-	int status;
-
-	fprintf(stderr, "resuming %d\n", pid);
-
-	if (kill(pid, SIGCONT)) {
-		perror("resume child");
-		exit(1);
-	}
-
-	if (waitpid(pid, &status, WCONTINUED) == -1) {
-		perror("waiting for child to resume");
-		exit(1);
-	}
-
-	if (WIFEXITED(status))
-		exit(0);
-
-	if (!WIFCONTINUED(status)) {
-		perror("child not resumed");
-		exit(1);
-	}
-}
-
-static void
-test(pid_t pid, int interval)
-{
-	for (;;) {
-		fprintf(stderr, "sleeping\n");
-		sleep(interval);
-		stop(pid);
-		resume(pid);
-	}
-}
-
-int
-main(int argc, char **argv)
-{
-	pid_t pid;
-	sigset_t set;
-	int c, interval;
-	struct sigaction act;
-
-	interval = 0;
-
-	while ((c = getopt(argc, argv, "i:h")) != -1) {
-		switch (c) {
-		case 'i':
-			interval = atoi(optarg);
-			break;
-		case 'h':
-			usage(argv[0], 0);
-			break;
-		default:
-			usage(argv[0], EINVAL);
-			break;
-		}
-	}
-
-	if (optind == argc || !interval)
-		usage(argv[0], EINVAL);
-
-	if (sigemptyset(&set)) {
-		perror("init sigset");
-		exit(1);
-	}
-
-	act = (struct sigaction) {
-		.sa_handler = sighandler,
-		.sa_mask    = set,
-		.sa_flags   = SA_NOCLDSTOP,
-	};
-
-	if (sigaction(SIGCHLD, &act, NULL)) {
-		perror("register sig handler");
-		exit(1);
-	}
-
-	switch ((pid = fork())) {
-	case 0:
-		if (putenv("LIBVHD_IO_TEST=y")) {
-			perror("setting environment");
-			exit(errno);
-		}
-
-		execvp(argv[optind], &argv[optind]);
-
-		perror("exec");
-		exit(errno);
-	case -1:
-		perror("fork");
-		exit(errno);
-	default:
-		test(pid, interval);
-		break;
-	}
-
-	return 0;
-}
diff -Nur blktap2_oxt//vhd/lib/vhd-util-check.c blktap2_xen//vhd/lib/vhd-util-check.c
--- blktap2_oxt//vhd/lib/vhd-util-check.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-check.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <time.h>
 #include <stdio.h>
 #include <errno.h>
@@ -38,7 +34,6 @@
 #include <inttypes.h>
 #include <sys/stat.h>
 
-#include "list.h"
 #include "libvhd.h"
 #include "vhd-util.h"
 
@@ -46,180 +41,6 @@
 // account for time skew with NFS servers
 #define TIMESTAMP_MAX_SLACK 1800
 
-struct vhd_util_check_options {
-	char                             ignore_footer;
-	char                             ignore_parent_uuid;
-	char                             ignore_timestamps;
-	char                             check_data;
-	char                             check_bitmaps;
-	char                             collect_stats;
-};
-
-struct vhd_util_check_stats {
-	char                            *name;
-	char                            *bitmap;
-	uint64_t                         secs_total;
-	uint64_t                         secs_allocated;
-	uint64_t                         secs_written;
-	struct list_head                 next;
-};
-
-struct vhd_util_check_ctx {
-	struct vhd_util_check_options    opts;
-	struct list_head                 stats;
-	int                              primary_footer_missing;
-};
-
-#define ctx_cur_stats(ctx) \
-	list_entry((ctx)->stats.next, struct vhd_util_check_stats, next)
-
-static inline int
-test_bit_u64(volatile char *addr, uint64_t nr)
-{
-	return ((addr[nr >> 3] << (nr & 7)) & 0x80) != 0;
-}
-
-static inline void
-set_bit_u64(volatile char *addr, uint64_t nr)
-{
-	addr[nr >> 3] |= (0x80 >> (nr & 7));
-}
-
-static void
-vhd_util_check_stats_init(struct vhd_util_check_ctx *ctx)
-{
-	memset(&ctx->stats, 0, sizeof(ctx->stats));
-	INIT_LIST_HEAD(&ctx->stats);
-}
-
-static void
-vhd_util_check_stats_free_one(struct vhd_util_check_stats *stats)
-{
-	if (stats) {
-		free(stats->name);
-		free(stats->bitmap);
-		free(stats);
-	}
-}
-
-static int
-vhd_util_check_stats_alloc_one(struct vhd_util_check_ctx *ctx,
-			       vhd_context_t *vhd)
-{
-	int size;
-	struct vhd_util_check_stats *stats;
-
-	stats = calloc(1, sizeof(*stats));
-	if (!stats)
-		goto fail;
-
-	stats->name = strdup(vhd->file);
-	if (!stats->name)
-		goto fail;
-
-	stats->secs_total = (uint64_t)vhd->spb * vhd->header.max_bat_size;
-	size = (stats->secs_total + 7) >> 3;
-	stats->bitmap = calloc(1, size);
-	if (!stats->bitmap)
-		goto fail;
-
-	INIT_LIST_HEAD(&stats->next);
-	list_add(&stats->next, &ctx->stats);
-
-	return 0;
-
-fail:
-	vhd_util_check_stats_free_one(stats);
-	printf("failed to allocate stats for %s\n", vhd->file);
-	return -ENOMEM;
-}
-
-static void
-vhd_util_check_stats_free(struct vhd_util_check_ctx *ctx)
-{
-	struct vhd_util_check_stats *stats, *tmp;
-
-	list_for_each_entry_safe(stats, tmp, &ctx->stats, next) {
-		list_del_init(&stats->next);
-		vhd_util_check_stats_free_one(stats);
-	}
-}
-
-static inline float
-pct(uint64_t num, uint64_t den)
-{
-	return (!den ? 0.0 : (((float)num / (float)den)) * 100.0);
-}
-
-static inline char *
-name(const char *path)
-{
-	char *p = strrchr(path, '/');
-	if (p && (p - path) == strlen(path))
-		p = strrchr(--p, '/');
-	return (char *)(p ? ++p : path);
-}
-
-static void
-vhd_util_check_stats_print(struct vhd_util_check_ctx *ctx)
-{
-	char *bitmap;
-	uint64_t secs;
-	struct vhd_util_check_stats *head, *cur, *prev;
-
-	if (list_empty(&ctx->stats))
-		return;
-
-	head = list_entry(ctx->stats.next, struct vhd_util_check_stats, next);
-	printf("%s: secs allocated: 0x%llx secs written: 0x%llx (%.2f%%)\n",
-	       name(head->name), head->secs_allocated, head->secs_written,
-	       pct(head->secs_written, head->secs_allocated));
-
-	if (list_is_last(&head->next, &ctx->stats))
-		return;
-
-	secs = head->secs_total;
-
-	bitmap = malloc((secs + 7) >> 3);
-	if (!bitmap) {
-		printf("failed to allocate bitmap\n");
-		return;
-	}
-	memcpy(bitmap, head->bitmap, ((secs + 7) >> 3));
-
-	cur = prev = head;
-	while (!list_is_last(&cur->next, &ctx->stats)) {
-		uint64_t i, up = 0, uc = 0;
-
-		cur = list_entry(cur->next.next,
-				 struct vhd_util_check_stats, next);
-
-		for (i = 0; i < secs; i++) {
-			if (test_bit_u64(cur->bitmap, i)) {
-				if (!test_bit_u64(prev->bitmap, i))
-					up++; /* sector is unique wrt parent */
-
-				if (!test_bit_u64(bitmap, i))
-					uc++; /* sector is unique wrt chain */
-
-				set_bit_u64(bitmap, i);
-			}
-		}
-
-		printf("%s: secs allocated: 0x%llx secs written: 0x%llx "
-		       "(%.2f%%) secs not in parent: 0x%llx (%.2f%%) "
-		       "secs not in ancestors: 0x%llx (%.2f%%)\n",
-		       name(cur->name), cur->secs_allocated, cur->secs_written,
-		       pct(cur->secs_written, cur->secs_allocated),
-		       up, pct(up, cur->secs_written),
-		       uc, pct(uc, cur->secs_written));
-
-		prev = cur;
-	}
-
-	free(bitmap);
-}
-
 static int
 vhd_util_check_zeros(void *buf, size_t size)
 {
@@ -234,12 +55,27 @@
 	return 0;
 }
 
+static int
+vhd_util_check_footer_opened(vhd_footer_t *footer)
+{
+	int i, n;
+	uint32_t *buf;
+
+	buf = (uint32_t *)footer;
+	n = sizeof(*footer) / sizeof(uint32_t);
+
+	for (i = 0; i < n; i++)
+		if (buf[i] != 0xc7c7c7c7)
+			return 0;
+
+	return 1;
+}
+
 static char *
-vhd_util_check_validate_footer(struct vhd_util_check_ctx *ctx,
-			       vhd_footer_t *footer)
+vhd_util_check_validate_footer(vhd_footer_t *footer)
 {
 	int size;
-	uint32_t checksum;
+	uint32_t checksum, now;
 
 	size = sizeof(footer->cookie);
 	if (memcmp(footer->cookie, HD_COOKIE, size))
@@ -278,11 +114,9 @@
 	    footer->data_offset != ~(0ULL))
 		return "invalid data offset";
 
-	if (!ctx->opts.ignore_timestamps) {
-		uint32_t now = vhd_time(time(NULL));
-		if (footer->timestamp > now + TIMESTAMP_MAX_SLACK)
-			return "creation time in future";
-	}
+	now = vhd_time(time(NULL));
+	if (footer->timestamp > now + TIMESTAMP_MAX_SLACK)
+		return "creation time in future";
 
 	if (!strncmp(footer->crtr_app, "tap", 3) &&
 	    footer->crtr_ver > VHD_CURRENT_VERSION)
@@ -312,7 +146,7 @@
 static char *
 vhd_util_check_validate_header(int fd, vhd_header_t *header)
 {
-	off64_t eof;
+	off_t eof;
 	int i, cnt, size;
 	uint32_t checksum;
 
@@ -330,8 +164,8 @@
 	if (header->data_offset != ~(0ULL))
 		return "invalid data offset";
 
-	eof = lseek64(fd, 0, SEEK_END);
-	if (eof == (off64_t)-1)
+	eof = lseek(fd, 0, SEEK_END);
+	if (eof == (off_t)-1)
 		return "error finding eof";
 
 	if (header->table_offset <= 0  ||
@@ -358,8 +192,7 @@
 }
 
 static char *
-vhd_util_check_validate_differencing_header(struct vhd_util_check_ctx *ctx,
-					    vhd_context_t *vhd)
+vhd_util_check_validate_differencing_header(vhd_context_t *vhd)
 {
 	vhd_header_t *header;
 
@@ -367,12 +200,11 @@
 
 	if (vhd->footer.type == HD_TYPE_DIFF) {
 		char *parent;
+		uint32_t now;
 
-		if (!ctx->opts.ignore_timestamps) {
-			uint32_t now = vhd_time(time(NULL));
-			if (header->prt_ts > now + TIMESTAMP_MAX_SLACK)
-				return "parent creation time in future";
-		}
+		now = vhd_time(time(NULL));
+		if (header->prt_ts > now + TIMESTAMP_MAX_SLACK)
+			return "parent creation time in future";
 
 		if (vhd_header_decode_parent(vhd, header, &parent))
 			return "invalid parent name";
@@ -386,7 +218,7 @@
 		if (vhd_util_check_zeros(header->loc, sizeof(header->loc)))
 			return "invalid non-null parent locators";
 
-		if (!uuid_is_null(header->prt_uuid))
+		if (!vhd_uuid_is_nil(&header->prt_uuid))
 			return "invalid non-null parent uuid";
 
 		if (header->prt_ts)
@@ -400,7 +232,7 @@
 vhd_util_check_validate_batmap(vhd_context_t *vhd, vhd_batmap_t *batmap)
 {
 	int size;
-	off64_t eof;
+	off_t eof;
 	uint32_t checksum;
 
 	size = sizeof(batmap->header.cookie);
@@ -410,19 +242,15 @@
 	if (batmap->header.batmap_version > VHD_BATMAP_CURRENT_VERSION)
 		return "unsupported batmap version";
 
-	checksum = vhd_checksum_batmap(vhd, batmap);
+	checksum = vhd_checksum_batmap(batmap);
 	if (checksum != batmap->header.checksum)
 		return "invalid checksum";
 
 	if (!batmap->header.batmap_size)
 		return "invalid size zero";
 
-	if (batmap->header.batmap_size << (VHD_SECTOR_SHIFT + 3) <
-			vhd->header.max_bat_size)
-		return "batmap-BAT size mismatch";
-
-	eof = lseek64(vhd->fd, 0, SEEK_END);
-	if (eof == (off64_t)-1)
+	eof = lseek(vhd->fd, 0, SEEK_END);
+	if (eof == (off_t)-1)
 		return "error finding eof";
 
 	if (!batmap->header.batmap_offset ||
@@ -441,7 +269,7 @@
 vhd_util_check_validate_parent_locator(vhd_context_t *vhd,
 				       vhd_parent_locator_t *loc)
 {
-	off64_t eof;
+	off_t eof;
 
 	if (vhd_validate_platform_code(loc->code))
 		return "invalid platform code";
@@ -462,8 +290,8 @@
 	if (!loc->data_len)
 		return "invalid data length";
 
-	eof = lseek64(vhd->fd, 0, SEEK_END);
-	if (eof == (off64_t)-1)
+	eof = lseek(vhd->fd, 0, SEEK_END);
+	if (eof == (off_t)-1)
 		return "error finding eof";
 
 	if (loc->data_offset + vhd_parent_locator_size(loc) >
@@ -476,26 +304,23 @@
 	return NULL;
 }
 
-static char *
-vhd_util_check_validate_parent(struct vhd_util_check_ctx *ctx,
-			       vhd_context_t *vhd, const char *ppath)
+static const char *
+vhd_util_check_validate_parent(vhd_context_t *vhd, const char *ppath)
 {
-	char *msg;
+	const char *msg;
 	vhd_context_t parent;
+	uint32_t status;
 
 	msg = NULL;
 
 	if (vhd_parent_raw(vhd))
 		return msg;
 
-	if (ctx->opts.ignore_parent_uuid)
-		return msg;
-
 	if (vhd_open(&parent, ppath,
 				VHD_OPEN_RDONLY | VHD_OPEN_IGNORE_DISABLED))
 		return "error opening parent";
 
-	if (uuid_compare(vhd->header.prt_uuid, parent.footer.uuid)) {
+	if (vhd_uuid_compare(&vhd->header.prt_uuid, &parent.footer.uuid)) {
 		msg = "invalid parent uuid";
 		goto out;
 	}
@@ -506,13 +331,12 @@
 }
 
 static int
-vhd_util_check_footer(struct vhd_util_check_ctx *ctx,
-		      int fd, vhd_footer_t *footer)
+vhd_util_check_footer(int fd, vhd_footer_t *footer, int ignore)
 {
-	int err;
 	size_t size;
+	int err, opened;
 	char *msg, *buf;
-	off64_t eof, off;
+	off_t eof, off;
 	vhd_footer_t primary, backup;
 
 	memset(&primary, 0, sizeof(primary));
@@ -526,16 +350,16 @@
 
 	memset(buf, 0, sizeof(primary));
 
-	eof = lseek64(fd, 0, SEEK_END);
-	if (eof == (off64_t)-1) {
+	eof = lseek(fd, 0, SEEK_END);
+	if (eof == (off_t)-1) {
 		err = -errno;
 		printf("error calculating end of file: %d\n", err);
 		goto out;
 	}
 
 	size = ((eof % 512) ? 511 : 512);
-	eof  = lseek64(fd, eof - size, SEEK_SET);
-	if (eof == (off64_t)-1) {
+	eof  = lseek(fd, eof - size, SEEK_SET);
+	if (eof == (off_t)-1) {
 		err = -errno;
 		printf("error calculating end of file: %d\n", err);
 		goto out;
@@ -549,13 +373,12 @@
 	}
 
 	memcpy(&primary, buf, sizeof(primary));
+	opened = vhd_util_check_footer_opened(&primary);
 	vhd_footer_in(&primary);
 
-	msg = vhd_util_check_validate_footer(ctx, &primary);
+	msg = vhd_util_check_validate_footer(&primary);
 	if (msg) {
-		ctx->primary_footer_missing = 1;
-
-		if (ctx->opts.ignore_footer)
+		if (opened && ignore)
 			goto check_backup;
 
 		err = -EINVAL;
@@ -569,8 +392,8 @@
 	}
 
 check_backup:
-	off = lseek64(fd, 0, SEEK_SET);
-	if (off == (off64_t)-1) {
+	off = lseek(fd, 0, SEEK_SET);
+	if (off == (off_t)-1) {
 		err = -errno;
 		printf("error seeking to backup footer: %d\n", err);
 		goto out;
@@ -589,7 +412,7 @@
 	memcpy(&backup, buf, sizeof(backup));
 	vhd_footer_in(&backup);
 
-	msg = vhd_util_check_validate_footer(ctx, &backup);
+	msg = vhd_util_check_validate_footer(&backup);
 	if (msg) {
 		err = -EINVAL;
 		printf("backup footer invalid: %s\n", msg);
@@ -597,7 +420,7 @@
 	}
 
 	if (memcmp(&primary, &backup, sizeof(primary))) {
-		if (ctx->opts.ignore_footer) {
+		if (opened && ignore) {
 			memcpy(&primary, &backup, sizeof(primary));
 			goto ok;
 		}
@@ -632,7 +455,7 @@
 vhd_util_check_header(int fd, vhd_footer_t *footer)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	char *msg, *buf;
 	vhd_header_t header;
 
@@ -643,8 +466,8 @@
 	}
 
 	off = footer->data_offset;
-	off = lseek64(fd, off, SEEK_SET);
-	if (off == (off64_t)-1) {
+	off = lseek(fd, off, SEEK_SET);
+	if (off == (off_t)-1) {
 		err = -errno;
 		printf("error seeking to header: %d\n", err);
 		goto out;
@@ -675,12 +498,11 @@
 }
 
 static int
-vhd_util_check_differencing_header(struct vhd_util_check_ctx *ctx,
-				   vhd_context_t *vhd)
+vhd_util_check_differencing_header(vhd_context_t *vhd)
 {
 	char *msg;
 
-	msg = vhd_util_check_validate_differencing_header(ctx, vhd);
+	msg = vhd_util_check_validate_differencing_header(vhd);
 	if (msg) {
 		printf("differencing header is invalid: %s\n", msg);
 		return -EINVAL;
@@ -690,113 +512,11 @@
 }
 
 static int
-vhd_util_check_bitmap(struct vhd_util_check_ctx *ctx,
-		      vhd_context_t *vhd, uint32_t block)
+vhd_util_check_bat(vhd_context_t *vhd)
 {
-	int err, i, bits;
-	uint64_t sector;
-	char *bitmap, *data;
-
-	bits   = 0;
-	data   = NULL;
-	bitmap = NULL;
-	sector = (uint64_t)block * vhd->spb;
-
-	err = vhd_read_bitmap(vhd, block, &bitmap);
-	if (err) {
-		printf("error reading bitmap 0x%x\n", block);
-		goto out;
-	}
-
-	if (ctx->opts.check_data) {
-		err = vhd_read_block(vhd, block, &data);
-		if (err) {
-			printf("error reading data block 0x%x\n", block);
-			goto out;
-		}
-	}
-
-	for (i = 0; i < vhd->spb; i++) {
-		int map = vhd_bitmap_test(vhd, bitmap, i);
-		if (map)
-			bits++;
-
-		if (ctx->opts.collect_stats && map) {
-			ctx_cur_stats(ctx)->secs_written++;
-			set_bit_u64(ctx_cur_stats(ctx)->bitmap, sector + i);
-		}
-
-		if (ctx->opts.check_data) {
-			char *buf = data + (i << VHD_SECTOR_SHIFT);
-			int set   = vhd_util_check_zeros(buf, VHD_SECTOR_SIZE);
-
-			if (set && !map) {
-				printf("sector 0x%x of block 0x%x has data "
-				       "where bitmap is clear\n", i, block);
-				err = -EINVAL;
-			}
-		}
-	}
-
-	if (ctx->opts.check_bitmaps) {
-		if (bits == vhd->spb &&
-		    !vhd_batmap_test(vhd, &vhd->batmap, block))
-			printf("bitmap of block 0x%x is full "
-			       "where batmap is clear\n", block);
-		else if (bits < vhd->spb &&
-			 vhd_batmap_test(vhd, &vhd->batmap, block)) {
-			printf("bitmap of block 0x%x is not full "
-			       "where batmap is set\n", block);
-			err = -EINVAL;
-		}
-	}
-
-out:
-	free(data);
-	free(bitmap);
-	return err;
-}
-
-static int
-vhd_util_check_get_batmap(vhd_context_t *vhd)
-{
-	int err;
-
-	if (vhd->batmap.map)
-		return 0;
-
-	if (!vhd_has_batmap(vhd))
-		return -EINVAL;
-
-	err = vhd_get_batmap(vhd);
-	if (err) {
-		err = vhd_read_batmap_header(vhd, &vhd->batmap);
-		if (err) {
-			printf("failed to read batmap header: %d\n", err);
-			return err;
-		}
-
-		err = vhd_read_batmap_map(vhd, &vhd->batmap);
-		if (err)
-			printf("failed to read batmap: %d\n", err);
-	}
-
-	return err;
-}
-
-static int
-vhd_util_check_bat(struct vhd_util_check_ctx *ctx, vhd_context_t *vhd)
-{
-	off64_t eof, eoh;
-	uint64_t vhd_blks;
+	off_t eof, eoh;
 	int i, j, err, block_size;
 
-	if (ctx->opts.collect_stats) {
-		err = vhd_util_check_stats_alloc_one(ctx, vhd);
-		if (err)
-			return err;
-	}
-
 	err = vhd_seek(vhd, 0, SEEK_END);
 	if (err) {
 		printf("error calculating eof: %d\n", err);
@@ -804,7 +524,7 @@
 	}
 
 	eof = vhd_position(vhd);
-	if (eof == (off64_t)-1) {
+	if (eof == (off_t)-1) {
 		printf("error calculating eof: %d\n", -errno);
 		return -errno;
 	}
@@ -836,18 +556,7 @@
 	eoh >>= VHD_SECTOR_SHIFT;
 	block_size = vhd->spb + vhd->bm_secs;
 
-	vhd_blks = vhd->footer.curr_size >> VHD_BLOCK_SHIFT;
-	if (vhd_blks > vhd->header.max_bat_size) {
-		printf("VHD size (%llu blocks) exceeds BAT size (%u)\n",
-		       vhd_blks, vhd->header.max_bat_size);
-		return -EINVAL;
-	}
-
-	free(vhd->batmap.map);
-	vhd->batmap.map = NULL;
-	vhd_util_check_get_batmap(vhd);
-
-	for (i = 0; i < vhd_blks; i++) {
+	for (i = 0; i < vhd->header.max_bat_size; i++) {
 		uint32_t off = vhd->bat.bat[i];
 		if (off == DD_BLK_UNUSED)
 			continue;
@@ -859,16 +568,12 @@
 		}
 
 		if (off + block_size > eof) {
-			if (!(ctx->primary_footer_missing &&
-			      ctx->opts.ignore_footer     &&
-			      off + block_size == eof + 1)) {
-				printf("block %d (offset 0x%x) clobbers "
-				       "footer\n", i, off);
-				return -EINVAL;
-			}
+			printf("block %d (offset 0x%x) clobbers footer\n",
+			       i, off);
+			return -EINVAL;
 		}
 
-		for (j = 0; j < vhd_blks; j++) {
+		for (j = 0; j < vhd->header.max_bat_size; j++) {
 			uint32_t joff = vhd->bat.bat[j];
 
 			if (i == j)
@@ -894,17 +599,6 @@
 				return err;
 			}
 		}
-
-		if (ctx->opts.check_data ||
-		    ctx->opts.check_bitmaps ||
-		    ctx->opts.collect_stats) {
-			if (ctx->opts.collect_stats)
-				ctx_cur_stats(ctx)->secs_allocated += vhd->spb;
-
-			err = vhd_util_check_bitmap(ctx, vhd, i);
-			if (err)
-				return err;
-		}
 	}
 
 	return 0;
@@ -913,9 +607,8 @@
 static int
 vhd_util_check_batmap(vhd_context_t *vhd)
 {
-	int err;
 	char *msg;
-	uint32_t i;
+	int i, err;
 
 	err = vhd_get_bat(vhd);
 	if (err) {
@@ -923,7 +616,7 @@
 		return err;
 	}
 
-	err = vhd_util_check_get_batmap(vhd);
+	err = vhd_get_batmap(vhd);
 	if (err) {
 		printf("error reading batmap: %d\n", err);
 		return err;
@@ -935,7 +628,7 @@
 		return -EINVAL;
 	}
 
-	for (i = 0; i < vhd->footer.curr_size >> VHD_BLOCK_SHIFT; i++) {
+	for (i = 0; i < vhd->header.max_bat_size; i++) {
 		if (!vhd_batmap_test(vhd, &vhd->batmap, i))
 			continue;
 
@@ -945,16 +638,16 @@
 		}
 	}
 
-	return err;
+	return 0;
 }
 
 static int
-vhd_util_check_parent_locators(struct vhd_util_check_ctx *ctx,
-			       vhd_context_t *vhd)
+vhd_util_check_parent_locators(vhd_context_t *vhd)
 {
 	int i, n, err;
 	vhd_parent_locator_t *loc;
-	char *msg, *file, *ppath, *location, *pname;
+	char *file, *ppath, *location, *pname;
+	const char *msg;
 	int mac, macx, w2ku, w2ru, wi2r, wi2k, found;
 
 	mac      = 0;
@@ -1060,7 +753,7 @@
 			goto out;
 		}
 
-		msg = vhd_util_check_validate_parent(ctx, vhd, location);
+		msg = vhd_util_check_validate_parent(vhd, location);
 		if (msg) {
 			err = -EINVAL;
 			printf("invalid parent %s: %s\n", location, msg);
@@ -1108,15 +801,16 @@
 }
 
 static int
-vhd_util_check_vhd(struct vhd_util_check_ctx *ctx, const char *name)
+vhd_util_check_vhd(const char *name, int ignore)
 {
 	int fd, err;
 	vhd_context_t vhd;
 	struct stat stats;
-	vhd_footer_t footer = {};
+	vhd_footer_t footer;
 
 	fd = -1;
 	memset(&vhd, 0, sizeof(vhd));
+        memset(&footer, 0, sizeof(footer));
 
 	err = stat(name, &stats);
 	if (err == -1) {
@@ -1135,7 +829,7 @@
 		return -errno;
 	}
 
-	err = vhd_util_check_footer(ctx, fd, &footer);
+	err = vhd_util_check_footer(fd, &footer, ignore);
 	if (err)
 		goto out;
 
@@ -1150,11 +844,11 @@
 	if (err)
 		goto out;
 
-	err = vhd_util_check_differencing_header(ctx, &vhd);
+	err = vhd_util_check_differencing_header(&vhd);
 	if (err)
 		goto out;
 
-	err = vhd_util_check_bat(ctx, &vhd);
+	err = vhd_util_check_bat(&vhd);
 	if (err)
 		goto out;
 
@@ -1165,15 +859,13 @@
 	}
 
 	if (vhd.footer.type == HD_TYPE_DIFF) {
-		err = vhd_util_check_parent_locators(ctx, &vhd);
+		err = vhd_util_check_parent_locators(&vhd);
 		if (err)
 			goto out;
 	}
 
 	err = 0;
-
-	if (!ctx->opts.collect_stats)
-		printf("%s is valid\n", name);
+	printf("%s is valid\n", name);
 
 out:
 	if (err)
@@ -1185,7 +877,7 @@
 }
 
 static int
-vhd_util_check_parents(struct vhd_util_check_ctx *ctx, const char *name)
+vhd_util_check_parents(const char *name, int ignore)
 {
 	int err;
 	vhd_context_t vhd;
@@ -1216,7 +908,7 @@
 			free(cur);
 		cur = parent;
 
-		err = vhd_util_check_vhd(ctx, cur);
+		err = vhd_util_check_vhd(cur, ignore);
 		if (err)
 			goto out;
 	}
@@ -1233,46 +925,30 @@
 vhd_util_check(int argc, char **argv)
 {
 	char *name;
-	int c, err, parents;
-	struct vhd_util_check_ctx ctx;
+	vhd_context_t vhd;
+	int c, err, ignore, parents;
 
 	if (!argc || !argv) {
 		err = -EINVAL;
 		goto usage;
 	}
 
-	name    = NULL;
+	ignore  = 0;
 	parents = 0;
-	memset(&ctx, 0, sizeof(ctx));
-	vhd_util_check_stats_init(&ctx);
+	name    = NULL;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "n:iItpbsh")) != -1) {
+	while ((c = getopt(argc, argv, "n:iph")) != -1) {
 		switch (c) {
 		case 'n':
 			name = optarg;
 			break;
 		case 'i':
-			ctx.opts.ignore_footer = 1;
-			break;
-		case 'I':
-			ctx.opts.ignore_parent_uuid = 1;
-			break;
-		case 't':
-			ctx.opts.ignore_timestamps = 1;
+			ignore = 1;
 			break;
 		case 'p':
 			parents = 1;
 			break;
-		case 'b':
-			ctx.opts.check_bitmaps = 1;
-			break;
-		case 'd':
-			ctx.opts.check_data = 1;
-			break;
-		case 's':
-			ctx.opts.collect_stats = 1;
-			break;
 		case 'h':
 			err = 0;
 			goto usage;
@@ -1287,25 +963,18 @@
 		goto usage;
 	}
 
-	err = vhd_util_check_vhd(&ctx, name);
+	err = vhd_util_check_vhd(name, ignore);
 	if (err)
 		goto out;
 
 	if (parents)
-		err = vhd_util_check_parents(&ctx, name);
-
-	if (ctx.opts.collect_stats)
-		vhd_util_check_stats_print(&ctx);
-
-	vhd_util_check_stats_free(&ctx);
+		err = vhd_util_check_parents(name, ignore);
 
 out:
 	return err;
 
 usage:
 	printf("options: -n <file> [-i ignore missing primary footers] "
-	       "[-I ignore parent uuids] [-t ignore timestamps] "
-	       "[-p check parents] [-b check bitmaps] [-d check data] "
-	       "[-s stats] [-h help]\n");
+	       "[-p check parents] [-h help]\n");
 	return err;
 }
diff -Nur blktap2_oxt//vhd/lib/vhd-util-clone-metadata.c blktap2_xen//vhd/lib/vhd-util-clone-metadata.c
--- blktap2_oxt//vhd/lib/vhd-util-clone-metadata.c	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-clone-metadata.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,317 +0,0 @@
-/*
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <errno.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stddef.h>
-
-#include "libvhd.h"
-
-#define ERR(_fmt, _args...) fprintf(stderr, _fmt, ##_args)
-
-int
-__vhd_util_clone_metadata_s(vhd_context_t *vhd, const char *output,
-			    uint64_t bytes, uint64_t mbytes, int quick)
-{
-	int err;
-	vhd_context_t vout;
-
-	memset(&vout, 0, sizeof(vout));
-
-	if (!access(output, F_OK)) {
-		ERR("%s already exists\n", output);
-		return -EEXIST;
-	}
-
-	switch (vhd->footer.type) {
-	case HD_TYPE_DYNAMIC:
-		err = vhd_create(output, bytes, HD_TYPE_DYNAMIC, mbytes, 0);
-		break;
-	case HD_TYPE_DIFF: {
-		int fd;
-		char *tmp;
-
-		if (asprintf(&tmp, "%s.XXXXXX", output) == -1) {
-			err = -ENOMEM;
-			goto out;
-		}
-
-		fd = mkstemp(tmp);
-		if (fd == -1) {
-			err = -errno;
-			free(tmp);
-			goto out;
-		}
-
-		err = vhd_snapshot(output, bytes, tmp,
-				   mbytes, VHD_FLAG_CREAT_PARENT_RAW);
-
-		close(fd);
-		unlink(tmp);
-		free(tmp);
-		break;
-	}
-	default:
-		err = -EINVAL;
-		break;
-	}
-
-	if (err) {
-		ERR("error creating %s: %d\n", output, err);
-		goto out;
-	}
-
-	err = vhd_open(&vout, output, VHD_OPEN_RDWR);
-	if (err) {
-		ERR("error opening %s: %d\n", output, err);
-		goto out;
-	}
-
-	/*
-	 * if the source vhd doesn't have a batmap, remove the batmap
-	 * in the destination vhd to keep the sizes consistent.
-	 */
-	if (!vhd_has_batmap(vhd)) {
-		off64_t off, eob;
-
-		err = vhd_batmap_header_offset(&vout, &off);
-		if (err) {
-			ERR("error finding batmap: %d\n", err);
-			goto out;
-		}
-
-		eob = vout.header.table_offset +
-			vhd_bytes_padded(vout.header.max_bat_size *
-					 sizeof(uint32_t));
-
-		/*
-		 * this won't work if the batmap is not located
-		 * directly after the bat.
-		 */
-		if (off != eob) {
-			err = -EINVAL;
-			ERR("unexpected batmap location\n");
-			goto out;
-		}
-
-		err = ftruncate(vout.fd, eob);
-		if (err) {
-			ERR("error removing batmap: %d\n", err);
-			goto out;
-		}
-
-		/*
-		 * update the in-memory footer so library calls
-		 * will realize that vout has no batmap.
-		 */
-		memcpy(&vout.footer, &vhd->footer, sizeof(vout.footer));
-	}
-
-	err = vhd_write_footer_at(&vout, &vhd->footer, 0);
-	if (err) {
-		ERR("error copying backup footer: %d\n", err);
-		goto out;
-	}
-
-	err = vhd_write_header(&vout, &vhd->header);
-	if (err) {
-		ERR("error copying header: %d\n", err);
-		goto out;
-	}
-
-	if (vhd->footer.type == HD_TYPE_DIFF) {
-		int i;
-
-		for (i = 0; i < vhd_parent_locator_count(vhd); i++) {
-			char *buf;
-			off64_t off;
-			size_t size;
-			vhd_parent_locator_t *loc;
-
-			buf  = NULL;
-			loc  = vhd->header.loc + i;
-			off  = loc->data_offset;
-			size = vhd_parent_locator_size(loc);
-
-			if (!size)
-				continue;
-
-			err = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, size);
-			if (err) {
-				err = -err;
-				goto out;
-			}
-
-			err = vhd_pread(vhd, buf, size, off);
-			if (err) {
-				ERR("error reading parent locator: %d\n", err);
-				free(buf);
-				goto out;
-			}
-
-			loc = vout.header.loc + i;
-			off = loc->data_offset;
-
-			if (size != vhd_parent_locator_size(loc)) {
-				free(buf);
-				ERR("parent locator mismatch\n");
-				err = -ENOSYS;
-				goto out;
-			}
-
-			err = vhd_pwrite(&vout, buf, size, loc->data_offset);
-			if (err) {
-				ERR("error writing parent locator: %d\n", err);
-				free(buf);
-				goto out;
-			}
-		}
-	}
-
-	if (quick) {
-		err = vhd_write_footer(&vout, &vhd->footer);
-		if (err) {
-			ERR("error writing footer: %d\n", err);
-			goto out;
-		}
-	} else {
-		vhd_footer_t footer;
-
-		err = vhd_read_footer(vhd, &footer);
-		if (err) {
-			ERR("error reading footer: %d\n", err);
-			goto out;
-		}
-
-		err = vhd_write_footer(&vout, &footer);
-		if (err) {
-			ERR("error writing footer: %d\n", err);
-			goto out;
-		}
-	}
-
-out:
-	vhd_close(&vout);
-	if (err)
-		unlink(output);
-	return err;
-}
-
-int
-__vhd_util_clone_metadata(vhd_context_t *vhd, const char *output, int quick)
-{
-	return __vhd_util_clone_metadata_s(vhd, output,
-					   vhd_cur_capacity(vhd),
-					   vhd_max_capacity(vhd),
-					   quick);
-}
-
-int
-vhd_util_clone_metadata(int argc, char **argv)
-{
-	int c, quick, err;
-	vhd_context_t *vhd;
-	const char *input, *output;
-
-	err    = 0;
-	quick  = 0;
-	vhd    = NULL;
-	input  = NULL;
-	output = NULL;
-
-	if (!argc || !argv)
-		goto usage;
-
-	optind = 0;
-	while ((c = getopt(argc, argv, "qi:o:h")) != -1) {
-		switch (c) {
-		case 'i':
-			input = optarg;
-			break;
-		case 'o':
-			output = optarg;
-			break;
-		case 'q':
-			quick = 1;
-			break;
-		case 'h':
-		default:
-			goto usage;
-		}
-	}
-
-	if (optind != argc)
-		goto usage;
-
-	if (!input || !output)
-		goto usage;
-
-	{
-		FILE *f;
-
-		if (!strncmp(input, "-", strlen("-")))
-			f = stdin;
-		else {
-			f = fopen(input, "r");
-			if (!f) {
-				err = -errno;
-				goto out;
-			}
-		}
-
-		vhd = vhd_stream_load(f);
-		if (f != stdin)
-			fclose(f);
-
-		if (!vhd) {
-			err = -errno;
-			goto out;
-		}
-	}
-
-	err = __vhd_util_clone_metadata(vhd, output, quick);
-
-out:
-	if (vhd)
-		vhd_close(vhd);
-	return err;
-
-usage:
-	printf("vhd-util clone-metadata creates an empty vhd with metadata "
-	       "identical to the input vhd.\n"
-	       "Options:\n"
-	       "-h          Print this help message.\n"
-	       "-o NAME     NAME of output VHD to be created.\n"
-	       "-i NAME     NAME of input VHD to clone ('-' for stdin).\n"
-	       "-q          Quick clone -- use input backup footer for both\n"
-	       "            output primary and backup footers.\n");
-	return EINVAL;
-}
diff -Nur blktap2_oxt//vhd/lib/vhd-util-coalesce.c blktap2_xen//vhd/lib/vhd-util-coalesce.c
--- blktap2_oxt//vhd/lib/vhd-util-coalesce.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-coalesce.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <errno.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -39,12 +35,12 @@
 static int
 __raw_io_write(int fd, char* buf, uint64_t sec, uint32_t secs)
 {
-	off64_t off;
+	off_t off;
 	size_t ret;
 
 	errno = 0;
-	off = lseek64(fd, vhd_sectors_to_bytes(sec), SEEK_SET);
-	if (off == (off64_t)-1) {
+	off = lseek(fd, vhd_sectors_to_bytes(sec), SEEK_SET);
+	if (off == (off_t)-1) {
 		printf("raw parent: seek(0x%08"PRIx64") failed: %d\n",
 		       vhd_sectors_to_bytes(sec), -errno);
 		return -errno;
@@ -64,7 +60,7 @@
  */
 static int
 vhd_util_coalesce_block(vhd_context_t *vhd, vhd_context_t *parent,
-			int parent_fd, uint64_t block)
+		int parent_fd, uint64_t block)
 {
 	int i, err;
 	char *buf, *map;
@@ -127,52 +123,36 @@
 	return err;
 }
 
-static int
-vhd_util_coalesce_onto(vhd_context_t *from,
-		       vhd_context_t *to, int to_fd, int progress)
+int
+vhd_util_coalesce(int argc, char **argv)
 {
-	int err;
+	int err, c;
 	uint64_t i;
+	char *name, *pname;
+	vhd_context_t vhd, parent;
+	int parent_fd = -1;
 
-	err = vhd_get_bat(from);
-	if (err)
-		goto out;
+	name  = NULL;
+	pname = NULL;
+	parent.file = NULL;
 
-	if (vhd_has_batmap(from)) {
-		err = vhd_get_batmap(from);
-		if (err)
-			goto out;
-	}
+	if (!argc || !argv)
+		goto usage;
 
-	for (i = 0; i < from->bat.entries; i++) {
-		if (progress) {
-			printf("\r%6.2f%%",
-			       ((float)i / (float)from->bat.entries) * 100.00);
-			fflush(stdout);
+	optind = 0;
+	while ((c = getopt(argc, argv, "n:h")) != -1) {
+		switch (c) {
+		case 'n':
+			name = optarg;
+			break;
+		case 'h':
+		default:
+			goto usage;
 		}
-		err = vhd_util_coalesce_block(from, to, to_fd, i);
-		if (err)
-			goto out;
 	}
 
-	err = 0;
-
-	if (progress)
-		printf("\r100.00%%\n");
-
-out:
-	return err;
-}
-
-static int
-vhd_util_coalesce_parent(const char *name, int sparse, int progress)
-{
-	char *pname;
-	int err, parent_fd;
-	vhd_context_t vhd, parent;
-
-	parent_fd   = -1;
-	parent.file = NULL;
+	if (!name || optind != argc)
+		goto usage;
 
 	err = vhd_open(&vhd, name, VHD_OPEN_RDONLY);
 	if (err) {
@@ -196,9 +176,7 @@
 			return err;
 		}
 	} else {
-		int flags = (sparse ? VHD_OPEN_IO_WRITE_SPARSE : 0);
-		if (sparse) printf("opening for sparse writes\n");
-		err = vhd_open(&parent, pname, VHD_OPEN_RDWR | flags);
+		err = vhd_open(&parent, pname, VHD_OPEN_RDWR);
 		if (err) {
 			printf("error opening %s: %d\n", pname, err);
 			free(pname);
@@ -207,503 +185,34 @@
 		}
 	}
 
-	err = vhd_util_coalesce_onto(&vhd, &parent, parent_fd, progress);
-
-	free(pname);
-	vhd_close(&vhd);
-	if (parent.file)
-		vhd_close(&parent);
-	else
-		close(parent_fd);
-	return err;
-}
-
-struct vhd_list_entry {
-	int                raw;
-	int                raw_fd;
-	vhd_context_t      vhd;
-	struct list_head   next;
-};
-
-static int
-vhd_util_pathcmp(const char *a, const char *b, int *cmp)
-{
-	int err;
-	char *apath = NULL, *bpath = NULL;
-
-	apath = vhd_realpath(a, NULL);
-	if (!apath) {
-		err = -errno;
-		goto out;
-	}
-
-	bpath = vhd_realpath(b, NULL);
-	if (!bpath) {
-		err = -errno;
-		goto out;
-	}
-
-	*cmp = strcmp(apath, bpath);
-	err  = 0;
-
-out:
-	free(apath);
-	free(bpath);
-	return err;
-}
-
-static void
-vhd_util_coalesce_free_chain(struct list_head *head)
-{
-	struct vhd_list_entry *entry, *tmp;
-
-	list_for_each_entry_safe(entry, tmp, head, next) {
-		if (entry->raw)
-			close(entry->raw_fd);
-		else
-			vhd_close(&entry->vhd);
-		list_del(&entry->next);
-		free(entry);
-	}
-
-	INIT_LIST_HEAD(head);
-}
-
-static int
-vhd_util_coalesce_load_chain(struct list_head *head,
-			     const char *cname, const char *aname, int sparse)
-{
-	char *next;
-	vhd_context_t *child;
-	int err, cmp, vhd_flags;
-	struct vhd_list_entry *entry;
-
-	next  = NULL;
-	entry = NULL;
-	INIT_LIST_HEAD(head);
-
-	vhd_flags = VHD_OPEN_RDWR | (sparse ? VHD_OPEN_IO_WRITE_SPARSE : 0);
-
-	err = vhd_util_pathcmp(cname, aname, &cmp);
-	if (err)
-		goto out;
-
-	if (!cmp) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	entry = calloc(1, sizeof(*entry));
-	if (!entry)
-		goto out;
-
-	err = vhd_open(&entry->vhd, cname, vhd_flags);
-	if (err)
-		goto out;
-
-	err = vhd_get_bat(&entry->vhd);
-	if (err)
-		goto out;
-
-	if (vhd_has_batmap(&entry->vhd)) {
-		err = vhd_get_batmap(&entry->vhd);
-		if (err)
-			goto out;
-	}
-
-	child = &entry->vhd;
-	list_add(&entry->next, head);
-
-	for (;;) {
-		int raw;
-
-		if (entry->raw || entry->vhd.footer.type != HD_TYPE_DIFF) {
-			err = -ENOENT;
-			goto out;
-		}
-
-		if (child->header.block_size != entry->vhd.header.block_size) {
-			err = -EINVAL;
-			goto out;
-		}
-
-		err = vhd_parent_locator_get(&entry->vhd, &next);
-		if (err)
-			goto out;
-
-		raw = vhd_parent_raw(&entry->vhd);
-
-		entry = calloc(1, sizeof(*entry));
-		if (!entry)
-			goto out;
-
-		if (raw) {
-			entry->raw = raw;
-			entry->raw_fd = open(next,
-					     O_RDWR | O_DIRECT | O_LARGEFILE);
-			if (entry->raw_fd == -1) {
-				err = -errno;
-				goto out;
-			}
-		} else {
-			err = vhd_open(&entry->vhd, next, vhd_flags);
-			if (err)
-				goto out;
-
-			err = vhd_get_bat(&entry->vhd);
-			if (err)
-				goto out;
-
-			if (vhd_has_batmap(&entry->vhd)) {
-				err = vhd_get_batmap(&entry->vhd);
-				if (err)
-					goto out;
-			}
-		}
-
-		list_add_tail(&entry->next, head);
-
-		err = vhd_util_pathcmp(next, aname, &cmp);
-		if (err)
-			goto out;
-
-		if (!cmp)
-			goto done;
-
-		free(next);
-		next = NULL;
-	}
-
-done:
-	err = 0;
-out:
-	if (err) {
-		if (entry && list_empty(&entry->next)) {
-			if (entry->vhd.file)
-				vhd_close(&entry->vhd);
-			else if (entry->raw)
-				close(entry->raw_fd);
-			free(entry);
-		}
-		vhd_util_coalesce_free_chain(head);
-	}
-	return err;
-}
-
-static int
-vhd_util_coalesce_clear_bitmap(vhd_context_t *child, char *cmap,
-			       vhd_context_t *ancestor, const uint64_t block)
-{
-	char *amap = NULL;
-	int i, dirty, err;
-
-	if (child->spb != ancestor->spb) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	if (block >= ancestor->bat.entries)
-		goto done;
-
-	if (ancestor->bat.bat[block] == DD_BLK_UNUSED)
-		goto done;
-
-	err = vhd_read_bitmap(ancestor, block, &amap);
-	if (err)
-		goto out;
-
-	for (i = 0; i < child->spb; i++) {
-		if (vhd_bitmap_test(child, cmap, i)) {
-			if (vhd_bitmap_test(ancestor, amap, i)) {
-				dirty = 1;
-				vhd_bitmap_clear(ancestor, amap, i);
-			}
-		}
-	}
-
-	if (dirty) {
-		err = vhd_write_bitmap(ancestor, block, amap);
-		if (err)
-			goto out;
-		if (vhd_has_batmap(ancestor) &&
-		    vhd_batmap_test(ancestor, &ancestor->batmap, block)) {
-			vhd_batmap_clear(ancestor, &ancestor->batmap, block);
-			err = vhd_write_batmap(ancestor, &ancestor->batmap);
-			if (err)
-				goto out;
-		}
-	}
-
-done:
-	err = 0;
-out:
-	free(amap);
-	return err;
-}
-
-static int
-vhd_util_coalesce_clear_bitmaps(struct list_head *chain, vhd_context_t *child,
-				vhd_context_t *ancestor, uint64_t block)
-{
-	int err;
-	char *map = NULL;
-	struct vhd_list_entry *entry;
-
-	if (child->bat.bat[block] == DD_BLK_UNUSED)
-		goto done;
-
-	err = vhd_read_bitmap(child, block, &map);
-	if (err)
-		goto out;
-
-	list_for_each_entry(entry, chain, next) {
-		if (&entry->vhd == child)
-			continue;
-		if (&entry->vhd == ancestor)
-			break;
-		err = vhd_util_coalesce_clear_bitmap(child, map,
-						     &entry->vhd, block);
-		if (err)
-			goto out;
-	}
-
-done:
-	err = 0;
-out:
-	free(map);
-	return err;
-}
-
-static int
-vhd_util_coalesce_ancestor(const char *cname,
-			   const char *aname, int sparse, int progress)
-{
-	uint64_t i;
-	int err, raw_fd;
-	struct list_head chain;
-	struct vhd_list_entry *entry;
-	vhd_context_t *child, *ancestor;
-
-	child    = NULL;
-	ancestor = NULL;
-
-	err = vhd_util_coalesce_load_chain(&chain, cname, aname, sparse);
-	if (err)
-		goto out;
-
-	list_for_each_entry(entry, &chain, next) {
-		if (!child)
-			child = &entry->vhd;
-		else if (list_is_last(&entry->next, &chain)) {
-			ancestor = &entry->vhd;
-			raw_fd = entry->raw_fd;
-			break;
-		}
-	}
-
-	if (!ancestor) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	err = vhd_util_coalesce_onto(child, ancestor, raw_fd, progress);
-	if (err)
-		goto out;
-
-	for (i = 0; i < child->bat.entries; i++) {
-		err = vhd_util_coalesce_clear_bitmaps(&chain,
-						      child, ancestor, i);
-		if (err)
-			goto out;
-	}
-
-out:
-	vhd_util_coalesce_free_chain(&chain);
-	return err;
-}
-
-static int
-vhd_util_coalesce_open_output(vhd_context_t *dst,
-			      vhd_context_t *src, const char *name, int flags)
-{
-	int err;
-
-	err = access(name, F_OK);
-	if (!err) {
-		printf("%s already exists\n", name);
-		return -EEXIST;
-	} else if (errno != ENOENT) {
-		printf("error checking %s: %d\n", name, errno);
-		return -errno;
-	}
-
-	err = vhd_create(name,
-			 vhd_cur_capacity(src),
-			 HD_TYPE_DYNAMIC,
-			 vhd_max_capacity(src),
-			 0);
-	if (err) {
-		printf("error creating %s: %d\n", name, err);
-		return err;
-	}
-
-	err = vhd_open(dst, name, VHD_OPEN_RDWR | flags);
-	if (err || dst->header.block_size != src->header.block_size) {
-		printf("error opening %s: %d\n", name, (err ? : EINVAL));
-		unlink(name);
-		return err ? : EINVAL;
-	}
-
-	return 0;
-}
-
-/*
- * read block from @src chain and write it to @dst, unless it is all zeros
- */
-static int
-vhd_util_coalesce_block_out(vhd_context_t *dst,
-			    vhd_context_t *src, uint64_t block)
-{
-	int i, err;
-	uint64_t sec;
-	char *buf, *p;
-
-	buf = NULL;
-	sec = block * src->spb;
-
-	err = posix_memalign((void **)&buf, 4096, src->header.block_size);
-	if (err)
-		return -err;
-
-	err = vhd_io_read(src, buf, sec, src->spb);
-	if (err)
-		goto done;
-
-	for (p = buf, i = 0; i < src->header.block_size; i++, p++) {
-		if (*p) {
-			err = vhd_io_write(dst, buf, sec, src->spb);
-			break;
-		}
-	}
-
-done:
-	free(buf);
-	return err;
-}
-
-static int
-vhd_util_coalesce_out(const char *src_name, const char *dst_name,
-		      int sparse, int progress)
-{
-	uint64_t i;
-	int err, flags;
-	vhd_context_t src, dst;
-
-	err = vhd_open(&src, src_name, VHD_OPEN_RDONLY | VHD_OPEN_CACHED);
-	if (err)
-		return err;
-
-	flags = (sparse ? VHD_OPEN_IO_WRITE_SPARSE : 0);
-	err = vhd_util_coalesce_open_output(&dst, &src, dst_name, flags);
-	if (err) {
-		vhd_close(&src);
-		return err;
-	}
-
-	err = vhd_get_bat(&src);
+	err = vhd_get_bat(&vhd);
 	if (err)
 		goto done;
 
-	if (vhd_has_batmap(&src)) {
-		err = vhd_get_batmap(&src);
+	if (vhd_has_batmap(&vhd)) {
+		err = vhd_get_batmap(&vhd);
 		if (err)
 			goto done;
 	}
 
-	for (i = 0; i < src.bat.entries; i++) {
-		if (progress) {
-			printf("\r%6.2f%%",
-			       ((float)i / (float)src.bat.entries) * 100.0);
-			fflush(stdout);
-		}
-		err = vhd_util_coalesce_block_out(&dst, &src, i);
+	for (i = 0; i < vhd.bat.entries; i++) {
+		err = vhd_util_coalesce_block(&vhd, &parent, parent_fd, i);
 		if (err)
 			goto done;
 	}
 
 	err = 0;
 
-	if (progress)
-		printf("\r100.00%%\n");
-
-done:
-	if (err)
-		unlink(dst.file);
-	vhd_close(&src);
-	vhd_close(&dst);
-	return err;
-}
-
-int
-vhd_util_coalesce(int argc, char **argv)
-{
-	char *name, *oname, *ancestor;
-	int err, c, progress, sparse;
-
-	name      = NULL;
-	oname     = NULL;
-	ancestor  = NULL;
-	sparse    = 0;
-	progress  = 0;
-
-	if (!argc || !argv)
-		goto usage;
-
-	optind = 0;
-	while ((c = getopt(argc, argv, "n:o:a:sph")) != -1) {
-		switch (c) {
-		case 'n':
-			name = optarg;
-			break;
-		case 'o':
-			oname = optarg;
-			break;
-		case 'a':
-			ancestor = optarg;
-			break;
-		case 's':
-			sparse = 1;
-			break;
-		case 'p':
-			progress = 1;
-			break;
-		case 'h':
-		default:
-			goto usage;
-		}
-	}
-
-	if (!name || optind != argc)
-		goto usage;
-
-	if (oname && ancestor)
-		goto usage;
-
-	if (oname)
-		err = vhd_util_coalesce_out(name, oname, sparse, progress);
-	else if (ancestor)
-		err = vhd_util_coalesce_ancestor(name, ancestor,
-						 sparse, progress);
+ done:
+	free(pname);
+	vhd_close(&vhd);
+	if (parent.file)
+		vhd_close(&parent);
 	else
-		err = vhd_util_coalesce_parent(name, sparse, progress);
-
-	if (err)
-		printf("error coalescing: %d\n", err);
-
+		close(parent_fd);
 	return err;
 
 usage:
-	printf("options: <-n name> [-a ancestor] "
-	       "[-o output] [-s sparse] [-p progress] [-h help]\n");
+	printf("options: <-n name> [-h help]\n");
 	return -EINVAL;
 }
diff -Nur blktap2_oxt//vhd/lib/vhd-util-create.c blktap2_xen//vhd/lib/vhd-util-create.c
--- blktap2_oxt//vhd/lib/vhd-util-create.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-create.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <stdio.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -39,13 +35,12 @@
 vhd_util_create(int argc, char **argv)
 {
 	char *name;
-	uint64_t size, msize;
+	uint64_t size;
 	int c, sparse, err;
 	vhd_flag_creat_t flags;
 
 	err       = -EINVAL;
 	size      = 0;
-	msize     = 0;
 	sparse    = 1;
 	name      = NULL;
 	flags     = 0;
@@ -54,7 +49,7 @@
 		goto usage;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "n:s:S:rh")) != -1) {
+	while ((c = getopt(argc, argv, "n:s:rh")) != -1) {
 		switch (c) {
 		case 'n':
 			name = optarg;
@@ -63,10 +58,6 @@
 			err  = 0;
 			size = strtoull(optarg, NULL, 10);
 			break;
-		case 'S':
-			err = 0;
-			msize = strtoull(optarg, NULL, 10);
-			break;
 		case 'r':
 			sparse = 0;
 			break;
@@ -79,18 +70,11 @@
 	if (err || !name || optind != argc)
 		goto usage;
 
-	if (msize && msize < size) {
-		printf("Error: <-S size> must be greater than <-s size>\n");
-		return -EINVAL;
-	}
-
 	return vhd_create(name, size << 20,
 				  (sparse ? HD_TYPE_DYNAMIC : HD_TYPE_FIXED),
-				  msize << 20, flags);
+				  flags);
 
 usage:
-	printf("options: <-n name> <-s size (MB)> [-r reserve] [-h help] "
-			"[<-S size (MB) for metadata preallocation "
-			"(see vhd-util resize)>]\n");
+	printf("options: <-n name> <-s size (MB)> [-r reserve] [-h help]\n");
 	return -EINVAL;
 }
diff -Nur blktap2_oxt//vhd/lib/vhd-util-dm-decrypt.c blktap2_xen//vhd/lib/vhd-util-dm-decrypt.c
--- blktap2_oxt//vhd/lib/vhd-util-dm-decrypt.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-dm-decrypt.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,428 +0,0 @@
-/*
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <errno.h>
-#include <stdio.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stddef.h>
-
-#include "libvhd.h"
-
-struct vhd_decrypt_progress {
-	char                          display;
-	uint32_t                      total;
-	uint32_t                      cur;
-};
-
-struct vhd_decrypt_context {
-	int                           src_raw;
-	vhd_context_t                *src_vhd;
-	vhd_context_t                *dst_vhd;
-	struct vhd_decrypt_progress   progress;
-};
-
-#define ERR(_fmt, _args...) fprintf(stderr, "%d: " _fmt, __LINE__, ##_args)
-
-#define VERR(_v, _fmt, _args...)					\
-	do {								\
-		char uuid[37];						\
-		uuid_unparse((_v)->footer.uuid, uuid);			\
-		ERR("%s: " _fmt, uuid, ##_args);			\
-	} while (0)							\
-
-#define PROGRESS(_ctx)							\
-	do {								\
-		if ((_ctx)->progress.display &&				\
-		    (_ctx)->progress.total) {				\
-			float cur = (float)(_ctx)->progress.cur;	\
-			float total = (float)(_ctx)->progress.total;	\
-			float pct = (cur / total) * 100.0;		\
-			fprintf(stderr, "\r%6.2f%%", pct);		\
-			fflush(stderr);					\
-		}							\
-	} while (0)
-
-static int
-vhd_util_pread_data(int fd, char *buf, size_t size, off64_t off)
-{
-	int err;
-	ssize_t ret;
-
-	err = 0;
-
-	if (lseek64(fd, off, SEEK_SET) == (off64_t)-1) {
-		err = -errno;
-		goto out;
-	}
-
-	while (size) {
-		ret = read(fd, buf, size);
-		if (ret == -1) {
-			if (errno == EAGAIN)
-				continue;
-			err = -errno;
-			goto out;
-		}
-
-		buf  += ret;
-		size -= ret;
-	}
-
-out:
-	return err;
-}
-
-static int
-vhd_util_stream_copy_block(struct vhd_decrypt_context *ctx, uint32_t blk)
-{
-	int err, i;
-	off64_t off;
-	char *bm, *data;
-	vhd_context_t *src, *dst;
-
-	bm    = NULL;
-	data  = NULL;
-	src   = ctx->src_vhd;
-	dst   = ctx->dst_vhd;
-
-	if (src->bat.bat[blk] == DD_BLK_UNUSED) {
-		if (dst->bat.bat[blk] == DD_BLK_UNUSED)
-			err = 0;
-		else {
-			err = -EIO;
-			ERR("skipping allocated block 0x%x\n", blk);
-		}
-		goto out;
-	}
-
-	PROGRESS(ctx);
-
-	err = posix_memalign((void **)&data,
-			     VHD_SECTOR_SIZE, src->header.block_size);
-	if (err) {
-		err  = -err;
-		data = NULL;
-		ERR("allocating block 0x%x\n", blk);
-		goto out;
-	}
-
-	memset(data, 0, src->header.block_size);
-	off = ((uint64_t)blk * src->header.block_size) >> VHD_SECTOR_SHIFT;
-
-	err = vhd_read_bitmap(src, blk, &bm);
-	if (err) {
-		ERR("error reading source bitmap for "
-		    "block 0x%x: %d\n", blk, err);
-		goto out;
-	}
-
-	i = 0;
-	while (i < src->spb) {
-		char *buf;
-		off64_t pos;
-		int cnt, copy;
-
-		cnt  = 1;
-		pos  = off + i;
-		buf  = data + vhd_sectors_to_bytes(i);
-		copy = vhd_bitmap_test(src, bm, i);
-
-		while (i + cnt < src->spb &&
-		       copy == vhd_bitmap_test(src, bm, i + cnt))
-			cnt++;
-
-		if (copy) {
-			err = vhd_util_pread_data(ctx->src_raw, buf,
-						  vhd_sectors_to_bytes(cnt),
-						  vhd_sectors_to_bytes(pos));
-			if (err) {
-				ERR("reading dev block 0x%x: %d\n", blk, err);
-				goto out;
-			}
-		}
-
-		i += cnt;
-	}
-
-	err = vhd_write_bitmap(dst, blk, bm);
-	if (err) {
-		ERR("writing bitmap 0x%x: %d\n", blk, err);
-		goto out;
-	}
-
-	err = vhd_write_block(dst, blk, data);
-	if (err) {
-		ERR("writing data 0x%x: %d\n", blk, err);
-		goto out;
-	}
-
-out:
-	free(bm);
-	free(data);
-	return err;
-}
-
-static int
-__vhd_util_dm_decrypt(struct vhd_decrypt_context *ctx)
-{
-	char *buf;
-	uint32_t i;
-	int err, spp;
-	vhd_bat_t bat;
-	off64_t off, eoh;
-	vhd_context_t *src;
-	vhd_context_t *dst;
-
-	buf = NULL;
-	src = ctx->src_vhd;
-	dst = ctx->dst_vhd;
-	spp = getpagesize() >> VHD_SECTOR_SHIFT;
-
-	/*
-	 * We copy all the source metadata unmodified,
-	 * with the exception of the BAT, which must be sorted
-	 * by physical block address to enable serial output to a fifo.
-	 */
-	err = vhd_end_of_headers(src, &eoh);
-	if (err) {
-		ERR("finding end of source headers: %d\n", err);
-		goto out;
-	}
-
-	err = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, eoh);
-	if (err) {
-		err = -err;
-		buf = NULL;
-		ERR("allocating metadata\n");
-		goto out;
-	}
-
-	err = vhd_pread(src, buf, eoh, 0);
-	if (err) {
-		ERR("reading vhd headers: %d\n", err);
-		goto out;
-	}
-
-	bat.spb     = src->bat.spb;
-	bat.entries = src->bat.entries;
-	bat.bat     = (uint32_t *)(buf + src->header.table_offset);
-
-	/*
-	 * sort output BAT
-	 */
-	memset(dst->bat.bat, DD_BLK_UNUSED,
-	       dst->bat.entries * sizeof(uint32_t));
-	for (i = 0; i < src->bat.entries; i++) {
-		if (src->bat.bat[i] != DD_BLK_UNUSED) {
-			int gap;
-	
-			gap = 0;
-			err = vhd_end_of_data(dst, &off);
-			if (err) {
-				ERR("finding end of data: %d\n", err);
-				goto out;
-			}
-
-			off >>= VHD_SECTOR_SHIFT;
-
-			/* data region of block should be page aligned */
-			if ((off + dst->bm_secs) % spp) {
-				gap  = (spp - ((off + dst->bm_secs) % spp));
-				off += gap;
-			}
-
-			dst->bat.bat[i] = off;
-			bat.bat[i] = off;
-
-			if (ctx->progress.display)
-				ctx->progress.total++;
-		}
-	}
-
-	vhd_bat_out(&bat);
-
-	err = vhd_pwrite(dst, buf, eoh, 0);
-	if (err) {
-		ERR("copying vhd headers\n");
-		goto out;
-	}
-
-	for (i = 0; i < src->bat.entries; i++) {
-		err = vhd_util_stream_copy_block(ctx, i);
-		if (err)
-			goto out;
-	}
-
-	err = vhd_end_of_data(dst, &off);
-	if (err) {
-		ERR("finding end of data: %d\n", err);
-		goto out;
-	}
-
-	err = vhd_write_footer_at(dst, &dst->footer, off);
-	if (err) {
-		ERR("writing primary footer: %d\n", err);
-		goto out;
-	}
-
-	PROGRESS(ctx);
-
-out:
-	free(buf);
-	return err;
-}
-
-static int
-vhd_util_dm_decrypt_open_output(struct vhd_decrypt_context *ctx,
-				const char *vhd_out)
-{
-	int err;
-	FILE *file;
-
-	if (!strcmp(vhd_out, "-")) {
-		file = stdout;
-	} else {
-		if (!access(vhd_out, F_OK)) {
-			err = -EEXIST;
-			ERR("%s already exists\n", vhd_out);
-			goto out;
-		}
-
-		file = fopen(vhd_out, "w");
-		if (!file) {
-			err = -errno;
-			ERR("error opening %s: %d\n", vhd_out, err);
-			goto out;
-		}
-	}
-
-	ctx->dst_vhd = vhd_stream_initialize(file, ctx->src_vhd);
-	if (!ctx->dst_vhd)
-		goto out;
-
-out:
-	return err;
-}
-
-int
-vhd_util_dm_decrypt(int argc, char **argv)
-{
-	int c, err;
-	vhd_context_t src;
-	struct vhd_decrypt_context ctx;
-	const char *raw_in, *vhd_in, *vhd_out;
-
-	err      = 0;
-	raw_in   = NULL;
-	vhd_in   = NULL;
-	vhd_out  = NULL;
-
-	memset(&src, 0, sizeof(src));
-	memset(&ctx, 0, sizeof(ctx));
-
-	ctx.src_raw = -1;
-
-	if (!argc || !argv)
-		goto usage;
-
-	optind = 0;
-	while ((c = getopt(argc, argv, "i:I:o:ph")) != -1) {
-		switch (c) {
-		case 'i':
-			raw_in = optarg;
-			break;
-		case 'I':
-			vhd_in = optarg;
-			break;
-		case 'o':
-			vhd_out = optarg;
-			break;
-		case 'p':
-			ctx.progress.display = 1;
-			break;
-		case 'h':
-		default:
-			goto usage;
-		}
-	}
-
-	if (optind != argc)
-		goto usage;
-
-	if (!raw_in || !vhd_in || !vhd_out)
-		goto usage;
-
-	ctx.src_raw = open(raw_in, O_RDONLY | O_LARGEFILE | O_DIRECT);
-	if (ctx.src_raw == -1) {
-		err = -errno;
-		fprintf(stderr, "error opening %s: %d\n", raw_in, err);
-		goto out;
-	}
-
-	err = vhd_open(&src, vhd_in, VHD_OPEN_RDONLY);
-	if (err) {
-		fprintf(stderr, "error opening %s: %d\n", vhd_in, err);
-		goto out;
-	}
-
-	ctx.src_vhd = &src;
-
-	err = vhd_util_dm_decrypt_open_output(&ctx, vhd_out);
-	if (err)
-		goto out;
-
-	err = __vhd_util_dm_decrypt(&ctx);
-	if (err)
-		goto out;
-
-out:
-	vhd_close(&src);
-	if (ctx.src_raw != -1)
-		close(ctx.src_raw);
-	if (ctx.dst_vhd)
-		vhd_close(ctx.dst_vhd);
-
-	if (err && vhd_out && strcmp(vhd_out, "-"))
-		unlink(vhd_out);
-
-	return err;
-
-usage:
-	printf("vhd-util dm-decrypt reads the allocated data of a given vhd "
-	       "dm target and writes it to a new vhd.\n"
-	       "Options:\n"
-	       "-h          Print this help message.\n"
-	       "-p          Display progress.\n"
-	       "-o NAME     NAME of output VHD to create ('-' for stdout).\n"
-	       "-i NAME     NAME of input device to read.\n"
-	       "-I NAME     NAME of input vhd to read.\n");
-	return EINVAL;
-}
diff -Nur blktap2_oxt//vhd/lib/vhd-util-dm-encrypt.c blktap2_xen//vhd/lib/vhd-util-dm-encrypt.c
--- blktap2_oxt//vhd/lib/vhd-util-dm-encrypt.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-dm-encrypt.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,426 +0,0 @@
-/*
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <errno.h>
-#include <stdio.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stddef.h>
-#include <sys/stat.h>
-
-#include "libvhd.h"
-#include "vhd-util.h"
-
-#define ERR(_fmt, _args...) fprintf(stderr, "%d: " _fmt, __LINE__, ##_args)
-
-#define VERR(_v, _fmt, _args...)					\
-	do {								\
-		char uuid[37];						\
-		uuid_unparse((_v)->footer.uuid, uuid);			\
-		ERR("%s: " _fmt, uuid, ##_args);			\
-	} while (0)							\
-
-static int
-vhd_util_stream_transfer_sectors(vhd_context_t *src, int fd,
-				 uint32_t blk, uint32_t sec, uint32_t cnt)
-{
-	int err;
-	char *buf;
-	off64_t off;
-	size_t size;
-	ssize_t ret;
-	uint64_t sout;
-
-	size = vhd_sectors_to_bytes(cnt);
-	sout = vhd_sectors_to_bytes((uint64_t)blk * src->spb + sec);
-	off  = src->bat.bat[blk] + src->bm_secs + sec;
-
-	err = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, size);
-	if (err) {
-		err = -err;
-		buf = NULL;
-		goto out;
-	}
-
-	err = vhd_pread(src, buf, size, vhd_sectors_to_bytes(off));
-	if (err) {
-		VERR(src, "error reading from stream\n");
-		goto out;
-	}
-
-	errno = 0;
-	ret = pwrite(fd, buf, size, sout);
-	if (ret != size) {
-		err = (errno ? -errno : -EIO);
-		VERR(src, "error writing 0x%x sectors at 0x%llx to output: "
-		     "%d\n", cnt, sout, err);
-		goto out;
-	}
-
-out:
-	free(buf);
-	return err;
-}
-
-static int
-vhd_util_stream_allocate_block(vhd_context_t *src, int fd, uint32_t blk)
-{
-	int err;
-	char *buf;
-	off64_t off;
-	ssize_t ret;
-
-	off = vhd_sectors_to_bytes((uint64_t)blk * src->spb);
-	err = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, VHD_SECTOR_SIZE);
-	if (err) {
-		err = -err;
-		buf = NULL;
-		goto out;
-	}
-
-	memset(buf, 0, VHD_SECTOR_SIZE);
-
-	errno = 0;
-	ret = pwrite(fd, buf, VHD_SECTOR_SIZE, off);
-	if (ret != VHD_SECTOR_SIZE) {
-		err = (errno ? -errno : -EIO);
-		VERR(src, "error allocating block 0x%x: %d\n", blk, err);
-	}
-
-out:
-	free(buf);
-	return err;
-}
-
-static int
-vhd_util_stream_copy_block(vhd_context_t *src, int fd, uint32_t blk)
-{
-	char *bm;
-	int err, i, allocated;
-
-	bm = NULL;
-	allocated = 0;
-
-	if (src->bat.bat[blk] == DD_BLK_UNUSED) {
-		err = 0;
-		goto out;
-	}
-
-	err = vhd_read_bitmap(src, blk, &bm);
-	if (err) {
-		ERR("error reading source bitmap for "
-		    "block 0x%x: %d\n", blk, err);
-		goto out;
-	}
-
-	i = 0;
-	while (i < src->spb) {
-		int cnt, copy;
-
-		cnt  = 1;
-		copy = vhd_bitmap_test(src, bm, i);
-
-		while (i + cnt < src->spb &&
-		       copy == vhd_bitmap_test(src, bm, i + cnt))
-			cnt++;
-
-		if (copy) {
-			err = vhd_util_stream_transfer_sectors(src, fd,
-							       blk, i, cnt);
-			if (err)
-				goto out;
-
-			allocated = 1;
-		}
-
-		i += cnt;
-	}
-
-	if (!allocated) {
-		/*
-		 * The BAT says this block is allocated, but it has an empty
-		 * bitmap. In general we are safe not writing any data, but to
-		 * force the output VHD size to match the original VHD size,
-		 * we'll write one sector of zeros here to allocate the block.
-		 */
-		err = vhd_util_stream_allocate_block(src, fd, blk);
-	}
-
-out:
-	free(bm);
-	return err;
-}
-
-#define p2v_entry(physical, virtual) (((uint64_t)(physical) << 32) | (virtual))
-#define p2v_physical(entry)          ((uint32_t)((entry) >> 32))
-#define p2v_virtual(entry)           ((uint32_t)((entry) & ((1ULL << 32) - 1)))
-
-static int
-p2v_compare(const void *p1, const void *p2)
-{
-	uint32_t phy1 = p2v_physical(*(uint64_t *)p1);
-	uint32_t phy2 = p2v_physical(*(uint64_t *)p2);
-	if (phy1 == phy2)
-		return 0;
-	return (phy1 < phy2 ? -1 : 1);
-}
-
-static int
-__vhd_util_dm_encrypt(vhd_context_t *src, const char *output, int progress)
-{
-	int fd, err;
-	uint32_t i;
-	uint64_t *p2v, cur, total;
-
-	cur   = 0;
-	total = 0;
-
-	fd = open(output, O_WRONLY | O_LARGEFILE | O_DIRECT);
-	if (fd == -1) {
-		err = -errno;
-		goto out;
-	}
-
-	p2v = malloc(src->bat.entries * sizeof(*p2v));
-	if (!p2v) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	for (i = 0; i < src->bat.entries; i++) {
-		if (progress && src->bat.bat[i] != DD_BLK_UNUSED)
-			total++;
-		p2v[i] = p2v_entry(src->bat.bat[i], i);
-	}
-
-	qsort(p2v, src->bat.entries, sizeof(*p2v), p2v_compare);
-
-	for (i = 0; i < src->bat.entries; i++) {
-		uint32_t phys = p2v_physical(p2v[i]);
-		uint32_t virt = p2v_virtual(p2v[i]);
-
-		if (phys != DD_BLK_UNUSED) {
-			if (progress && total) {
-				printf("\r%6.2f%%",
-				       ((float)cur / (float)total) * 100.0);
-				fflush(stdout);
-				cur++;
-			}
-
-			err = vhd_util_stream_copy_block(src, fd, virt);
-			if (err)
-				goto out;
-		}
-	}
-
-	if (progress) {
-		printf("\r%6.2f%%\n", 100.0);
-		fflush(stdout);
-	}
-
-out:
-	free(p2v);
-	close(fd);
-	return err;
-}
-
-static int
-vhd_util_drain_fifo(FILE *fifo)
-{
-	ssize_t ret;
-	char buf[4096];
-
-	while ((ret = fread(buf, sizeof(buf), 1, fifo)))
-		if (ret == -1 && errno != EAGAIN)
-			return -errno;
-
-	return 0;
-}
-
-static int
-vhd_util_instantiate_output(const char *command)
-{
-	FILE *cmd;
-	int err, ret;
-
-	cmd = popen(command, "r");
-	if (!cmd) {
-		err = -errno;
-		goto out;
-	}
-
-	err = vhd_util_drain_fifo(cmd);
-
-	ret = pclose(cmd);
-	if (ret)
-		err = ret;
-
-out:
-	return err;
-}
-
-int
-vhd_util_dm_encrypt(int argc, char **argv)
-{
-	FILE *file;
-	vhd_context_t *vhd;
-	int c, fd, err, progress;
-	const char *input, *raw_out, *vhd_out, *command;
-
-	err      = 0;
-	progress = 0;
-	vhd      = NULL;
-	file     = NULL;
-	input    = NULL;
-	raw_out  = NULL;
-	vhd_out  = NULL;
-	command  = NULL;
-
-	if (!argc || !argv)
-		goto usage;
-
-	optind = 0;
-	while ((c = getopt(argc, argv, "i:o:c:C:ph")) != -1) {
-		switch (c) {
-		case 'i':
-			input = optarg;
-			break;
-		case 'o':
-			raw_out = optarg;
-			break;
-		case 'c':
-			vhd_out = optarg;
-			break;
-		case 'C':
-			command = optarg;
-			break;
-		case 'p':
-			progress = 1;
-			break;
-		case 'h':
-		default:
-			goto usage;
-		}
-	}
-
-	if (optind != argc)
-		goto usage;
-
-	if (!input || !raw_out)
-		goto usage;
-
-	if ((!!vhd_out) ^ (!!command))
-		goto usage;
-
-	if (!strcmp(input, "-"))
-		file = stdin;
-	else {
-		file = fopen(input, "r");
-		if (!file) {
-			err = -errno;
-			goto out;
-		}
-	}
-
-	vhd = vhd_stream_load(file);
-	if (!vhd) {
-		err = -errno;
-		ERR("error loading vhd from %s: %d\n", input, err);
-		goto out;
-	}
-
-	if (vhd_out) {
-		err = __vhd_util_clone_metadata(vhd, vhd_out, 1);
-		if (err) {
-			ERR("error creating %s: %d\n", vhd_out, err);
-			goto out;
-		}
-
-		err = vhd_util_instantiate_output(command);
-		if (err) {
-			ERR("error running %s: %d\n", command, err);
-			goto cleanup;
-		}
-	}
-
-	err = __vhd_util_dm_encrypt(vhd, raw_out, progress);
-	if (err) {
-		ERR("error encrypting data: %d\n", err);
-		goto cleanup;
-	}
-
-	fd = fileno(file);
-	if (fd != -1) {
-		struct stat st;
-
-		if (!fstat(fd, &st) && S_ISFIFO(st.st_mode))
-			vhd_util_drain_fifo(file);
- 	}
-
-cleanup:
-	if (err && vhd_out)
-		unlink(vhd_out);
-out:
-	if (vhd)
-		vhd_close(vhd);
-	if (file)
-		fclose(file);
-	return err;
-
-usage:
-	printf("vhd-util dm-encrypt writes the allocated data of a given vhd "
-	       "to a given file/device.\n"
-	       "\n"
-	       "Optionally, dm-encrypt can create the vhd it will write to.\n"
-	       "In this case, the -c switch designates the name of the vhd "
-	       "to be created,\n"
-	       "and the -C switch designates a command to be used (via popen) "
-	       "to instantiate\n"
-	       "the vhd as the device with the name specified by the -o "
-	       "switch.\n\n"
-	       "Example: cat clear.vhd |\n"
-	       "    vhd-util dm-encrypt -i - -o /dev/mapper/encrypt-dev -c "
-	       "encrypt.vhd \\\n"
-	       "             -C 'command to instantiate encrypt.vhd as "
-	       "encrypt-dev'\n"
-	       "\nThis will create encrypt.vhd with metadata cloned from "
-	       "clear.vhd,\n"
-	       "instantiate encrypt-dev over encrypt.vhd via the -C command,\n"
-	       "and write the data from clear.vhd to encrypt-dev.\n"
-	       "\n"
-	       "Options:\n"
-	       "-h          Print this help message.\n"
-	       "-p          Display progress.\n"
-	       "-o NAME     NAME of file/device to write to.\n"
-	       "-i NAME     NAME of input VHD to copy ('-' for stdin).\n"
-	       "-c NAME     NAME of vhd to create (requires -C option).\n"
-	       "-C COMMAND  COMMAND to instantiate created vhd.\n");
-	return EINVAL;
-}
diff -Nur blktap2_oxt//vhd/lib/vhd-util-fill.c blktap2_xen//vhd/lib/vhd-util-fill.c
--- blktap2_oxt//vhd/lib/vhd-util-fill.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-fill.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <errno.h>
 #include <fcntl.h>
 #include <stdio.h>
diff -Nur blktap2_oxt//vhd/lib/vhd-util-key.c blktap2_xen//vhd/lib/vhd-util-key.c
--- blktap2_oxt//vhd/lib/vhd-util-key.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-key.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,531 +0,0 @@
-/*
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <syslog.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
-#include <openssl/evp.h>
-
-#include "icbinn.h"
-
-#include "libvhd.h"
-
-#define MAX_KEY_SIZE 512
-
-#define ERR(_f, _a...)						\
-	do {							\
-		syslog(LOG_INFO, "%s: " _f, __func__, ##_a);	\
-		fprintf(stderr, "%s: " _f, __func__, ##_a);	\
-	} while (0)
-
-static int
-vhd_util_read_key(const char *keypath, uint8_t *key,
-		  size_t max_size, size_t *out_size)
-{
-	int fd, err;
-	ssize_t size;
-	struct stat sb;
-
-	fd = open(keypath, O_RDONLY);
-	if (fd == -1) {
-		ERR("failed to open %s: %d\n", keypath, errno);
-		err = -errno;
-		goto out;
-	}
-
-	err = fstat(fd, &sb);
-	if (err) {
-		ERR("failed to stat %s: %d\n", keypath, errno);
-		err = -errno;
-		goto out;
-	}
-
-	size = read(fd, key, max_size);
-	if (size == -1) {
-		ERR("failed to read key: %d\n", errno);
-		err = -errno;
-		goto out;
-	}
-
-	if (size != sb.st_size) {
-		ERR("short read of key\n");
-		err = -EIO;
-		goto out;
-	}
-
-	if (out_size)
-		*out_size = size;
-
-out:
-	if (fd != -1)
-		close(fd);
-	return err;
-}
-
-static int
-vhd_util_read_key_icbinn(ICBINN *icb, const char *keypath, uint8_t *key,
-		  size_t max_size, size_t *out_size)
-{
-	int fd, err;
-	ssize_t size;
-	struct icbinn_stat sb;
-
-
-
-	err = icbinn_stat(icb, keypath, &sb);
-	if (err) {
-		ERR("failed to stat %s\n", keypath);
-		err = -ENOENT;
-		goto out;
-	}
-
-	if (sb.type != ICBINN_TYPE_FILE) {
-		ERR("%s isn't a file\n", keypath);
-		err = -EISDIR;
-		goto out;
-	}
-
-	fd = icbinn_open(icb, keypath, O_RDONLY);
-	if (fd == -1) {
-		ERR("failed to open %s\n", keypath );
-		err = -EINVAL;
-		goto out;
-	}
-
-	size = icbinn_pread(icb, fd, key, max_size, 0);
-	if (size == -1) {
-		ERR("failed to read key\n");
-		err = -EIO;
-		goto out;
-	}
-
-	if (size != sb.size) {
-		ERR("short read of key\n");
-		err = -EIO;
-		goto out;
-	}
-
-	if (out_size)
-		*out_size = size;
-
-out:
-	if (fd != -1)
-		icbinn_close(icb,fd);
-	return err;
-}
-
-/*
- * calculates keyhash by taking a SHA256 hash of @keyhash->nonce + key
- */
-int
-__vhd_util_calculate_keyhash(struct vhd_keyhash *keyhash,
-			     const uint8_t *key, size_t size)
-{
-	int err;
-	EVP_MD_CTX evp;
-
-	err = -1;
-	EVP_MD_CTX_init(&evp);
-	if (!EVP_DigestInit_ex(&evp, EVP_sha256(), NULL)) {
-		ERR("failed to init sha256 context\n");
-		goto out;
-	}
-
-	if (!EVP_DigestUpdate(&evp, keyhash->nonce, sizeof(keyhash->nonce))) {
-		ERR("failed to hash nonce\n");
-		goto cleanup;
-	}
-
-	if (!EVP_DigestUpdate(&evp, key, size)) {
-		ERR("failed to hash key\n");
-		goto cleanup;
-	}
-
-	if (!EVP_DigestFinal_ex(&evp, keyhash->hash, NULL)) {
-		ERR("failed to finalize hash\n");
-		goto cleanup;
-	}
-
-	err = 0;
-
-cleanup:
-	EVP_MD_CTX_cleanup(&evp);
-out:
-	return err;
-}
-
-static int
-vhd_util_calculate_keyhash(struct vhd_keyhash *keyhash, const char *keypath)
-{
-	int err;
-	size_t size;
-	uint8_t key[MAX_KEY_SIZE];
-	ICBINN *icb = vhd_icbinn_key();
-
-	size = 0;
-	if (icb) {
-		err = vhd_util_read_key_icbinn(icb, keypath, key, sizeof(key), &size);
-	} else {
-		err = vhd_util_read_key(keypath, key, sizeof(key), &size);
-	}
-	if (err) {
-		ERR("failed to read key: %d\n", err);
-		goto out;
-	}
-
-	err = __vhd_util_calculate_keyhash(keyhash, key, size);
-	if (err) {
-		ERR("failed to calculate keyhash: %d\n", err);
-		goto out;
-	}
-
-out:
-	memset(key, 0, sizeof(key));
-	return err;
-}
-
-static int
-vhd_util_set_hex(uint8_t *dst, size_t size, const char *hex)
-{
-	int i, n, err;
-
-	err = 0;
-
-	n = strlen(hex);
-	if (n / 2 != size) {
-		ERR("invalid size for hex string\n");
-		err = -EINVAL;
-		goto out;
-	}
-
-	for (i = 0; i < n; i++) {
-		unsigned char c = (unsigned char)hex[i];
-		switch (c) {
-		case 0:
-			break;
-		case '0'...'9':
-			c -= '0';
-			break;
-		case 'a' ... 'f':
-			c = c - 'a' + 10;
-			break;
-		case 'A' ... 'F':
-			c = c - 'A' + 10;
-			break;
-		default:
-			ERR("invalid hex digit\n");
-			err = -EINVAL;
-			goto out;
-		}
-
-		if (i & 1)
-			dst[i / 2] |= c;
-		else
-			dst[i / 2] = (c << 4);
-	}
-
-out:
-	return err;
-}
-
-static int
-vhd_util_set_keyhash(struct vhd_keyhash *keyhash, const char *keypath,
-		     const char *hash, const char *nonce)
-{
-	int err;
-
-	memset(keyhash, 0, sizeof(*keyhash));
-
-	if (nonce) {
-		err = vhd_util_set_hex(keyhash->nonce,
-				       sizeof(keyhash->nonce), nonce);
-		if (err)
-			goto out;
-	}
-
-	if (hash) {
-		err = vhd_util_set_hex(keyhash->hash,
-				       sizeof(keyhash->hash), hash);
-		if (err)
-			goto out;
-	} else {
-		err = vhd_util_calculate_keyhash(keyhash, keypath);
-		if (err) {
-			ERR("failed to calculate keyhash: %d\n", err);
-			goto out;
-		}
-	}
-
-	keyhash->cookie = 1;
-
-out:
-	return err;
-}
-
-static int
-vhd_util_set_key(vhd_context_t *vhd, const char *keypath,
-		 const char *hash, const char *nonce)
-{
-	int err;
-	struct vhd_keyhash keyhash;
-        uint32_t i, used;
-
-	memset(&keyhash, 0, sizeof(keyhash));
-
-	if (vhd->footer.type == HD_TYPE_FIXED) {
-		ERR("can't save key hashes for fixed vhds\n");
-		err = -EINVAL;
-		goto out;
-	}
-
-	if (keypath && hash) {
-		ERR("can't provide both keyhash and keypath\n");
-		err = -EINVAL;
-		goto out;
-	}
-
-	err = vhd_get_bat(vhd);
-        if (err) {
-            ERR("error reading bat: %d\n", err);
-            goto out;
-        }
-        for (i = 0, used = 0; i < vhd->bat.entries; i++)
-            if (vhd->bat.bat[i] != DD_BLK_UNUSED)
-                used++;
-        if (used != 0) {
-            ERR("can't save key hashes for non-empty vhds\n");
-            err = -EINVAL;
-            goto out;
-        }
-
-
-	err = vhd_util_set_keyhash(&keyhash, keypath, hash, nonce);
-	if (err)
-		goto out;
-
-	err = vhd_set_keyhash(vhd, &keyhash);
-	if (err) {
-		ERR("failed to set keyhash: %d\n", err);
-		goto out;
-	}
-
-out:
-	return err;
-}
-
-static int
-vhd_util_check_key(vhd_context_t *vhd, const char *keypath)
-{
-	int err;
-	struct vhd_keyhash vhdhash, keyhash;
-
-	err = vhd_get_keyhash(vhd, &vhdhash);
-	if (err) {
-		ERR("failed to read keyhash: %d\n", err);
-		goto out;
-	}
-
-	if (!vhdhash.cookie) {
-		ERR("this vhd has no keyhash\n");
-		err = -EINVAL;
-		goto out;
-	}
-
-	memcpy(keyhash.nonce, vhdhash.nonce, sizeof(keyhash.nonce));
-	err = vhd_util_calculate_keyhash(&keyhash, keypath);
-	if (err) {
-		ERR("failed to calculate keyhash: %d\n", err);
-		goto out;
-	}
-
-	if (memcmp(keyhash.hash, vhdhash.hash, sizeof(keyhash.hash))) {
-		ERR("vhd hash doesn't match key hash\n");
-		err = -EINVAL;
-		goto out;
-	}
-
-out:
-	return err;
-}
-
-int
-vhd_util_key(int argc, char **argv)
-{
-	vhd_context_t vhd;
-	const char *name, *nonce, *keypath, *keyhash;
-	int err, c, set, check, print, flags, calc;
-
-	err     = -EINVAL;
-	set     = 0;
-	check   = 0;
-	print   = 0;
-	calc    = 0;
-	name    = NULL;
-	nonce   = NULL;
-	keypath = NULL;
-	keyhash = NULL;
-
-	if (!argc || !argv)
-		goto usage;
-
-	optind = 0;
-	while ((c = getopt(argc, argv, "n:k:N:H:scCph")) != -1) {
-		switch (c) {
-		case 'n':
-			name = optarg;
-			break;
-		case 'k':
-			keypath = optarg;
-			break;
-		case 'N':
-			nonce = optarg;
-			break;
-		case 'H':
-			keyhash = optarg;
-			break;
-		case 's':
-			set = 1;
-			break;
-		case 'c':
-			check = 1;
-			break;
-		case 'C':
-			calc = 1;
-			break;
-		case 'p':
-			print = 1;
-			break;
-		case 'h':
-			err = 0;
-		default:
-			goto usage;
-		}
-	}
-
-	if (optind != argc)
-		goto usage;
-
-	if (calc) {
-		int i;
-		struct vhd_keyhash keyhash;
-		err = vhd_util_set_keyhash(&keyhash, keypath, NULL, nonce);
-		if (err) {
-			ERR("calculating keyhash failed: %d\n", err);
-			goto out;
-		}
-
-		for (i = 0; i < sizeof(keyhash.hash); i++)
-			printf("%02x", keyhash.hash[i]);
-
-		printf("\n");
-		goto out;
-	}
-
-	if (!name)
-		goto usage;
-
-	if (set) {
-		if (check)
-			goto usage;
-
-		if (!(!!keypath ^ !!keyhash))
-			goto usage;
-	} else if (check) {
-		if (!keypath)
-			goto usage;
-
-		if (nonce || keyhash)
-			goto usage;
-	} else if (!print) {
-		goto usage;
-	}
-
-	flags = (set ? VHD_OPEN_RDWR : VHD_OPEN_RDONLY);
-	err = vhd_open(&vhd, name, flags);
-	if (err) {
-		fprintf(stderr, "failed to open %s: %d\n", name, err);
-		goto out;
-	}
-
-	if (set) {
-		err = vhd_util_set_key(&vhd, keypath, keyhash, nonce);
-		if (err)
-			fprintf(stderr, "setting key failed: %d\n", err);
-	} else if (check) {
-		err = vhd_util_check_key(&vhd, keypath);
-		if (err)
-			fprintf(stderr, "key check failed: %d\n", err);
-	}
-
-	if (print) {
-		struct vhd_keyhash keyhash;
-
-		err = vhd_get_keyhash(&vhd, &keyhash);
-		if (err) {
-			fprintf(stderr, "failed to read keyhash: %d\n", err);
-		} else {
-			if (keyhash.cookie != 1)
-				printf("none\n");
-			else {
-				int i;
-
-				for (i = 0; i < sizeof(keyhash.nonce); i++)
-					printf("%02x", keyhash.nonce[i]);
-
-				printf(" ");
-
-				for (i = 0; i < sizeof(keyhash.hash); i++)
-					printf("%02x", keyhash.hash[i]);
-
-				printf("\n");
-			}
-		}
-	}
-
-	vhd_close(&vhd);
-
-out:
-	return err;
-
-usage:
-	fprintf(stderr,
-		"usage:\n"
-		"-C -k KEYPATH [-N NONCE]: calculate keyhash for KEYPATH\n"
-		"-s -n NAME <-k KEYPATH | -H HASH> [-N NONCE]: set keyhash for NAME\n"
-		"-c -n NAME <-k KEYPATH>: check keyhash for NAME\n"
-		"-p -n NAME: print keyhash for NAME\n"
-		"-h help\n");
-	return err;
-}
diff -Nur blktap2_oxt//vhd/lib/vhd-util-modify.c blktap2_xen//vhd/lib/vhd-util-modify.c
--- blktap2_oxt//vhd/lib/vhd-util-modify.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-modify.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,6 +23,21 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Altering operations:
+ *
+ * 1. Change the parent pointer to another file.
+ * 2. Change the size of the file containing the VHD image. This does NOT 
+ * affect the VHD disk capacity, only the physical size of the file containing 
+ * the VHD. Naturally, it is not possible to set the file size to be less than  
+ * the what VHD utilizes.
+ * The operation doesn't actually change the file size, but it writes the 
+ * footer in the right location such that resizing the file (manually, as a 
+ * separate step) will produce the correct results. If the new file size is 
+ * greater than the current file size, the file must first be expanded and then 
+ * altered with this operation. If the new size is smaller than the current 
+ * size, the VHD must first be altered with this operation and then the file 
+ * must be shrunk. Failing to resize the file will result in a corrupted VHD.
  */
 
 #include <errno.h>
@@ -38,51 +50,22 @@
 
 TEST_FAIL_EXTERN_VARS;
 
-static int
-vhd_util_zero_bat(vhd_context_t *vhd)
-{
-	int err, map_bytes;
-	uint64_t i;
-
-	err = vhd_get_bat(vhd);
-	if (err)
-		return err;
-
-	if (vhd_has_batmap(vhd)) {
-		err = vhd_get_batmap(vhd);
-		if (err)
-			return err;
-	}
-
-	for (i = 0; i < vhd->header.max_bat_size; i++)
-		vhd->bat.bat[i] = DD_BLK_UNUSED;
-	err = vhd_write_bat(vhd, &vhd->bat);
-	if (err)
-		return err;
-
-	map_bytes = vhd_sectors_to_bytes(vhd->batmap.header.batmap_size);
-	memset(vhd->batmap.map, 0, map_bytes);
-	return vhd_write_batmap(vhd, &vhd->batmap);
-}
-
 int
 vhd_util_modify(int argc, char **argv)
 {
-	char *name, *type;
+	char *name;
 	vhd_context_t vhd;
-	int err, c, size, parent, parent_raw, kill_data;
-	off64_t newsize = 0;
+	int err, c, size, parent, parent_raw;
+	off_t newsize = 0;
 	char *newparent = NULL;
 
 	name       = NULL;
-	type       = NULL;
 	size       = 0;
 	parent     = 0;
 	parent_raw = 0;
-	kill_data  = 0;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "n:s:p:mt:zh")) != -1) {
+	while ((c = getopt(argc, argv, "n:s:p:mh")) != -1) {
 		switch (c) {
 		case 'n':
 			name = optarg;
@@ -103,12 +86,7 @@
 		case 'm':
 			parent_raw = 1;
 			break;
-		case 't':
-			type = optarg;
-			break;
-		case 'z':
-			kill_data = 1;
-			break;
+
 		case 'h':
 		default:
 			goto usage;
@@ -124,24 +102,6 @@
 		return err;
 	}
 
-	if (kill_data) {
-		if (vhd_type_dynamic(&vhd))
-			err = vhd_util_zero_bat(&vhd);
-		else
-			err = -ENOSYS;
-
-		if (!err) {
-			err = vhd_end_of_headers(&vhd, &newsize);
-			newsize += sizeof(vhd_footer_t);
-		}
-
-		if (!err)
-			err = vhd_set_phys_size(&vhd, newsize);
-
-		if (err)
-			printf("failed to zero VHD: %d\n", err);
-	}
-
 	if (size) {
 		err = vhd_set_phys_size(&vhd, newsize);
 		if (err)
@@ -160,41 +120,6 @@
 		TEST_FAIL_AT(FAIL_REPARENT_END);
 	}
 
-	if (type) {
-		if (vhd.footer.type == HD_TYPE_FIXED) {
-			printf("changing fixed vhd type not supported\n");
-			err = -EINVAL;
-			goto done;
-		}
-
-		if (!strcmp(type, "differencing"))
-			vhd.footer.type = HD_TYPE_DIFF;
-		else if (!strcmp(type, "dynamic"))
-			vhd.footer.type = HD_TYPE_DYNAMIC;
-		else if (!strcmp(type, "original")) {
-			char *n;
-
-			err = vhd_header_decode_parent(&vhd, &vhd.header, &n);
-			if (err) {
-				printf("error inferring type: %d\n", err);
-				goto done;
-			}
-
-			if (!strcmp(n, ""))
-				vhd.footer.type = HD_TYPE_DYNAMIC;
-			else
-				vhd.footer.type = HD_TYPE_DIFF;
-
-			free(n);
-		} else {
-			printf("invalid type %s (must be 'differencing or "
-			       "dynamic')\n", type);
-			err = -EINVAL;
-			goto done;
-		}
-		err = vhd_write_footer(&vhd, &vhd.footer);
-	}
-
 done:
 	vhd_close(&vhd);
 	return err;
@@ -202,7 +127,6 @@
 usage:
 	printf("*** Dangerous operations, use with care ***\n");
 	printf("options: <-n name> [-p NEW_PARENT set parent [-m raw]] "
-	       "[-s NEW_SIZE set size] [-z zero (kill data)] "
-	       "[-t TYPE (differencing|dynamic|original)] [-h help]\n");
+			"[-s NEW_SIZE set size] [-h help]\n");
 	return -EINVAL;
 }
diff -Nur blktap2_oxt//vhd/lib/vhd-util-query.c blktap2_xen//vhd/lib/vhd-util-query.c
--- blktap2_oxt//vhd/lib/vhd-util-query.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-query.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <errno.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -41,19 +37,15 @@
 {
 	char *name;
 	vhd_context_t vhd;
-	off64_t currsize;
-	int ret, err, c, size, physize, parent, fields, depth, fastresize;
-	int marker, allocated;
-
-	name       = NULL;
-	size       = 0;
-	physize    = 0;
-	parent     = 0;
-	fields     = 0;
-	depth      = 0;
-	fastresize = 0;
-	marker     = 0;
-	allocated  = 0;
+	off_t currsize;
+	int ret, err, c, size, physize, parent, fields, depth;
+
+	name    = NULL;
+	size    = 0;
+	physize = 0;
+	parent  = 0;
+	fields  = 0;
+	depth   = 0;
 
 	if (!argc || !argv) {
 		err = -EINVAL;
@@ -61,7 +53,7 @@
 	}
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "n:vspfdSmah")) != -1) {
+	while ((c = getopt(argc, argv, "n:vspfdh")) != -1) {
 		switch (c) {
 		case 'n':
 			name = optarg;
@@ -81,15 +73,6 @@
 		case 'd':
 			depth = 1;
 			break;
-		case 'S':
-			fastresize = 1;
-			break;
-		case 'm':
-			marker = 1;
-			break;
-		case 'a':
-			allocated = 1;
-			break;
 		case 'h':
 			err = 0;
 			goto usage;
@@ -111,7 +94,7 @@
 	}
 
 	if (size)
-		printf("%llu\n", vhd.footer.curr_size >> 20);
+		printf("%"PRIu64"\n", vhd.footer.curr_size >> 20);
 
 	if (physize) {
 		err = vhd_get_phys_size(&vhd, &currsize);
@@ -153,18 +136,6 @@
 		err = (err ? : ret);
 	}
 
-	if (marker) {
-		char marker;
-
-		ret = vhd_marker(&vhd, &marker);
-		if (ret)
-			printf("error checking 'marker' field: %d\n", ret);
-		else
-			printf("marker: %d\n", marker);
-
-		err = (err ? : ret);
-	}
-
 	if (depth) {
 		int length;
 
@@ -176,30 +147,6 @@
 
 		err = (err ? : ret);
 	}
-
-	if (fastresize) {
-		uint64_t max_size;
-
-		max_size = vhd.header.max_bat_size << (VHD_BLOCK_SHIFT - 20);
-		printf("%llu\n", max_size);
-	}
-
-	if (allocated) {
-		ret = vhd_get_bat(&vhd);
-		if (ret)
-			printf("error reading bat: %d\n", ret);
-		else {
-			uint32_t i, used;
-
-			for (i = 0, used = 0; i < vhd.bat.entries; i++)
-				if (vhd.bat.bat[i] != DD_BLK_UNUSED)
-					used++;
-
-			printf("%u\n", used);
-		}
-
-		err = (err ? : ret);
-	}
 		
 	vhd_close(&vhd);
 	return err;
@@ -207,8 +154,6 @@
 usage:
 	printf("options: <-n name> [-v print virtual size (in MB)] "
 	       "[-s print physical utilization (bytes)] [-p print parent] "
-	       "[-f print fields] [-m print marker] [-d print chain depth] "
-	       "[-S print max virtual size (MB) for fast resize] "
-	       "[-a print allocated block count] [-h help]\n");
+	       "[-f print fields] [-d print chain depth] [-h help]\n");
 	return err;
 }
diff -Nur blktap2_oxt//vhd/lib/vhd-util-read.c blktap2_xen//vhd/lib/vhd-util-read.c
--- blktap2_oxt//vhd/lib/vhd-util-read.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-read.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -38,16 +34,6 @@
 #include "libvhd.h"
 #include "vhd-util.h"
 
-const char *HD_TYPE_STR[7] = {
-        "None",                    /* 0 */
-        "Reserved (deprecated)",   /* 1 */
-        "Fixed hard disk",         /* 2 */
-        "Dynamic hard disk",       /* 3 */
-        "Differencing hard disk",  /* 4 */
-        "Reserved (deprecated)",   /* 5 */
-        "Reserved (deprecated)"    /* 6 */
-};
-
 #define nsize     15
 static char nbuf[nsize];
 
@@ -73,11 +59,11 @@
 {
 	int err;
 	uint32_t  cksm;
-	char      uuid[37], time_str[26], cookie[9], *name;
+	char      uuid[39], time_str[26], cookie[9], out[512], *name;
 
 	printf("VHD Header Summary:\n-------------------\n");
 
-	snprintf(cookie, 9, "%s", h->cookie);
+	snprintf(cookie, sizeof(cookie), "%s", h->cookie);
 	printf("Cookie              : %s\n", cookie);
 
 	printf("Data offset (unusd) : %s\n", conv(hex, h->data_offset));
@@ -92,7 +78,7 @@
 	       (err ? "failed to read name" : name));
 	free(name);
 
-	uuid_unparse(h->prt_uuid, uuid);
+	vhd_uuid_to_string(&h->prt_uuid, uuid, sizeof(uuid));
 	printf("Parent UUID         : %s\n", uuid);
     
 	vhd_time_to_string(h->prt_ts, time_str);
@@ -108,12 +94,12 @@
 vhd_print_footer(vhd_footer_t *f, int hex)
 {
 	uint64_t  c, h, s;
-	uint32_t  ff_maj, ff_min, cr_maj, cr_min, cksm;
-	char      time_str[26], creator[5], uuid[37], cookie[9];
+	uint32_t  ff_maj, ff_min, cr_maj, cr_min, cksm, cksm_save;
+	char      time_str[26], creator[5], uuid[39], cookie[9];
 
 	printf("VHD Footer Summary:\n-------------------\n");
 
-	snprintf(cookie, 9, "%s", f->cookie);
+	snprintf(cookie, sizeof(cookie), "%s", f->cookie);
 	printf("Cookie              : %s\n", cookie);
 
 	printf("Features            : (0x%08x) %s%s\n", f->features,
@@ -167,7 +153,7 @@
 	printf("Checksum            : 0x%x|0x%x (%s)\n", f->checksum, cksm,
 		f->checksum == cksm ? "Good!" : "Bad!");
 
-	uuid_unparse(f->uuid, uuid);
+	vhd_uuid_to_string(&f->uuid, uuid, sizeof(uuid));
 	printf("UUID                : %s\n", uuid);
 
 	printf("Saved state         : %s\n", f->saved == 0 ? "No" : "Yes");
@@ -211,7 +197,6 @@
 	}
 
 	printf("       decoded name : %s\n", buf);
-	free(buf);
 }
 
 static void
@@ -244,31 +229,7 @@
 }
 
 static void
-vhd_print_keyhash(vhd_context_t *vhd)
-{
-	int ret;
-	struct vhd_keyhash keyhash;
-
-	ret = vhd_get_keyhash(vhd, &keyhash);
-	if (ret)
-		printf("error reading keyhash: %d\n", ret);
-	else if (keyhash.cookie == 1) {
-		int i;
-
-		printf("Batmap keyhash nonce: ");
-		for (i = 0; i < sizeof(keyhash.nonce); i++)
-			printf("%02x", keyhash.nonce[i]);
-
-		printf("\nBatmap keyhash hash : ");
-		for (i = 0; i < sizeof(keyhash.hash); i++)
-			printf("%02x", keyhash.hash[i]);
-
-		printf("\n");
-	}
-}
-
-static void
-vhd_print_batmap_header(vhd_context_t *vhd, vhd_batmap_t *batmap, int hex)
+vhd_print_batmap_header(vhd_batmap_t *batmap, int hex)
 {
 	uint32_t cksm;
 
@@ -279,9 +240,8 @@
 	       conv(hex, batmap->header.batmap_size));
 	printf("Batmap version      : 0x%08x\n",
 	       batmap->header.batmap_version);
-	vhd_print_keyhash(vhd);
 
-	cksm = vhd_checksum_batmap(vhd, batmap);
+	cksm = vhd_checksum_batmap(batmap);
 	printf("Checksum            : 0x%x|0x%x (%s)\n",
 	       batmap->header.checksum, cksm,
 	       (batmap->header.checksum == cksm ? "Good!" : "Bad!"));
@@ -291,7 +251,7 @@
 static inline int
 check_block_range(vhd_context_t *vhd, uint64_t block, int hex)
 {
-	if (block > vhd_cur_capacity(vhd) / vhd->header.block_size) {
+	if (block > vhd->header.max_bat_size) {
 		fprintf(stderr, "block %s past end of file\n",
 			conv(hex, block));
 		return -ERANGE;
@@ -300,7 +260,7 @@
 	return 0;
 }
 
-int
+static int
 vhd_print_headers(vhd_context_t *vhd, int hex)
 {
 	int err;
@@ -316,22 +276,11 @@
 		if (vhd_has_batmap(vhd)) {
 			err = vhd_get_batmap(vhd);
 			if (err) {
-				err = vhd_read_batmap_header(vhd,
-							     &vhd->batmap);
-				if (err) {
-					printf("failed to get batmap header\n");
-					return err;
-				}
-
-				err = vhd_read_batmap_map(vhd,
-							  &vhd->batmap);
-				if (err) {
-					printf("failed to get batmap map\n");
-					return err;
-				}
+				printf("failed to get batmap header\n");
+				return err;
 			}
 
-			vhd_print_batmap_header(vhd, &vhd->batmap, hex);
+			vhd_print_batmap_header(&vhd->batmap, hex);
 		}
 	}
 
@@ -423,33 +372,26 @@
 	return 0;
 }
 
-static int
-vhd_print_bat_str(vhd_context_t *vhd)
+static inline void
+write_full(int fd, void* buf, size_t count)
 {
-	int i, gcc, total_blocks, bitmap_size;
-	char *bitmap;
-
-	if (!vhd_type_dynamic(vhd))
-		return -EINVAL;
-
-	total_blocks = vhd->footer.curr_size / vhd->header.block_size;
-	bitmap_size = total_blocks >> 3;
-	if (bitmap_size << 3 < total_blocks)
-		bitmap_size++;
-
-	bitmap = malloc(bitmap_size);
-	if (!bitmap)
-		return -ENOMEM;
-	memset(bitmap, 0, bitmap_size);
-
-	for (i = 0; i < total_blocks; i++) {
-		if (vhd->bat.bat[i] != DD_BLK_UNUSED)
-			set_bit(bitmap, i);
+	ssize_t num_written = 0;
+	if (!buf) return;
+	
+	
+	while(count > 0) {
+		
+		num_written = write(fd, buf, count);
+		if (num_written == -1) {
+			if (errno == EINTR) 
+				continue;
+			else
+				return;
+		}
+		
+		count -= num_written;
+		buf   += num_written;
 	}
-
-	gcc = write(STDOUT_FILENO, bitmap, bitmap_size);
-	free(bitmap);
-	return 0;
 }
 
 static int
@@ -463,7 +405,6 @@
 		return -ERANGE;
 
 	for (i = 0; i < count; i++) {
-		int gcc;
 		cur = block + i;
 
 		if (vhd->bat.bat[cur] == DD_BLK_UNUSED) {
@@ -475,7 +416,8 @@
 		if (err)
 			goto out;
 
-		gcc = write(STDOUT_FILENO, buf, vhd_sectors_to_bytes(vhd->bm_secs));
+		write_full(STDOUT_FILENO, buf, 
+			   vhd_sectors_to_bytes(vhd->bm_secs));
 		free(buf);
 	}
 
@@ -520,8 +462,9 @@
 		if (vhd->bat.bat[blk] == DD_BLK_UNUSED)
 			bit = 0;
 		else
-			bit = vhd_bitmap_test(vhd, buf, sec);
+			bit = vhd_bitmap_test(vhd, buf, blk);
 
+	print:
 		printf("block %s: ", conv(hex, blk));
 		printf("sec: %s: %d\n", conv(hex, sec), bit);
 	}
@@ -533,74 +476,9 @@
 }
 
 static int
-vhd_print_bitmap_extents(vhd_context_t *vhd, uint64_t sector, int count,
-			 int hex)
-{
-	char *buf;
-	uint64_t cur;
-	int i, err, bit;
-	uint32_t blk, bm_blk, sec;
-	int64_t s, r;
-
-	if (vhd_sectors_to_bytes(sector + count) > vhd->footer.curr_size) {
-		printf("sector %s past end of file\n", conv(hex, sector));
-		return -ERANGE;
-	}
-
-	bm_blk = -1;
-	buf    = NULL;
-	s = -1;
-	r = 0;
-
-	for (i = 0; i < count; i++) {
-		cur = sector + i;
-		blk = cur / vhd->spb;
-		sec = cur % vhd->spb;
-
-		if (blk != bm_blk) {
-			bm_blk = blk;
-			free(buf);
-			buf = NULL;
-
-			if (vhd->bat.bat[blk] != DD_BLK_UNUSED) {
-				err = vhd_read_bitmap(vhd, blk, &buf);
-				if (err)
-					goto out;
-			}
-		}
-
-		if (vhd->bat.bat[blk] == DD_BLK_UNUSED)
-			bit = 0;
-		else
-			bit = vhd_bitmap_test(vhd, buf, sec);
-
-		if (bit) {
-			if (r == 0)
-				s = cur;
-			r++;
-		} else {
-			if (r > 0) {
-				printf("%s ", conv(hex, s));
-				printf("%s\n", conv(hex, r));
-			}
-			r = 0;
-		}
-	}
-	if (r > 0) {
-		printf("%s ", conv(hex, s));
-		printf("%s\n", conv(hex, r));
-	}
-
-	err = 0;
- out:
-	free(buf);
-	return err;
-}
-
-static int
 vhd_print_batmap(vhd_context_t *vhd)
 {
-	int err, gcc;
+	int err;
 	size_t size;
 
 	err = vhd_get_batmap(vhd);
@@ -610,7 +488,7 @@
 	}
 
 	size = vhd_sectors_to_bytes(vhd->batmap.header.batmap_size);
-	gcc = write(STDOUT_FILENO, vhd->batmap.map, size);
+	write_full(STDOUT_FILENO, vhd->batmap.map, size);
 
 	return 0;
 }
@@ -652,7 +530,6 @@
 		return -ERANGE;
 
 	for (i = 0; i < count; i++) {
-		int gcc;
 		cur = block + i;
 
 		if (vhd->bat.bat[cur] == DD_BLK_UNUSED) {
@@ -664,7 +541,7 @@
 		if (err)
 			break;
 
-		gcc = write(STDOUT_FILENO, buf, vhd->header.block_size);
+		write_full(STDOUT_FILENO, buf, vhd->header.block_size);
 		free(buf);
 	}
 
@@ -688,14 +565,12 @@
 
 	cur = sec;
 	while (count) {
-		int gcc;
-
 		secs = MIN((max >> VHD_SECTOR_SHIFT), count);
 		err  = vhd_io_read(vhd, buf, cur, secs);
 		if (err)
 			break;
 
-		gcc = write(STDOUT_FILENO, buf, vhd_sectors_to_bytes(secs));
+		write_full(STDOUT_FILENO, buf, vhd_sectors_to_bytes(secs));
 
 		cur   += secs;
 		count -= secs;
@@ -705,72 +580,33 @@
 	return err;
 }
 
-static int
-vhd_read_bytes(vhd_context_t *vhd, uint64_t byte, int count, int hex)
-{
-	char *buf;
-	uint64_t cur;
-	int err, max, bytes;
-
-	if (byte + count > vhd->footer.curr_size)
-		return -ERANGE;
-
-	max = MIN(count, VHD_BLOCK_SIZE);
-	err = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, max);
-	if (err)
-		return -err;
-
-	cur = byte;
-	while (count) {
-		int gcc;
-
-		bytes = MIN(max, count);
-		err   = vhd_io_read_bytes(vhd, buf, bytes, cur);
-		if (err)
-			break;
-
-		gcc = write(STDOUT_FILENO, buf, bytes);
-
-		cur   += bytes;
-		count -= bytes;
-	}
-
-	free(buf);
-	return err;
-}
-
 int
 vhd_util_read(int argc, char **argv)
 {
 	char *name;
 	vhd_context_t vhd;
-	int c, err, headers, hex, bat_str, cache, flags;
-	uint64_t bat, bitmap, tbitmap, ebitmap, batmap, tbatmap, data, lsec, count, read;
-	uint64_t bread;
+	int c, err, headers, hex;
+	uint64_t bat, bitmap, tbitmap, batmap, tbatmap, data, lsec, count, read;
 
 	err     = 0;
 	hex     = 0;
-	cache   = 0;
 	headers = 0;
-	bat_str = 0;
 	count   = 1;
 	bat     = -1;
 	bitmap  = -1;
 	tbitmap = -1;
-	ebitmap = -1;
 	batmap  = -1;
 	tbatmap = -1;
 	data    = -1;
 	lsec    = -1;
 	read    = -1;
-	bread   = -1;
 	name    = NULL;
 
 	if (!argc || !argv)
 		goto usage;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "n:pt:b:Bm:i:e:aj:d:c:r:R:xCh")) != -1) {
+	while ((c = getopt(argc, argv, "n:pt:b:m:i:aj:d:c:r:xh")) != -1) {
 		switch(c) {
 		case 'n':
 			name = optarg;
@@ -778,12 +614,6 @@
 		case 'p':
 			headers = 1;
 			break;
-		case 'C':
-			cache = 1;
-			break;
-		case 'B':
-			bat_str = 1;
-			break;
 		case 't':
 			lsec = strtoul(optarg, NULL, 10);
 			break;
@@ -796,9 +626,6 @@
 		case 'i':
 			tbitmap = strtoul(optarg, NULL, 10);
 			break;
-		case 'e':
-			ebitmap = strtoul(optarg, NULL, 10);
-			break;
 		case 'a':
 			batmap = 1;
 			break;
@@ -811,9 +638,6 @@
 		case 'r':
 			read = strtoull(optarg, NULL, 10);
 			break;
-		case 'R':
-			bread = strtoull(optarg, NULL, 10);
-			break;
 		case 'c':
 			count = strtoul(optarg, NULL, 10);
 			break;
@@ -829,10 +653,7 @@
 	if (!name || optind != argc)
 		goto usage;
 
-	flags = VHD_OPEN_RDONLY | VHD_OPEN_IGNORE_DISABLED;
-	if (cache)
-		flags |= VHD_OPEN_CACHED | VHD_OPEN_FAST;
-	err = vhd_open(&vhd, name, flags);
+	err = vhd_open(&vhd, name, VHD_OPEN_RDONLY | VHD_OPEN_IGNORE_DISABLED);
 	if (err) {
 		printf("Failed to open %s: %d\n", name, err);
 		vhd_dump_headers(name, hex);
@@ -860,12 +681,6 @@
 			goto out;
 	}
 
-	if (bat_str) {
-		err = vhd_print_bat_str(&vhd);
-		if (err)
-			goto out;
-	}
-
 	if (bitmap != -1) {
 		err = vhd_print_bitmap(&vhd, bitmap, count, hex);
 		if (err)
@@ -878,12 +693,6 @@
 			goto out;
 	}
 
-	if (ebitmap != -1) {
-		err = vhd_print_bitmap_extents(&vhd, ebitmap, count, hex);
-		if (err)
-			goto out;
-	}
-
 	if (batmap != -1) {
 		err = vhd_print_batmap(&vhd);
 		if (err)
@@ -908,12 +717,6 @@
 			goto out;
 	}
 
-	if (bread != -1) {
-		err = vhd_read_bytes(&vhd, bread, count, hex);
-		if (err)
-			goto out;
-	}
-
 	err = 0;
 
  out:
@@ -927,16 +730,13 @@
 	       "-p          print VHD headers\n"
 	       "-t sec      translate logical sector to VHD location\n"
 	       "-b blk      print bat entry\n"
-	       "-B          print entire bat as a bitmap\n"
 	       "-m blk      print bitmap\n"
 	       "-i sec      test bitmap for logical sector\n"
-	       "-e sec      output extent list of allocated logical sectors\n"
 	       "-a          print batmap\n"
 	       "-j blk      test batmap for block\n"
 	       "-d blk      print data\n"
 	       "-c num      num units\n"
 	       "-r sec      read num sectors at sec\n"
-	       "-R byte     read num bytes at byte\n"
 	       "-x          print in hex\n");
 	return EINVAL;
 }
diff -Nur blktap2_oxt//vhd/lib/vhd-util-repair.c blktap2_xen//vhd/lib/vhd-util-repair.c
--- blktap2_oxt//vhd/lib/vhd-util-repair.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-repair.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <errno.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -41,6 +37,7 @@
 {
 	char *name;
 	int err, c;
+	off_t eof;
 	vhd_context_t vhd;
 
 	name = NULL;
@@ -69,10 +66,15 @@
 		return err;
 	}
 
-	err = vhd_write_footer(&vhd, &vhd.footer);
-	if (err)
-		printf("error writing footer: %d\n", err);
+	err = vhd_end_of_data(&vhd, &eof);
+	if (err) {
+		printf("error finding end of data: %d\n", err);
+		goto done;
+	}
+
+	err = vhd_write_footer_at(&vhd, &vhd.footer, eof);
 
+ done:
 	vhd_close(&vhd);
 	return err;
 
diff -Nur blktap2_oxt//vhd/lib/vhd-util-resize.c blktap2_xen//vhd/lib/vhd-util-resize.c
--- blktap2_oxt//vhd/lib/vhd-util-resize.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-resize.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <errno.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -99,7 +95,7 @@
 }
 
 static int
-vhd_write_zeros(vhd_journal_t *journal, off64_t off, uint64_t size)
+vhd_write_zeros(vhd_journal_t *journal, off_t off, uint64_t size)
 {
 	int err;
 	char *buf;
@@ -113,7 +109,7 @@
 	if (err)
 		return err;
 
-	buf = mmap(0, map, PROT_READ, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
+	buf = mmap(0, map, PROT_READ, MAP_SHARED | MAP_ANON, -1, 0);
 	if (buf == MAP_FAILED)
 		return -errno;
 
@@ -147,7 +143,7 @@
 		goto out;
 
 	eof = vhd_position(vhd);
-	if (eof == (off64_t)-1) {
+	if (eof == (off_t)-1) {
 		err = -errno;
 		goto out;
 	}
@@ -238,13 +234,13 @@
 }
 
 static int
-vhd_move_block(vhd_journal_t *journal, uint32_t src, off64_t offset)
+vhd_move_block(vhd_journal_t *journal, uint32_t src, off_t offset)
 {
 	int err;
 	char *buf;
 	size_t size;
 	vhd_context_t *vhd;
-	off64_t off, src_off;
+	off_t off, src_off;
 
 	buf     = NULL;
 	vhd     = &journal->vhd;
@@ -304,7 +300,7 @@
 vhd_clobber_block(vhd_journal_t *journal, uint32_t src, uint32_t dest)
 {
 	int err;
-	off64_t off;
+	off_t off;
 	vhd_context_t *vhd;
 
 	vhd = &journal->vhd;
@@ -408,7 +404,7 @@
 {
 	int i, err;
 	vhd_context_t *vhd;
-	off64_t orig_map_off, new_map_off;
+	off_t orig_map_off, new_map_off;
 	uint32_t orig_entries, new_entries;
 
 	vhd          = &journal->vhd;
@@ -477,7 +473,7 @@
 static int
 vhd_dynamic_shrink(vhd_journal_t *journal, uint64_t secs)
 {
-	off64_t eof;
+	off_t eof;
 	uint32_t blocks;
 	vhd_context_t *vhd;
 	int i, j, err, free_cnt;
@@ -585,7 +581,7 @@
 }
 
 static inline int
-in_range(off64_t off, off64_t start, off64_t size)
+in_range(off_t off, off_t start, off_t size)
 {
 	return (start < off && start + size > off);
 }
@@ -603,7 +599,7 @@
 }
 
 static int
-vhd_check_for_clobber(vhd_context_t *vhd, off64_t off, int mode)
+vhd_check_for_clobber(vhd_context_t *vhd, off_t off, int mode)
 {
 	int i, n;
 	char *msg;
@@ -680,7 +676,7 @@
  * take any metadata after the bat (@eob) and shift it
  */
 static int
-vhd_shift_metadata(vhd_journal_t *journal, off64_t eob,
+vhd_shift_metadata(vhd_journal_t *journal, off_t eob,
 		   size_t bat_needed, size_t map_needed)
 {
 	int i, n, err;
@@ -728,7 +724,7 @@
 	}
 
 	for (i = 0; i < n; i++) {
-		off64_t off;
+		off_t off;
 		size_t size;
 
 		if (!locators[i])
@@ -779,7 +775,7 @@
 vhd_add_bat_entries(vhd_journal_t *journal, int entries)
 {
 	int i, err;
-	off64_t off;
+	off_t off;
 	vhd_bat_t new_bat;
 	vhd_context_t *vhd;
 	uint32_t new_entries;
@@ -799,7 +795,7 @@
 	off = vhd->header.table_offset + new_bat_size;
 	if (vhd_check_for_clobber(vhd, off, SKIP_BAT | SKIP_BATMAP)) {
 		EPRINTF("%s: writing new bat of 0x%"PRIx64" bytes "
-			"at 0x%08llx would clobber data\n", 
+			"at 0x%08"PRIx64" would clobber data\n", 
 			vhd->file, new_bat_size, vhd->header.table_offset);
 		return -EINVAL;
 	}
@@ -808,7 +804,7 @@
 		off = vhd->batmap.header.batmap_offset + new_map_size;
 		if (vhd_check_for_clobber(vhd, off, 0)) {
 			EPRINTF("%s: writing new batmap of 0x%"PRIx64" bytes"
-				" at 0x%08llx would clobber data\n", vhd->file,
+				" at 0x%08"PRIx64" would clobber data\n", vhd->file,
 				new_map_size, vhd->batmap.header.batmap_offset);
 			return -EINVAL;
 		}
@@ -820,6 +816,14 @@
 	if (err)
 		return err;
 
+	/* update footer */
+	vhd->footer.curr_size = (uint64_t)new_entries * vhd->header.block_size;
+	vhd->footer.geometry  = vhd_chs(vhd->footer.curr_size);
+	vhd->footer.checksum  = vhd_checksum_footer(&vhd->footer);
+	err = vhd_write_footer(vhd, &vhd->footer);
+	if (err)
+		return err;
+
 	/* allocate new bat */
 	err = posix_memalign((void **)&new_bat.bat, VHD_SECTOR_SIZE, new_bat_size);
 	if (err)
@@ -867,22 +871,14 @@
 	free(vhd->batmap.map);
 	vhd->batmap = new_batmap;
 
-	/* update footer */
-	vhd->footer.curr_size = (uint64_t)new_entries * vhd->header.block_size;
-	vhd->footer.geometry  = vhd_chs(vhd->footer.curr_size);
-	vhd->footer.checksum  = vhd_checksum_footer(&vhd->footer);
-	err = vhd_write_footer(vhd, &vhd->footer);
-	if (err)
-		return err;
-
 	return 0;
 }
 
 static int
 vhd_dynamic_grow(vhd_journal_t *journal, uint64_t secs)
 {
-	int err;
-	off64_t eob, eom;
+	int i, err;
+	off_t eob, eom;
 	vhd_context_t *vhd;
 	vhd_block_t first_block;
 	uint64_t blocks, size_needed;
@@ -957,7 +953,7 @@
 	 * move vhd data blocks to the end of the file to make room 
 	 */
 	do {
-		off64_t new_off, bm_size, gap_size;
+		off_t new_off, bm_size, gap_size;
 
 		new_off = vhd_sectors_to_bytes(vhd_next_block_offset(vhd));
 
@@ -1052,51 +1048,12 @@
 	return err;
 }
 
-static int
-vhd_dynamic_grow_fast(const char *name, uint64_t bytes)
-{
-	vhd_context_t vhd;
-	uint64_t blks, size;
-	int err;
-
-	err = vhd_open(&vhd, name, VHD_OPEN_RDWR);
-	if (err)
-		return err;
-
-	err = vhd_get_bat(&vhd);
-	if (err)
-		goto done;
-
-	if (vhd_has_batmap(&vhd)) {
-		err = vhd_get_batmap(&vhd);
-		if (err)
-			goto done;
-	}
-
-	blks   = (bytes + VHD_BLOCK_SIZE - 1) >> VHD_BLOCK_SHIFT;
-	size   = blks << VHD_BLOCK_SHIFT;
-	if (size < vhd.footer.curr_size) {
-		printf("%s: size (%llu) < curr size (%llu)\n", 
-				name, size, vhd.footer.curr_size);
-		err = -EINVAL;
-		goto done;
-	}
-	if (size == vhd.footer.curr_size)
-		goto done;
-
-	err = vhd_set_virt_size(&vhd, size);
-
-done:
-	vhd_close(&vhd);
-	return err;
-}
-
 int
 vhd_util_resize(int argc, char **argv)
 {
 	char *name, *jname;
 	uint64_t size;
-	int fast, c, err, jerr;
+	int c, err, jerr;
 	vhd_journal_t journal;
 	vhd_context_t *vhd;
 
@@ -1104,10 +1061,9 @@
 	size  = 0;
 	name  = NULL;
 	jname = NULL;
-	fast  = 0;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "n:s:j:fh")) != -1) {
+	while ((c = getopt(argc, argv, "n:j:s:h")) != -1) {
 		switch (c) {
 		case 'n':
 			name = optarg;
@@ -1115,9 +1071,6 @@
 		case 'j':
 			jname = optarg;
 			break;
-		case 'f':
-			fast = 1;
-			break;
 		case 's':
 			err  = 0;
 			size = strtoull(optarg, NULL, 10);
@@ -1128,10 +1081,7 @@
 		}
 	}
 
-	if (err || !name || (!jname && !fast) || argc != optind)
-		goto usage;
-
-	if (jname && fast)
+	if (err || !name || !jname || argc != optind)
 		goto usage;
 
 	err = vhd_util_resize_check_creator(name);
@@ -1139,10 +1089,6 @@
 		return err;
 
 	libvhd_set_log_level(1);
-
-	if (fast)
-		return vhd_dynamic_grow_fast(name, size << 20);
-
 	err = vhd_journal_create(&journal, name, jname);
 	if (err) {
 		printf("creating journal failed: %d\n", err);
@@ -1180,15 +1126,6 @@
 	return (err ? : jerr);
 
 usage:
-	printf("options: <-n name> <-s size (in MB)> (<-j journal>|<-f fast>) "
-			"[-h help]\n\n"
-			"The resize operation can only be performed offline "
-			"and must be journaled because resizing the metadata "
-			"might require moving data blocks. However, if a "
-			"VHD was created with -S <msize> option (during "
-			"vhd-util create/snapshot), which preallocates the "
-			"metadata for growing the VHD up to size <msize>, then "
-			"resizing such a VHD up to <msize> can be performed "
-			"online without journaling (-f option).\n");
+	printf("options: <-n name> <-j journal> <-s size (in MB)> [-h help]\n");
 	return -EINVAL;
 }
diff -Nur blktap2_oxt//vhd/lib/vhd-util-revert.c blktap2_xen//vhd/lib/vhd-util-revert.c
--- blktap2_oxt//vhd/lib/vhd-util-revert.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-revert.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,7 +23,22 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
+ *
+ * Altering operations:
+ *
+ * 1. Change the parent pointer to another file.
+ * 2. Change the size of the file containing the VHD image. This does NOT 
+ * affect the VHD disk capacity, only the physical size of the file containing 
+ * the VHD. Naturally, it is not possible to set the file size to be less than  
+ * the what VHD utilizes.
+ * The operation doesn't actually change the file size, but it writes the 
+ * footer in the right location such that resizing the file (manually, as a 
+ * separate step) will produce the correct results. If the new file size is 
+ * greater than the current file size, the file must first be expanded and then 
+ * altered with this operation. If the new size is smaller than the current 
+ * size, the VHD must first be altered with this operation and then the file 
+ * must be shrunk. Failing to resize the file will result in a corrupted VHD.
+*/
 
 #include <errno.h>
 //#include <fcntl.h>
diff -Nur blktap2_oxt//vhd/lib/vhd-util-scan.c blktap2_xen//vhd/lib/vhd-util-scan.c
--- blktap2_oxt//vhd/lib/vhd-util-scan.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-scan.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,7 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
+*/
 
 #include <glob.h>
 #include <errno.h>
@@ -36,7 +33,7 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <fnmatch.h>
-#include <syslog.h>
+#include <libgen.h>	/* for basename() */
 #include <sys/stat.h>
 
 #include "list.h"
@@ -49,18 +46,12 @@
 #define VHD_SCAN_NOFAIL      0x08
 #define VHD_SCAN_VERBOSE     0x10
 #define VHD_SCAN_PARENTS     0x20
-#define VHD_SCAN_MARKERS     0x40
 
 #define VHD_TYPE_RAW_FILE    0x01
 #define VHD_TYPE_VHD_FILE    0x02
 #define VHD_TYPE_RAW_VOLUME  0x04
 #define VHD_TYPE_VHD_VOLUME  0x08
 
-#define EPRINTF(_f, _a...)					\
-	do {							\
-		syslog(LOG_INFO, "%s: " _f, __func__, ##_a);	\
-	} while (0)
-
 static inline int
 target_volume(uint8_t type)
 {
@@ -93,10 +84,8 @@
 	char                *name;
 	char                *parent;
 	uint64_t             capacity;
-	off64_t              size;
+	off_t                size;
 	uint8_t              hidden;
-	char                 marker;
-	struct vhd_keyhash   keyhash;
 	int                  error;
 	char                *message;
 
@@ -126,6 +115,7 @@
 vhd_util_scan_pretty_allocate_list(int cnt)
 {
 	int i;
+	struct vhd_image *list;
 
 	memset(&scan, 0, sizeof(scan));
 
@@ -227,10 +217,8 @@
 	img->capacity = image->capacity;
 	img->size     = image->size;
 	img->hidden   = image->hidden;
-	img->marker   = image->marker;
 	img->error    = image->error;
 	img->message  = image->message;
-	memcpy(&img->keyhash, &image->keyhash, sizeof(img->keyhash));
 
 	img->name = strdup(image->name);
 	if (!img->name)
@@ -286,28 +274,10 @@
 	if (image->error)
 		printf("%*svhd=%s scan-error=%d error-message='%s'\n",
 		       tab, pad, image->name, image->error, image->message);
-	else if (!(flags & VHD_SCAN_MARKERS))
+	else
 		printf("%*svhd=%s capacity=%"PRIu64" size=%"PRIu64" hidden=%u "
 		       "parent=%s%s\n", tab, pad, name, image->capacity,
 		       image->size, image->hidden, parent, pmsg);
-	else {
-		int i;
-		uint8_t *hash;
-		char *p, str[65];
-
-		str[0] = 0;
-		hash   = image->keyhash.hash;
-
-		if (image->keyhash.cookie)
-			for (i = 0, p = str;
-			     i < sizeof(image->keyhash.hash); i++)
-				p += sprintf(p, "%02x", hash[i]);
-
-		printf("%*svhd=%s capacity=%"PRIu64" size=%"PRIu64" hidden=%u "
-		       "marker=%u keyhash=%s parent=%s%s\n", tab, pad, name,
-		       image->capacity, image->size, image->hidden,
-		       (uint8_t)image->marker, str, parent, pmsg);
-	}
 }
 
 static void
@@ -473,6 +443,7 @@
 static int
 vhd_util_scan_extract_volume_name(char *dst, const char *src)
 {
+	int err;
 	char copy[VHD_MAX_NAME_LEN], *name, *s, *c;
 
 	name = strrchr(src, '/');
@@ -539,7 +510,7 @@
 static int
 vhd_util_scan_get_parent(vhd_context_t *vhd, struct vhd_image *image)
 {
-	int err;
+	int i, err;
 	vhd_parent_locator_t *loc;
 
 	if (!target_vhd(image->target->type)) {
@@ -597,32 +568,6 @@
 }
 
 static int
-vhd_util_scan_get_markers(vhd_context_t *vhd, struct vhd_image *image)
-{
-	int err;
-	char marker;
-	struct vhd_keyhash keyhash;
-
-	err    = 0;
-	marker = 0;
-
-	if (target_vhd(image->target->type) /* && vhd_has_batmap(vhd) */) {
-		err = vhd_marker(vhd, &marker);
-		if (err)
-			return err;
-
-		err = vhd_get_keyhash(vhd, &keyhash);
-		if (err)
-			return err;
-	}
-
-	image->marker = marker;
-	memcpy(&image->keyhash, &keyhash, sizeof(image->keyhash));
-
-	return err;
-}
-
-static int
 vhd_util_scan_get_size(vhd_context_t *vhd, struct vhd_image *image)
 {
 	image->size = image->target->size;
@@ -733,6 +678,7 @@
 static int
 vhd_util_scan_open_volume(vhd_context_t *vhd, struct vhd_image *image)
 {
+	int err;
 	struct target *target;
 
 	target = image->target;
@@ -778,7 +724,7 @@
 	if (target_volume(image->target->type) || !(flags & VHD_SCAN_PRETTY))
 		image->name = target->name;
 	else {
-		image->name = vhd_realpath(target->name, NULL);
+		image->name = realpath(target->name, NULL);
 		if (!image->name) {
 			image->name    = target->name;
 			image->message = "resolving name";
@@ -830,17 +776,12 @@
 		return -ENOSYS;
 
 	err = copy_name(target->name, lv->name);
-	if (err) {
-		EPRINTF("copy target name failed: '%s'\n", lv->name);
+	if (err)
 		return err;
-	}
 
 	err = copy_name(target->device, lv->first_segment.device);
-	if (err) {
-		EPRINTF("copy target device failed: '%s'\n",
-				lv->first_segment.device);
+	if (err)
 		return err;
-	}
 
 	target->type  = type;
 	target->size  = lv->size;
@@ -1032,16 +973,6 @@
 			goto end;
 		}
 
-		if (flags & VHD_SCAN_MARKERS) {
-			err = vhd_util_scan_get_markers(&vhd, &image);
-			if (err) {
-				ret           = -EAGAIN;
-				image.message = "checking markers";
-				image.error   = err;
-				goto end;
-			}
-		}
-
 		if (vhd.footer.type == HD_TYPE_DIFF) {
 			err = vhd_util_scan_get_parent(&vhd, &image);
 			if (err) {
@@ -1214,8 +1145,6 @@
 		err = fnmatch(filter, lv->name, FNM_PATHNAME);
 		if (err) {
 			if (err != FNM_NOMATCH) {
-				EPRINTF("fnmatch failed: '%s', '%s'\n", 
-						filter, lv->name);
 				vhd_util_scan_error(lv->name, err);
 				if (!(flags & VHD_SCAN_NOFAIL))
 					return err;
@@ -1306,7 +1235,7 @@
 int
 vhd_util_scan(int argc, char **argv)
 {
-	int c, ret, err, cnt, markers;
+	int c, ret, err, cnt;
 	char *filter, *volume;
 	struct target *targets;
 
@@ -1314,13 +1243,12 @@
 	ret     = 0;
 	err     = 0;
 	flags   = 0;
-	markers = 0;
 	filter  = NULL;
 	volume  = NULL;
 	targets = NULL;
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "m:fcl:pavMh")) != -1) {
+	while ((c = getopt(argc, argv, "m:fcl:pavh")) != -1) {
 		switch (c) {
 		case 'm':
 			filter = optarg;
@@ -1344,9 +1272,6 @@
 		case 'v':
 			flags |= VHD_SCAN_VERBOSE;
 			break;
-		case 'M':
-			flags |= VHD_SCAN_MARKERS;
-			break;
 		case 'h':
 			goto usage;
 		default:
@@ -1387,6 +1312,6 @@
 	printf("usage: [OPTIONS] FILES\n"
 	       "options: [-m match filter] [-f fast] [-c continue on failure] "
 	       "[-l LVM volume] [-p pretty print] [-a scan parents] "
-	       "[-v verbose] [-h help] [-M show markers]\n");
+	       "[-v verbose] [-h help]\n");
 	return err;
 }
diff -Nur blktap2_oxt//vhd/lib/vhd-util-set-field.c blktap2_xen//vhd/lib/vhd-util-set-field.c
--- blktap2_oxt//vhd/lib/vhd-util-set-field.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-set-field.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <errno.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -41,6 +37,7 @@
 {
 	long value;
 	int err, c;
+	off_t eof;
 	vhd_context_t vhd;
 	char *name, *field;
 
@@ -79,7 +76,7 @@
 		goto usage;
 	}
 
-	if (strcmp(field, "hidden") && strcmp(field, "marker")) {
+	if (strcmp(field, "hidden")) {
 		printf("invalid field %s\n", field);
 		goto usage;
 	}
@@ -95,17 +92,11 @@
 		return err;
 	}
 
-	if (!strcmp(field, "hidden")) {
-		vhd.footer.hidden = (char)value;
-		err = vhd_write_footer(&vhd, &vhd.footer);
-		if (err == -ENOSPC && vhd_type_dynamic(&vhd) && value)
-			/* if no space to write the primary footer, at least write the 
-			 * backup footer so that it's possible to delete the VDI */
-			err = vhd_write_footer_at(&vhd, &vhd.footer, 0);
-	} else {
-		err = vhd_set_marker(&vhd, (char)value);
-	}
+	vhd.footer.hidden = (char)value;
+
+	err = vhd_write_footer(&vhd, &vhd.footer);
 		
+ done:
 	vhd_close(&vhd);
 	return err;
 
diff -Nur blktap2_oxt//vhd/lib/vhd-util-snapshot.c blktap2_xen//vhd/lib/vhd-util-snapshot.c
--- blktap2_oxt//vhd/lib/vhd-util-snapshot.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-snapshot.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <errno.h>
 #include <stdio.h>
 #include <fcntl.h>
@@ -111,7 +107,7 @@
 	vhd_flag_creat_t flags;
 	int c, err, prt_raw, limit;
 	char *name, *pname, *ppath, *backing;
-	uint64_t size, msize;
+	uint64_t size;
 	vhd_context_t vhd;
 
 	name    = NULL;
@@ -119,7 +115,6 @@
 	ppath   = NULL;
 	backing = NULL;
 	size    = 0;
-	msize   = 0;
 	flags   = 0;
 	limit   = 0;
 
@@ -129,7 +124,7 @@
 	}
 
 	optind = 0;
-	while ((c = getopt(argc, argv, "n:p:S:l:mh")) != -1) {
+	while ((c = getopt(argc, argv, "n:p:l:mh")) != -1) {
 		switch (c) {
 		case 'n':
 			name = optarg;
@@ -137,9 +132,6 @@
 		case 'p':
 			pname = optarg;
 			break;
-		case 'S':
-			msize = strtoull(optarg, NULL, 10);
-			break;
 		case 'l':
 			limit = strtol(optarg, NULL, 10);
 			break;
@@ -160,7 +152,7 @@
 		goto usage;
 	}
 
-	ppath = vhd_realpath(pname, NULL);
+	ppath = realpath(pname, NULL);
 	if (!ppath)
 		return -errno;
 
@@ -209,7 +201,7 @@
 			goto out;
 	}
 
-	err = vhd_snapshot(name, size, backing, msize << 20, flags);
+	err = vhd_snapshot(name, size, backing, flags);
 
 out:
 	free(ppath);
@@ -219,7 +211,6 @@
 
 usage:
 	printf("options: <-n name> <-p parent name> [-l snapshot depth limit]"
-	       " [-m parent_is_raw] [-S size (MB) for metadata preallocation "
-	       "(see vhd-util resize)] [-h help]\n");
+	       " [-m parent_is_raw] [-h help]\n");
 	return err;
 }
diff -Nur blktap2_oxt//vhd/lib/vhd-util-stream-coalesce.c blktap2_xen//vhd/lib/vhd-util-stream-coalesce.c
--- blktap2_oxt//vhd/lib/vhd-util-stream-coalesce.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/vhd-util-stream-coalesce.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,575 +0,0 @@
-/*
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <errno.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stddef.h>
-
-#include "libvhd.h"
-#include "vhd-util.h"
-
-struct vhd_stream_stats {
-	char             display;
-	uint32_t         total;
-	uint32_t         cur;
-};
-
-#define ERR(_fmt, _args...) fprintf(stderr, "%d: " _fmt, __LINE__, ##_args)
-
-#define VERR(_v, _fmt, _args...)					\
-	do {								\
-		char uuid[37];						\
-		uuid_unparse((_v)->footer.uuid, uuid);			\
-		ERR("%s: " _fmt, uuid, ##_args);			\
-	} while (0)							\
-
-#define PROGRESS(_stats)						\
-	do {								\
-		if ((_stats)->display && (_stats)->total) {		\
-			printf("\r%6.2f%%",				\
-			       ((float)(_stats)->cur /			\
-				(float)(_stats)->total) * 100.0);	\
-			fflush(stdout);					\
-		}							\
-	} while (0)
-
-static void
-vhd_util_stream_swap(vhd_context_t **vhds, int i, int j)
-{
-	vhd_context_t *tmp;
-
-	if (i == j)
-		return;
-
-	tmp     = vhds[i];
-	vhds[i] = vhds[j];
-	vhds[j] = tmp;
-}
-
-static int
-vhd_util_stream_sort(vhd_context_t **vhds, int num)
-{
-	int i, err, head;
-
-	err  = -EINVAL;
-	head = -1;
-
-	for (i = 0; i < num; i++) {
-		int j;
-		uuid_t cur;
-
-		uuid_copy(cur, vhds[i]->footer.uuid);
-
-		for (j = 0; j < num; j++) {
-			if (vhds[j]->footer.type == HD_TYPE_DIFF) {
-				uuid_t tmp;
-
-				uuid_copy(tmp, vhds[j]->header.prt_uuid);
-
-				if (!uuid_compare(cur, tmp))
-					break;
-			}
-		}
-
-		if (j == num) {
-			if (head != -1) {
-				ERR("multiple children found\n");
-				goto out;
-			}
-			head = i;
-		}
-	}
-
-	if (head == -1) {
-		ERR("child VHD not found\n");
-		goto out;
-	}
-
-	vhd_util_stream_swap(vhds, head, 0);
-
-	for (i = 0; i < num - 1; i++) {
-		int j;
-		uuid_t parent;
-
-		if (vhds[i]->footer.type != HD_TYPE_DIFF) {
-			VERR(vhds[i], "non-differencing VHD found\n");
-			goto out;
-		}
-
-		uuid_copy(parent, vhds[i]->header.prt_uuid);
-
-		for (j = i + 1; j < num; j++) {
-			uuid_t tmp;
-
-			uuid_copy(tmp, vhds[j]->footer.uuid);
-
-			if (!uuid_compare(tmp, parent)) {
-				vhd_util_stream_swap(vhds, i + 1, j);
-				break;
-			}
-		}
-
-		if (j == num) {
-			ERR("VHD parent not found\n");
-			goto out;
-		}
-	}
-
-	for (i = 0; i < num - 1; i++) {
-		uuid_t parent, next;
-
-		uuid_copy(parent, vhds[i]->header.prt_uuid);
-		uuid_copy(next, vhds[i + 1]->footer.uuid);
-
-		if (uuid_compare(parent, next)) {
-			VERR(vhds[i], "VHD sort failed\n");
-			goto out;
-		}
-	}
-
-	err = 0;
-
-out:
-	return err;
-}
-
-static int
-vhd_util_stream_transfer_sectors(vhd_context_t *src, vhd_context_t *dst,
-				 uint32_t blk, uint32_t sec, uint32_t cnt)
-{
-	int err;
-	char *buf;
-	size_t size;
-	off64_t off;
-	uint64_t sout;
-
-	size = vhd_sectors_to_bytes(cnt);
-	sout = (uint64_t)blk * dst->spb + sec;
-	off  = src->bat.bat[blk] + src->bm_secs + sec;
-
-	err = posix_memalign((void **)&buf, VHD_SECTOR_SIZE, size);
-	if (err) {
-		err = -err;
-		buf = NULL;
-		VERR(src, "error allocating data buffer: %d\n", err);
-		goto out;
-	}
-
-	err = vhd_pread(src, buf, size, vhd_sectors_to_bytes(off));
-	if (err) {
-		VERR(src, "error reading from stream\n");
-		goto out;
-	}
-
-	err = vhd_io_write(dst, buf, sout, cnt);
-	if (err) {
-		VERR(src, "error writing 0x%x sectors at 0x%llx to output: "
-		     "%d\n", cnt, sout, err);
-		goto out;
-	}
-
-out:
-	free(buf);
-	return err;
-}
-
-static int
-vhd_util_stream_copy_block(vhd_context_t *src,
-			   vhd_context_t *dst, uint32_t blk)
-{
-	int err, i;
-	char *sbm, *dbm;
-
-	sbm = NULL;
-	dbm = NULL;
-
-	if (src->header.block_size != dst->header.block_size) {
-		err = -EINVAL;
-		VERR(src, "src and dst have different block sizes\n");
-		goto out;
-	}
-
-	if ((uint64_t)blk * dst->header.block_size > dst->footer.curr_size) {
-		err = -EINVAL;
-		VERR(src, "block 0x%x beyond end of dst\n", blk);
-		goto out;
-	}
-
-	if ((uint64_t)blk * src->header.block_size > src->footer.curr_size ||
-	    src->bat.bat[blk] == DD_BLK_UNUSED) {
-		err = 0;
-		goto out;
-	}
-
-	if (vhd_has_batmap(dst) && vhd_batmap_test(dst, &dst->batmap, blk)) {
-		err = 0;
-		goto out;
-	}
-
-	if (dst->bat.bat[blk] == DD_BLK_UNUSED) {
-		dbm = calloc(1, vhd_sectors_to_bytes(dst->bm_secs));
-		if (!dbm) {
-			err = -ENOMEM;
-			VERR(src, "allocating bitmap");
-			goto out;
-		}
-	} else {
-		err = vhd_read_bitmap(dst, blk, &dbm);
-		if (err) {
-			VERR(src, "error reading dst bitmap for block 0x%x: "
-			     "%d\n", blk, err);
-			goto out;
-		}
-	}
-
-	err = vhd_read_bitmap(src, blk, &sbm);
-	if (err) {
-		ERR("error reading source bitmap for "
-		    "block 0x%x: %d\n", blk, err);
-		goto out;
-	}
-
-	i = 0;
-	while (i < src->spb) {
-		int cnt, copy;
-
-		cnt  = 1;
-		copy = vhd_bitmap_test(src, sbm, i) &&
-			!vhd_bitmap_test(dst, dbm, i);
-
-		while (i + cnt < src->spb &&
-		       (copy == (vhd_bitmap_test(src, sbm, i + cnt) &&
-				 !vhd_bitmap_test(dst, dbm, i + cnt))))
-			cnt++;
-
-		if (copy) {
-			err = vhd_util_stream_transfer_sectors(src, dst,
-							       blk, i, cnt);
-			if (err)
-				goto out;
-		}
-
-		i += cnt;
-	}
-
-out:
-	free(sbm);
-	free(dbm);
-	return err;
-}
-
-#define p2v_entry(physical, virtual) (((uint64_t)(physical) << 32) | (virtual))
-#define p2v_physical(entry)          ((uint32_t)((entry) >> 32))
-#define p2v_virtual(entry)           ((uint32_t)((entry) & ((1ULL << 32) - 1)))
-
-static int
-p2v_compare(const void *p1, const void *p2)
-{
-	uint32_t phy1 = p2v_physical(*(uint64_t *)p1);
-	uint32_t phy2 = p2v_physical(*(uint64_t *)p2);
-	if (phy1 == phy2)
-		return 0;
-	return (phy1 < phy2 ? -1 : 1);
-}
-
-static int
-vhd_util_stream_coalesce_one(vhd_context_t *src, vhd_context_t *dst,
-			     struct vhd_stream_stats *stats)
-{
-	int err;
-	uint32_t i;
-	uint64_t *p2v;
-
-	p2v = malloc(src->bat.entries * sizeof(*p2v));
-	if (!p2v) {
-		err = -ENOMEM;
-		VERR(src, "allocating p2v map");
-		goto out;
-	}
-
-	for (i = 0; i < src->bat.entries; i++)
-		p2v[i] = p2v_entry(src->bat.bat[i], i);
-
-	qsort(p2v, src->bat.entries, sizeof(*p2v), p2v_compare);
-
-	for (i = 0; i < src->bat.entries; i++) {
-		uint32_t phys = p2v_physical(p2v[i]);
-		uint32_t virt = p2v_virtual(p2v[i]);
-
-		if (phys != DD_BLK_UNUSED) {
-			PROGRESS(stats);
-			stats->cur++;
-
-			err = vhd_util_stream_copy_block(src, dst, virt);
-			if (err)
-				goto out;
-		}
-	}
-
-out:
-	free(p2v);
-	return err;
-}
-
-static int
-vhd_util_stream_open_output(vhd_context_t *src, vhd_context_t *tail,
-			    vhd_context_t *dst, const char *output)
-{
-	int err;
-
-	memset(dst, 0, sizeof(*dst));
-
-	if (access(output, F_OK) == 0) {
-		err = -EEXIST;
-		ERR("%s already exists\n", output);
-		goto out;
-	}
-
-	err = __vhd_util_clone_metadata_s(tail, output,
-					  vhd_cur_capacity(src),
-					  vhd_max_capacity(src),
-					  1);
-	if (err) {
-		ERR("error creating %s: %d\n", output, err);
-		goto out;
-	}
-
-	err = vhd_open(dst, output, VHD_OPEN_RDWR);
-	if (err) {
-		ERR("error opening %s: %d\n", output, err);
-		goto out;
-	}
-
-	dst->footer.timestamp = src->footer.timestamp;
-	uuid_copy(dst->footer.uuid, src->footer.uuid);
-
-	err = vhd_write_footer(dst, &dst->footer);
-	if (err) {
-		ERR("error creating %s: %d\n", output, err);
-		goto out;
-	}
-
-	err = vhd_get_bat(dst);
-	if (err) {
-		ERR("error reading bat for %s: %d\n", output, err);
-		goto out;
-	}
-
-	if (vhd_has_batmap(dst)) {
-		err = vhd_get_batmap(dst);
-		if (err) {
-			ERR("error reading batmap for %s: %d\n", output, err);
-			goto out;
-		}
-	}
-
-out:
-	if (err) {
-		vhd_close(dst);
-		memset(dst, 0, sizeof(*dst));
-	}
-	return err;
-}
-
-static int
-__vhd_util_stream_coalesce(vhd_context_t **vhds, const int num,
-			   const char *output, struct vhd_stream_stats *stats)
-{
-	int i, err;
-	vhd_context_t dst, *src;
-
-	src = vhds[0];
-	memset(&dst, 0, sizeof(dst));
-
-	err = vhd_util_stream_open_output(src, vhds[num - 1], &dst, output);
-	if (err) {
-		if (err == -EEXIST)
-			return err;
-		else
-			goto out;
-	}
-
-	for (i = 0; i < num; i++) {
-		uint32_t blk;
-		src = vhds[i];
-		for (blk = 0; blk < src->bat.entries; blk++)
-			if (src->bat.bat[blk] != DD_BLK_UNUSED)
-				stats->total++;
-	}
-
-	if (stats->display) {
-		stats->cur = 0;
-		PROGRESS(stats);
-	}
-
-	for (i = 0; i < num; i++) {
-		src = vhds[i];
-		err = vhd_util_stream_coalesce_one(src, &dst, stats);
-		if (err)
-			goto out;
-	}
-
-	if (stats->display) {
-		stats->cur = stats->total;
-		PROGRESS(stats);
-		printf("\n");
-	}
-
-out:
-	vhd_close(&dst);
-	if (err)
-		unlink(output);
-	return err;
-}
-
-int
-vhd_util_stream_coalesce(int argc, char **argv)
-{
-	const char *output;
-	vhd_context_t **vhds;
-	struct vhd_stream_stats stats;
-	int c, i, err, cnt, hex, info, ignore_order;
-
-	hex    = 0;
-	info   = 0;
-	err    = -EINVAL;
-	output = NULL;
-	ignore_order = 0;
-
-	memset(&stats, 0, sizeof(stats));
-
-	if (!argc || !argv)
-		goto usage;
-
-	optind = 0;
-	while ((c = getopt(argc, argv, "ixDpo:h")) != -1) {
-		switch (c) {
-		case 'i':
-			info = 1;
-			break;
-		case 'x':
-			hex = 1;
-			break;
-		case 'p':
-			stats.display = 1;
-			break;
-		case 'D':
-			ignore_order = 1;
-			break;
-		case 'o':
-			output = optarg;
-			break;
-		case 'h':
-		default:
-			goto usage;
-		}
-	}
-
-	cnt = argc - optind;
-	if (!cnt)
-		goto usage;
-
-	if (!info && !output)
-		goto usage;
-
-	vhds = calloc(cnt, sizeof(*vhds));
-	if (!vhds) {
-		err = -ENOMEM;
-		ERR("allocating streams");
-		goto out;
-	}
-
-	for (i = 0; i < cnt; i++) {
-		FILE *f;
-
-		f = fopen(argv[optind + i], "r");
-		if (!f) {
-			err = -errno;
-			goto out;
-		}
-
-		vhds[i] = vhd_stream_load(f);
-		fclose(f);
-
-		if (!vhds[i]) {
-			err = -errno;
-			goto out;
-		}
-	}
-
-	if (info) {
-		for (i = 0; i < cnt; i++) {
-			vhd_print_headers(vhds[i], hex);
-			if (i + 1 < cnt)
-				printf("\n\n");
-		}
-	} else {
-		err = vhd_util_stream_sort(vhds, cnt);
-		if (err) {
-			if (ignore_order)
-				ERR("WARNING: continuing in spite of "
-				    "mal-ordered VHDs.  The output VHD "
-				    "may not contain what you expect.\n");
-			else
-				goto out;
-		}
-
-		err = __vhd_util_stream_coalesce(vhds, cnt, output, &stats);
-	}
-
-out:
-	if (vhds) {
-		for (i = 0; i < cnt; i++)
-			if (vhds[i])
-				vhd_close(vhds[i]);
-		free(vhds);
-	}
-	return err;
-
-usage:
-	printf("vhd-util stream-coalesce accepts a chain of VHD streams as\n"
-	       "input and produces a single, coalesced version of the chain.\n"
-	       "All intput VHDs supplied to this utility should be part of\n"
-	       "the same VHD chain, and should be ordered from youngest to\n"
-	       "oldest.  VHD UUIDs are checked to verify proper ordering.\n"
-	       "Example: vhd-util stream <(cat child.vhd) <(cat parent.vhd) "
-	       "-o output.vhd\n"
-	       "Options:\n"
-	       "-h          Print this help message.\n"
-	       "-o NAME     NAME of output VHD to be created.\n"
-	       "-D          Disable checking VHD UUIDs for proper ordering.\n"
-	       "            Only use this if you know what you are doing.\n"
-	       "-p          Display coalesce progress.\n"
-	       "-i          Print basic info about the VHDs and exit.\n"
-	       "            (No output VHD is created in this case.)\n"
-	       "-x          Print in hex.\n");
-	return EINVAL;
-}
diff -Nur blktap2_oxt//vhd/lib/vhd-util-uuid.c blktap2_xen//vhd/lib/vhd-util-uuid.c
--- blktap2_oxt//vhd/lib/vhd-util-uuid.c	1969-12-31 19:00:00.000000000 -0500
+++ blktap2_xen//vhd/lib/vhd-util-uuid.c	2015-03-19 11:08:36.000000000 -0400
@@ -0,0 +1,128 @@
+ /* Copyright (c) 2008, XenSource Inc.
+ * Copyright (c) 2011, Citrix
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of XenSource Inc. nor the names of its contributors
+ *       may be used to endorse or promote products derived from this software
+ *       without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#if defined(__linux__)
+
+#include <uuid/uuid.h>
+
+typedef struct {
+    uuid_t uuid;
+} vhd_uuid_t;
+
+int vhd_uuid_is_nil(vhd_uuid_t *uuid)
+{
+	return uuid_is_null(uuid->uuid);
+}
+
+void vhd_uuid_generate(vhd_uuid_t *uuid)
+{
+	uuid_generate(uuid->uuid);
+}
+
+void vhd_uuid_to_string(vhd_uuid_t *uuid, char *out, size_t size)
+{
+	uuid_unparse(uuid->uuid, out);
+}
+
+void vhd_uuid_from_string(vhd_uuid_t *uuid, const char *in)
+{
+	uuid_parse(in, uuid->uuid);
+}
+
+void vhd_uuid_copy(vhd_uuid_t *dst, vhd_uuid_t *src)
+{
+	uuid_copy(dst->uuid, src->uuid);
+}
+
+void vhd_uuid_clear(vhd_uuid_t *uuid)
+{
+	uuid_clear(uuid->uuid);
+}
+
+int vhd_uuid_compare(vhd_uuid_t *uuid1, vhd_uuid_t *uuid2)
+{
+	return uuid_compare(uuid1->uuid, uuid2->uuid);
+}
+
+#elif defined(__NetBSD__)
+
+#include <uuid.h>
+#include <string.h>
+#include <stdlib.h>
+
+typedef uuid_t vhd_uuid_t;
+
+int vhd_uuid_is_nil(vhd_uuid_t *uuid)
+{
+	uint32_t status;
+	return uuid_is_nil((uuid_t *)uuid, &status);
+}
+
+void vhd_uuid_generate(vhd_uuid_t *uuid)
+{
+	uint32_t status;
+	uuid_create((uuid_t *)uuid, &status);
+}
+
+void vhd_uuid_to_string(vhd_uuid_t *uuid, char *out, size_t size)
+{
+	uint32_t status;
+	char *_out = NULL;
+	uuid_to_string((uuid_t *)uuid, &_out, &status);
+	strlcpy(out, _out, size);
+	free(_out);
+}
+
+void vhd_uuid_from_string(vhd_uuid_t *uuid, const char *in)
+{
+	uint32_t status;
+	uuid_from_string(in, (uuid_t *)uuid, &status);
+}
+
+void vhd_uuid_copy(vhd_uuid_t *dst, vhd_uuid_t *src)
+{
+	memcpy((uuid_t *)dst, (uuid_t *)src, sizeof(uuid_t));
+}
+
+void vhd_uuid_clear(vhd_uuid_t *uuid)
+{
+	memset((uuid_t *)uuid, 0, sizeof(uuid_t));
+}
+
+int vhd_uuid_compare(vhd_uuid_t *uuid1, vhd_uuid_t *uuid2)
+{
+	uint32_t status;
+	return uuid_compare((uuid_t *)uuid1, (uuid_t *)uuid2, &status);
+}
+
+#else
+
+#error "Please update vhd-util-uuid.c for your OS"
+
+#endif
diff -Nur blktap2_oxt//vhd/lib/xattr.c blktap2_xen//vhd/lib/xattr.c
--- blktap2_oxt//vhd/lib/xattr.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/xattr.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,114 +0,0 @@
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-#include "xattr.h"
-
-#include <errno.h>
-#include <unistd.h>
-#include <string.h>
-#include <features.h>
-
-#ifndef ENOATTR
-# define ENOATTR ENODATA        /* No such attribute */
-#endif
-
-#if defined (__i386__)
-# define HAVE_XATTR_SYSCALLS 1
-# define __NR_fsetxattr		228
-# define __NR_fgetxattr		231
-#elif defined (__sparc__)
-# define HAVE_XATTR_SYSCALLS 1
-# define __NR_fsetxattr		171
-# define __NR_fgetxattr		177
-#elif defined (__ia64__)
-# define HAVE_XATTR_SYSCALLS 1
-# define __NR_fsetxattr		1219
-# define __NR_fgetxattr		1222
-#elif defined (__powerpc__)
-# define HAVE_XATTR_SYSCALLS 1
-# define __NR_fsetxattr		211
-# define __NR_fgetxattr		214
-#elif defined (__x86_64__)
-# define HAVE_XATTR_SYSCALLS 1
-# define __NR_fsetxattr		190
-# define __NR_fgetxattr		193
-#elif defined (__s390__)
-# define HAVE_XATTR_SYSCALLS 1
-# define __NR_fsetxattr		226
-# define __NR_fgetxattr		229
-#elif defined (__arm__)
-# define HAVE_XATTR_SYSCALLS 1
-# if defined(__ARM_EABI__) || defined(__thumb__)
-#  define __NR_SYSCALL_BASE 0
-# else
-#  define __NR_SYSCALL_BASE 0x900000
-# endif
-# define __NR_fsetxattr		(__NR_SYSCALL_BASE+228)
-# define __NR_fgetxattr		(__NR_SYSCALL_BASE+231)
-#elif defined (__mips64)
-# define HAVE_XATTR_SYSCALLS 1
-# ifdef __LP64__ /* mips64 using n64 ABI */
-#  define __NR_Linux 5000
-# else /* mips64 using n32 ABI */
-#  define __NR_Linux 6000
-# endif
-# define __NR_fsetxattr		(__NR_Linux + 182)
-# define __NR_fgetxattr		(__NR_Linux + 185)
-#elif defined (__mips__) /* mips32, or mips64 using o32 ABI */
-# define HAVE_XATTR_SYSCALLS 1
-# define __NR_Linux 4000
-# define __NR_fsetxattr		(__NR_Linux + 226)
-# define __NR_fgetxattr		(__NR_Linux + 229)
-#elif defined (__alpha__)
-# define HAVE_XATTR_SYSCALLS 1
-# define __NR_fsetxattr		384
-# define __NR_fgetxattr		387
-#elif defined (__mc68000__)
-# define HAVE_XATTR_SYSCALLS 1
-# define __NR_fsetxattr		225
-# define __NR_fgetxattr		228
-#else
-# warning "Extended attribute syscalls undefined for this architecture"
-# define HAVE_XATTR_SYSCALLS 0
-#endif
-
-#if HAVE_XATTR_SYSCALLS
-# define SYSCALL(args...)	syscall(args)
-#else
-# define SYSCALL(args...)	( errno = ENOSYS, -1 )
-#endif
-
-static ssize_t
-_fgetxattr(int fd, const char *name, void *value, size_t size)
-{
-	return SYSCALL(__NR_fgetxattr, fd, name, value, size);
-}
-
-static int
-_fsetxattr(int fd, const char *name, const void *value, size_t size, int flags)
-{
-	return SYSCALL(__NR_fsetxattr, fd, name, value, size, flags);
-}
-
-int
-xattr_get(int fd, const char *name, void *value, size_t size)
-{
-	if (_fgetxattr(fd, name, value, size) == -1) {
-		if (errno == ENOATTR) {
-			memset(value, 0, size);
-			return 0;
-		}
-		return -errno;
-	}
-
-	return 0;
-}
-
-int
-xattr_set(int fd, const char *name, const void *value, size_t size)
-{
-	if (_fsetxattr(fd, name, value, size, 0) == -1)
-		return -errno;
-	return 0;
-}
diff -Nur blktap2_oxt//vhd/lib/xattr.h blktap2_xen//vhd/lib/xattr.h
--- blktap2_oxt//vhd/lib/xattr.h	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/lib/xattr.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,16 +0,0 @@
-/*
- * Copyright (c) 2010 Citrix Systems, Inc.
- */
-
-#ifndef VHD_XATTR_H
-#define VHD_XATTR_H
-
-#include <sys/types.h>
-
-#define VHD_XATTR_MARKER  "user.com.citrix.xenclient.backend.marker"
-#define VHD_XATTR_KEYHASH "user.com.citrix.xenclient.backend.keyhash"
-
-int xattr_get(int, const char *, void *, size_t);
-int xattr_set(int, const char *, const void *, size_t);
-
-#endif
diff -Nur blktap2_oxt//vhd/Makefile blktap2_xen//vhd/Makefile
--- blktap2_oxt//vhd/Makefile	2016-03-14 14:24:58.168021126 -0400
+++ blktap2_xen//vhd/Makefile	2015-03-19 11:08:36.000000000 -0400
@@ -1,56 +1,49 @@
-#
-# Copyright (c) 2012 Citrix Systems, Inc.
-#
+XEN_ROOT=$(CURDIR)/../../..
+BLKTAP_ROOT := ..
+include $(XEN_ROOT)/tools/Rules.mk
 
-BLKTAP_ROOT := ../
-include $(BLKTAP_ROOT)/Rules.mk
+SUBDIRS-y         :=
+SUBDIRS-y         += lib
 
-IBIN               = vhd-util vhd-index vhd-update
-INST_DIR           = /usr/sbin
+IBIN               = vhd-util vhd-update
+INST_DIR           = $(SBINDIR)
 
-CFLAGS            += -Wall
 CFLAGS            += -Werror
 CFLAGS            += -Wno-unused
 CFLAGS            += -I../include
 CFLAGS            += -D_GNU_SOURCE
 
+ifeq ($(CONFIG_X86_64),y)
+CFLAGS            += -fPIC
+endif
+
 ifeq ($(VHD_STATIC),y)
 CFLAGS            += -static
 endif
 
-LIBS              := -Llib -lvhd -licbinn_resolved -ldl -lpthread
-LIBS              += -luuid -lcrypto
-
-# Get gcc to generate the dependencies for us.
-CFLAGS            += -Wp,-MD,.$(@F).d
-DEPS               = .*.d
-
-all: build
+LIBS              := -Llib -lvhd
 
-build: libvhd $(IBIN)
+all: subdirs-all build
 
-libvhd:
-	@set -e
-	$(MAKE) -C lib all
+build: $(IBIN)
 
-vhd-util: vhd-util.o
-	$(CC) $(CFLAGS) -o vhd-util vhd-util.o $(LIBS)
+LIBS_DEPENDS	  := lib/libvhd.so lib/vhd.a
+$(LIBS_DEPENDS):subdirs-all
 
-vhd-index: vhd-index.o
-	$(CC) $(CFLAGS) -o vhd-index vhd-index.o $(LIBS)
+vhd-util: vhd-util.o $(LIBS_DEPENDS)
+	$(CC) $(LDFLAGS) -o vhd-util vhd-util.o $(LIBS)
 
-vhd-update: vhd-update.o
-	$(CC) $(CFLAGS) -o vhd-update vhd-update.o $(LIBS)
+vhd-update: vhd-update.o $(LIBS_DEPENDS)
+	$(CC) $(LDFLAGS) -o vhd-update vhd-update.o $(LIBS)
 
 install: all
-	$(MAKE) -C lib install
+	$(MAKE) subdirs-install
 	$(INSTALL_DIR) -p $(DESTDIR)$(INST_DIR)
 	$(INSTALL_PROG) $(IBIN) $(DESTDIR)$(INST_DIR)
 
-clean:
-	$(MAKE) -C lib clean
+clean: subdirs-clean
 	rm -rf *.o *~ $(DEPS) $(IBIN)
 
-.PHONY: all build clean install libvhd
+.PHONY: all build clean install vhd-util vhd-update
 
 -include $(DEPS)
diff -Nur blktap2_oxt//vhd/vhd-index.c blktap2_xen//vhd/vhd-index.c
--- blktap2_oxt//vhd/vhd-index.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/vhd-index.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,1008 +0,0 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of XenSource Inc. nor the names of its contributors
- *       may be used to endorse or promote products derived from this software
- *       without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <stdio.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-
-#include "libvhd.h"
-#include "libvhd-index.h"
-
-static void
-usage(void)
-{
-	printf("usage: vhd-index <command>\n"
-	       "commands:\n"
-	       "\t   index: <-i index name> <-v vhd file>\n"
-	       "\t summary: <-s index name> [-v vhd file [-b block]]\n");
-	exit(-EINVAL);
-}
-
-typedef struct vhdi_name              vhdi_name_t;
-
-struct vhdi_name {
-	char                         *vhd;
-	char                         *bat;
-
-	char                         *base;
-	char                         *index;
-	char                         *files;
-};
-
-static int
-vhd_index_get_name(const char *index, const char *vhd, vhdi_name_t *name)
-{
-	int err, len;
-
-	memset(name, 0, sizeof(vhdi_name_t));
-
-	len = strnlen(index, VHD_MAX_NAME_LEN);
-	if (len + 5 >= VHD_MAX_NAME_LEN - 1)
-		return -ENAMETOOLONG;
-
-	if (vhd) {
-		len = strnlen(vhd, VHD_MAX_NAME_LEN);
-		if (len >= VHD_MAX_NAME_LEN - 1)
-			return -ENAMETOOLONG;
-
-		err = asprintf(&name->vhd, "%s", vhd);
-		if (err == -1) {
-			name->vhd = NULL;
-			goto fail;
-		}
-
-		err = asprintf(&name->bat, "%s.bat", vhd);
-		if (err == -1) {
-			name->bat = NULL;
-			goto fail;
-		}
-	}
-
-	err = asprintf(&name->base, "%s", index);
-	if (err == -1) {
-		name->base = NULL;
-		goto fail;
-	}
-
-	err = asprintf(&name->index, "%s.index", index);
-	if (err == -1) {
-		name->index = NULL;
-		goto fail;
-	}
-
-	err = asprintf(&name->files, "%s.files", index);
-	if (err == -1) {
-		name->files = NULL;
-		goto fail;
-	}
-
-	return 0;
-
-fail:
-	free(name->vhd);
-	free(name->bat);
-	free(name->base);
-	free(name->index);
-	free(name->files);
-
-	return -ENOMEM;
-}
-
-static inline void
-vhd_index_free_name(vhdi_name_t *name)
-{
-	free(name->vhd);
-	free(name->bat);
-	free(name->base);
-	free(name->index);
-	free(name->files);
-}
-
-static inline int
-vhd_index_add_file_table_entry(vhdi_name_t *name, const char *file,
-			       vhdi_file_table_t *files, vhdi_file_id_t *fid)
-{
-	int err;
-
-	vhdi_file_table_free(files);
-
-	err = vhdi_file_table_add(name->files, file, fid);
-	if (err)
-		return err;
-
-	return vhdi_file_table_load(name->files, files);
-}
-
-static inline int
-vhd_index_get_file_id(vhdi_name_t *name, const char *file,
-		      vhdi_file_table_t *files, vhdi_file_id_t *fid)
-{
-	int i;
-	char *path;
-
-	path = realpath(file, NULL);
-	if (!path)
-		return -errno;
-
-	for (i = 0; i < files->entries; i++)
-		if (!strcmp(files->table[i].path, path)) {
-			*fid = files->table[i].file_id;
-			free(path);
-			return 0;
-		}
-
-	free(path);
-	return vhd_index_add_file_table_entry(name, file, files, fid);
-}
-
-static inline int
-vhd_index_get_block(vhdi_context_t *vhdi, vhd_context_t *vhd,
-		    uint32_t block, vhdi_block_t *vhdi_block)
-{
-	int i;
-
-	if (block)
-		return vhdi_read_block(vhdi, vhdi_block, block);
-
-	vhdi_block->entries = vhd->spb;
-	vhdi_block->table   = calloc(vhd->spb, sizeof(vhdi_entry_t));
-	if (!vhdi_block->table)
-		return -ENOMEM;
-
-	for (i = 0; i < vhdi_block->entries; i++)
-		vhdi_block->table[i].offset = DD_BLK_UNUSED;
-
-	return 0;
-}
-
-static int
-vhd_index_add_bat_entry(vhdi_name_t *name, vhdi_context_t *vhdi,
-			vhdi_bat_t *bat, vhdi_file_table_t *files,
-			vhd_context_t *vhd, uint32_t block, char *finished)
-{
-	char *map;
-	vhdi_file_id_t fid;
-	uint32_t i, count, off;
-	vhdi_block_t vhdi_block;
-	int err, update, append;
-
-	fid    = 0;
-	count  = 0;
-	update = 0;
-	append = (bat->table[block] == 0);
-
-	if (vhd->bat.bat[block] == DD_BLK_UNUSED)
-		return 0;
-
-	err = vhd_index_get_block(vhdi, vhd, bat->table[block], &vhdi_block);
-	if (err)
-		return err;
-
-	err = vhd_read_bitmap(vhd, block, &map);
-	if (err)
-		goto out;
-
-	err = vhd_index_get_file_id(name, vhd->file, files, &fid);
-	if (err)
-		goto out;
-
-	for (i = 0; i < vhd->spb; i++) {
-		if (vhdi_block.table[i].file_id) {
-			count++;
-			continue;
-		}
-
-		if (!vhd_bitmap_test(vhd, map, i))
-			continue;
-
-		err = vhd_offset(vhd, (uint64_t)block * vhd->spb + i, &off);
-		if (err)
-			goto out;
-
-		vhdi_block.table[i].file_id = fid;
-		vhdi_block.table[i].offset  = off;
-		count++;
-		update++;
-	}
-
-	if (update) {
-		if (append) {
-			uint32_t location;
-
-			err = vhdi_append_block(vhdi, &vhdi_block, &location);
-			if (err)
-				goto out;
-
-			bat->table[block] = location;
-		} else {
-			err = vhdi_write_block(vhdi, &vhdi_block,
-					       bat->table[block]);
-			if (err)
-				goto out;
-		}
-	}
-
-	if (count == vhd->spb)
-		*finished = 1;
-
-	err = 0;
-
-out:
-	free(vhdi_block.table);
-	free(map);
-
-	return err;
-}
-
-static int
-vhd_index_clone_bat_entry(vhdi_name_t *name, vhdi_context_t *vhdi,
-			  vhdi_bat_t *bat, vhdi_file_table_t *files,
-			  vhd_context_t *vhd, uint32_t block)
-{
-	char *map;
-	int err, update;
-	uint32_t i, off;
-	vhdi_file_id_t fid;
-	vhdi_block_t vhdi_block;
-
-	fid    = 0;
-	update = 0;
-
-	if (vhd->bat.bat[block] == DD_BLK_UNUSED)
-		return 0;
-
-	err = vhd_index_get_block(vhdi, vhd, bat->table[block], &vhdi_block);
-	if (err)
-		return err;
-
-	err = vhd_read_bitmap(vhd, block, &map);
-	if (err)
-		goto out;
-
-	err = vhd_index_get_file_id(name, vhd->file, files, &fid);
-	if (err)
-		goto out;
-
-	for (i = 0; i < vhd->spb; i++) {
-		if (!vhd_bitmap_test(vhd, map, i))
-			continue;
-
-		err = vhd_offset(vhd, (uint64_t)block * vhd->spb + i, &off);
-		if (err)
-			goto out;
-
-		vhdi_block.table[i].file_id = fid;
-		vhdi_block.table[i].offset  = off;
-		update++;
-	}
-
-	if (update) {
-		uint32_t location;
-
-		err = vhdi_append_block(vhdi, &vhdi_block, &location);
-		if (err)
-			goto out;
-
-		bat->table[block] = location;
-	}
-
-	err = 0;
-
-out:
-	free(vhdi_block.table);
-	free(map);
-
-	return err;
-}
-
-static int
-vhd_index_update_bat_entry(vhdi_name_t *name, vhdi_context_t *vhdi,
-			   vhdi_bat_t *bat, vhdi_file_table_t *files,
-			   vhd_context_t *vhd, uint32_t block)
-{
-	char *map;
-	int err, update;
-	uint32_t i, off;
-	vhdi_file_id_t fid;
-	vhdi_block_t vhdi_block;
-
-	fid    = 0;
-	update = 0;
-
-	if (vhd->bat.bat[block] == DD_BLK_UNUSED)
-		return 0;
-
-	err = vhd_index_get_block(vhdi, vhd, bat->table[block], &vhdi_block);
-	if (err)
-		return err;
-
-	err = vhd_read_bitmap(vhd, block, &map);
-	if (err)
-		goto out;
-
-	err = vhd_index_get_file_id(name, vhd->file, files, &fid);
-	if (err)
-		goto out;
-
-	for (i = 0; i < vhd->spb; i++) {
-		if (!vhd_bitmap_test(vhd, map, i))
-			continue;
-
-		err = vhd_offset(vhd, (uint64_t)block * vhd->spb + i, &off);
-		if (err)
-			goto out;
-
-		if (vhdi_block.table[i].file_id == fid &&
-		    vhdi_block.table[i].offset  == off)
-			continue;
-
-		vhdi_block.table[i].file_id = fid;
-		vhdi_block.table[i].offset  = off;
-		update++;
-	}
-
-	if (update) {
-		uint32_t location;
-
-		err = vhdi_append_block(vhdi, &vhdi_block, &location);
-		if (err)
-			goto out;
-
-		bat->table[block] = location;
-	}
-
-	err = 0;
-
-out:
-	free(vhdi_block.table);
-	free(map);
-
-	return err;
-}
-
-static int
-vhd_index_add_bat(vhdi_name_t *name,
-		  uint64_t vhd_blocks, uint32_t vhd_block_size)
-{
-	int err;
-	vhdi_bat_t bat;
-	vhd_context_t vhd;
-	vhdi_context_t vhdi;
-	vhdi_file_table_t files;
-	char *vhd_file, *finished;
-	uint32_t block, remaining;
-
-	memset(&bat, 0, sizeof(vhdi_bat_t));
-	memset(&files, 0, sizeof(vhdi_file_table_t));
-
-	vhd_file           = NULL;
-	finished           = NULL;
-	bat.vhd_blocks     = vhd_blocks;
-	bat.vhd_block_size = vhd_block_size;
-
-	strcpy(bat.vhd_path, name->vhd);
-	strcpy(bat.index_path, name->index);
-	strcpy(bat.file_table_path, name->files);
-
-	err = vhdi_open(&vhdi, name->index, O_RDWR);
-	if (err)
-		return err;
-
-	err = vhdi_file_table_load(name->files, &files);
-	if (err) {
-		vhdi_close(&vhdi);
-		return err;
-	}
-
-	err = vhdi_bat_create(name->bat, name->vhd, name->index, name->files);
-	if (err)
-		goto out;
-
-	bat.table = calloc(vhd_blocks, sizeof(uint32_t));
-	if (!bat.table) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	vhd_file = strdup(name->vhd);
-	if (!vhd_file)
-		goto out;
-
-	remaining = vhd_blocks;
-	finished  = calloc(remaining, sizeof(char));
-	if (!finished) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	for (;;) {
-		err = vhd_open(&vhd, vhd_file, VHD_OPEN_RDONLY);
-		if (err)
-			goto out;
-
-		err = vhd_get_bat(&vhd);
-		if (err)
-			goto out_vhd;
-
-		for (block = 0; block < vhd.bat.entries; block++) {
-			if (finished[block])
-				continue;
-
-			err = vhd_index_add_bat_entry(name, &vhdi, &bat,
-						      &files, &vhd, block,
-						      &finished[block]);
-			if (err)
-				goto out_bat;
-
-			if (finished[block])
-				remaining--;
-		}
-
-		free(vhd_file);
-		vhd_file = NULL;
-
-		if (!remaining || vhd.footer.type != HD_TYPE_DIFF) {
-			vhd_put_bat(&vhd);
-			vhd_close(&vhd);
-			break;
-		}
-
-		err = vhd_parent_locator_get(&vhd, &vhd_file);
-		if (err)
-			goto out_bat;
-
-	out_bat:
-		vhd_put_bat(&vhd);
-	out_vhd:
-		vhd_close(&vhd);
-		if (err)
-			goto out;
-	} 
-
-	err = vhdi_bat_write(name->bat, &bat);
-	if (err)
-		goto out;
-
-	err = 0;
-
-out:
-	if (err)
-		unlink(name->bat);
-
-	vhdi_file_table_free(&files);
-	vhdi_close(&vhdi);
-	free(bat.table);
-	free(finished);
-	free(vhd_file);
-
-	return err;
-}
-
-static int
-vhd_index_clone_bat(vhdi_name_t *name, const char *parent)
-{
-	int err;
-	char *pbat;
-	uint32_t block;
-	vhdi_bat_t bat;
-	vhd_context_t vhd;
-	vhdi_context_t vhdi;
-	vhdi_file_table_t files;
-
-	memset(&bat, 0, sizeof(vhdi_bat_t));
-	memset(&files, 0, sizeof(vhdi_file_table_t));
-
-	err = asprintf(&pbat, "%s.bat", parent);
-	if (err == -1)
-		return -ENOMEM;
-
-	err = access(pbat, R_OK);
-	if (err == -1) {
-		free(pbat);
-		return -errno;
-	}
-
-	err = vhdi_open(&vhdi, name->index, O_RDWR);
-	if (err)
-		goto out;
-
-	err = vhdi_bat_load(pbat, &bat);
-	if (err)
-		goto out_vhdi;
-
-	err = vhdi_file_table_load(name->files, &files);
-	if (err)
-		goto out_vhdi;
-
-	err = vhdi_bat_create(name->bat, name->vhd, name->index, name->files);
-	if (err)
-		goto out_ft;
-
-	err = vhdi_bat_write(name->bat, &bat);
-	if (err)
-		goto out_ft;
-
-	err = vhd_open(&vhd, name->vhd, VHD_OPEN_RDONLY);
-	if (err)
-		goto out_ft;
-
-	err = vhd_get_bat(&vhd);
-	if (err)
-		goto out_vhd;
-
-	for (block = 0; block < vhd.bat.entries; block++) {
-		err = vhd_index_clone_bat_entry(name, &vhdi, &bat,
-						&files, &vhd, block);
-		if (err)
-			goto out_bat;
-	}
-
-	err = vhdi_bat_write(name->bat, &bat);
-	if (err)
-		goto out_bat;
-
-	err = 0;
-
-out_bat:
-	vhd_put_bat(&vhd);
-out_vhd:
-	vhd_close(&vhd);
-out_ft:
-	vhdi_file_table_free(&files);
-out_vhdi:
-	vhdi_close(&vhdi);
-out:
-	if (err)
-		unlink(name->bat);
-	free(bat.table);
-	free(pbat);
-	return err;
-}
-
-static int
-vhd_index_update_bat(vhdi_name_t *name)
-{
-	int err;
-	uint32_t block;
-	vhdi_bat_t bat;
-	vhd_context_t vhd;
-	vhdi_context_t vhdi;
-	vhdi_file_table_t files;
-
-	memset(&bat, 0, sizeof(vhdi_bat_t));
-	memset(&files, 0, sizeof(vhdi_file_table_t));
-
-	err = access(name->bat, R_OK);
-	if (err == -1)
-		return -errno;
-
-	err = vhdi_open(&vhdi, name->index, O_RDWR);
-	if (err)
-		goto out;
-
-	err = vhdi_bat_load(name->bat, &bat);
-	if (err)
-		goto out_vhdi;
-
-	err = vhdi_file_table_load(name->files, &files);
-	if (err)
-		goto out_vhdi;
-
-	err = vhd_open(&vhd, name->vhd, VHD_OPEN_RDONLY);
-	if (err)
-		goto out_ft;
-
-	err = vhd_get_bat(&vhd);
-	if (err)
-		goto out_bat;
-
-	for (block = 0; block < vhd.bat.entries; block++) {
-		err = vhd_index_update_bat_entry(name, &vhdi, &bat,
-						 &files, &vhd, block);
-		if (err)
-			goto out_bat;
-	}
-
-	err = vhdi_bat_write(name->bat, &bat);
-	if (err)
-		goto out_bat;
-
-	err = 0;
-
-out_bat:
-	vhd_put_bat(&vhd);
-	vhd_close(&vhd);
-out_ft:
-	vhdi_file_table_free(&files);
-out_vhdi:
-	vhdi_close(&vhdi);
-out:
-	free(bat.table);
-	return err;
-}
-
-static int
-vhd_index_create(vhdi_name_t *name)
-{
-	int err;
-	vhd_context_t ctx;
-	uint32_t block_size;
-
-	if (!access(name->index, F_OK) || !access(name->files, F_OK))
-		return -EEXIST;
-
-	err = vhd_open(&ctx, name->vhd, VHD_OPEN_RDONLY);
-	if (err)
-		return err;
-
-	err = vhd_get_header(&ctx);
-	if (err) {
-		vhd_close(&ctx);
-		return err;
-	}
-
-	block_size = ctx.header.block_size;
-	vhd_close(&ctx);
-
-	err = vhdi_create(name->index, block_size);
-	if (err)
-		goto out;
-
-	err = vhdi_file_table_create(name->files);
-	if (err)
-		goto out;
-
-	err = 0;
-
-out:
-	if (err) {
-		unlink(name->index);
-		unlink(name->files);
-	}
-
-	return err;
-}
-
-static int
-vhd_index(vhdi_name_t *name)
-{
-	char *parent;
-	vhd_context_t ctx;
-	uint64_t vhd_blocks;
-	uint32_t vhd_block_size;
-	int err, new_index, new_bat;
-
-	parent    = NULL;
-	new_bat   = 0;
-	new_index = 0;
-
-	/* find vhd's parent -- we only index read-only vhds */
-	err = vhd_open(&ctx, name->vhd, VHD_OPEN_RDONLY);
-	if (err)
-		return err;
-
-	err = vhd_parent_locator_get(&ctx, &parent);
-	vhd_close(&ctx);
-
-	if (err)
-		return err;
-
-	/* update name to point to parent */
-	free(name->vhd);
-	name->vhd = parent;
-	parent = NULL;
-
-	free(name->bat);
-	err = asprintf(&name->bat, "%s.bat", name->vhd);
-	if (err == -1) {
-		name->bat = NULL;
-		return -ENOMEM;
-	}
-
-	/* create index if it doesn't already exist */
-	err = access(name->index, R_OK | W_OK);
-	if (err == -1 && errno == ENOENT) {
-		new_index = 1;
-		err = vhd_index_create(name);
-	}
-
-	if (err)
-		return err;
-
-	/* get basic vhd info */
-	err = vhd_open(&ctx, name->vhd, VHD_OPEN_RDONLY);
-	if (err)
-		goto out;
-
-	err = vhd_get_header(&ctx);
-	if (err) {
-		vhd_close(&ctx);
-		goto out;
-	}
-
-	vhd_blocks     = ctx.header.max_bat_size;
-	vhd_block_size = ctx.header.block_size;
-
-	if (vhd_parent_locator_get(&ctx, &parent))
-		parent = NULL;
-
-	vhd_close(&ctx);
-
-	/* update existing bat if it exists */
-	err = vhd_index_update_bat(name);
-	if (err != -ENOENT)
-		goto out;
-
-	new_bat = 1;
-
-	if (parent) {
-		/* clone parent bat if it exists */
-		err = vhd_index_clone_bat(name, parent);
-		if (err != -ENOENT)
-			goto out;
-	}
-
-	/* create new bat from scratch */
-	err = vhd_index_add_bat(name, vhd_blocks, vhd_block_size);
-	if (err)
-		goto out;
-
-	err = 0;
-
-out:
-	if (err) {
-		if (new_bat)
-			unlink(name->bat);
-		if (new_index) {
-			unlink(name->index);
-			unlink(name->files);
-		}
-	}
-	free(parent);
-	return err;
-}
-
-static void
-vhd_index_print_summary(vhdi_name_t *name,
-			uint32_t block_size, vhdi_file_table_t *files)
-{
-	int i;
-	char time[26], uuid[37];
-
-	printf("VHD INDEX          : %s\n", name->index);
-	printf("--------------------\n");
-	printf("block size         : %u\n", block_size);
-	printf("files              : %d\n", files->entries);
-
-	printf("\n");
-	for (i = 0; i < files->entries; i++) {
-		uuid_unparse(files->table[i].vhd_uuid, uuid);
-		vhd_time_to_string(files->table[i].vhd_timestamp, time);
-
-		printf("        fid 0x%04x : %s, %s, %s\n",
-		       files->table[i].file_id, files->table[i].path, uuid, time);
-	}
-
-	printf("\n");
-}
-
-static inline void
-vhd_index_print_bat_header(const char *name, vhdi_bat_t *bat)
-{
-	printf("VHD INDEX BAT      : %s\n", name);
-	printf("--------------------\n");
-	printf("blocks             : %"PRIu64"\n", bat->vhd_blocks);
-	printf("block size         : %u\n", bat->vhd_block_size);
-	printf("vhd path           : %s\n", bat->vhd_path);
-	printf("index path         : %s\n", bat->index_path);
-	printf("file table path    : %s\n", bat->file_table_path);
-}
-
-static int
-vhd_index_print_vhd_summary(vhdi_name_t *name)
-{
-	int err;
-	uint32_t i;
-	vhdi_bat_t bat;
-
-	err = vhdi_bat_load(name->bat, &bat);
-	if (err)
-		return err;
-
-	vhd_index_print_bat_header(name->bat, &bat);
-
-	printf("\n");
-	for (i = 0; i < bat.vhd_blocks; i++)
-		printf("      block 0x%04x : offset 0x%08x\n", i, bat.table[i]);
-
-	free(bat.table);
-	return 0;
-}
-
-static int
-vhd_index_print_vhd_block_summary(vhdi_name_t *name, uint32_t block)
-{
-	int err;
-	uint32_t i;
-	uint32_t off;
-	vhdi_bat_t bat;
-	vhdi_context_t vhdi;
-	vhdi_block_t vhdi_block;
-
-	err = vhdi_bat_load(name->bat, &bat);
-	if (err)
-		return err;
-
-	vhd_index_print_bat_header(name->bat, &bat);
-
-	if (block > bat.vhd_blocks) {
-		printf("block %u past end of bat (%"PRIu64")\n",
-		       block, bat.vhd_blocks);
-		err = -EINVAL;
-		goto out;
-	}
-
-	off = bat.table[block];
-	if (off == DD_BLK_UNUSED) {
-		printf("block %u is unallocated\n", block);
-		err = 0;
-		goto out;
-	}
-
-	err = vhdi_open(&vhdi, name->index, O_RDWR);
-	if (err)
-		goto out;
-
-	err = vhdi_read_block(&vhdi, &vhdi_block, off);
-	vhdi_close(&vhdi);
-	if (err)
-		goto out;
-
-	printf("\nBLOCK 0x%08x\n", block);
-	for (i = 0; i < vhdi_block.entries; i++)
-		printf("        sec 0x%04x : fid 0x%04x, offset 0x%08x\n", i,
-		       vhdi_block.table[i].file_id,
-		       vhdi_block.table[i].offset);
-
-	free(vhdi_block.table);
-	err = 0;
-
-out:
-	free(bat.table);
-	return err;
-}
-
-static int
-vhd_index_summary(vhdi_name_t *name, uint32_t block)
-{
-	int err;
-	uint32_t block_size;
-	vhdi_context_t vhdi;
-	vhdi_file_table_t files;
-
-	err = vhdi_open(&vhdi, name->index, O_RDWR);
-	if (err)
-		return err;
-
-	block_size = vhdi.vhd_block_size;
-	vhdi_close(&vhdi);
-
-	err = vhdi_file_table_load(name->files, &files);
-	if (err)
-		return err;
-
-	vhd_index_print_summary(name, block_size, &files);
-
-	if (name->vhd) {
-		if (block == (uint32_t)-1)
-			err = vhd_index_print_vhd_summary(name);
-		else
-			err = vhd_index_print_vhd_block_summary(name, block);
-
-		if (err)
-			goto out;
-	}
-
-	err = 0;
-
-out:
-	vhdi_file_table_free(&files);
-	return err;
-}
-
-int
-main(int argc, char *argv[])
-{
-	int err;
-	uint32_t block;
-	vhdi_name_t name;
-	char *vhd, *index;
-	int c, update, summary;
-
-	vhd     = NULL;
-	index   = NULL;
-	block   = (uint32_t)-1;
-	update  = 0;
-	summary = 0;
-
-	while ((c = getopt(argc, argv, "i:v:s:b:h")) != -1) {
-		switch (c) {
-		case 'i':
-			index   = optarg;
-			update  = 1;
-			break;
-
-		case 'v':
-			vhd     = optarg;
-			break;
-
-		case 's':
-			index   = optarg;
-			summary = 1;
-			break;
-
-		case 'b':
-			block   = strtoul(optarg, NULL, 10);
-			break;
-
-		default:
-			usage();
-		}
-	}
-
-	if (optind != argc)
-		usage();
-
-	if (!(update ^ summary))
-		usage();
-
-	if (block != (uint32_t)-1 && (!summary || !vhd))
-		usage();
-
-	err = vhd_index_get_name(index, vhd, &name);
-	if (err)
-		goto out;
-
-	if (summary)
-		err = vhd_index_summary(&name, block);
-	else if (update) {
-		if (!vhd)
-			usage();
-
-		err = vhd_index(&name);
-	}
-
-out:
-	vhd_index_free_name(&name);
-	return -err;
-}
diff -Nur blktap2_oxt//vhd/vhd-update.c blktap2_xen//vhd/vhd-update.c
--- blktap2_oxt//vhd/vhd-update.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/vhd-update.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2007, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,10 +23,8 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-* Before updating a VHD file, we create a journal consisting of:
+ *
+ * Before updating a VHD file, we create a journal consisting of:
  *   - all data at the beginning of the file, up to and including the BAT
  *   - each allocated bitmap (existing at the same offset in the journal as
  *                            its corresponding bitmap in the original file)
@@ -41,8 +36,6 @@
 #include <fcntl.h>
 #include <stdlib.h>
 #include <unistd.h>
-#include <endian.h>
-#include <byteswap.h>
 
 #include "atomicio.h"
 #include "libvhd.h"
diff -Nur blktap2_oxt//vhd/vhd-util.c blktap2_xen//vhd/vhd-util.c
--- blktap2_oxt//vhd/vhd-util.c	2016-03-14 14:24:58.172021126 -0400
+++ blktap2_xen//vhd/vhd-util.c	2015-03-19 11:08:36.000000000 -0400
@@ -1,7 +1,4 @@
-/*
- * Copyright (c) 2008, XenSource Inc.
- * Copyright (c) 2010, Citrix Systems, Inc.
- *
+/* Copyright (c) 2008, XenSource Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,8 +23,7 @@
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
+*/
 #include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -63,11 +59,6 @@
 	{ .name = "scan",        .func = vhd_util_scan          },
 	{ .name = "check",       .func = vhd_util_check         },
 	{ .name = "revert",      .func = vhd_util_revert        },
-	{ .name = "dm-encrypt",  .func = vhd_util_dm_encrypt    },
-	{ .name = "dm-decrypt",  .func = vhd_util_dm_decrypt    },
-	{ .name = "key",         .func = vhd_util_key           },
-	{ .name = "clone-metadata", .func = vhd_util_clone_metadata },
-	{ .name = "stream-coalesce", .func = vhd_util_stream_coalesce },
 };
 
 #define print_commands()					\
