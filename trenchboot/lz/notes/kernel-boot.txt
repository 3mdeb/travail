---- Linux Kernel Boot ----

The Linux boot process is rather complicated and has a lot of lagacy baggage
that it carries around. This is an attempt to collect some of that process
in one place. Note this is only concerned with x86 platforms.

First consider there are 4 ways of booting a Linux kernel:

1. Starting directly from real mode and jumping to the real mode boot sector.
2. Jumping to the 32b entry point(s) names startup_32 from a boot loader.
3. Jumping to the EFI stub code using the EFI Handover Protocol.
4. Mocking up a PE header and allowing EFI firmware to treat Linux as an
   EFI bootable image.

For Trenchboot purposes, we are primarily concerned with #2. A section later
on will give a few more details about #3 and #4.

-- Layout --

The Linux kernel starts out as the bzImage. This file has several section and
they are placed in different areas of memory. Consider the following memory
map fron the TBOOT project - it gives a pretty good view of the recommended
layout:

        |  Protected-mode kernel    |  The kernel protected-mode code.
100000  +---------------------------+
        |  I/O memory hole          |
0A0000  +---------------------------+
        |  Reserved for BIOS        |  Do not use.  Reserved for BIOS EBDA.
099100  +---------------------------+
        |  cmdline                  |
099000  +---------------------------+
        |  Stack/heap               |  For use by the kernel real-mode code.
098000  +---------------------------+
        |  Kernel setup             |  The kernel real-mode code.
090200  +---------------------------+
        |  Kernel boot sector       |  The kernel legacy boot sector.
090000  +---------------------------+
        |  Boot loader              |  <- Boot sector entry point 0000:7C00
001000  +---------------------------+
        |  Reserved for MBR/BIOS    |
000800  +---------------------------+
        |  Typically used by MBR    |
000600  +---------------------------+
        |  BIOS use only            |
000000  +---------------------------+

The first 64K of the bzImage is called the real mode boot sector and is copied
to 0x90000 (called Kernel boot sector here). The Boot loader is the real
mode entry point that jumps to the boot sector. The main part of the 32b or 64b
kernel is loaded at 0x100000 - The Protected-mode kernel. This is the bulk of
the bzImage.

-- Real Mode Boot Sector --

This area, also called the Zero Page is a strange item. I consists of what is
the Real-mode Kernel Header, a pile of other parameters call the Boot Params
(of which the Real-mode Header is part of) and 16b code. The following shows
this (look for **** THE REAL-MODE KERNEL HEADER):

https://www.kernel.org/doc/Documentation/x86/boot.txt

Everything from 0x1F1 to 0x200 (512 byte boundary) is the original header. At
512 bytes is where the Boot loader jump would take you. To allow extending the
header, the 2 byte jump field at 0x200 was added. This jumps over the header
extensions which offficially start at 0x200 and go to 0x268 as can be seen.
All the area before the header contains the Boot Params.

The code that forms the boot sector is in arch/x86/boot/head.S where the Real-
mode Kernel Header is laid out. The reset of the Boot Params are defined in
arch/x86/include/uapi/asm/bootparam.h. Their current status is discussed here:

https://github.com/torvalds/linux/blob/master/Documentation/x86/zero-page.txt

The values for the Boot Params and Real-mode Header are used regardless of
which of the modes of entry discussed above are used. The values are populated
in various:
 - Hard coded
 - Written by the boot loader program (for our purposes GRUB)
 - Written at build time by the utility program arch/x86/boot/tools/build
 - Written by code in the protected mode or EFI entry points.

-- Protected Mode Kernel --

This is the bulk of the kernel. It comes in two logical parts:
1. The protected mode uncompressed entry point code at the beginning
   of the image. These start at arch/x86/boot/compressed/head_32/64.S
2. The compressed payload (piggy) that the uncompressed part (#1) decompresses
   and relocates.

#1 part is basically the code in arch/x86/boot/compressed. The #2 method of
booting from the list above enters at startup_32 in protected mode with the
Boot Params address in %esi.

-- EFI --

As noted above (methods #3 and #4) are two ways of booting Linux as an EFI
binary.

#3 is the more straight forward approach. Again in the code in
arch/x86/boot/compressed/head_32/64.S, there are EFI entry points called
efi32_stub_entry and efi64_stub_entry. These entry points are setup in the
handover_offset of the Real-mode Kernel Header. See the "EFI HANDOVER PROTOCOL"
section in the link above for details. Note a 64b kernel can be entered through
either the 32b and 64b entry pointsi. The Linux kernel can be enntered by a
loader that understands the EFI Handover Protocol.

#4 is mutch more of a kludge. Basically part of the Boot Params area (starting
at offset 0x82) has enough of a PE header to trick EFI into thing this is a
PE COFF binary so it will attempt to load it. The entry point efi_pe_entry
is writtne into the PE header at the proper offset (commented w/
AddressOfEntryPoint). The Linux kernel can be entered directly by the EFI
Boot Manager code.

-- Build Tool --

The build tool mentioned above that is built from arch/x86/boot/tools/build.c
is used to fixup Real-Mode Kernel Header that is built into
arch/x86/boot/setup.bin and the Protected Mode Kernel binary which is
arch/x86/boot/compressed/vmlinux.bin. Both files are read as well as
arch/x86/boot/zoffset.h. The latter file is parsed to find the entry
point offsets. The EFI entry points discussed above are written into
setup.bin as well as some other values. The checksum is updated in vmlinux.bin
and then both are mashed together and written out as bzImage.

Some particulars:
 - update_pecoff_text() writes the efi_pe_entry value into [pe_header + 0x1c]
   (where pe_header is the offset of the PE header at 0x82 mentioned above).
 - efi_stub_entry_update() writes the efiXX_stub_entry value into offset
   0x268, the handover_offset.

-- GRUB --

Just a little bit on GRUB, specifically the Linux loader and the 32b relocator.
The Linux loader is in grub/grub-core/loader/i386/linux.c. This function
grub_cmd_linux() is called when a "kernel" entry is found in grub.cfg. This
routine does all the setup and then registers the callbacks to do the boot
here:

grub_loader_set (grub_linux_boot, grub_linux_unload,
                 0 /* set noreturn=0 in order to avoid grub_console_fini() */);

When Linux is booted, grub_linux_boot() is called. It does further setup and
calls grub_relocator32_boot(). This routine is in the relocator code in
grub/grub-core/loader/i386/relocator.c and uses grub_relocator32_start
in grub/grub-core/loader/i386/relocator32.S to do the final launch.
