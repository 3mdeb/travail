From fd34e5e8f21b273f57cfe898f2a6acf11931c821 Mon Sep 17 00:00:00 2001
From: Ross Philipson <ross.philipson@oracle.com>
Date: Mon, 10 Dec 2018 16:02:06 -0500
Subject: [PATCH 6/8] x86: Trenchboot kernel late boot stub

Signed-off-by: Ross Philipson <ross.philipson@oracle.com>
---
 arch/x86/kernel/Makefile     |   2 +-
 arch/x86/kernel/setup.c      |   5 ++
 arch/x86/kernel/trenchboot.c | 134 +++++++++++++++++++++++++++++++++++++++++++
 drivers/iommu/dmar.c         |   5 ++
 4 files changed, 145 insertions(+), 1 deletion(-)
 create mode 100644 arch/x86/kernel/trenchboot.c

diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index adb6e123fae1..e40951a1cafd 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -70,7 +70,7 @@ obj-$(CONFIG_X86_32)		+= tls.o
 obj-$(CONFIG_IA32_EMULATION)	+= tls.o
 obj-y				+= step.o
 obj-$(CONFIG_INTEL_TXT)		+= tboot.o
-obj-$(CONFIG_TRENCHBOOT_STUB)	+= early_sha1.o early_tpm.o
+obj-$(CONFIG_TRENCHBOOT_STUB)	+= early_sha1.o early_tpm.o trenchboot.o
 obj-$(CONFIG_ISA_DMA_API)	+= i8237.o
 obj-$(CONFIG_STACKTRACE)	+= stacktrace.o
 obj-y				+= cpu/
diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c
index b4866badb235..9feda4d81677 100644
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@ -117,6 +117,7 @@
 #include <asm/microcode.h>
 #include <asm/kaslr.h>
 #include <asm/unwind.h>
+#include <asm/trenchboot.h>
 
 /*
  * max_low_pfn_mapped: highest direct mapped pfn under 4GB
@@ -1218,6 +1219,10 @@ void __init setup_arch(char **cmdline_p)
 
 	tboot_probe();
 
+#ifdef CONFIG_TRENCHBOOT_STUB
+	tb_setup();
+#endif
+
 	map_vsyscall();
 
 	generic_apic_probe();
diff --git a/arch/x86/kernel/trenchboot.c b/arch/x86/kernel/trenchboot.c
new file mode 100644
index 000000000000..9935ba855bb3
--- /dev/null
+++ b/arch/x86/kernel/trenchboot.c
@@ -0,0 +1,134 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+#include <linux/init.h>
+#include <linux/linkage.h>
+#include <asm/segment.h>
+#include <asm/boot.h>
+#include <asm/msr.h>
+#include <asm/processor-flags.h>
+#include <asm/asm-offsets.h>
+#include <asm/sha1.h>
+#include <asm/tpm.h>
+#include <asm/bootparam.h>
+#include <asm/setup.h>
+#include <asm/trenchboot.h>
+
+/* This should be plenty of room */
+static u8 txt_dmar[PAGE_SIZE] __attribute__((aligned(16)));
+
+struct acpi_table_header *tb_get_dmar_table(struct acpi_table_header *dmar)
+{
+	if (memcmp(txt_dmar, "DMAR", 4))
+		return dmar;
+	return (struct acpi_table_header*)(&txt_dmar[0]);
+}
+
+static void tb_copy_dmar_table(void)
+{
+	void __iomem *heap;
+	void __iomem *sinit_mle_data;
+	u32 dmar_offset, dmar_size;
+
+	memset(&txt_dmar, 0, PAGE_SIZE);
+
+	heap = txt_get_heap();
+	if (unlikely(!heap)) {
+		/* TODO add TPM info log entry */
+		return;
+	}
+
+	sinit_mle_data = txt_sinit_mle_data_start(heap);
+	dmar_size = readl(sinit_mle_data + TXT_SINIT_MLE_DMAR_TABLE_SIZE);
+	dmar_offset = readl(sinit_mle_data + TXT_SINIT_MLE_DMAR_TABLE_OFFSET);
+
+	if (unlikely(dmar_size > PAGE_SIZE)) {
+		/* TODO add TPM info log entry */
+		return;
+	}
+
+	memcpy(txt_dmar, (void*)(sinit_mle_data + dmar_offset), dmar_size);
+}
+
+void tb_setup_intel(void)
+{
+	/* On Intel, have to handle TPM localities via TXT */
+	txt_write_reg(TXTCR_CMD_SECRETS, 0x1, 0);
+	(void)txt_read_reg(TXTCR_E2STS, 0);
+	txt_write_reg(TXTCR_CMD_OPEN_LOCALITY1, 0x1, 0);
+	(void)txt_read_reg(TXTCR_E2STS, 0);
+
+	/* Make a copy of the TXT heap provided DMAR to pass on later */
+	tb_copy_dmar_table();
+
+	/* TODO validate the PMRs */
+}
+
+void tb_setup_amd(void)
+{
+	/* TODO validate the DEV tables and devices */
+}
+
+void tb_update_tpm(void)
+{
+	struct sha1_state sctx = {0};
+	u8 sha1_hash[SHA1_DIGEST_SIZE];
+	struct tpm_digest extend = {
+		.pcr = 18,
+	};
+
+	memset(sha1_hash, 0, SHA1_DIGEST_SIZE);
+
+	tis_init();
+	tis_request_locality(2);
+
+	/* Hash the zero page/boot params */
+	early_sha1_init(&sctx);
+	early_sha1_update(&sctx, (u8*)&boot_params, sizeof(struct boot_params));
+	early_sha1_finalize(&sctx);
+	early_sha1_finish(&sctx, &sha1_hash[0]);
+	memcpy(&extend.digest.sha1.digest[0], &sha1_hash[0], SHA1_DIGEST_SIZE);
+	tpm_pcr_extend(&extend);
+
+	memset(sha1_hash, 0, SHA1_DIGEST_SIZE);
+
+	/* Hash the command line */
+	early_sha1_init(&sctx);
+	early_sha1_update(&sctx, (u8*)boot_command_line, boot_params.hdr.cmdline_size);
+	early_sha1_finalize(&sctx);
+	early_sha1_finish(&sctx, &sha1_hash[0]);
+	memcpy(&extend.digest.sha1.digest[0], &sha1_hash[0], SHA1_DIGEST_SIZE);
+	tpm_pcr_extend(&extend);
+
+	/* tis_init will ensure all localities are closed */
+	tis_init();
+
+	tis_free();
+}
+
+void tb_setup(void)
+{
+	BUG_ON(!(boot_params.trenchboot_info.tb_flags & TB_FLAG_ACTIVE));
+
+	/* First update TPM with boot params and commmand line */
+	tb_update_tpm();
+
+	if (boot_params.trenchboot_info.tb_flags & TB_FLAG_ARCH_TXT)
+		tb_setup_intel();
+	else if (boot_params.trenchboot_info.tb_flags & TB_FLAG_ARCH_SKINIT)
+		tb_setup_amd();
+	else
+		BUG();
+}
diff --git a/drivers/iommu/dmar.c b/drivers/iommu/dmar.c
index d9c748b6f9e4..723efdf04b49 100644
--- a/drivers/iommu/dmar.c
+++ b/drivers/iommu/dmar.c
@@ -41,6 +41,7 @@
 #include <linux/iommu.h>
 #include <asm/irq_remapping.h>
 #include <asm/iommu_table.h>
+#include <asm/trenchboot.h>
 
 #include "irq_remapping.h"
 
@@ -632,7 +633,11 @@ parse_dmar_table(void)
 	 * ACPI tables may not be DMA protected by tboot, so use DMAR copy
 	 * SINIT saved in SinitMleData in TXT heap (which is DMA protected)
 	 */
+#ifdef CONFIG_TRENCHBOOT_STUB
+	dmar_tbl = tb_get_dmar_table(dmar_tbl);
+#else
 	dmar_tbl = tboot_get_dmar_table(dmar_tbl);
+#endif
 
 	dmar = (struct acpi_table_dmar *)dmar_tbl;
 	if (!dmar)
-- 
2.13.6

