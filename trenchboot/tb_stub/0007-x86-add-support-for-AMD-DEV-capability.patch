From 6b31063e67336fb656fea798c25e0c8a2fe49543 Mon Sep 17 00:00:00 2001
From: "Daniel P. Smith" <dpsmith@apertussolutions.com>
Date: Fri, 19 Oct 2018 08:59:16 -0400
Subject: [PATCH 7/8] x86: add support for AMD DEV capability

AMD provides the Device Exclusion Vector as part of the AMD-V specification that
allows page level memory access to HyperTransport buses.

Signed-off-by: Daniel P. Smith <dpsmith@apertussolutions.com>
---
 arch/x86/Kconfig               |   5 ++
 arch/x86/include/asm/amd_dev.h |  50 +++++++++++++
 arch/x86/kernel/Makefile       |   2 +
 arch/x86/kernel/amd_dev.c      | 159 +++++++++++++++++++++++++++++++++++++++++
 arch/x86/realmode/init.c       |  10 +++
 5 files changed, 226 insertions(+)
 create mode 100644 arch/x86/include/asm/amd_dev.h
 create mode 100644 arch/x86/kernel/amd_dev.c

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 83b4892e0b15..1b5a91d51726 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -1956,6 +1956,7 @@ config EFI_MIXED
 config TRENCHBOOT_STUB
 	bool "Trenchboot stub support"
 	depends on X86_64
+	select AMD_DEV
 	---help---
 	  This kernel feature allows a bzImage to be loaded directly
 	  through Intel TXT or AMD SKINIT measured launch.
@@ -2827,6 +2828,10 @@ config AMD_NB
 	def_bool y
 	depends on CPU_SUP_AMD && PCI
 
+config AMD_DEV
+	def_bool y
+	depends on CPU_SUP_AMD && PCI
+
 source "drivers/pcmcia/Kconfig"
 
 config RAPIDIO
diff --git a/arch/x86/include/asm/amd_dev.h b/arch/x86/include/asm/amd_dev.h
new file mode 100644
index 000000000000..46bd09968bac
--- /dev/null
+++ b/arch/x86/include/asm/amd_dev.h
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _ASM_X86_AMD_DEV_H
+#define _ASM_X86_AMD_DEV_H
+
+#include <linux/types.h>
+
+#define DEV_PCI_BUS                     0x0
+#define DEV_PCI_DEVICE                  0x18
+#define DEV_PCI_FUNCTION                0x3
+#define DEV_PCI_HDR                     0xF0
+#define DEV_PCI_OP                      0xF4
+#define DEV_PCI_DATA                    0xF8
+
+#define PCI_CAPABILITIES_ID_DEV         0x0F
+
+/* DEV Functions */
+#define DEV_BASE_LO                     0
+#define DEV_BASE_HI                     1
+#define DEV_MAP                         2
+#define DEV_CAP                         3
+#define DEV_CR                          4
+#define DEV_ERR_STATUS                  5
+#define DEV_ERR_ADDR_LO                 6
+#define DEV_ERR_ADDR_HI                 7
+
+/* Contrl Register  */
+#define DEV_CR_ENABLE_MASK              1<<0
+#define DEV_CR_MEM_CLR_MASK             1<<1
+#define DEV_CR_IOSP_EN_MASK             1<<2
+#define DEV_CR_MCE_EN_MASK              1<<3
+#define DEV_CR_INV_CACHE_MASK           1<<4
+#define DEV_CR_SL_DEV_EN_MASK           1<<5
+#define DEV_CR_WALK_PROBE_MASK          1<<6
+
+#define DEV_BASE_LO_VALID_MASK          1<<0
+#define DEV_BASE_LO_PROTECTED_MASK      1<<1
+#define DEV_BASE_LO_SET_SIZE(b,s)       (b & (s << 2))
+#define DEV_BASE_LO_ADDR_MASK           0xFFFFF000
+
+
+u32 amd_dev_locate(void);
+u8 amd_get_map_count(void);
+u8 amd_get_domain_count(void);
+void amd_dev_load_map(u8 domain, u8 size, u32 dev_bitmap_paddr);
+u32 amd_dev_fetch_map(u8 domain);
+u32 amd_dev_enable(u32 domain, u32 dev_bitmap_paddr);
+void amd_dev_flush_cache(void);
+int amd_dev_protect_pages(u32 domain, u32 start, u32 size, u32 map);
+
+#endif /* _ASM_X86_AMD_DEV_H */
diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index 45d567867ff2..b19dbe8dffd9 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -111,6 +111,8 @@ obj-$(CONFIG_APB_TIMER)		+= apb_timer.o
 obj-$(CONFIG_AMD_NB)		+= amd_nb.o
 obj-$(CONFIG_DEBUG_NMI_SELFTEST) += nmi_selftest.o
 
+obj-$(CONFIG_AMD_DEV)		+= amd_dev.o
+
 obj-$(CONFIG_KVM_GUEST)		+= kvm.o kvmclock.o
 obj-$(CONFIG_PARAVIRT)		+= paravirt.o paravirt_patch_$(BITS).o
 obj-$(CONFIG_PARAVIRT_SPINLOCKS)+= paravirt-spinlocks.o
diff --git a/arch/x86/kernel/amd_dev.c b/arch/x86/kernel/amd_dev.c
new file mode 100644
index 000000000000..726383ac5bb1
--- /dev/null
+++ b/arch/x86/kernel/amd_dev.c
@@ -0,0 +1,159 @@
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/pci.h>
+#include <linux/pfn.h>
+#include <asm/pci-direct.h>
+#include <asm/processor.h>
+#include <asm/amd_dev.h>
+
+static u32 dev_read(u8 func, u8 index)
+{
+	u32 dev_op = (func << 8) | (index);
+	u32 data;
+
+	write_pci_config(DEV_PCI_BUS, DEV_PCI_DEVICE, DEV_PCI_FUNCTION,
+			DEV_PCI_OP, dev_op);
+
+	data = read_pci_config(DEV_PCI_BUS, DEV_PCI_DEVICE, DEV_PCI_FUNCTION,
+			DEV_PCI_DATA);
+
+	return data;
+}
+
+static void dev_write(u8 func, u8 index, u32 val)
+{
+	u32 dev_op = (func << 8) | (index);
+
+	write_pci_config(DEV_PCI_BUS, DEV_PCI_DEVICE, DEV_PCI_FUNCTION,
+			DEV_PCI_OP, dev_op);
+
+	write_pci_config(DEV_PCI_BUS, DEV_PCI_DEVICE, DEV_PCI_FUNCTION,
+			DEV_PCI_DATA, val);
+}
+
+u32 amd_dev_locate(void)
+{
+	u32 dev_cap_hdr;
+
+	/* read capabilities pointer */
+	dev_cap_hdr = read_pci_config(DEV_PCI_BUS, DEV_PCI_DEVICE,
+			DEV_PCI_FUNCTION, DEV_PCI_HDR);
+
+	if ( (dev_cap_hdr & 0xFF) != PCI_CAPABILITIES_ID_DEV)
+		return 0;
+
+	return dev_cap_hdr;
+}
+
+u8 amd_get_map_count(void)
+{
+	u32 cap_reg;
+
+	cap_reg = dev_read(DEV_CAP, 0);
+
+	return (u8)((cap_reg >> 16) & 0xFF);
+}
+
+u8 amd_get_domain_count(void)
+{
+	u32 cap_reg;
+
+	cap_reg = dev_read(DEV_CAP, 0);
+
+	return (u8)((cap_reg >> 8) & 0xFF);
+}
+
+void amd_dev_load_map(u8 domain, u8 size, u32 dev_bitmap_paddr)
+{
+	u32 dev_base_hi = 0;
+	u32 dev_base_low = 0;
+	u8 fields;
+
+	fields = ((size << 2) & 0x7c);
+	fields |= DEV_BASE_LO_VALID_MASK;
+
+	dev_base_low = dev_bitmap_paddr & DEV_BASE_LO_ADDR_MASK;
+	dev_base_low |= fields;
+
+	dev_write(DEV_BASE_HI, domain, dev_base_hi);
+	dev_write(DEV_BASE_LO, domain, dev_base_low);
+}
+
+u32 amd_dev_fetch_map(u8 domain)
+{
+	u32 dev_base_hi = 0;
+	u32 dev_base_low = 0;
+
+	dev_base_hi = dev_read(DEV_BASE_HI, domain);
+	dev_base_low = dev_read(DEV_BASE_LO, domain);
+
+	dev_base_low &= DEV_BASE_LO_ADDR_MASK;
+
+	return dev_base_low;
+}
+
+u32 amd_dev_enable(u32 domain, u32 dev_bitmap_paddr)
+{
+	u32 dev_cr;
+
+	/* enable DEV protections */
+	dev_cr = (DEV_CR_ENABLE_MASK | DEV_CR_IOSP_EN_MASK |
+			DEV_CR_SL_DEV_EN_MASK);
+
+	dev_write(DEV_CR, 0, dev_cr);
+
+	return 0;
+}
+
+void amd_dev_flush_cache(void)
+{
+	u32 dev_cr;
+
+	dev_cr = dev_read(DEV_CR, 0);
+	dev_cr |= (DEV_CR_INV_CACHE_MASK | DEV_CR_ENABLE_MASK);
+	dev_write(DEV_CR, 0, dev_cr);
+
+	/* TODO: extend loop with timeout to prohibit infinite loop */
+	while (dev_cr && DEV_CR_INV_CACHE_MASK)
+                dev_cr = dev_read(DEV_CR, 0);
+}
+
+
+int amd_dev_protect_pages(u32 domain, u32 start, u32 size, u32 map)
+{
+	u32 dev_map;
+	u32 pfn, end_pfn;
+	int err;
+
+	if (boot_cpu_data.x86_vendor != X86_VENDOR_AMD)
+		return 0;
+
+	if (map == 0) {
+		dev_map = amd_dev_fetch_map(domain);
+		if (dev_map == 0) {
+			err = -ENODEV;
+			goto out;
+		}
+	} else {
+		dev_map = map;
+	}
+
+	pfn = PHYS_PFN(start);
+	end_pfn = PHYS_PFN((start + size) & PAGE_MASK);
+
+	/* TODO: check end_pfn is not ouside of range of DEV map */
+
+	/* build protection bitmap */
+	for ( ; pfn <= end_pfn; pfn++) {
+		u32 byte, bit;
+		u8 *bit_vector = (u8*)(u64)dev_map;
+
+		byte= pfn / 8;
+		bit= pfn & 7;
+		bit_vector[byte] |= (1 << bit);
+	}
+
+out:
+	return err;
+}
diff --git a/arch/x86/realmode/init.c b/arch/x86/realmode/init.c
index d10105825d57..3b8207c5d46b 100644
--- a/arch/x86/realmode/init.c
+++ b/arch/x86/realmode/init.c
@@ -9,6 +9,11 @@
 #include <asm/realmode.h>
 #include <asm/tlbflush.h>
 
+#ifdef CONFIG_AMD_DEV
+#include <asm/setup.h>
+#include <asm/amd_dev.h>
+#endif
+
 struct real_mode_header *real_mode_header;
 u32 *trampoline_cr4_features;
 
@@ -42,6 +47,11 @@ void __init reserve_real_mode(void)
 	}
 
 	memblock_reserve(mem, size);
+#ifdef CONFIG_AMD_DEV
+	/* DEV protect this region before use*/
+	amd_dev_protect_pages(0, mem, size,
+			boot_params.trenchboot_info.tb_dev_map);
+#endif
 	set_real_mode_mem(mem, size);
 }
 
-- 
2.11.0

