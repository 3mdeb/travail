From 67d7e3f4554512cc72b6d4625cb609d0b87b0b61 Mon Sep 17 00:00:00 2001
From: "Daniel P. Smith" <dpsmith@apertussolutions.com>
Date: Fri, 19 Oct 2018 08:59:16 -0400
Subject: [PATCH 7/9] x86: Add support for AMD DEV capability

AMD provides the Device Exclusion Vector as part of the AMD-V specification that
allows page level memory access to HyperTransport buses.

Signed-off-by: Daniel P. Smith <dpsmith@apertussolutions.com>
---
 arch/x86/Kconfig               |   5 ++
 arch/x86/include/asm/amd_dev.h |  57 ++++++++++++++
 arch/x86/kernel/Makefile       |   2 +
 arch/x86/kernel/amd_dev.c      | 167 +++++++++++++++++++++++++++++++++++++++++
 arch/x86/realmode/init.c       |  27 +++++++
 5 files changed, 258 insertions(+)
 create mode 100644 arch/x86/include/asm/amd_dev.h
 create mode 100644 arch/x86/kernel/amd_dev.c

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index a017c7b3adf0..badcb1a38c17 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -1946,6 +1946,7 @@ config EFI_MIXED
 config SECURE_LAUNCH_STUB
 	bool "Secure Launch stub support"
 	depends on X86_64
+	select AMD_DEV
 	---help---
 	  This kernel feature allows a bzImage to be loaded directly
 	  through Intel TXT or AMD SKINIT measured launch.
@@ -2817,6 +2818,10 @@ config AMD_NB
 	def_bool y
 	depends on CPU_SUP_AMD && PCI
 
+config AMD_DEV
+	def_bool y
+	depends on CPU_SUP_AMD && PCI
+
 source "drivers/pcmcia/Kconfig"
 
 config RAPIDIO
diff --git a/arch/x86/include/asm/amd_dev.h b/arch/x86/include/asm/amd_dev.h
new file mode 100644
index 000000000000..0a994ae51dac
--- /dev/null
+++ b/arch/x86/include/asm/amd_dev.h
@@ -0,0 +1,57 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _ASM_X86_AMD_DEV_H
+#define _ASM_X86_AMD_DEV_H
+
+/*
+ * Copyright (c) 2019 Apertus Solutions, LLC
+ *
+ * Author(s):
+ * 	Daniel P. Smith <dpsmith@apertussolutions.com>
+ */
+
+#include <linux/types.h>
+
+#define DEV_PCI_BUS                     0x0
+#define DEV_PCI_DEVICE                  0x18
+#define DEV_PCI_FUNCTION                0x3
+#define DEV_PCI_HDR                     0xF0
+#define DEV_PCI_OP                      0xF4
+#define DEV_PCI_DATA                    0xF8
+
+#define PCI_CAPABILITIES_ID_DEV         0x0F
+
+/* DEV Functions */
+#define DEV_BASE_LO                     0
+#define DEV_BASE_HI                     1
+#define DEV_MAP                         2
+#define DEV_CAP                         3
+#define DEV_CR                          4
+#define DEV_ERR_STATUS                  5
+#define DEV_ERR_ADDR_LO                 6
+#define DEV_ERR_ADDR_HI                 7
+
+/* Contrl Register  */
+#define DEV_CR_ENABLE_MASK              1<<0
+#define DEV_CR_MEM_CLR_MASK             1<<1
+#define DEV_CR_IOSP_EN_MASK             1<<2
+#define DEV_CR_MCE_EN_MASK              1<<3
+#define DEV_CR_INV_CACHE_MASK           1<<4
+#define DEV_CR_SL_DEV_EN_MASK           1<<5
+#define DEV_CR_WALK_PROBE_MASK          1<<6
+
+#define DEV_BASE_LO_VALID_MASK          1<<0
+#define DEV_BASE_LO_PROTECTED_MASK      1<<1
+#define DEV_BASE_LO_SET_SIZE(b,s)       (b & (s << 2))
+#define DEV_BASE_LO_ADDR_MASK           0xFFFFF000
+
+
+u32 amd_dev_locate(void);
+u8 amd_get_map_count(void);
+u8 amd_get_domain_count(void);
+void amd_dev_load_map(u8 domain, u8 size, u32 dev_bitmap_paddr);
+u32 amd_dev_fetch_map(u8 domain);
+u32 amd_dev_enable(u32 domain, u32 dev_bitmap_paddr);
+void amd_dev_flush_cache(void);
+int amd_dev_protect_pages(u32 domain, u32 start, u32 size, u32 map);
+
+#endif /* _ASM_X86_AMD_DEV_H */
diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index 798a7dc44c83..d4cc0081d369 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -111,6 +111,8 @@ obj-$(CONFIG_APB_TIMER)		+= apb_timer.o
 obj-$(CONFIG_AMD_NB)		+= amd_nb.o
 obj-$(CONFIG_DEBUG_NMI_SELFTEST) += nmi_selftest.o
 
+obj-$(CONFIG_AMD_DEV)		+= amd_dev.o
+
 obj-$(CONFIG_KVM_GUEST)		+= kvm.o kvmclock.o
 obj-$(CONFIG_PARAVIRT)		+= paravirt.o paravirt_patch_$(BITS).o
 obj-$(CONFIG_PARAVIRT_SPINLOCKS)+= paravirt-spinlocks.o
diff --git a/arch/x86/kernel/amd_dev.c b/arch/x86/kernel/amd_dev.c
new file mode 100644
index 000000000000..2af6be0c8dad
--- /dev/null
+++ b/arch/x86/kernel/amd_dev.c
@@ -0,0 +1,167 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 Apertus Solutions, LLC
+ *
+ * Author(s):
+ *	Daniel P. Smith <dpsmith@apertussolutions.com>
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/pci.h>
+#include <linux/pfn.h>
+#include <asm/pci-direct.h>
+#include <asm/processor.h>
+#include <asm/amd_dev.h>
+
+static u32 dev_read(u8 func, u8 index)
+{
+	u32 dev_op = (func << 8) | (index);
+	u32 data;
+
+	write_pci_config(DEV_PCI_BUS, DEV_PCI_DEVICE, DEV_PCI_FUNCTION,
+			DEV_PCI_OP, dev_op);
+
+	data = read_pci_config(DEV_PCI_BUS, DEV_PCI_DEVICE, DEV_PCI_FUNCTION,
+			DEV_PCI_DATA);
+
+	return data;
+}
+
+static void dev_write(u8 func, u8 index, u32 val)
+{
+	u32 dev_op = (func << 8) | (index);
+
+	write_pci_config(DEV_PCI_BUS, DEV_PCI_DEVICE, DEV_PCI_FUNCTION,
+			DEV_PCI_OP, dev_op);
+
+	write_pci_config(DEV_PCI_BUS, DEV_PCI_DEVICE, DEV_PCI_FUNCTION,
+			DEV_PCI_DATA, val);
+}
+
+u32 amd_dev_locate(void)
+{
+	u32 dev_cap_hdr;
+
+	/* read capabilities pointer */
+	dev_cap_hdr = read_pci_config(DEV_PCI_BUS, DEV_PCI_DEVICE,
+			DEV_PCI_FUNCTION, DEV_PCI_HDR);
+
+	if ( (dev_cap_hdr & 0xFF) != PCI_CAPABILITIES_ID_DEV)
+		return 0;
+
+	return dev_cap_hdr;
+}
+
+u8 amd_get_map_count(void)
+{
+	u32 cap_reg;
+
+	cap_reg = dev_read(DEV_CAP, 0);
+
+	return (u8)((cap_reg >> 16) & 0xFF);
+}
+
+u8 amd_get_domain_count(void)
+{
+	u32 cap_reg;
+
+	cap_reg = dev_read(DEV_CAP, 0);
+
+	return (u8)((cap_reg >> 8) & 0xFF);
+}
+
+void amd_dev_load_map(u8 domain, u8 size, u32 dev_bitmap_paddr)
+{
+	u32 dev_base_hi = 0;
+	u32 dev_base_low = 0;
+	u8 fields;
+
+	fields = ((size << 2) & 0x7c);
+	fields |= DEV_BASE_LO_VALID_MASK;
+
+	dev_base_low = dev_bitmap_paddr & DEV_BASE_LO_ADDR_MASK;
+	dev_base_low |= fields;
+
+	dev_write(DEV_BASE_HI, domain, dev_base_hi);
+	dev_write(DEV_BASE_LO, domain, dev_base_low);
+}
+
+u32 amd_dev_fetch_map(u8 domain)
+{
+	u32 dev_base_hi = 0;
+	u32 dev_base_low = 0;
+
+	dev_base_hi = dev_read(DEV_BASE_HI, domain);
+	dev_base_low = dev_read(DEV_BASE_LO, domain);
+
+	dev_base_low &= DEV_BASE_LO_ADDR_MASK;
+
+	return dev_base_low;
+}
+
+u32 amd_dev_enable(u32 domain, u32 dev_bitmap_paddr)
+{
+	u32 dev_cr;
+
+	/* enable DEV protections */
+	dev_cr = (DEV_CR_ENABLE_MASK | DEV_CR_IOSP_EN_MASK |
+			DEV_CR_SL_DEV_EN_MASK);
+
+	dev_write(DEV_CR, 0, dev_cr);
+
+	return 0;
+}
+
+void amd_dev_flush_cache(void)
+{
+	u32 dev_cr;
+
+	dev_cr = dev_read(DEV_CR, 0);
+	dev_cr |= (DEV_CR_INV_CACHE_MASK | DEV_CR_ENABLE_MASK);
+	dev_write(DEV_CR, 0, dev_cr);
+
+	/* TODO: extend loop with timeout to prohibit infinite loop */
+	while (dev_cr && DEV_CR_INV_CACHE_MASK)
+                dev_cr = dev_read(DEV_CR, 0);
+}
+
+
+int amd_dev_protect_pages(u32 domain, u32 start, u32 size, u32 map)
+{
+	u32 dev_map;
+	u32 pfn, end_pfn;
+	int err;
+
+	if (boot_cpu_data.x86_vendor != X86_VENDOR_AMD)
+		return 0;
+
+	if (map == 0) {
+		dev_map = amd_dev_fetch_map(domain);
+		if (dev_map == 0) {
+			err = -ENODEV;
+			goto out;
+		}
+	} else {
+		dev_map = map;
+	}
+
+	pfn = PHYS_PFN(start);
+	end_pfn = PHYS_PFN((start + size) & PAGE_MASK);
+
+	/* TODO: check end_pfn is not ouside of range of DEV map */
+
+	/* build protection bitmap */
+	for ( ; pfn <= end_pfn; pfn++) {
+		u32 byte, bit;
+		u8 *bit_vector = (u8*)(u64)dev_map;
+
+		byte= pfn / 8;
+		bit= pfn & 7;
+		bit_vector[byte] |= (1 << bit);
+	}
+
+out:
+	return err;
+}
diff --git a/arch/x86/realmode/init.c b/arch/x86/realmode/init.c
index d10105825d57..b7f30a54e888 100644
--- a/arch/x86/realmode/init.c
+++ b/arch/x86/realmode/init.c
@@ -9,12 +9,36 @@
 #include <asm/realmode.h>
 #include <asm/tlbflush.h>
 
+#ifdef CONFIG_AMD_DEV
+#include <asm/setup.h>
+#include <asm/slaunch.h>
+#include <asm/amd_dev.h>
+#endif
+
 struct real_mode_header *real_mode_header;
 u32 *trampoline_cr4_features;
 
 /* Hold the pgd entry used on booting additional CPUs */
 pgd_t trampoline_pgd_entry;
 
+#ifdef CONFIG_AMD_DEV
+void __init setup_amd_dev(phys_addr_t mem, size_t size)
+{
+	void *lz;
+	void *dev_map;
+
+	/* Locate the dev map in the LZ */
+	lz = __va(boot_params.hdr.code32_start +
+		boot_params.hdr.slaunch_header +
+		SKINIT_LZ_OFFSET);
+	dev_map = __va((u64)(*(u32*)lz)) + SKINIT_DEV_MAP_OFFSET;
+
+	/* DEV protect this region before use*/
+	/* TODO the dev code needs to be fixed to use 64b addresses */
+	amd_dev_protect_pages(0, mem, size, (u32)(u64)dev_map);
+}
+#endif
+
 void __init set_real_mode_mem(phys_addr_t mem, size_t size)
 {
 	void *base = __va(mem);
@@ -42,6 +66,9 @@ void __init reserve_real_mode(void)
 	}
 
 	memblock_reserve(mem, size);
+#ifdef CONFIG_AMD_DEV
+	setup_amd_dev(mem, size);
+#endif
 	set_real_mode_mem(mem, size);
 }
 
-- 
2.13.6

