From dea3bbf300d0fa5b60e3d3e1892c7e606b6999db Mon Sep 17 00:00:00 2001
From: Ross Philipson <ross.philipson@oracle.com>
Date: Tue, 30 Oct 2018 14:44:38 -0400
Subject: [PATCH 2/8] x86: Trenchboot main header file

Signed-off-by: Ross Philipson <ross.philipson@oracle.com>
---
 arch/x86/include/asm/trenchboot.h | 202 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 202 insertions(+)
 create mode 100644 arch/x86/include/asm/trenchboot.h

diff --git a/arch/x86/include/asm/trenchboot.h b/arch/x86/include/asm/trenchboot.h
new file mode 100644
index 0000000..db7dcdf
--- /dev/null
+++ b/arch/x86/include/asm/trenchboot.h
@@ -0,0 +1,202 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+#ifndef _ASM_X86_TRENCHBOOT_H
+#define _ASM_X86_TRENCHBOOT_H
+
+#define __TB32_CS	0x0008
+#define __TB32_DS	0x0010
+
+#define CPU_AMD			1
+#define CPU_INTEL		2
+
+#define X86_GETSEC_SMCTRL	7
+#define X86_GETSEC_WAKEUP	8
+
+#define TXT_PUB_CONFIG_REGS_BASE	0xfed30000
+#define TXT_PRIV_CONFIG_REGS_BASE	0xfed20000
+#define TXT_NR_CONFIG_PAGES     ((TXT_PUB_CONFIG_REGS_BASE - \
+				  TXT_PRIV_CONFIG_REGS_BASE) >> PAGE_SHIFT)
+
+#define TXTCR_STS			0x0000
+#define TXTCR_ESTS			0x0008
+#define TXTCR_ERRORCODE			0x0030
+#define TXTCR_MLE_JOIN			0x0290
+#define TXTCR_HEAP_BASE			0x0300
+#define TXTCR_HEAP_SIZE			0x0308
+#define TXTCR_CMD_OPEN_LOCALITY1	0x0380
+#define TXTCR_CMD_CLOSE_LOCALITY1	0x0388
+#define TXTCR_CMD_OPEN_LOCALITY2	0x0390
+#define TXTCR_CMD_CLOSE_LOCALITY2	0x0398
+#define TXTCR_CMD_SECRETS		0x08e0
+#define TXTCR_E2STS			0x08f0
+
+#define TXT_CAP_RLP_WAKE_GETSEC		0x0000001
+#define TXT_CAP_RLP_WAKE_MONITOR	0x0000002
+
+#define TXT_MAX_EVENT_LOG_SIZE		5*4*1024   /* 4k*5 */
+
+#define TXT_OS_MLE_ZERO_PAGE_ADDR	0x0
+#define TXT_OS_MLE_EVENT_LOG_BUFFER	0x4
+#define TXT_OS_SINIT_CAPABILITIES	0x50
+#define TXT_SINIT_MLE_RLP_WAKEUP_ADDR	0x78
+#define TXT_SINIT_MLE_DMAR_TABLE_SIZE	0x88
+#define TXT_SINIT_MLE_DMAR_TABLE_OFFSET	0x8c
+
+#define TRENCHBOOT_INFO_OFFSET	0x0cc
+#define TB_FLAGS_OFFSET		0x4
+#define TB_XBI_OFFSET		0x8
+
+#define BP_CMD_LINE_PTR		0x228
+#define BP_CMDLINE_SIZE		0x238
+
+#define TB_FLAG_ACTIVE		0x00000001
+#define TB_FLAG_ARCH_SKINIT	0x00000002
+#define TB_FLAG_ARCH_TXT	0x00000004
+
+#ifndef __ASSEMBLY__
+
+struct txt_mle_join {
+	uint32_t	gdt_limit;
+	uint32_t	gdt_base;
+	uint32_t	seg_sel;               /* cs (ds, es, ss are seg_sel+8) */
+	uint32_t	entry_point;           /* phys addr */
+} __attribute__((packed));
+
+#include <asm/io.h>
+
+static inline u64 txt_read_reg(u32 reg, int pub)
+{
+	u64 val = ~0ULL;
+	void __iomem *addr;
+
+	addr = early_ioremap((pub ? TXT_PUB_CONFIG_REGS_BASE :
+			      TXT_PRIV_CONFIG_REGS_BASE),
+			     TXT_NR_CONFIG_PAGES * PAGE_SIZE);
+	if (!addr)
+		return val;
+
+	memcpy_fromio(&val, addr + reg, sizeof(u64));
+
+	early_iounmap(addr, TXT_NR_CONFIG_PAGES * PAGE_SIZE);
+	return val;
+}
+
+static inline void txt_write_reg(u32 reg, u64 val, int pub)
+{
+	void __iomem *addr;
+
+	addr = early_ioremap((pub ? TXT_PUB_CONFIG_REGS_BASE :
+			      TXT_PRIV_CONFIG_REGS_BASE),
+			     TXT_NR_CONFIG_PAGES * PAGE_SIZE);
+	if (addr) {
+		memcpy_toio(addr + reg, &val, sizeof(u64));
+		early_iounmap(addr, TXT_NR_CONFIG_PAGES * PAGE_SIZE);
+	}
+}
+
+static inline void __iomem *txt_get_heap(void)
+{
+	u64 base, size;
+
+	base = txt_read_reg(TXTCR_HEAP_BASE, 0);
+	size = txt_read_reg(TXTCR_HEAP_SIZE, 0);
+	if ((base == ~0ULL)||(size == ~0ULL))
+		return NULL;
+
+	return early_ioremap(base, size);
+}
+
+static inline void txt_put_heap(void __iomem *heap)
+{
+	u64 size;
+
+	size = txt_read_reg(TXTCR_HEAP_SIZE, 0);
+	if (size == ~0ULL)
+		return;
+
+	if (heap)
+		early_iounmap(heap, size);
+}
+
+static inline u64 txt_bios_data_size(void __iomem *heap)
+{
+	u64 val;
+
+	memcpy_fromio(&val, heap, sizeof(u64));
+	return val;
+}
+
+static inline void __iomem *txt_bios_data_start(void __iomem *heap)
+{
+	return heap + sizeof(u64);
+}
+
+static inline u64 txt_os_mle_data_size(void __iomem *heap)
+{
+	u64 val;
+
+	memcpy_fromio(&val, heap + txt_bios_data_size(heap), sizeof(u64));
+	return val;
+}
+
+static inline void __iomem *txt_os_mle_data_start(void __iomem *heap)
+{
+	return heap + txt_bios_data_size(heap) + sizeof(u64);
+}
+
+static inline u64 txt_os_sinit_data_size(void __iomem *heap)
+{
+	u64 val;
+
+	memcpy_fromio(&val, heap + txt_bios_data_size(heap) +
+			txt_os_mle_data_size(heap), sizeof(u64));
+	return val;
+}
+
+static inline void __iomem *txt_os_sinit_data_start(void __iomem *heap)
+{
+	return heap + txt_bios_data_size(heap) +
+		txt_os_mle_data_size(heap) + sizeof(u64);
+}
+
+static inline u64 txt_sinit_mle_data_size(void __iomem *heap)
+{
+	u64 val;
+
+	memcpy_fromio(&val, heap + txt_bios_data_size(heap) +
+			txt_os_mle_data_size(heap) +
+			txt_os_sinit_data_size(heap), sizeof(u64));
+	return val;
+}
+
+static inline void __iomem *txt_sinit_mle_data_start(void __iomem *heap)
+{
+	return heap + txt_bios_data_size(heap) +
+		txt_os_mle_data_size(heap) +
+		txt_sinit_mle_data_size(heap) + sizeof(u64);
+}
+
+static inline void txt_getsec_wakeup(void)
+{
+	__asm__ __volatile__ (".byte 0x0f,0x37\n" : : "a"(X86_GETSEC_WAKEUP));
+}
+
+void tb_setup(void);
+struct acpi_table_header *tb_get_dmar_table(struct acpi_table_header *dmar);
+
+#endif
+
+#endif /* _ASM_X86_TRENCHBOOT_H */
-- 
2.1.4

