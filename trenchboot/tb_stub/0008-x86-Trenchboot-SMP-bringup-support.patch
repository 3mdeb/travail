From 2c53010729742a4591a2348478c8d06c50805ffe Mon Sep 17 00:00:00 2001
From: Ross Philipson <ross.philipson@oracle.com>
Date: Tue, 2 Oct 2018 14:41:49 -0400
Subject: [PATCH 8/8] x86: Trenchboot SMP bringup support

Note the AP bringup is very different becuase SKINIT and the ACM leave
the APs in very different states post launch.

Signed-off-by: Ross Philipson <ross.philipson@oracle.com>
---
 arch/x86/include/asm/realmode.h      |  5 +++
 arch/x86/kernel/smpboot.c            | 67 +++++++++++++++++++++++++++++++++++
 arch/x86/realmode/init.c             |  8 +++++
 arch/x86/realmode/rm/header.S        |  5 +++
 arch/x86/realmode/rm/trampoline_64.S | 68 ++++++++++++++++++++++++++++++++++++
 5 files changed, 153 insertions(+)

diff --git a/arch/x86/include/asm/realmode.h b/arch/x86/include/asm/realmode.h
index 63b3393bd98e..d3839bc371a5 100644
--- a/arch/x86/include/asm/realmode.h
+++ b/arch/x86/include/asm/realmode.h
@@ -32,6 +32,11 @@ struct real_mode_header {
 #endif
 	/* APM/BIOS reboot */
 	u32	machine_real_restart_asm;
+#ifdef CONFIG_TRENCHBOOT_STUB
+	u32	tb_trampoline_start32;
+	u32	tr_gdt;
+	u32	tr_gdt_end;
+#endif
 #ifdef CONFIG_X86_64
 	u32	machine_real_restart_seg;
 #endif
diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c
index f02ecaf97904..7eb7bc9a1486 100644
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@ -81,6 +81,7 @@
 #include <asm/cpu_device_id.h>
 #include <asm/spec-ctrl.h>
 #include <asm/hw_irq.h>
+#include <asm/trenchboot.h>
 
 /* representing HT siblings of each logical CPU */
 DEFINE_PER_CPU_READ_MOSTLY(cpumask_var_t, cpu_sibling_map);
@@ -740,6 +741,14 @@ wakeup_secondary_cpu_via_init(int phys_apicid, unsigned long start_eip)
 		apic_read(APIC_ESR);
 	}
 
+	/*
+	 * Only here after a measured launch via SKINIT on AMD. SKINIT
+	 * returns with INIT asserted on all the APs so do not send
+	 * INIT here. The rest would be the normal SIPI process and then
+	 * starting the AP in the realmode blob code.
+	 */
+#ifndef CONFIG_TRENCHBOOT_STUB
+
 	pr_debug("Asserting INIT\n");
 
 	/*
@@ -756,6 +765,8 @@ wakeup_secondary_cpu_via_init(int phys_apicid, unsigned long start_eip)
 
 	udelay(init_udelay);
 
+#endif
+
 	pr_debug("Deasserting INIT\n");
 
 	/* Target chip */
@@ -885,6 +896,36 @@ static int wakeup_cpu0_nmi(unsigned int cmd, struct pt_regs *regs)
 	return NMI_DONE;
 }
 
+#ifdef CONFIG_TRENCHBOOT_STUB
+static int
+wakeup_cpu_via_intel_txt(int cpu)
+{
+	struct txt_mle_join mle_join = {0};
+	struct txt_os_sinit_data *os_sinit_data;
+	struct txt_sinit_mle_data *sinit_mle_data;
+
+	/* Get start IP and GDT info from rmpiggy to use in TXT AP startup */
+	mle_join.entry_point = real_mode_header->tb_trampoline_start32;
+	mle_join.seg_sel = __KERNEL32_CS;
+	mle_join.gdt_base = real_mode_header->tr_gdt;
+	mle_join.gdt_base = real_mode_header->tr_gdt -
+			    real_mode_header->tr_gdt - 1;
+	txt_write_priv_reg(TXTCR_MLE_JOIN, (uint64_t)(unsigned long)&mle_join);
+
+	/* Fish around in the TXT heap for capabilities/AP startup values */
+	os_sinit_data = txt_os_sinit_data_start();
+	sinit_mle_data = txt_sinit_mle_data_start();
+
+	/* Usa appropriate startup mechanism specified by the capabilities */
+	if (os_sinit_data->capabilities & TXT_CAP_RLP_WAKE_MONITOR)
+		*((uint32_t *)(unsigned long)(sinit_mle_data->rlp_wakeup_addr)) = 0x01;
+	else
+		txt_getsec_wakeup();
+
+	return 0;
+}
+#endif
+
 /*
  * Wake up AP by INIT, INIT, STARTUP sequence.
  *
@@ -1010,6 +1051,8 @@ static int do_boot_cpu(int apicid, int cpu, struct task_struct *idle,
 	cpumask_clear_cpu(cpu, cpu_initialized_mask);
 	smp_mb();
 
+#ifndef CONFIG_TRENCHBOOT_STUB
+
 	/*
 	 * Wake up a CPU in difference cases:
 	 * - Use the method in the APIC driver if it's defined
@@ -1022,6 +1065,30 @@ static int do_boot_cpu(int apicid, int cpu, struct task_struct *idle,
 		boot_error = wakeup_cpu_via_init_nmi(cpu, start_ip, apicid,
 						     cpu0_nmi_registered);
 
+#else
+
+	/*
+	 * Halting and restarting the BSP is not supported in the Intermediate
+	 * Loader. Also this code path should not be taken if Trenchboot is
+	 * not active.
+	 */
+	BUG_ON(cpu == 0);
+	BUG_ON(!(boot_params.trenchboot_info.tb_flags & TB_FLAG_ACTIVE));
+
+	/*
+	 * Custom APIC driver configuration is not currently supported on AMD
+	 * and on Intel the startup is totally different.
+	 */
+	if (boot_params.trenchboot_info.tb_flags & TB_FLAG_ARCH_SKINIT)
+		boot_error = wakeup_cpu_via_init_nmi(cpu, start_ip, apicid,
+						     cpu0_nmi_registered);
+	else if (boot_params.trenchboot_info.tb_flags & TB_FLAG_ARCH_TXT)
+		boot_error = wakeup_cpu_via_intel_txt(cpu);
+	else
+		BUG();
+
+#endif
+
 	if (!boot_error) {
 		/*
 		 * Wait 10s total for first sign of life from AP
diff --git a/arch/x86/realmode/init.c b/arch/x86/realmode/init.c
index d10105825d57..4fbff4532c2b 100644
--- a/arch/x86/realmode/init.c
+++ b/arch/x86/realmode/init.c
@@ -9,6 +9,10 @@
 #include <asm/realmode.h>
 #include <asm/tlbflush.h>
 
+#ifdef CONFIG_AMD_DEV
+#include <asm/amd_dev.h>
+#endif
+
 struct real_mode_header *real_mode_header;
 u32 *trampoline_cr4_features;
 
@@ -42,6 +46,10 @@ void __init reserve_real_mode(void)
 	}
 
 	memblock_reserve(mem, size);
+#ifdef CONFIG_AMD_DEV
+	/* DEV protect this region before use*/
+	amd_dev_protect_pages(0, mem, size, 0);
+#endif
 	set_real_mode_mem(mem, size);
 }
 
diff --git a/arch/x86/realmode/rm/header.S b/arch/x86/realmode/rm/header.S
index 30b0d30d861a..679bb8c217f3 100644
--- a/arch/x86/realmode/rm/header.S
+++ b/arch/x86/realmode/rm/header.S
@@ -31,6 +31,11 @@ GLOBAL(real_mode_header)
 #endif
 	/* APM/BIOS reboot */
 	.long	pa_machine_real_restart_asm
+#ifdef CONFIG_TRENCHBOOT_STUB
+	.long	pa_tb_trampoline_start32
+	.long	pa_tr_gdt
+	.long	pa_tr_gdt_end
+#endif
 #ifdef CONFIG_X86_64
 	.long	__KERNEL32_CS
 #endif
diff --git a/arch/x86/realmode/rm/trampoline_64.S b/arch/x86/realmode/rm/trampoline_64.S
index 24bb7598774e..05c5ff1e15a5 100644
--- a/arch/x86/realmode/rm/trampoline_64.S
+++ b/arch/x86/realmode/rm/trampoline_64.S
@@ -32,6 +32,7 @@
 #include <asm/segment.h>
 #include <asm/processor-flags.h>
 #include <asm/realmode.h>
+#include <asm/trenchboot.h>
 #include "realmode.h"
 
 	.text
@@ -42,6 +43,11 @@ ENTRY(trampoline_start)
 	cli			# We should be safe anyway
 	wbinvd
 
+	# Only here in RM code on AMD platforms post SKINIT launch
+#ifdef CONFIG_TRENCHBOOT_STUB
+	stgi
+#endif
+
 	LJMPW_RM(1f)
 1:
 	mov	%cs, %ax	# Code and data in the same place
@@ -86,6 +92,65 @@ no_longmode:
 	.section ".text32","ax"
 	.code32
 	.balign 4
+#ifdef CONFIG_TRENCHBOOT_STUB
+ENTRY(tb_trampoline_start32)
+	/*
+	 * Entry vectro for AP startup from TXT. On entry:
+	 *  - Protected mode
+	 *  - Paging disabled
+	 *  - %ebx has linear address of tb_trampoline_start
+	 *  - Only %cs is valid
+	 *  - MCE/SMI/NMI are all disabled
+	 * For the rest of the state of the world, see the Intel TXT manual
+	 */
+	cli
+	cld
+
+	/*
+	 * The %ebx provided is not terribly useful since it is the physical
+	 * address of tb_trampoline_start and not the base of the image.
+	 * Use pa_real_mode_base, which is fixed up, to get a run time
+	 * base register to use for offsets to location.
+	 */
+	movl	$pa_real_mode_base, %ebx
+
+	lgdt	tr_gdt(%ebx)
+	lidt	tr_idt(%ebx)
+
+	/* Going to use the real mode stack since it is there */
+	movl	rm_stack_end(%ebx), %esp
+
+	/* Enable SMI with GETSET[SMCTRL] */
+	pushl	%ebx
+	xorl	%ebx, %ebx
+	movl	$(X86_GETSEC_SMCTRL), %eax
+	.byte 	0x0f, 0x37 /* GETSEC opcode */
+	popl	%ebx
+
+	/* Enable NMI using an IRET-to-self */
+	leal	.Lnmi_enabled(%ebx), %eax
+	pushfl
+	pushl	$(__KERNEL32_CS)
+	pushl	%eax
+	iret
+
+.Lnmi_enabled:
+	addl	$12, %esp
+
+	movw	$__KERNEL_DS, %dx	# Data segment descriptor
+
+	/*
+	 * This may seem a little odd but this is what %esp would have had in
+	 * it on the jmp from real mode because all real mode fixups were done
+	 * via the code segment.
+	 */
+	movl	$rm_stack_end, %esp
+
+	/* Jump to where the 16b code would have jumped */
+	ljmpl	$__KERNEL32_CS, $pa_startup_32
+#endif
+
+	.balign 4
 ENTRY(startup_32)
 	movl	%edx, %ss
 	addl	$pa_real_mode_base, %esp
@@ -160,6 +225,9 @@ tr_gdt:
 	.quad	0x00cf9b000000ffff	# __KERNEL32_CS
 	.quad	0x00af9b000000ffff	# __KERNEL_CS
 	.quad	0x00cf93000000ffff	# __KERNEL_DS
+#ifdef CONFIG_TRENCHBOOT_STUB
+	.globl tr_gdt_end
+#endif
 tr_gdt_end:
 
 	.bss
-- 
2.13.6

