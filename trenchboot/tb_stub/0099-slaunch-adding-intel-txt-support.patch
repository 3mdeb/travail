From e9dacd1cefcbef078bfde5e03e579d9551a4f415 Mon Sep 17 00:00:00 2001
From: "Daniel P. Smith" <dpsmith@apertussolutions.com>
Date: Thu, 18 May 2017 17:48:52 -0400
Subject: [PATCH] slaunch: adding intel txt support

---
 arch/x86/kernel/slaunch.c | 196 ++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 196 insertions(+)

diff --git a/arch/x86/kernel/slaunch.c b/arch/x86/kernel/slaunch.c
index af41d15352c3..338a5862a69d 100644
--- a/arch/x86/kernel/slaunch.c
+++ b/arch/x86/kernel/slaunch.c
@@ -91,3 +91,199 @@ void slaunch_setup(void)
 	else
 		BUG();
 }
+
+
+struct memfile {
+	char *name;
+	void *addr;
+	size_t size;
+}
+
+static struct memfile sl_evtlog = {"evtlog", 0, 0};
+static struct memfile sl_config = {"config", 0, 0};
+
+#define SL_EVTLOG_ENTRY 0
+#define SL_CONFIG_ENTRY 1
+#define SL_DIR_ENTRY 2 /* directoy node must be last */
+#define FS_ENTRIES 3
+
+static struct dentry *fs_entries[FS_ENTRIES];
+
+
+static ssize_t sl_memfile_read(struct memfile *file, char __user *outbuf, size_t count, loff_t *pos)
+{
+	void __iomem *addr;
+	void *buf;
+	int ret = -EFAULT;
+
+	if (!file->addr)
+		goto err;
+
+	addr = ioremap_nocache(file->addr, file->size);
+	if (!addr)
+		goto err;
+
+	if (*pos >= file->size) {
+		ret = 0;
+		goto iounmap;
+	}
+
+	if (*pos + count > file->size)
+		count = file->size - *pos;
+
+	buf = kmalloc(count, GFP_KERNEL);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto iounmap;
+	}
+
+	memcpy_fromio(buf, addr + *pos, count);
+	if (copy_to_user(outbuf, buf, count))
+		goto free;
+
+	*ppos += count;
+
+	ret = count;
+
+free:
+	kfree(buf);
+
+iounmap:
+	iounmap(addr);
+
+err:
+	return ret;
+}
+
+static ssize_t sl_evtlog_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
+{
+	return sl_memfile_read(&sl_evtlog, buf, count, pos);
+}
+
+static ssize_t sl_config_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
+{
+	return sl_memfile_read(&sl_evtlog, buf, count, pos);
+}
+
+static const struct file_operations evtlog_ops = {
+        .read = sl_evtlog_read,
+	.llseek	= default_llseek,
+};
+
+static const struct file_operations config_ops = {
+        .read = sl_config_read,
+	.llseek	= default_llseek,
+};
+
+/*
+ * TXT configuration registers (offsets from TXT_{PUB, PRIV}_CONFIG_REGS_BASE)
+ */
+
+#define TXT_PUB_CONFIG_REGS_BASE       0xfed30000
+#define TXT_PRIV_CONFIG_REGS_BASE      0xfed20000
+
+/* # pages for each config regs space - used by fixmap */
+#define NR_TXT_CONFIG_PAGES     ((TXT_PUB_CONFIG_REGS_BASE -                \
+				  TXT_PRIV_CONFIG_REGS_BASE) >> PAGE_SHIFT)
+
+/* offsets from pub/priv config space */
+#define TXTCR_HEAP_BASE             0x0300
+#define TXTCR_HEAP_SIZE             0x0308
+
+
+static long expose_evtlog(const char *name)
+{
+	long ret = 0;
+	char *filename;
+
+	fs_entries[FS_DIR_ENTRY] = securityfs_create_dir(name, NULL);
+	if (IS_ERR(fs_entries[FS_DIR_ENTRY])) {
+		ret = PTR_ERR(fs_entries[FS_DIR_ENTRY]);
+		goto out;
+	}
+
+	if ((ret = tpm_is_tpm2(TPM_ANY_NUM)) < 0)
+		goto out_dir;
+
+	if (ret == 0)
+		filename = "tpm12_binary_evtlog";
+	else
+		filename = "tpm20_binary_evtlog";
+
+	fs_entries[FS_LOG_ENTRY] =
+	    securityfs_create_file(filename,
+				   S_IRUSR | S_IRGRP,
+				   fs_entries[FS_DIR_ENTRY], NULL,
+				   &tpm_evtlog_ops);
+	if (IS_ERR(fs_entries[FS_LOG_ENTRY])) {
+		ret = PTR_ERR(fs_entries[FS_LOG_ENTRY]);
+		goto out_dir;
+	}
+
+	return 0;
+
+out_dir:
+	securityfs_remove(fs_entries[FS_DIR_ENTRY]);
+out:
+	return ret;
+}
+
+void teardown_evtlog(void)
+{
+	int i;
+
+	for (i = 0; i < FS_ENTRIES; i++)
+		securityfs_remove(fs_entries[i]);
+}
+
+
+static int slaunch_intel_evtlog(void)
+{
+	int err;
+
+	txt_log.size = 0;
+	if ((err = HYPERVISOR_txt_op(TXTOP_GET, &txt_log)) != 0)
+		return err;
+
+	txt_log.buffer = kmalloc((size_t) txt_log.size, GFP_KERNEL);
+	if (!txt_log.buffer)
+		return -ENOMEM;
+
+	if ((err = HYPERVISOR_txt_op(TXTOP_GET, &txt_log)) != 0)
+		goto error;
+
+	if ((err = expose_evtlog("txt")) != 0)
+		goto error;
+
+	return 0;
+}
+
+static int slaunch_amd_evtlog(void)
+{
+	return 0;
+}
+
+static int __init slauch_late_init(void)
+{
+	int err;
+
+	if (boot_params.slaunch_info.sl_flags & SL_FLAG_ARCH_TXT)
+		slaunch_intel_evtlog();
+	else if (boot_params.slaunch_info.sl_flags & SL_FLAG_ARCH_SKINIT)
+		slaunch_amd_evtlog();
+	else
+		BUG();
+	return 0;
+
+error:
+	kfree(txt_log.buffer);
+	return err;
+}
+
+static void __exit slaunch_exit(void)
+{
+}
+
+late_initcall(slaunch_late_init);
+
+__exitcall(slaunch_exit);
-- 
2.11.0

