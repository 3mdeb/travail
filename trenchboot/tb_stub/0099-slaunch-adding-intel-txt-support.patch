From fff0597d2d92aceb9e7fbb0d00d8ff51850e85b2 Mon Sep 17 00:00:00 2001
From: "Daniel P. Smith" <dpsmith@apertussolutions.com>
Date: Thu, 18 May 2017 17:48:52 -0400
Subject: [PATCH 99/99] slaunch: adding intel txt support

---
 arch/x86/kernel/slaunch.c | 188 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 188 insertions(+)

diff --git a/arch/x86/kernel/slaunch.c b/arch/x86/kernel/slaunch.c
index af41d15352c3..551a64c1f3c8 100644
--- a/arch/x86/kernel/slaunch.c
+++ b/arch/x86/kernel/slaunch.c
@@ -24,6 +24,7 @@
 #include <asm/bootparam.h>
 #include <asm/setup.h>
 #include <asm/slaunch.h>
+#include <linux/seq_file.h>
 
 /* This should be plenty of room */
 static u8 txt_dmar[PAGE_SIZE] __attribute__((aligned(16)));
@@ -91,3 +92,190 @@ void slaunch_setup(void)
 	else
 		BUG();
 }
+
+#define FS_LOG_ENTRY 0
+#define FS_DIR_ENTRY 1 /* must be last */
+#define FS_ENTRIES 2
+
+static struct dentry *fs_entries[FS_ENTRIES];
+
+
+#define TPM_LOG_BLOCK_SIZE 1024
+
+static void *tpm_evtlog_start(struct seq_file *m, loff_t *pos)
+{
+	struct txt_op *log = m->private;
+	void *addr = log->buffer;
+
+	addr += *pos * TPM_LOG_BLOCK_SIZE;
+
+	if (addr > log->buffer + log->size)
+		return NULL;
+
+	return addr;
+}
+
+static void *tpm_evtlog_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	size_t size = 0;
+	struct txt_op *log = m->private;
+	void *addr = v;
+
+	size = (log->buffer + log->size) - addr;
+	size = size > TPM_LOG_BLOCK_SIZE ? TPM_LOG_BLOCK_SIZE : size;
+
+	if ((size == 0) ||
+	    ((addr + size) > (log->buffer + log->size)))
+		return NULL;
+
+	addr += size;
+	(*pos)++;
+
+	return addr;
+}
+
+static void tpm_evtlog_stop(struct seq_file *m, void *v)
+{
+}
+
+static int tpm_evtlog_show(struct seq_file *m, void *v)
+{
+	size_t size;
+	struct txt_op *log = m->private;
+	void *addr = v;
+
+	size = ((log->buffer + log->size) - addr) > TPM_LOG_BLOCK_SIZE ?
+		TPM_LOG_BLOCK_SIZE : (log->buffer + log->size) - addr;
+
+	if ((size != 0) &&
+	    ((addr + size) <= (log->buffer + log->size)))
+		seq_write(m, addr, size);
+
+	return 0;
+}
+
+const struct seq_operations tpm_evtlog_seqops = {
+	.start = tpm_evtlog_start,
+	.next = tpm_evtlog_next,
+	.stop = tpm_evtlog_stop,
+	.show = tpm_evtlog_show,
+};
+
+static int tpm_evtlog_open(struct inode *inode, struct file *file)
+{
+	int err;
+	struct seq_file *seq;
+
+	err = seq_open(file, &tpm_evtlog_seqops);
+	if (!err) {
+		seq = file->private_data;
+		seq->private = &txt_log;
+	}
+
+	return err;
+}
+
+static const struct file_operations tpm_evtlog_ops = {
+        .open = tpm_evtlog_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+        .release = seq_release,
+};
+
+
+static long expose_evtlog(const char *name)
+{
+	long ret = 0;
+	char *filename;
+
+	fs_entries[FS_DIR_ENTRY] = securityfs_create_dir(name, NULL);
+	if (IS_ERR(fs_entries[FS_DIR_ENTRY])) {
+		ret = PTR_ERR(fs_entries[FS_DIR_ENTRY]);
+		goto out;
+	}
+
+	if ((ret = tpm_is_tpm2(TPM_ANY_NUM)) < 0)
+		goto out_dir;
+
+	if (ret == 0)
+		filename = "tpm12_binary_evtlog";
+	else
+		filename = "tpm20_binary_evtlog";
+
+	fs_entries[FS_LOG_ENTRY] =
+	    securityfs_create_file(filename,
+				   S_IRUSR | S_IRGRP,
+				   fs_entries[FS_DIR_ENTRY], NULL,
+				   &tpm_evtlog_ops);
+	if (IS_ERR(fs_entries[FS_LOG_ENTRY])) {
+		ret = PTR_ERR(fs_entries[FS_LOG_ENTRY]);
+		goto out_dir;
+	}
+
+	return 0;
+
+out_dir:
+	securityfs_remove(fs_entries[FS_DIR_ENTRY]);
+out:
+	return ret;
+}
+
+void teardown_evtlog(void)
+{
+	int i;
+
+	for (i = 0; i < FS_ENTRIES; i++)
+		securityfs_remove(fs_entries[i]);
+}
+
+
+static int slaunch_intel_log(void)
+{
+	int err;
+
+	txt_log.size = 0;
+	if ((err = HYPERVISOR_txt_op(TXTOP_GET, &txt_log)) != 0)
+		return err;
+
+	txt_log.buffer = kmalloc((size_t) txt_log.size, GFP_KERNEL);
+	if (!txt_log.buffer)
+		return -ENOMEM;
+
+	if ((err = HYPERVISOR_txt_op(TXTOP_GET, &txt_log)) != 0)
+		goto error;
+
+	if ((err = expose_evtlog("txt")) != 0)
+		goto error;
+
+	return 0;
+}
+
+static int slaunch_intel_log(void)
+{
+	return 0;
+}
+
+static int __init slauch_late_init(void)
+{
+	int err;
+
+	if (boot_params.slaunch_info.sl_flags & SL_FLAG_ARCH_TXT)
+		slaunch_intel_log();
+	else if (boot_params.slaunch_info.sl_flags & SL_FLAG_ARCH_SKINIT)
+		slaunch_amd_log();
+	else
+		BUG();
+	return 0;
+
+error:
+	kfree(txt_log.buffer);
+	return err;
+}
+
+static void __exit slaunch_exit(void)
+{
+}
+
+late_initcall(slaunch_late_init);
+
+__exitcall(slaunch_exit);
-- 
2.20.1

