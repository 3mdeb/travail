General Notes:
---------------------------------------------------------------------

Big questions:
 - What boot params do we need to deal with in tb_stub?
 - Memory map - pass as e820 in boot params (looks like EFI
   stub stuff just turns mem map into e820 on EFI boot)?
 - How/where to handle and measure cmdlines for other boot modules?
 - How to pass other modules to IL?
 - Where to measure other modules?
 - What to do about Runtime Services (not really booting EFI)?
 - TXT: What about the shared page?
 - TXT: What about S3 hooks?
 - TXT: What are we passing in the OS-MLE data?
 - SKINIT: What post launch things need to be checked?

Stages:
---------------------------------------------------------------------

This seems like the stages of Trenchboot in the IL starting with the
earliest:

0. Built time:
  - Built tool reads ZO_tb_stub_entry from zoffsets.h
  - Writes to our BP location (at 0x0cc)

1. TB stub early:
  - Early assembly entry code in "compressed" to setup basics
  - May need a early C module to frob e820 before we let the kernel loose
    on the map.

2. TB stub late:
  - Later chunk of code in "kernel" to do other needed tasks.
  - Probably the place to setup logging.
  - May be where the PMRs and DEV changes happen.
  - Need to figure out what other ops that TBOOT did go here.
  - Need to figure out what comparable ops for SKINIT go here.

3. TB SMP bringup:
  - Will happen when the kernel runs the smpboot.c code.
  - May happen before #2.

4. Main security environment:
  - This is the code in u-root.
  - All policy handling here.
  - Customizable security operations.
  - Module handling and kexec next kernel.

TXT Specific:
---------------------------------------------------------------------

boot.S:
--------------------
  Taken care of in the tb_stub code.

begin_launch():
--------------------

tboot_parse_cmdline():
  What to do with the command lines from GRUB. The TBOOT one gets put in the MLE
    and measured by TXT.
  For TXT, the IL cmdline will be part of the MLE so it gets measured.
  For SKINIT, the LZ measures it. Same PCR in both cases?
  The cmdlines will be in the MB2 struct that TB is handed. Probably measured in
    u-root.

get_tboot_call_racm_check():
  No RACMs exist. Put a TODO to add future support if neeed.

if ( !(rdmsr(MSR_APICBASE) & APICBASE_BSP) )
  Taken care of in tb_stub

copy_e820_map():
  To use and adjust. We will handle this differently.

tpm_detect():
  Already been done in the GRUB TB code.

verify_IA32_se_svn_status():
  TXT only. Not sure where it should happen?

set_policy():
apply_policy(err):
  TXT only. u-root is effectively our VL policy.

launch_racm():
  No RACMs exist. Put a TODO to add future support if neeed.

supports_txt():
  The GRUB bits have done that.

txt_display_errors():
  This is something we can do later in the IL kernel
    once logging is operational.

verify_platform():
  The GRUB bits have done that.

verify_loader_context():
  IL has its own plan to get module info etc.

post_launch():
--------------------

txt_post_launch():
  txt_post_launch_verify_platform():
    Verify heap seems like something we can do later
    Verify MTRRs. What to do about passig MTRRs? See below...
    Verify PMRs seems like something we can do later
      Leave these as a TODO for now.

  Clear error regs
    Throw in tb_stub.

  txt_wakeup_cpus():
    I believe we will do this very differently in the SMP bringup code
      without putting APs in mini guests.

  Restore MSR_IA32_MISC_ENABLE
  restore_mtrrs():
    The kernel should set this stuff up correctly. Plan to do nothing around this.

  apply_policy():
    See above note on policy.

  TXTCR_CMD_SECRETS
    Have to read about, not sure when to do it. Maybe tb_stub.

  TXTCR_CMD_OPEN_LOCALITY1
    Have to read about, not sure when to do it. Maybe tb_stub.

save_vtd_dmar_table():
  Not sure why this is done along with restore_vtd_dmar_table()

remove_txt_modules():
  My guess is that the GRUB bits will figure out what ACM to use
    and this routine is meamingless because it is about the MBI

txt_protect_mem_regions():
  Involves updating e820. Needs consideration.
  May have to do this very early before kernel gets at the e820
  Presumably the bootparams can be munged in place.

verify_modules():
  This will happen when we measure the other modules in u-root

/* verify that tboot is in valid RAM (i.e. E820_RAM) */
  Do this early - see txt_protect_mem_regions

/* protect ourselves, MLE page table, and MLE/kernel shared page */
  Do this early - see txt_protect_mem_regions

TBOOT_LOG_TARGET_MEMORY
  Need to figure out logging

replace_e820_map()
  Does not make sense for us

print_e820_map()
  Need to figure out logging

verify_all_modules()
  Modules and policy handled in u-root

verify_all_nvindices()
  Seems this could be deferred to later, possibly in u-root

seal_pre_k_state()
  Policy handled in u-root

_tboot_shared
  This will look very different to us

